(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.cubejsngx = {}));
}(this, function (exports) { 'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
	}

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.6.5' };
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
	});
	var _core_1 = _core.version;

	var _global = createCommonjsModule(function (module) {
	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
	});

	var _library = false;

	var _shared = createCommonjsModule(function (module) {
	var SHARED = '__core-js_shared__';
	var store = _global[SHARED] || (_global[SHARED] = {});

	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: _core.version,
	  mode: 'global',
	  copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id = 0;
	var px = Math.random();
	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var _wks = createCommonjsModule(function (module) {
	var store = _shared('wks');

	var Symbol = _global.Symbol;
	var USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
	};

	$exports.store = store;
	});

	var _isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject = function (it) {
	  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var _descriptors = !_fails(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var document$1 = _global.document;
	// typeof document.createElement is 'object' in old IE
	var is = _isObject(document$1) && _isObject(document$1.createElement);
	var _domCreate = function (it) {
	  return is ? document$1.createElement(it) : {};
	};

	var _ie8DomDefine = !_descriptors && !_fails(function () {
	  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	// 7.1.1 ToPrimitive(input [, PreferredType])

	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var _toPrimitive = function (it, S) {
	  if (!_isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP = Object.defineProperty;

	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject(O);
	  P = _toPrimitive(P, true);
	  _anObject(Attributes);
	  if (_ie8DomDefine) try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var _objectDp = {
		f: f
	};

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide = _descriptors ? function (object, key, value) {
	  return _objectDp.f(object, key, _propertyDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = _wks('unscopables');
	var ArrayProto = Array.prototype;
	if (ArrayProto[UNSCOPABLES] == undefined) _hide(ArrayProto, UNSCOPABLES, {});
	var _addToUnscopables = function (key) {
	  ArrayProto[UNSCOPABLES][key] = true;
	};

	var _iterStep = function (done, value) {
	  return { value: value, done: !!done };
	};

	var _iterators = {};

	var toString = {}.toString;

	var _cof = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	// fallback for non-array-like ES3 and non-enumerable old V8 strings

	// eslint-disable-next-line no-prototype-builtins
	var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return _cof(it) == 'String' ? it.split('') : Object(it);
	};

	// 7.2.1 RequireObjectCoercible(argument)
	var _defined = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};

	// to indexed object, toObject with fallback for non-array-like ES3 strings


	var _toIobject = function (it) {
	  return _iobject(_defined(it));
	};

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var _functionToString = _shared('native-function-to-string', Function.toString);

	var _redefine = createCommonjsModule(function (module) {
	var SRC = _uid('src');

	var TO_STRING = 'toString';
	var TPL = ('' + _functionToString).split(TO_STRING);

	_core.inspectSource = function (it) {
	  return _functionToString.call(it);
	};

	(module.exports = function (O, key, val, safe) {
	  var isFunction = typeof val == 'function';
	  if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
	  if (O[key] === val) return;
	  if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if (O === _global) {
	    O[key] = val;
	  } else if (!safe) {
	    delete O[key];
	    _hide(O, key, val);
	  } else if (O[key]) {
	    O[key] = val;
	  } else {
	    _hide(O, key, val);
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString() {
	  return typeof this == 'function' && this[SRC] || _functionToString.call(this);
	});
	});

	var _aFunction = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};

	// optional / simple context binding

	var _ctx = function (fn, that, length) {
	  _aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var PROTOTYPE = 'prototype';

	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
	    // extend global
	    if (target) _redefine(target, key, out, type & $export.U);
	    // export
	    if (exports[key] != out) _hide(exports, key, exp);
	    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
	  }
	};
	_global.core = _core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	var _export = $export;

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	// 7.1.15 ToLength

	var min = Math.min;
	var _toLength = function (it) {
	  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

	var max = Math.max;
	var min$1 = Math.min;
	var _toAbsoluteIndex = function (index, length) {
	  index = _toInteger(index);
	  return index < 0 ? max(index + length, 0) : min$1(index, length);
	};

	// false -> Array#indexOf
	// true  -> Array#includes



	var _arrayIncludes = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = _toIobject($this);
	    var length = _toLength(O.length);
	    var index = _toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var shared = _shared('keys');

	var _sharedKey = function (key) {
	  return shared[key] || (shared[key] = _uid(key));
	};

	var arrayIndexOf = _arrayIncludes(false);
	var IE_PROTO = _sharedKey('IE_PROTO');

	var _objectKeysInternal = function (object, names) {
	  var O = _toIobject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (_has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	// IE 8- don't enum bug keys
	var _enumBugKeys = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)



	var _objectKeys = Object.keys || function keys(O) {
	  return _objectKeysInternal(O, _enumBugKeys);
	};

	var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  _anObject(O);
	  var keys = _objectKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

	var document$2 = _global.document;
	var _html = document$2 && document$2.documentElement;

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



	var IE_PROTO$1 = _sharedKey('IE_PROTO');
	var Empty = function () { /* empty */ };
	var PROTOTYPE$1 = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = _domCreate('iframe');
	  var i = _enumBugKeys.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  _html.appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
	  return createDict();
	};

	var _objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE$1] = _anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE$1] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO$1] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : _objectDps(result, Properties);
	};

	var def = _objectDp.f;

	var TAG = _wks('toStringTag');

	var _setToStringTag = function (it, tag, stat) {
	  if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};

	var IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	_hide(IteratorPrototype, _wks('iterator'), function () { return this; });

	var _iterCreate = function (Constructor, NAME, next) {
	  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
	  _setToStringTag(Constructor, NAME + ' Iterator');
	};

	// 7.1.13 ToObject(argument)

	var _toObject = function (it) {
	  return Object(_defined(it));
	};

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


	var IE_PROTO$2 = _sharedKey('IE_PROTO');
	var ObjectProto = Object.prototype;

	var _objectGpo = Object.getPrototypeOf || function (O) {
	  O = _toObject(O);
	  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

	var ITERATOR = _wks('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';

	var returnThis = function () { return this; };

	var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  _iterCreate(Constructor, NAME, next);
	  var getMethod = function (kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS: return function keys() { return new Constructor(this, kind); };
	      case VALUES: return function values() { return new Constructor(this, kind); };
	    } return function entries() { return new Constructor(this, kind); };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = $native || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = _objectGpo($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      _setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if (typeof IteratorPrototype[ITERATOR] != 'function') _hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() { return $native.call(this); };
	  }
	  // Define iterator
	  if (BUGGY || VALUES_BUG || !proto[ITERATOR]) {
	    _hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  _iterators[NAME] = $default;
	  _iterators[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) _redefine(proto, key, methods[key]);
	    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
	  this._t = _toIobject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return _iterStep(1);
	  }
	  if (kind == 'keys') return _iterStep(0, index);
	  if (kind == 'values') return _iterStep(0, O[index]);
	  return _iterStep(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	_iterators.Arguments = _iterators.Array;

	_addToUnscopables('keys');
	_addToUnscopables('values');
	_addToUnscopables('entries');

	var ITERATOR$1 = _wks('iterator');
	var TO_STRING_TAG = _wks('toStringTag');
	var ArrayValues = _iterators.Array;

	var DOMIterables = {
	  CSSRuleList: true, // TODO: Not spec compliant, should be false.
	  CSSStyleDeclaration: false,
	  CSSValueList: false,
	  ClientRectList: false,
	  DOMRectList: false,
	  DOMStringList: false,
	  DOMTokenList: true,
	  DataTransferItemList: false,
	  FileList: false,
	  HTMLAllCollection: false,
	  HTMLCollection: false,
	  HTMLFormElement: false,
	  HTMLSelectElement: false,
	  MediaList: true, // TODO: Not spec compliant, should be false.
	  MimeTypeArray: false,
	  NamedNodeMap: false,
	  NodeList: true,
	  PaintRequestList: false,
	  Plugin: false,
	  PluginArray: false,
	  SVGLengthList: false,
	  SVGNumberList: false,
	  SVGPathSegList: false,
	  SVGPointList: false,
	  SVGStringList: false,
	  SVGTransformList: false,
	  SourceBufferList: false,
	  StyleSheetList: true, // TODO: Not spec compliant, should be false.
	  TextTrackCueList: false,
	  TextTrackList: false,
	  TouchList: false
	};

	for (var collections = _objectKeys(DOMIterables), i = 0; i < collections.length; i++) {
	  var NAME = collections[i];
	  var explicit = DOMIterables[NAME];
	  var Collection = _global[NAME];
	  var proto = Collection && Collection.prototype;
	  var key;
	  if (proto) {
	    if (!proto[ITERATOR$1]) _hide(proto, ITERATOR$1, ArrayValues);
	    if (!proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
	    _iterators[NAME] = ArrayValues;
	    if (explicit) for (key in es6_array_iterator) if (!proto[key]) _redefine(proto, key, es6_array_iterator[key], true);
	  }
	}

	var f$1 = _wks;

	var _wksExt = {
		f: f$1
	};

	var defineProperty = _objectDp.f;
	var _wksDefine = function (name) {
	  var $Symbol = _core.Symbol || (_core.Symbol = _global.Symbol || {});
	  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: _wksExt.f(name) });
	};

	_wksDefine('asyncIterator');

	var _meta = createCommonjsModule(function (module) {
	var META = _uid('meta');


	var setDesc = _objectDp.f;
	var id = 0;
	var isExtensible = Object.isExtensible || function () {
	  return true;
	};
	var FREEZE = !_fails(function () {
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function (it) {
	  setDesc(it, META, { value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  } });
	};
	var fastKey = function (it, create) {
	  // return primitive with prefix
	  if (!_isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!_has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function (it, create) {
	  if (!_has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY: META,
	  NEED: false,
	  fastKey: fastKey,
	  getWeak: getWeak,
	  onFreeze: onFreeze
	};
	});
	var _meta_1 = _meta.KEY;
	var _meta_2 = _meta.NEED;
	var _meta_3 = _meta.fastKey;
	var _meta_4 = _meta.getWeak;
	var _meta_5 = _meta.onFreeze;

	var f$2 = Object.getOwnPropertySymbols;

	var _objectGops = {
		f: f$2
	};

	var f$3 = {}.propertyIsEnumerable;

	var _objectPie = {
		f: f$3
	};

	// all enumerable object keys, includes symbols



	var _enumKeys = function (it) {
	  var result = _objectKeys(it);
	  var getSymbols = _objectGops.f;
	  if (getSymbols) {
	    var symbols = getSymbols(it);
	    var isEnum = _objectPie.f;
	    var i = 0;
	    var key;
	    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
	  } return result;
	};

	// 7.2.2 IsArray(argument)

	var _isArray = Array.isArray || function isArray(arg) {
	  return _cof(arg) == 'Array';
	};

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

	var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

	var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return _objectKeysInternal(O, hiddenKeys);
	};

	var _objectGopn = {
		f: f$4
	};

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window

	var gOPN = _objectGopn.f;
	var toString$1 = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return gOPN(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};

	var f$5 = function getOwnPropertyNames(it) {
	  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(_toIobject(it));
	};

	var _objectGopnExt = {
		f: f$5
	};

	var gOPD = Object.getOwnPropertyDescriptor;

	var f$6 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = _toIobject(O);
	  P = _toPrimitive(P, true);
	  if (_ie8DomDefine) try {
	    return gOPD(O, P);
	  } catch (e) { /* empty */ }
	  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
	};

	var _objectGopd = {
		f: f$6
	};

	// ECMAScript 6 symbols shim





	var META = _meta.KEY;



















	var gOPD$1 = _objectGopd.f;
	var dP$1 = _objectDp.f;
	var gOPN$1 = _objectGopnExt.f;
	var $Symbol = _global.Symbol;
	var $JSON = _global.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE$2 = 'prototype';
	var HIDDEN = _wks('_hidden');
	var TO_PRIMITIVE = _wks('toPrimitive');
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = _shared('symbol-registry');
	var AllSymbols = _shared('symbols');
	var OPSymbols = _shared('op-symbols');
	var ObjectProto$1 = Object[PROTOTYPE$2];
	var USE_NATIVE = typeof $Symbol == 'function';
	var QObject = _global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = _descriptors && _fails(function () {
	  return _objectCreate(dP$1({}, 'a', {
	    get: function () { return dP$1(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD$1(ObjectProto$1, key);
	  if (protoDesc) delete ObjectProto$1[key];
	  dP$1(it, key, D);
	  if (protoDesc && it !== ObjectProto$1) dP$1(ObjectProto$1, key, protoDesc);
	} : dP$1;

	var wrap = function (tag) {
	  var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D) {
	  if (it === ObjectProto$1) $defineProperty(OPSymbols, key, D);
	  _anObject(it);
	  key = _toPrimitive(key, true);
	  _anObject(D);
	  if (_has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!_has(it, HIDDEN)) dP$1(it, HIDDEN, _propertyDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if (_has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
	      D = _objectCreate(D, { enumerable: _propertyDesc(0, false) });
	    } return setSymbolDesc(it, key, D);
	  } return dP$1(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
	  _anObject(it);
	  var keys = _enumKeys(P = _toIobject(P));
	  var i = 0;
	  var l = keys.length;
	  var key;
	  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P) {
	  return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum.call(this, key = _toPrimitive(key, true));
	  if (this === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;
	  return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  it = _toIobject(it);
	  key = _toPrimitive(key, true);
	  if (it === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;
	  var D = gOPD$1(it, key);
	  if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN$1(_toIobject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto$1;
	  var names = gOPN$1(IS_OP ? OPSymbols : _toIobject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto$1, key) : true)) result.push(AllSymbols[key]);
	  } return result;
	};

	// 19.4.1.1 Symbol([description])
	if (!USE_NATIVE) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	    var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function (value) {
	      if (this === ObjectProto$1) $set.call(OPSymbols, value);
	      if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, _propertyDesc(1, value));
	    };
	    if (_descriptors && setter) setSymbolDesc(ObjectProto$1, tag, { configurable: true, set: $set });
	    return wrap(tag);
	  };
	  _redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {
	    return this._k;
	  });

	  _objectGopd.f = $getOwnPropertyDescriptor;
	  _objectDp.f = $defineProperty;
	  _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
	  _objectPie.f = $propertyIsEnumerable;
	  _objectGops.f = $getOwnPropertySymbols;

	  if (_descriptors && !_library) {
	    _redefine(ObjectProto$1, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  _wksExt.f = function (name) {
	    return wrap(_wks(name));
	  };
	}

	_export(_export.G + _export.W + _export.F * !USE_NATIVE, { Symbol: $Symbol });

	for (var es6Symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), j = 0; es6Symbols.length > j;)_wks(es6Symbols[j++]);

	for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) _wksDefine(wellKnownSymbols[k++]);

	_export(_export.S + _export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function (key) {
	    return _has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
	    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
	  },
	  useSetter: function () { setter = true; },
	  useSimple: function () { setter = false; }
	});

	_export(_export.S + _export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && _export(_export.S + _export.F * (!USE_NATIVE || _fails(function () {
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    var args = [it];
	    var i = 1;
	    var replacer, $replacer;
	    while (arguments.length > i) args.push(arguments[i++]);
	    $replacer = replacer = args[1];
	    if (!_isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	    if (!_isArray(replacer)) replacer = function (key, value) {
	      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	      if (!isSymbol(value)) return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	_setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	_setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	_setToStringTag(_global.JSON, 'JSON', true);

	// getting tag from 19.1.3.6 Object.prototype.toString()

	var TAG$1 = _wks('toStringTag');
	// ES3 wrong here
	var ARG = _cof(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (e) { /* empty */ }
	};

	var _classof = function (it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
	    // builtinTag case
	    : ARG ? _cof(O)
	    // ES3 arguments fallback
	    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

	var _anInstance = function (it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

	// call something on iterator step with safe closing on error

	var _iterCall = function (iterator, fn, value, entries) {
	  try {
	    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) _anObject(ret.call(iterator));
	    throw e;
	  }
	};

	// check on default Array iterator

	var ITERATOR$2 = _wks('iterator');
	var ArrayProto$1 = Array.prototype;

	var _isArrayIter = function (it) {
	  return it !== undefined && (_iterators.Array === it || ArrayProto$1[ITERATOR$2] === it);
	};

	var ITERATOR$3 = _wks('iterator');

	var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$3]
	    || it['@@iterator']
	    || _iterators[_classof(it)];
	};

	var _forOf = createCommonjsModule(function (module) {
	var BREAK = {};
	var RETURN = {};
	var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	  var iterFn = ITERATOR ? function () { return iterable; } : core_getIteratorMethod(iterable);
	  var f = _ctx(fn, that, entries ? 2 : 1);
	  var index = 0;
	  var length, step, iterator, result;
	  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
	    result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if (result === BREAK || result === RETURN) return result;
	  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	    result = _iterCall(iterator, f, step.value, entries);
	    if (result === BREAK || result === RETURN) return result;
	  }
	};
	exports.BREAK = BREAK;
	exports.RETURN = RETURN;
	});

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)


	var SPECIES = _wks('species');
	var _speciesConstructor = function (O, D) {
	  var C = _anObject(O).constructor;
	  var S;
	  return C === undefined || (S = _anObject(C)[SPECIES]) == undefined ? D : _aFunction(S);
	};

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	var _invoke = function (fn, args, that) {
	  var un = that === undefined;
	  switch (args.length) {
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return fn.apply(that, args);
	};

	var process = _global.process;
	var setTask = _global.setImmediate;
	var clearTask = _global.clearImmediate;
	var MessageChannel = _global.MessageChannel;
	var Dispatch = _global.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function () {
	  var id = +this;
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function (event) {
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      _invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (_cof(process) == 'process') {
	    defer = function (id) {
	      process.nextTick(_ctx(run, id, 1));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(_ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if (MessageChannel) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = _ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
	    defer = function (id) {
	      _global.postMessage(id + '', '*');
	    };
	    _global.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in _domCreate('script')) {
	    defer = function (id) {
	      _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
	        _html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(_ctx(run, id, 1), 0);
	    };
	  }
	}
	var _task = {
	  set: setTask,
	  clear: clearTask
	};

	var macrotask = _task.set;
	var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
	var process$1 = _global.process;
	var Promise$1 = _global.Promise;
	var isNode = _cof(process$1) == 'process';

	var _microtask = function () {
	  var head, last, notify;

	  var flush = function () {
	    var parent, fn;
	    if (isNode && (parent = process$1.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // Node.js
	  if (isNode) {
	    notify = function () {
	      process$1.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
	  } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$1 && Promise$1.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    var promise = Promise$1.resolve(undefined);
	    notify = function () {
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(_global, flush);
	    };
	  }

	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) last.next = task;
	    if (!head) {
	      head = task;
	      notify();
	    } last = task;
	  };
	};

	// 25.4.1.5 NewPromiseCapability(C)


	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = _aFunction(resolve);
	  this.reject = _aFunction(reject);
	}

	var f$7 = function (C) {
	  return new PromiseCapability(C);
	};

	var _newPromiseCapability = {
		f: f$7
	};

	var _perform = function (exec) {
	  try {
	    return { e: false, v: exec() };
	  } catch (e) {
	    return { e: true, v: e };
	  }
	};

	var navigator = _global.navigator;

	var _userAgent = navigator && navigator.userAgent || '';

	var _promiseResolve = function (C, x) {
	  _anObject(C);
	  if (_isObject(x) && x.constructor === C) return x;
	  var promiseCapability = _newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var _redefineAll = function (target, src, safe) {
	  for (var key in src) _redefine(target, key, src[key], safe);
	  return target;
	};

	var SPECIES$1 = _wks('species');

	var _setSpecies = function (KEY) {
	  var C = _global[KEY];
	  if (_descriptors && C && !C[SPECIES$1]) _objectDp.f(C, SPECIES$1, {
	    configurable: true,
	    get: function () { return this; }
	  });
	};

	var ITERATOR$4 = _wks('iterator');
	var SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR$4]();
	  riter['return'] = function () { SAFE_CLOSING = true; };
	} catch (e) { /* empty */ }

	var _iterDetect = function (exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;
	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR$4]();
	    iter.next = function () { return { done: safe = true }; };
	    arr[ITERATOR$4] = function () { return iter; };
	    exec(arr);
	  } catch (e) { /* empty */ }
	  return safe;
	};

	var task = _task.set;
	var microtask = _microtask();




	var PROMISE = 'Promise';
	var TypeError$1 = _global.TypeError;
	var process$2 = _global.process;
	var versions = process$2 && process$2.versions;
	var v8 = versions && versions.v8 || '';
	var $Promise = _global[PROMISE];
	var isNode$1 = _classof(process$2) == 'process';
	var empty = function () { /* empty */ };
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;

	var USE_NATIVE$1 = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1);
	    var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode$1 || typeof PromiseRejectionEvent == 'function')
	      && promise.then(empty) instanceof FakePromise
	      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	      // we can't detect it synchronously, so just check versions
	      && v8.indexOf('6.6') !== 0
	      && _userAgent.indexOf('Chrome/66') === -1;
	  } catch (e) { /* empty */ }
	}();

	// helpers
	var isThenable = function (it) {
	  var then;
	  return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function (promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;
	    var run = function (reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value); // may throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        if (domain && !exited) domain.exit();
	        reject(e);
	      }
	    };
	    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};
	var onUnhandled = function (promise) {
	  task.call(_global, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;
	    if (unhandled) {
	      result = _perform(function () {
	        if (isNode$1) {
	          process$2.emit('unhandledRejection', value, promise);
	        } else if (handler = _global.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = _global.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if (unhandled && result.e) throw result.v;
	  });
	};
	var isUnhandled = function (promise) {
	  return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled = function (promise) {
	  task.call(_global, function () {
	    var handler;
	    if (isNode$1) {
	      process$2.emit('rejectionHandled', promise);
	    } else if (handler = _global.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function (value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function (value) {
	  var promise = this;
	  var then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false }; // wrap
	        try {
	          then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e); // wrap
	  }
	};

	// constructor polyfill
	if (!USE_NATIVE$1) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    _anInstance(this, $Promise, PROMISE, '_h');
	    _aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = _redefineAll($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode$1 ? process$2.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = _ctx($resolve, promise, 1);
	    this.reject = _ctx($reject, promise, 1);
	  };
	  _newPromiseCapability.f = newPromiseCapability = function (C) {
	    return C === $Promise || C === Wrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}

	_export(_export.G + _export.W + _export.F * !USE_NATIVE$1, { Promise: $Promise });
	_setToStringTag($Promise, PROMISE);
	_setSpecies(PROMISE);
	Wrapper = _core[PROMISE];

	// statics
	_export(_export.S + _export.F * !USE_NATIVE$1, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	_export(_export.S + _export.F * (_library || !USE_NATIVE$1), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    return _promiseResolve(_library && this === Wrapper ? $Promise : this, x);
	  }
	});
	_export(_export.S + _export.F * !(USE_NATIVE$1 && _iterDetect(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = _perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      _forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = _perform(function () {
	      _forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  }
	});

	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	_export(_export.S + _export.F * !_descriptors, 'Object', { defineProperty: _objectDp.f });

	function _typeof(obj) {
	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	var _strictMethod = function (method, arg) {
	  return !!method && _fails(function () {
	    // eslint-disable-next-line no-useless-call
	    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
	  });
	};

	var $indexOf = _arrayIncludes(false);
	var $native = [].indexOf;
	var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

	_export(_export.P + _export.F * (NEGATIVE_ZERO || !_strictMethod($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});

	// 19.1.2.1 Object.assign(target, source, ...)





	var $assign = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	var _objectAssign = !$assign || _fails(function () {
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) { B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
	  var T = _toObject(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = _objectGops.f;
	  var isEnum = _objectPie.f;
	  while (aLen > index) {
	    var S = _iobject(arguments[index++]);
	    var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	  } return T;
	} : $assign;

	// 19.1.3.1 Object.assign(target, source)


	_export(_export.S + _export.F, 'Object', { assign: _objectAssign });

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	_export(_export.S, 'Object', { create: _objectCreate });

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */


	var check = function (O, proto) {
	  _anObject(O);
	  if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
	};
	var _setProto = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function (test, buggy, set) {
	      try {
	        set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch (e) { buggy = true; }
	      return function setPrototypeOf(O, proto) {
	        check(O, proto);
	        if (buggy) O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

	// 19.1.3.19 Object.setPrototypeOf(O, proto)

	_export(_export.S, 'Object', { setPrototypeOf: _setProto.set });

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */

	/* global Reflect, Promise */
	var _extendStatics = function extendStatics(d, b) {
	  _extendStatics = Object.setPrototypeOf || {
	    __proto__: []
	  } instanceof Array && function (d, b) {
	    d.__proto__ = b;
	  } || function (d, b) {
	    for (var p in b) {
	      if (b.hasOwnProperty(p)) d[p] = b[p];
	    }
	  };

	  return _extendStatics(d, b);
	};

	function __extends(d, b) {
	  _extendStatics(d, b);

	  function __() {
	    this.constructor = d;
	  }

	  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var _assign = function __assign() {
	  _assign = Object.assign || function __assign(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) {
	        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	      }
	    }

	    return t;
	  };

	  return _assign.apply(this, arguments);
	};
	function __decorate(decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	}
	function __param(paramIndex, decorator) {
	  return function (target, key) {
	    decorator(target, key, paramIndex);
	  };
	}
	function __metadata(metadataKey, metadataValue) {
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
	}
	function __awaiter(thisArg, _arguments, P, generator) {
	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : new P(function (resolve) {
	        resolve(result.value);
	      }).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	}
	function __values(o) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator],
	      i = 0;
	  if (m) return m.call(o);
	  return {
	    next: function next() {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	}
	function __read(o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	      r,
	      ar = [],
	      e;

	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
	      ar.push(r.value);
	    }
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }

	  return ar;
	}
	function __spread() {
	  for (var ar = [], i = 0; i < arguments.length; i++) {
	    ar = ar.concat(__read(arguments[i]));
	  }

	  return ar;
	}

	var $native$1 = [].lastIndexOf;
	var NEGATIVE_ZERO$1 = !!$native$1 && 1 / [1].lastIndexOf(1, -0) < 0;

	_export(_export.P + _export.F * (NEGATIVE_ZERO$1 || !_strictMethod($native$1)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	    // convert -0 to +0
	    if (NEGATIVE_ZERO$1) return $native$1.apply(this, arguments) || 0;
	    var O = _toIobject(this);
	    var length = _toLength(O.length);
	    var index = length - 1;
	    if (arguments.length > 1) index = Math.min(index, _toInteger(arguments[1]));
	    if (index < 0) index = length + index;
	    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
	    return -1;
	  }
	});

	var _arrayReduce = function (that, callbackfn, aLen, memo, isRight) {
	  _aFunction(callbackfn);
	  var O = _toObject(that);
	  var self = _iobject(O);
	  var length = _toLength(O.length);
	  var index = isRight ? length - 1 : 0;
	  var i = isRight ? -1 : 1;
	  if (aLen < 2) for (;;) {
	    if (index in self) {
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if (isRight ? index < 0 : length <= index) {
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};

	_export(_export.P + _export.F * !_strictMethod([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return _arrayReduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

	var SPECIES$2 = _wks('species');

	var _arraySpeciesConstructor = function (original) {
	  var C;
	  if (_isArray(original)) {
	    C = original.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;
	    if (_isObject(C)) {
	      C = C[SPECIES$2];
	      if (C === null) C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)


	var _arraySpeciesCreate = function (original, length) {
	  return new (_arraySpeciesConstructor(original))(length);
	};

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex





	var _arrayMethods = function (TYPE, $create) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  var create = $create || _arraySpeciesCreate;
	  return function ($this, callbackfn, that) {
	    var O = _toObject($this);
	    var self = _iobject(O);
	    var f = _ctx(callbackfn, that, 3);
	    var length = _toLength(self.length);
	    var index = 0;
	    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var val, res;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      val = self[index];
	      res = f(val, index, O);
	      if (TYPE) {
	        if (IS_MAP) result[index] = res;   // map
	        else if (res) switch (TYPE) {
	          case 3: return true;             // some
	          case 5: return val;              // find
	          case 6: return index;            // findIndex
	          case 2: result.push(val);        // filter
	        } else if (IS_EVERY) return false; // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

	var $filter = _arrayMethods(2);

	_export(_export.P + _export.F * !_strictMethod([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

	// 7.2.9 SameValue(x, y)
	var _sameValue = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

	var builtinExec = RegExp.prototype.exec;

	 // `RegExpExec` abstract operation
	// https://tc39.github.io/ecma262/#sec-regexpexec
	var _regexpExecAbstract = function (R, S) {
	  var exec = R.exec;
	  if (typeof exec === 'function') {
	    var result = exec.call(R, S);
	    if (typeof result !== 'object') {
	      throw new TypeError('RegExp exec method returned something other than an Object or null');
	    }
	    return result;
	  }
	  if (_classof(R) !== 'RegExp') {
	    throw new TypeError('RegExp#exec called on incompatible receiver');
	  }
	  return builtinExec.call(R, S);
	};

	// 21.2.5.3 get RegExp.prototype.flags

	var _flags = function () {
	  var that = _anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

	var nativeExec = RegExp.prototype.exec;
	// This always refers to the native implementation, because the
	// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
	// which loads this file before patching the method.
	var nativeReplace = String.prototype.replace;

	var patchedExec = nativeExec;

	var LAST_INDEX = 'lastIndex';

	var UPDATES_LAST_INDEX_WRONG = (function () {
	  var re1 = /a/,
	      re2 = /b*/g;
	  nativeExec.call(re1, 'a');
	  nativeExec.call(re2, 'a');
	  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
	})();

	// nonparticipating capturing group, copied from es5-shim's String#split patch.
	var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

	var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

	if (PATCH) {
	  patchedExec = function exec(str) {
	    var re = this;
	    var lastIndex, reCopy, match, i;

	    if (NPCG_INCLUDED) {
	      reCopy = new RegExp('^' + re.source + '$(?!\\s)', _flags.call(re));
	    }
	    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

	    match = nativeExec.call(re, str);

	    if (UPDATES_LAST_INDEX_WRONG && match) {
	      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
	    }
	    if (NPCG_INCLUDED && match && match.length > 1) {
	      // Fix browsers whose `exec` methods don't consistently return `undefined`
	      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
	      // eslint-disable-next-line no-loop-func
	      nativeReplace.call(match[0], reCopy, function () {
	        for (i = 1; i < arguments.length - 2; i++) {
	          if (arguments[i] === undefined) match[i] = undefined;
	        }
	      });
	    }

	    return match;
	  };
	}

	var _regexpExec = patchedExec;

	_export({
	  target: 'RegExp',
	  proto: true,
	  forced: _regexpExec !== /./.exec
	}, {
	  exec: _regexpExec
	});

	var SPECIES$3 = _wks('species');

	var REPLACE_SUPPORTS_NAMED_GROUPS = !_fails(function () {
	  // #replace needs built-in support for named groups.
	  // #match works fine because it just return the exec results, even if it has
	  // a "grops" property.
	  var re = /./;
	  re.exec = function () {
	    var result = [];
	    result.groups = { a: '7' };
	    return result;
	  };
	  return ''.replace(re, '$<a>') !== '7';
	});

	var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
	  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
	  var re = /(?:)/;
	  var originalExec = re.exec;
	  re.exec = function () { return originalExec.apply(this, arguments); };
	  var result = 'ab'.split(re);
	  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
	})();

	var _fixReWks = function (KEY, length, exec) {
	  var SYMBOL = _wks(KEY);

	  var DELEGATES_TO_SYMBOL = !_fails(function () {
	    // String methods call symbol-named RegEp methods
	    var O = {};
	    O[SYMBOL] = function () { return 7; };
	    return ''[KEY](O) != 7;
	  });

	  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !_fails(function () {
	    // Symbol-named RegExp methods call .exec
	    var execCalled = false;
	    var re = /a/;
	    re.exec = function () { execCalled = true; return null; };
	    if (KEY === 'split') {
	      // RegExp[@@split] doesn't call the regex's exec method, but first creates
	      // a new one. We need to return the patched regex when creating the new one.
	      re.constructor = {};
	      re.constructor[SPECIES$3] = function () { return re; };
	    }
	    re[SYMBOL]('');
	    return !execCalled;
	  }) : undefined;

	  if (
	    !DELEGATES_TO_SYMBOL ||
	    !DELEGATES_TO_EXEC ||
	    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
	    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
	  ) {
	    var nativeRegExpMethod = /./[SYMBOL];
	    var fns = exec(
	      _defined,
	      SYMBOL,
	      ''[KEY],
	      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
	        if (regexp.exec === _regexpExec) {
	          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
	            // The native String method already delegates to @@method (this
	            // polyfilled function), leasing to infinite recursion.
	            // We avoid it by directly calling the native @@method method.
	            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
	          }
	          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
	        }
	        return { done: false };
	      }
	    );
	    var strfn = fns[0];
	    var rxfn = fns[1];

	    _redefine(String.prototype, KEY, strfn);
	    _hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function (string, arg) { return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function (string) { return rxfn.call(string, this); }
	    );
	  }
	};

	// @@search logic
	_fixReWks('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
	  return [
	    // `String.prototype.search` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.search
	    function search(regexp) {
	      var O = defined(this);
	      var fn = regexp == undefined ? undefined : regexp[SEARCH];
	      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	    },
	    // `RegExp.prototype[@@search]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
	    function (regexp) {
	      var res = maybeCallNative($search, regexp, this);
	      if (res.done) return res.value;
	      var rx = _anObject(regexp);
	      var S = String(this);
	      var previousLastIndex = rx.lastIndex;
	      if (!_sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
	      var result = _regexpExecAbstract(rx, S);
	      if (!_sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
	      return result === null ? -1 : result.index;
	    }
	  ];
	});

	var _validateCollection = function (it, TYPE) {
	  if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
	  return it;
	};

	var getWeak = _meta.getWeak;







	var arrayFind = _arrayMethods(5);
	var arrayFindIndex = _arrayMethods(6);
	var id$2 = 0;

	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function (that) {
	  return that._l || (that._l = new UncaughtFrozenStore());
	};
	var UncaughtFrozenStore = function () {
	  this.a = [];
	};
	var findUncaughtFrozen = function (store, key) {
	  return arrayFind(store.a, function (it) {
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function (key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) return entry[1];
	  },
	  has: function (key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function (key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function (key) {
	    var index = arrayFindIndex(this.a, function (it) {
	      return it[0] === key;
	    });
	    if (~index) this.a.splice(index, 1);
	    return !!~index;
	  }
	};

	var _collectionWeak = {
	  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      _anInstance(that, C, NAME, '_i');
	      that._t = NAME;      // collection type
	      that._i = id$2++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    _redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function (key) {
	        if (!_isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME))['delete'](key);
	        return data && _has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key) {
	        if (!_isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME)).has(key);
	        return data && _has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function (that, key, value) {
	    var data = getWeak(_anObject(key), true);
	    if (data === true) uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};

	var setPrototypeOf = _setProto.set;
	var _inheritIfRequired = function (that, target, C) {
	  var S = target.constructor;
	  var P;
	  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf) {
	    setPrototypeOf(that, P);
	  } return that;
	};

	var _collection = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
	  var Base = _global[NAME];
	  var C = Base;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var proto = C && C.prototype;
	  var O = {};
	  var fixMethod = function (KEY) {
	    var fn = proto[KEY];
	    _redefine(proto, KEY,
	      KEY == 'delete' ? function (a) {
	        return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a) {
	        return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a) {
	        return IS_WEAK && !_isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
	    new C().entries().next();
	  }))) {
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    _redefineAll(C.prototype, methods);
	    _meta.NEED = true;
	  } else {
	    var instance = new C();
	    // early implementations not supports chaining
	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	    var THROWS_ON_PRIMITIVES = _fails(function () { instance.has(1); });
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    var ACCEPT_ITERABLES = _iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
	    // for early implementations -0 and +0 not the same
	    var BUGGY_ZERO = !IS_WEAK && _fails(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new C();
	      var index = 5;
	      while (index--) $instance[ADDER](index, index);
	      return !$instance.has(-0);
	    });
	    if (!ACCEPT_ITERABLES) {
	      C = wrapper(function (target, iterable) {
	        _anInstance(target, C, NAME);
	        var that = _inheritIfRequired(new Base(), target, C);
	        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if (IS_WEAK && proto.clear) delete proto.clear;
	  }

	  _setToStringTag(C, NAME);

	  O[NAME] = C;
	  _export(_export.G + _export.W + _export.F * (C != Base), O);

	  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

	  return C;
	};

	var es6_weakMap = createCommonjsModule(function (module) {

	var each = _arrayMethods(0);






	var NATIVE_WEAK_MAP = _validateCollection;
	var IS_IE11 = !_global.ActiveXObject && 'ActiveXObject' in _global;
	var WEAK_MAP = 'WeakMap';
	var getWeak = _meta.getWeak;
	var isExtensible = Object.isExtensible;
	var uncaughtFrozenStore = _collectionWeak.ufstore;
	var InternalMap;

	var wrapper = function (get) {
	  return function WeakMap() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};

	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key) {
	    if (_isObject(key)) {
	      var data = getWeak(key);
	      if (data === true) return uncaughtFrozenStore(_validateCollection(this, WEAK_MAP)).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value) {
	    return _collectionWeak.def(_validateCollection(this, WEAK_MAP), key, value);
	  }
	};

	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = _collection(WEAK_MAP, wrapper, methods, _collectionWeak, true, true);

	// IE11 WeakMap frozen keys fix
	if (NATIVE_WEAK_MAP && IS_IE11) {
	  InternalMap = _collectionWeak.getConstructor(wrapper, WEAK_MAP);
	  _objectAssign(InternalMap.prototype, methods);
	  _meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function (key) {
	    var proto = $WeakMap.prototype;
	    var method = proto[key];
	    _redefine(proto, key, function (a, b) {
	      // store frozen objects on internal weakmap shim
	      if (_isObject(a) && !isExtensible(a)) {
	        if (!this._f) this._f = new InternalMap();
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}
	});

	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

	var $find = _arrayMethods(5);
	var KEY = 'find';
	var forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () { forced = false; });
	_export(_export.P + _export.F * forced, 'Array', {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	_addToUnscopables(KEY);

	var $sort = [].sort;
	var test = [1, 2, 3];

	_export(_export.P + _export.F * (_fails(function () {
	  // IE8-
	  test.sort(undefined);
	}) || !_fails(function () {
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !_strictMethod($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn) {
	    return comparefn === undefined
	      ? $sort.call(_toObject(this))
	      : $sort.call(_toObject(this), _aFunction(comparefn));
	  }
	});

	var _createProperty = function (object, index, value) {
	  if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));
	  else object[index] = value;
	};

	_export(_export.S + _export.F * !_iterDetect(function (iter) { }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	    var O = _toObject(arrayLike);
	    var C = typeof this == 'function' ? this : Array;
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var index = 0;
	    var iterFn = core_getIteratorMethod(O);
	    var length, result, step, iterator;
	    if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
	      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
	        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = _toLength(O.length);
	      for (result = new C(length); length > index; index++) {
	        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});

	var dP$2 = _objectDp.f;









	var fastKey = _meta.fastKey;

	var SIZE = _descriptors ? '_s' : 'size';

	var getEntry = function (that, key) {
	  // fast case
	  var index = fastKey(key);
	  var entry;
	  if (index !== 'F') return that._i[index];
	  // frozen object case
	  for (entry = that._f; entry; entry = entry.n) {
	    if (entry.k == key) return entry;
	  }
	};

	var _collectionStrong = {
	  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      _anInstance(that, C, NAME, '_i');
	      that._t = NAME;         // collection type
	      that._i = _objectCreate(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    _redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
	          entry.r = true;
	          if (entry.p) entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function (key) {
	        var that = _validateCollection(this, NAME);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.n;
	          var prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if (prev) prev.n = next;
	          if (next) next.p = prev;
	          if (that._f == entry) that._f = next;
	          if (that._l == entry) that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        _validateCollection(this, NAME);
	        var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;
	        while (entry = entry ? entry.n : this._f) {
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while (entry && entry.r) entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(_validateCollection(this, NAME), key);
	      }
	    });
	    if (_descriptors) dP$2(C.prototype, 'size', {
	      get: function () {
	        return _validateCollection(this, NAME)[SIZE];
	      }
	    });
	    return C;
	  },
	  def: function (that, key, value) {
	    var entry = getEntry(that, key);
	    var prev, index;
	    // change existing entry
	    if (entry) {
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if (!that._f) that._f = entry;
	      if (prev) prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if (index !== 'F') that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function (C, NAME, IS_MAP) {
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    _iterDefine(C, NAME, function (iterated, kind) {
	      this._t = _validateCollection(iterated, NAME); // target
	      this._k = kind;                     // kind
	      this._l = undefined;                // previous
	    }, function () {
	      var that = this;
	      var kind = that._k;
	      var entry = that._l;
	      // revert to the last existing entry
	      while (entry && entry.r) entry = entry.p;
	      // get next entry
	      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
	        // or finish the iteration
	        that._t = undefined;
	        return _iterStep(1);
	      }
	      // return step by kind
	      if (kind == 'keys') return _iterStep(0, entry.k);
	      if (kind == 'values') return _iterStep(0, entry.v);
	      return _iterStep(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    _setSpecies(NAME);
	  }
	};

	var SET = 'Set';

	// 23.2 Set Objects
	var es6_set = _collection(SET, function (get) {
	  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value) {
	    return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);
	  }
	}, _collectionStrong);

	var _arrayFill = function fill(value /* , start = 0, end = @length */) {
	  var O = _toObject(this);
	  var length = _toLength(O.length);
	  var aLen = arguments.length;
	  var index = _toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
	  var end = aLen > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : _toAbsoluteIndex(end, length);
	  while (endPos > index) O[index++] = value;
	  return O;
	};

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


	_export(_export.P, 'Array', { fill: _arrayFill });

	_addToUnscopables('fill');

	// 7.2.8 IsRegExp(argument)


	var MATCH = _wks('match');
	var _isRegexp = function (it) {
	  var isRegExp;
	  return _isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : _cof(it) == 'RegExp');
	};

	// helper for String#{startsWith, endsWith, includes}



	var _stringContext = function (that, searchString, NAME) {
	  if (_isRegexp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(_defined(that));
	};

	var MATCH$1 = _wks('match');
	var _failsIsRegexp = function (KEY) {
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch (e) {
	    try {
	      re[MATCH$1] = false;
	      return !'/./'[KEY](re);
	    } catch (f) { /* empty */ }
	  } return true;
	};

	var STARTS_WITH = 'startsWith';
	var $startsWith = ''[STARTS_WITH];

	_export(_export.P + _export.F * _failsIsRegexp(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = _stringContext(this, searchString, STARTS_WITH);
	    var index = _toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

	var dP$3 = _objectDp.f;
	var gOPN$2 = _objectGopn.f;


	var $RegExp = _global.RegExp;
	var Base = $RegExp;
	var proto$1 = $RegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g;
	// "new" creates a new object, old webkit buggy here
	var CORRECT_NEW = new $RegExp(re1) !== re1;

	if (_descriptors && (!CORRECT_NEW || _fails(function () {
	  re2[_wks('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))) {
	  $RegExp = function RegExp(p, f) {
	    var tiRE = this instanceof $RegExp;
	    var piRE = _isRegexp(p);
	    var fiU = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : _inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? _flags.call(p) : f)
	      , tiRE ? this : proto$1, $RegExp);
	  };
	  var proxy = function (key) {
	    key in $RegExp || dP$3($RegExp, key, {
	      configurable: true,
	      get: function () { return Base[key]; },
	      set: function (it) { Base[key] = it; }
	    });
	  };
	  for (var keys = gOPN$2(Base), i$1 = 0; keys.length > i$1;) proxy(keys[i$1++]);
	  proto$1.constructor = $RegExp;
	  $RegExp.prototype = proto$1;
	  _redefine(_global, 'RegExp', $RegExp);
	}

	_setSpecies('RegExp');

	var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var space = '[' + _stringWs + ']';
	var non = '\u200b\u0085';
	var ltrim = RegExp('^' + space + space + '*');
	var rtrim = RegExp(space + space + '*$');

	var exporter = function (KEY, exec, ALIAS) {
	  var exp = {};
	  var FORCE = _fails(function () {
	    return !!_stringWs[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
	  if (ALIAS) exp[ALIAS] = fn;
	  _export(_export.P + _export.F * FORCE, 'String', exp);
	};

	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function (string, TYPE) {
	  string = String(_defined(string));
	  if (TYPE & 1) string = string.replace(ltrim, '');
	  if (TYPE & 2) string = string.replace(rtrim, '');
	  return string;
	};

	var _stringTrim = exporter;

	// 21.1.3.25 String.prototype.trim()
	_stringTrim('trim', function ($trim) {
	  return function trim() {
	    return $trim(this, 3);
	  };
	});

	// true  -> String#at
	// false -> String#codePointAt
	var _stringAt = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(_defined(that));
	    var i = _toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

	var at = _stringAt(true);

	 // `AdvanceStringIndex` abstract operation
	// https://tc39.github.io/ecma262/#sec-advancestringindex
	var _advanceStringIndex = function (S, index, unicode) {
	  return index + (unicode ? at(S, index).length : 1);
	};

	var $min = Math.min;
	var $push = [].push;
	var $SPLIT = 'split';
	var LENGTH = 'length';
	var LAST_INDEX$1 = 'lastIndex';
	var MAX_UINT32 = 0xffffffff;

	// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
	var SUPPORTS_Y = !_fails(function () { });

	// @@split logic
	_fixReWks('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
	  var internalSplit;
	  if (
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ) {
	    // based on es5-shim implementation, need to rework it
	    internalSplit = function (separator, limit) {
	      var string = String(this);
	      if (separator === undefined && limit === 0) return [];
	      // If `separator` is not a regex, use native split
	      if (!_isRegexp(separator)) return $split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var match, lastIndex, lastLength;
	      while (match = _regexpExec.call(separatorCopy, string)) {
	        lastIndex = separatorCopy[LAST_INDEX$1];
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if (output[LENGTH] >= splitLimit) break;
	        }
	        if (separatorCopy[LAST_INDEX$1] === match.index) separatorCopy[LAST_INDEX$1]++; // Avoid an infinite loop
	      }
	      if (lastLastIndex === string[LENGTH]) {
	        if (lastLength || !separatorCopy.test('')) output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
	    internalSplit = function (separator, limit) {
	      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
	    };
	  } else {
	    internalSplit = $split;
	  }

	  return [
	    // `String.prototype.split` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.split
	    function split(separator, limit) {
	      var O = defined(this);
	      var splitter = separator == undefined ? undefined : separator[SPLIT];
	      return splitter !== undefined
	        ? splitter.call(separator, O, limit)
	        : internalSplit.call(String(O), separator, limit);
	    },
	    // `RegExp.prototype[@@split]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
	    //
	    // NOTE: This cannot be properly polyfilled in engines that don't support
	    // the 'y' flag.
	    function (regexp, limit) {
	      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
	      if (res.done) return res.value;

	      var rx = _anObject(regexp);
	      var S = String(this);
	      var C = _speciesConstructor(rx, RegExp);

	      var unicodeMatching = rx.unicode;
	      var flags = (rx.ignoreCase ? 'i' : '') +
	                  (rx.multiline ? 'm' : '') +
	                  (rx.unicode ? 'u' : '') +
	                  (SUPPORTS_Y ? 'y' : 'g');

	      // ^(? + rx + ) is needed, in combination with some S slicing, to
	      // simulate the 'y' flag.
	      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
	      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      if (lim === 0) return [];
	      if (S.length === 0) return _regexpExecAbstract(splitter, S) === null ? [S] : [];
	      var p = 0;
	      var q = 0;
	      var A = [];
	      while (q < S.length) {
	        splitter.lastIndex = SUPPORTS_Y ? q : 0;
	        var z = _regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
	        var e;
	        if (
	          z === null ||
	          (e = $min(_toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
	        ) {
	          q = _advanceStringIndex(S, q, unicodeMatching);
	        } else {
	          A.push(S.slice(p, q));
	          if (A.length === lim) return A;
	          for (var i = 1; i <= z.length - 1; i++) {
	            A.push(z[i]);
	            if (A.length === lim) return A;
	          }
	          q = p = e;
	        }
	      }
	      A.push(S.slice(p));
	      return A;
	    }
	  ];
	});

	// @@match logic
	_fixReWks('match', 1, function (defined, MATCH, $match, maybeCallNative) {
	  return [
	    // `String.prototype.match` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.match
	    function match(regexp) {
	      var O = defined(this);
	      var fn = regexp == undefined ? undefined : regexp[MATCH];
	      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	    },
	    // `RegExp.prototype[@@match]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
	    function (regexp) {
	      var res = maybeCallNative($match, regexp, this);
	      if (res.done) return res.value;
	      var rx = _anObject(regexp);
	      var S = String(this);
	      if (!rx.global) return _regexpExecAbstract(rx, S);
	      var fullUnicode = rx.unicode;
	      rx.lastIndex = 0;
	      var A = [];
	      var n = 0;
	      var result;
	      while ((result = _regexpExecAbstract(rx, S)) !== null) {
	        var matchStr = String(result[0]);
	        A[n] = matchStr;
	        if (matchStr === '') rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode);
	        n++;
	      }
	      return n === 0 ? null : A;
	    }
	  ];
	});

	// most Object methods by ES6 should accept primitives



	var _objectSap = function (KEY, exec) {
	  var fn = (_core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
	};

	// 19.1.2.14 Object.keys(O)



	_objectSap('keys', function () {
	  return function keys(it) {
	    return _objectKeys(_toObject(it));
	  };
	});

	var $at = _stringAt(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	_iterDefine(String, 'String', function (iterated) {
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var index = this._i;
	  var point;
	  if (index >= O.length) return { value: undefined, done: true };
	  point = $at(O, index);
	  this._i += point.length;
	  return { value: point, done: false };
	});

	var MAP = 'Map';

	// 23.1 Map Objects
	var es6_map = _collection(MAP, function (get) {
	  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key) {
	    var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value) {
	    return _collectionStrong.def(_validateCollection(this, MAP), key === 0 ? 0 : key, value);
	  }
	}, _collectionStrong, true);

	var $some = _arrayMethods(3);

	_export(_export.P + _export.F * !_strictMethod([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

	// 21.2.5.3 get RegExp.prototype.flags()
	if (_descriptors && /./g.flags != 'g') _objectDp.f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: _flags
	});

	// 19.1.2.5 Object.freeze(O)

	var meta = _meta.onFreeze;

	_objectSap('freeze', function ($freeze) {
	  return function freeze(it) {
	    return $freeze && _isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

	var $forEach = _arrayMethods(0);
	var STRICT = _strictMethod([].forEach, true);

	_export(_export.P + _export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */) {
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

	var max$1 = Math.max;
	var min$2 = Math.min;
	var floor$1 = Math.floor;
	var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
	var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

	var maybeToString = function (it) {
	  return it === undefined ? it : String(it);
	};

	// @@replace logic
	_fixReWks('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
	  return [
	    // `String.prototype.replace` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
	    function replace(searchValue, replaceValue) {
	      var O = defined(this);
	      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	      return fn !== undefined
	        ? fn.call(searchValue, O, replaceValue)
	        : $replace.call(String(O), searchValue, replaceValue);
	    },
	    // `RegExp.prototype[@@replace]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
	    function (regexp, replaceValue) {
	      var res = maybeCallNative($replace, regexp, this, replaceValue);
	      if (res.done) return res.value;

	      var rx = _anObject(regexp);
	      var S = String(this);
	      var functionalReplace = typeof replaceValue === 'function';
	      if (!functionalReplace) replaceValue = String(replaceValue);
	      var global = rx.global;
	      if (global) {
	        var fullUnicode = rx.unicode;
	        rx.lastIndex = 0;
	      }
	      var results = [];
	      while (true) {
	        var result = _regexpExecAbstract(rx, S);
	        if (result === null) break;
	        results.push(result);
	        if (!global) break;
	        var matchStr = String(result[0]);
	        if (matchStr === '') rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode);
	      }
	      var accumulatedResult = '';
	      var nextSourcePosition = 0;
	      for (var i = 0; i < results.length; i++) {
	        result = results[i];
	        var matched = String(result[0]);
	        var position = max$1(min$2(_toInteger(result.index), S.length), 0);
	        var captures = [];
	        // NOTE: This is equivalent to
	        //   captures = result.slice(1).map(maybeToString)
	        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
	        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
	        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
	        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
	        var namedCaptures = result.groups;
	        if (functionalReplace) {
	          var replacerArgs = [matched].concat(captures, position, S);
	          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
	          var replacement = String(replaceValue.apply(undefined, replacerArgs));
	        } else {
	          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
	        }
	        if (position >= nextSourcePosition) {
	          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
	          nextSourcePosition = position + matched.length;
	        }
	      }
	      return accumulatedResult + S.slice(nextSourcePosition);
	    }
	  ];

	    // https://tc39.github.io/ecma262/#sec-getsubstitution
	  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
	    var tailPos = position + matched.length;
	    var m = captures.length;
	    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
	    if (namedCaptures !== undefined) {
	      namedCaptures = _toObject(namedCaptures);
	      symbols = SUBSTITUTION_SYMBOLS;
	    }
	    return $replace.call(replacement, symbols, function (match, ch) {
	      var capture;
	      switch (ch.charAt(0)) {
	        case '$': return '$';
	        case '&': return matched;
	        case '`': return str.slice(0, position);
	        case "'": return str.slice(tailPos);
	        case '<':
	          capture = namedCaptures[ch.slice(1, -1)];
	          break;
	        default: // \d\d?
	          var n = +ch;
	          if (n === 0) return match;
	          if (n > m) {
	            var f = floor$1(n / 10);
	            if (f === 0) return match;
	            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
	            return match;
	          }
	          capture = captures[n - 1];
	      }
	      return capture === undefined ? '' : capture;
	    });
	  }
	});

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)


	_export(_export.S, 'Array', { isArray: _isArray });

	var TO_STRING = 'toString';
	var $toString = /./[TO_STRING];

	var define = function (fn) {
	  _redefine(RegExp.prototype, TO_STRING, fn, true);
	};

	// 21.2.5.14 RegExp.prototype.toString()
	if (_fails(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
	  define(function toString() {
	    var R = _anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !_descriptors && R instanceof RegExp ? _flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if ($toString.name != TO_STRING) {
	  define(function toString() {
	    return $toString.call(this);
	  });
	}

	var DateProto = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING$1 = 'toString';
	var $toString$1 = DateProto[TO_STRING$1];
	var getTime = DateProto.getTime;
	if (new Date(NaN) + '' != INVALID_DATE) {
	  _redefine(DateProto, TO_STRING$1, function toString() {
	    var value = getTime.call(this);
	    // eslint-disable-next-line no-self-compare
	    return value === value ? $toString$1.call(this) : INVALID_DATE;
	  });
	}

	var $map = _arrayMethods(1);

	_export(_export.P + _export.F * !_strictMethod([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

	var dP$4 = _objectDp.f;
	var FProto = Function.prototype;
	var nameRE = /^\s*function ([^ (]*)/;
	var NAME$1 = 'name';

	// 19.2.4.2 name
	NAME$1 in FProto || _descriptors && dP$4(FProto, NAME$1, {
	  configurable: true,
	  get: function () {
	    try {
	      return ('' + this).match(nameRE)[1];
	    } catch (e) {
	      return '';
	    }
	  }
	});

	var arraySlice = [].slice;
	var factories = {};

	var construct = function (F, len, args) {
	  if (!(len in factories)) {
	    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
	    // eslint-disable-next-line no-new-func
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};

	var _bind = Function.bind || function bind(that /* , ...args */) {
	  var fn = _aFunction(this);
	  var partArgs = arraySlice.call(arguments, 1);
	  var bound = function (/* args... */) {
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : _invoke(fn, args, that);
	  };
	  if (_isObject(fn.prototype)) bound.prototype = fn.prototype;
	  return bound;
	};

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)


	_export(_export.P, 'Function', { bind: _bind });

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function isFunction(x) {
	  return typeof x === 'function';
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	var _enable_super_gross_mode_that_will_cause_bad_things = false;
	var config = {
	  Promise: undefined,

	  set useDeprecatedSynchronousErrorHandling(value) {
	    if (value) {
	      var error =
	      /*@__PURE__*/
	      new Error();
	      /*@__PURE__*/

	      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
	    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
	      /*@__PURE__*/
	      console.log('RxJS: Back to a better error behavior. Thank you. <3');
	    }

	    _enable_super_gross_mode_that_will_cause_bad_things = value;
	  },

	  get useDeprecatedSynchronousErrorHandling() {
	    return _enable_super_gross_mode_that_will_cause_bad_things;
	  }

	};

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function hostReportError(err) {
	  setTimeout(function () {
	    throw err;
	  }, 0);
	}

	/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
	var empty$1 = {
	  closed: true,
	  next: function next(value) {},
	  error: function error(err) {
	    if (config.useDeprecatedSynchronousErrorHandling) {
	      throw err;
	    } else {
	      hostReportError(err);
	    }
	  },
	  complete: function complete() {}
	};

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	var isArray = Array.isArray || function (x) {
	  return x && typeof x.length === 'number';
	};

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function isObject(x) {
	  return x !== null && _typeof(x) === 'object';
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function UnsubscriptionErrorImpl(errors) {
	  Error.call(this);
	  this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) {
	    return i + 1 + ") " + err.toString();
	  }).join('\n  ') : '';
	  this.name = 'UnsubscriptionError';
	  this.errors = errors;
	  return this;
	}

	UnsubscriptionErrorImpl.prototype =
	/*@__PURE__*/
	Object.create(Error.prototype);
	var UnsubscriptionError = UnsubscriptionErrorImpl;

	var Subscription =
	/*@__PURE__*/
	function () {
	  function Subscription(unsubscribe) {
	    this.closed = false;
	    this._parentOrParents = null;
	    this._subscriptions = null;

	    if (unsubscribe) {
	      this._unsubscribe = unsubscribe;
	    }
	  }

	  Subscription.prototype.unsubscribe = function () {
	    var errors;

	    if (this.closed) {
	      return;
	    }

	    var _a = this,
	        _parentOrParents = _a._parentOrParents,
	        _unsubscribe = _a._unsubscribe,
	        _subscriptions = _a._subscriptions;

	    this.closed = true;
	    this._parentOrParents = null;
	    this._subscriptions = null;

	    if (_parentOrParents instanceof Subscription) {
	      _parentOrParents.remove(this);
	    } else if (_parentOrParents !== null) {
	      for (var index = 0; index < _parentOrParents.length; ++index) {
	        var parent_1 = _parentOrParents[index];
	        parent_1.remove(this);
	      }
	    }

	    if (isFunction(_unsubscribe)) {
	      try {
	        _unsubscribe.call(this);
	      } catch (e) {
	        errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
	      }
	    }

	    if (isArray(_subscriptions)) {
	      var index = -1;
	      var len = _subscriptions.length;

	      while (++index < len) {
	        var sub = _subscriptions[index];

	        if (isObject(sub)) {
	          try {
	            sub.unsubscribe();
	          } catch (e) {
	            errors = errors || [];

	            if (e instanceof UnsubscriptionError) {
	              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
	            } else {
	              errors.push(e);
	            }
	          }
	        }
	      }
	    }

	    if (errors) {
	      throw new UnsubscriptionError(errors);
	    }
	  };

	  Subscription.prototype.add = function (teardown) {
	    var subscription = teardown;

	    switch (_typeof(teardown)) {
	      case 'function':
	        subscription = new Subscription(teardown);

	      case 'object':
	        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
	          return subscription;
	        } else if (this.closed) {
	          subscription.unsubscribe();
	          return subscription;
	        } else if (!(subscription instanceof Subscription)) {
	          var tmp = subscription;
	          subscription = new Subscription();
	          subscription._subscriptions = [tmp];
	        }

	        break;

	      default:
	        {
	          if (!teardown) {
	            return Subscription.EMPTY;
	          }

	          throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	    }

	    var _parentOrParents = subscription._parentOrParents;

	    if (_parentOrParents === null) {
	      subscription._parentOrParents = this;
	    } else if (_parentOrParents instanceof Subscription) {
	      if (_parentOrParents === this) {
	        return subscription;
	      }

	      subscription._parentOrParents = [_parentOrParents, this];
	    } else if (_parentOrParents.indexOf(this) === -1) {
	      _parentOrParents.push(this);
	    } else {
	      return subscription;
	    }

	    var subscriptions = this._subscriptions;

	    if (subscriptions === null) {
	      this._subscriptions = [subscription];
	    } else {
	      subscriptions.push(subscription);
	    }

	    return subscription;
	  };

	  Subscription.prototype.remove = function (subscription) {
	    var subscriptions = this._subscriptions;

	    if (subscriptions) {
	      var subscriptionIndex = subscriptions.indexOf(subscription);

	      if (subscriptionIndex !== -1) {
	        subscriptions.splice(subscriptionIndex, 1);
	      }
	    }
	  };

	  Subscription.EMPTY = function (empty) {
	    empty.closed = true;
	    return empty;
	  }(new Subscription());

	  return Subscription;
	}();

	function flattenUnsubscriptionErrors(errors) {
	  return errors.reduce(function (errs, err) {
	    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
	  }, []);
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	var rxSubscriber = typeof Symbol === 'function' ?
	/*@__PURE__*/
	Symbol('rxSubscriber') : '@@rxSubscriber_' +
	/*@__PURE__*/
	Math.random();

	var Subscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(Subscriber, _super);

	  function Subscriber(destinationOrNext, error, complete) {
	    var _this = _super.call(this) || this;

	    _this.syncErrorValue = null;
	    _this.syncErrorThrown = false;
	    _this.syncErrorThrowable = false;
	    _this.isStopped = false;

	    switch (arguments.length) {
	      case 0:
	        _this.destination = empty$1;
	        break;

	      case 1:
	        if (!destinationOrNext) {
	          _this.destination = empty$1;
	          break;
	        }

	        if (_typeof(destinationOrNext) === 'object') {
	          if (destinationOrNext instanceof Subscriber) {
	            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
	            _this.destination = destinationOrNext;
	            destinationOrNext.add(_this);
	          } else {
	            _this.syncErrorThrowable = true;
	            _this.destination = new SafeSubscriber(_this, destinationOrNext);
	          }

	          break;
	        }

	      default:
	        _this.syncErrorThrowable = true;
	        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
	        break;
	    }

	    return _this;
	  }

	  Subscriber.prototype[rxSubscriber] = function () {
	    return this;
	  };

	  Subscriber.create = function (next, error, complete) {
	    var subscriber = new Subscriber(next, error, complete);
	    subscriber.syncErrorThrowable = false;
	    return subscriber;
	  };

	  Subscriber.prototype.next = function (value) {
	    if (!this.isStopped) {
	      this._next(value);
	    }
	  };

	  Subscriber.prototype.error = function (err) {
	    if (!this.isStopped) {
	      this.isStopped = true;

	      this._error(err);
	    }
	  };

	  Subscriber.prototype.complete = function () {
	    if (!this.isStopped) {
	      this.isStopped = true;

	      this._complete();
	    }
	  };

	  Subscriber.prototype.unsubscribe = function () {
	    if (this.closed) {
	      return;
	    }

	    this.isStopped = true;

	    _super.prototype.unsubscribe.call(this);
	  };

	  Subscriber.prototype._next = function (value) {
	    this.destination.next(value);
	  };

	  Subscriber.prototype._error = function (err) {
	    this.destination.error(err);
	    this.unsubscribe();
	  };

	  Subscriber.prototype._complete = function () {
	    this.destination.complete();
	    this.unsubscribe();
	  };

	  Subscriber.prototype._unsubscribeAndRecycle = function () {
	    var _parentOrParents = this._parentOrParents;
	    this._parentOrParents = null;
	    this.unsubscribe();
	    this.closed = false;
	    this.isStopped = false;
	    this._parentOrParents = _parentOrParents;
	    return this;
	  };

	  return Subscriber;
	}(Subscription);

	var SafeSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(SafeSubscriber, _super);

	  function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
	    var _this = _super.call(this) || this;

	    _this._parentSubscriber = _parentSubscriber;
	    var next;
	    var context = _this;

	    if (isFunction(observerOrNext)) {
	      next = observerOrNext;
	    } else if (observerOrNext) {
	      next = observerOrNext.next;
	      error = observerOrNext.error;
	      complete = observerOrNext.complete;

	      if (observerOrNext !== empty$1) {
	        context = Object.create(observerOrNext);

	        if (isFunction(context.unsubscribe)) {
	          _this.add(context.unsubscribe.bind(context));
	        }

	        context.unsubscribe = _this.unsubscribe.bind(_this);
	      }
	    }

	    _this._context = context;
	    _this._next = next;
	    _this._error = error;
	    _this._complete = complete;
	    return _this;
	  }

	  SafeSubscriber.prototype.next = function (value) {
	    if (!this.isStopped && this._next) {
	      var _parentSubscriber = this._parentSubscriber;

	      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
	        this.__tryOrUnsub(this._next, value);
	      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
	        this.unsubscribe();
	      }
	    }
	  };

	  SafeSubscriber.prototype.error = function (err) {
	    if (!this.isStopped) {
	      var _parentSubscriber = this._parentSubscriber;
	      var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;

	      if (this._error) {
	        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
	          this.__tryOrUnsub(this._error, err);

	          this.unsubscribe();
	        } else {
	          this.__tryOrSetError(_parentSubscriber, this._error, err);

	          this.unsubscribe();
	        }
	      } else if (!_parentSubscriber.syncErrorThrowable) {
	        this.unsubscribe();

	        if (useDeprecatedSynchronousErrorHandling) {
	          throw err;
	        }

	        hostReportError(err);
	      } else {
	        if (useDeprecatedSynchronousErrorHandling) {
	          _parentSubscriber.syncErrorValue = err;
	          _parentSubscriber.syncErrorThrown = true;
	        } else {
	          hostReportError(err);
	        }

	        this.unsubscribe();
	      }
	    }
	  };

	  SafeSubscriber.prototype.complete = function () {
	    var _this = this;

	    if (!this.isStopped) {
	      var _parentSubscriber = this._parentSubscriber;

	      if (this._complete) {
	        var wrappedComplete = function wrappedComplete() {
	          return _this._complete.call(_this._context);
	        };

	        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
	          this.__tryOrUnsub(wrappedComplete);

	          this.unsubscribe();
	        } else {
	          this.__tryOrSetError(_parentSubscriber, wrappedComplete);

	          this.unsubscribe();
	        }
	      } else {
	        this.unsubscribe();
	      }
	    }
	  };

	  SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	    try {
	      fn.call(this._context, value);
	    } catch (err) {
	      this.unsubscribe();

	      if (config.useDeprecatedSynchronousErrorHandling) {
	        throw err;
	      } else {
	        hostReportError(err);
	      }
	    }
	  };

	  SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	    if (!config.useDeprecatedSynchronousErrorHandling) {
	      throw new Error('bad call');
	    }

	    try {
	      fn.call(this._context, value);
	    } catch (err) {
	      if (config.useDeprecatedSynchronousErrorHandling) {
	        parent.syncErrorValue = err;
	        parent.syncErrorThrown = true;
	        return true;
	      } else {
	        hostReportError(err);
	        return true;
	      }
	    }

	    return false;
	  };

	  SafeSubscriber.prototype._unsubscribe = function () {
	    var _parentSubscriber = this._parentSubscriber;
	    this._context = null;
	    this._parentSubscriber = null;

	    _parentSubscriber.unsubscribe();
	  };

	  return SafeSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
	function canReportError(observer) {
	  while (observer) {
	    var _a = observer,
	        closed_1 = _a.closed,
	        destination = _a.destination,
	        isStopped = _a.isStopped;

	    if (closed_1 || isStopped) {
	      return false;
	    } else if (destination && destination instanceof Subscriber) {
	      observer = destination;
	    } else {
	      observer = null;
	    }
	  }

	  return true;
	}

	/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
	function toSubscriber(nextOrObserver, error, complete) {
	  if (nextOrObserver) {
	    if (nextOrObserver instanceof Subscriber) {
	      return nextOrObserver;
	    }

	    if (nextOrObserver[rxSubscriber]) {
	      return nextOrObserver[rxSubscriber]();
	    }
	  }

	  if (!nextOrObserver && !error && !complete) {
	    return new Subscriber(empty$1);
	  }

	  return new Subscriber(nextOrObserver, error, complete);
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	var observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function noop() {}

	function pipeFromArray(fns) {
	  if (!fns) {
	    return noop;
	  }

	  if (fns.length === 1) {
	    return fns[0];
	  }

	  return function piped(input) {
	    return fns.reduce(function (prev, fn) {
	      return fn(prev);
	    }, input);
	  };
	}

	var Observable =
	/*@__PURE__*/
	function () {
	  function Observable(subscribe) {
	    this._isScalar = false;

	    if (subscribe) {
	      this._subscribe = subscribe;
	    }
	  }

	  Observable.prototype.lift = function (operator) {
	    var observable$$1 = new Observable();
	    observable$$1.source = this;
	    observable$$1.operator = operator;
	    return observable$$1;
	  };

	  Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	    var operator = this.operator;
	    var sink = toSubscriber(observerOrNext, error, complete);

	    if (operator) {
	      sink.add(operator.call(sink, this.source));
	    } else {
	      sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
	    }

	    if (config.useDeprecatedSynchronousErrorHandling) {
	      if (sink.syncErrorThrowable) {
	        sink.syncErrorThrowable = false;

	        if (sink.syncErrorThrown) {
	          throw sink.syncErrorValue;
	        }
	      }
	    }

	    return sink;
	  };

	  Observable.prototype._trySubscribe = function (sink) {
	    try {
	      return this._subscribe(sink);
	    } catch (err) {
	      if (config.useDeprecatedSynchronousErrorHandling) {
	        sink.syncErrorThrown = true;
	        sink.syncErrorValue = err;
	      }

	      if (canReportError(sink)) {
	        sink.error(err);
	      } else {
	        console.warn(err);
	      }
	    }
	  };

	  Observable.prototype.forEach = function (next, promiseCtor) {
	    var _this = this;

	    promiseCtor = getPromiseCtor(promiseCtor);
	    return new promiseCtor(function (resolve, reject) {
	      var subscription;
	      subscription = _this.subscribe(function (value) {
	        try {
	          next(value);
	        } catch (err) {
	          reject(err);

	          if (subscription) {
	            subscription.unsubscribe();
	          }
	        }
	      }, reject, resolve);
	    });
	  };

	  Observable.prototype._subscribe = function (subscriber) {
	    var source = this.source;
	    return source && source.subscribe(subscriber);
	  };

	  Observable.prototype[observable] = function () {
	    return this;
	  };

	  Observable.prototype.pipe = function () {
	    var operations = [];

	    for (var _i = 0; _i < arguments.length; _i++) {
	      operations[_i] = arguments[_i];
	    }

	    if (operations.length === 0) {
	      return this;
	    }

	    return pipeFromArray(operations)(this);
	  };

	  Observable.prototype.toPromise = function (promiseCtor) {
	    var _this = this;

	    promiseCtor = getPromiseCtor(promiseCtor);
	    return new promiseCtor(function (resolve, reject) {
	      var value;

	      _this.subscribe(function (x) {
	        return value = x;
	      }, function (err) {
	        return reject(err);
	      }, function () {
	        return resolve(value);
	      });
	    });
	  };

	  Observable.create = function (subscribe) {
	    return new Observable(subscribe);
	  };

	  return Observable;
	}();

	function getPromiseCtor(promiseCtor) {
	  if (!promiseCtor) {
	    promiseCtor = config.Promise || Promise;
	  }

	  if (!promiseCtor) {
	    throw new Error('no Promise impl found');
	  }

	  return promiseCtor;
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function ObjectUnsubscribedErrorImpl() {
	  Error.call(this);
	  this.message = 'object unsubscribed';
	  this.name = 'ObjectUnsubscribedError';
	  return this;
	}

	ObjectUnsubscribedErrorImpl.prototype =
	/*@__PURE__*/
	Object.create(Error.prototype);
	var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

	var SubjectSubscription =
	/*@__PURE__*/
	function (_super) {
	  __extends(SubjectSubscription, _super);

	  function SubjectSubscription(subject, subscriber) {
	    var _this = _super.call(this) || this;

	    _this.subject = subject;
	    _this.subscriber = subscriber;
	    _this.closed = false;
	    return _this;
	  }

	  SubjectSubscription.prototype.unsubscribe = function () {
	    if (this.closed) {
	      return;
	    }

	    this.closed = true;
	    var subject = this.subject;
	    var observers = subject.observers;
	    this.subject = null;

	    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
	      return;
	    }

	    var subscriberIndex = observers.indexOf(this.subscriber);

	    if (subscriberIndex !== -1) {
	      observers.splice(subscriberIndex, 1);
	    }
	  };

	  return SubjectSubscription;
	}(Subscription);

	/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */

	var SubjectSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(SubjectSubscriber, _super);

	  function SubjectSubscriber(destination) {
	    var _this = _super.call(this, destination) || this;

	    _this.destination = destination;
	    return _this;
	  }

	  return SubjectSubscriber;
	}(Subscriber);

	var Subject =
	/*@__PURE__*/
	function (_super) {
	  __extends(Subject, _super);

	  function Subject() {
	    var _this = _super.call(this) || this;

	    _this.observers = [];
	    _this.closed = false;
	    _this.isStopped = false;
	    _this.hasError = false;
	    _this.thrownError = null;
	    return _this;
	  }

	  Subject.prototype[rxSubscriber] = function () {
	    return new SubjectSubscriber(this);
	  };

	  Subject.prototype.lift = function (operator) {
	    var subject = new AnonymousSubject(this, this);
	    subject.operator = operator;
	    return subject;
	  };

	  Subject.prototype.next = function (value) {
	    if (this.closed) {
	      throw new ObjectUnsubscribedError();
	    }

	    if (!this.isStopped) {
	      var observers = this.observers;
	      var len = observers.length;
	      var copy = observers.slice();

	      for (var i = 0; i < len; i++) {
	        copy[i].next(value);
	      }
	    }
	  };

	  Subject.prototype.error = function (err) {
	    if (this.closed) {
	      throw new ObjectUnsubscribedError();
	    }

	    this.hasError = true;
	    this.thrownError = err;
	    this.isStopped = true;
	    var observers = this.observers;
	    var len = observers.length;
	    var copy = observers.slice();

	    for (var i = 0; i < len; i++) {
	      copy[i].error(err);
	    }

	    this.observers.length = 0;
	  };

	  Subject.prototype.complete = function () {
	    if (this.closed) {
	      throw new ObjectUnsubscribedError();
	    }

	    this.isStopped = true;
	    var observers = this.observers;
	    var len = observers.length;
	    var copy = observers.slice();

	    for (var i = 0; i < len; i++) {
	      copy[i].complete();
	    }

	    this.observers.length = 0;
	  };

	  Subject.prototype.unsubscribe = function () {
	    this.isStopped = true;
	    this.closed = true;
	    this.observers = null;
	  };

	  Subject.prototype._trySubscribe = function (subscriber) {
	    if (this.closed) {
	      throw new ObjectUnsubscribedError();
	    } else {
	      return _super.prototype._trySubscribe.call(this, subscriber);
	    }
	  };

	  Subject.prototype._subscribe = function (subscriber) {
	    if (this.closed) {
	      throw new ObjectUnsubscribedError();
	    } else if (this.hasError) {
	      subscriber.error(this.thrownError);
	      return Subscription.EMPTY;
	    } else if (this.isStopped) {
	      subscriber.complete();
	      return Subscription.EMPTY;
	    } else {
	      this.observers.push(subscriber);
	      return new SubjectSubscription(this, subscriber);
	    }
	  };

	  Subject.prototype.asObservable = function () {
	    var observable = new Observable();
	    observable.source = this;
	    return observable;
	  };

	  Subject.create = function (destination, source) {
	    return new AnonymousSubject(destination, source);
	  };

	  return Subject;
	}(Observable);

	var AnonymousSubject =
	/*@__PURE__*/
	function (_super) {
	  __extends(AnonymousSubject, _super);

	  function AnonymousSubject(destination, source) {
	    var _this = _super.call(this) || this;

	    _this.destination = destination;
	    _this.source = source;
	    return _this;
	  }

	  AnonymousSubject.prototype.next = function (value) {
	    var destination = this.destination;

	    if (destination && destination.next) {
	      destination.next(value);
	    }
	  };

	  AnonymousSubject.prototype.error = function (err) {
	    var destination = this.destination;

	    if (destination && destination.error) {
	      this.destination.error(err);
	    }
	  };

	  AnonymousSubject.prototype.complete = function () {
	    var destination = this.destination;

	    if (destination && destination.complete) {
	      this.destination.complete();
	    }
	  };

	  AnonymousSubject.prototype._subscribe = function (subscriber) {
	    var source = this.source;

	    if (source) {
	      return this.source.subscribe(subscriber);
	    } else {
	      return Subscription.EMPTY;
	    }
	  };

	  return AnonymousSubject;
	}(Subject);

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function refCount() {
	  return function refCountOperatorFunction(source) {
	    return source.lift(new RefCountOperator(source));
	  };
	}

	var RefCountOperator =
	/*@__PURE__*/
	function () {
	  function RefCountOperator(connectable) {
	    this.connectable = connectable;
	  }

	  RefCountOperator.prototype.call = function (subscriber, source) {
	    var connectable = this.connectable;
	    connectable._refCount++;
	    var refCounter = new RefCountSubscriber(subscriber, connectable);
	    var subscription = source.subscribe(refCounter);

	    if (!refCounter.closed) {
	      refCounter.connection = connectable.connect();
	    }

	    return subscription;
	  };

	  return RefCountOperator;
	}();

	var RefCountSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(RefCountSubscriber, _super);

	  function RefCountSubscriber(destination, connectable) {
	    var _this = _super.call(this, destination) || this;

	    _this.connectable = connectable;
	    return _this;
	  }

	  RefCountSubscriber.prototype._unsubscribe = function () {
	    var connectable = this.connectable;

	    if (!connectable) {
	      this.connection = null;
	      return;
	    }

	    this.connectable = null;
	    var refCount = connectable._refCount;

	    if (refCount <= 0) {
	      this.connection = null;
	      return;
	    }

	    connectable._refCount = refCount - 1;

	    if (refCount > 1) {
	      this.connection = null;
	      return;
	    }

	    var connection = this.connection;
	    var sharedConnection = connectable._connection;
	    this.connection = null;

	    if (sharedConnection && (!connection || sharedConnection === connection)) {
	      sharedConnection.unsubscribe();
	    }
	  };

	  return RefCountSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */

	var ConnectableObservable =
	/*@__PURE__*/
	function (_super) {
	  __extends(ConnectableObservable, _super);

	  function ConnectableObservable(source, subjectFactory) {
	    var _this = _super.call(this) || this;

	    _this.source = source;
	    _this.subjectFactory = subjectFactory;
	    _this._refCount = 0;
	    _this._isComplete = false;
	    return _this;
	  }

	  ConnectableObservable.prototype._subscribe = function (subscriber) {
	    return this.getSubject().subscribe(subscriber);
	  };

	  ConnectableObservable.prototype.getSubject = function () {
	    var subject = this._subject;

	    if (!subject || subject.isStopped) {
	      this._subject = this.subjectFactory();
	    }

	    return this._subject;
	  };

	  ConnectableObservable.prototype.connect = function () {
	    var connection = this._connection;

	    if (!connection) {
	      this._isComplete = false;
	      connection = this._connection = new Subscription();
	      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));

	      if (connection.closed) {
	        this._connection = null;
	        connection = Subscription.EMPTY;
	      }
	    }

	    return connection;
	  };

	  ConnectableObservable.prototype.refCount = function () {
	    return refCount()(this);
	  };

	  return ConnectableObservable;
	}(Observable);
	var connectableProto = ConnectableObservable.prototype;
	var connectableObservableDescriptor = {
	  operator: {
	    value: null
	  },
	  _refCount: {
	    value: 0,
	    writable: true
	  },
	  _subject: {
	    value: null,
	    writable: true
	  },
	  _connection: {
	    value: null,
	    writable: true
	  },
	  _subscribe: {
	    value: connectableProto._subscribe
	  },
	  _isComplete: {
	    value: connectableProto._isComplete,
	    writable: true
	  },
	  getSubject: {
	    value: connectableProto.getSubject
	  },
	  connect: {
	    value: connectableProto.connect
	  },
	  refCount: {
	    value: connectableProto.refCount
	  }
	};

	var ConnectableSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(ConnectableSubscriber, _super);

	  function ConnectableSubscriber(destination, connectable) {
	    var _this = _super.call(this, destination) || this;

	    _this.connectable = connectable;
	    return _this;
	  }

	  ConnectableSubscriber.prototype._error = function (err) {
	    this._unsubscribe();

	    _super.prototype._error.call(this, err);
	  };

	  ConnectableSubscriber.prototype._complete = function () {
	    this.connectable._isComplete = true;

	    this._unsubscribe();

	    _super.prototype._complete.call(this);
	  };

	  ConnectableSubscriber.prototype._unsubscribe = function () {
	    var connectable = this.connectable;

	    if (connectable) {
	      this.connectable = null;
	      var connection = connectable._connection;
	      connectable._refCount = 0;
	      connectable._subject = null;
	      connectable._connection = null;

	      if (connection) {
	        connection.unsubscribe();
	      }
	    }
	  };

	  return ConnectableSubscriber;
	}(SubjectSubscriber);

	var RefCountSubscriber$1 =
	/*@__PURE__*/
	function (_super) {
	  __extends(RefCountSubscriber, _super);

	  function RefCountSubscriber(destination, connectable) {
	    var _this = _super.call(this, destination) || this;

	    _this.connectable = connectable;
	    return _this;
	  }

	  RefCountSubscriber.prototype._unsubscribe = function () {
	    var connectable = this.connectable;

	    if (!connectable) {
	      this.connection = null;
	      return;
	    }

	    this.connectable = null;
	    var refCount$$1 = connectable._refCount;

	    if (refCount$$1 <= 0) {
	      this.connection = null;
	      return;
	    }

	    connectable._refCount = refCount$$1 - 1;

	    if (refCount$$1 > 1) {
	      this.connection = null;
	      return;
	    }

	    var connection = this.connection;
	    var sharedConnection = connectable._connection;
	    this.connection = null;

	    if (sharedConnection && (!connection || sharedConnection === connection)) {
	      sharedConnection.unsubscribe();
	    }
	  };

	  return RefCountSubscriber;
	}(Subscriber);

	var GroupBySubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(GroupBySubscriber, _super);

	  function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
	    var _this = _super.call(this, destination) || this;

	    _this.keySelector = keySelector;
	    _this.elementSelector = elementSelector;
	    _this.durationSelector = durationSelector;
	    _this.subjectSelector = subjectSelector;
	    _this.groups = null;
	    _this.attemptedToUnsubscribe = false;
	    _this.count = 0;
	    return _this;
	  }

	  GroupBySubscriber.prototype._next = function (value) {
	    var key;

	    try {
	      key = this.keySelector(value);
	    } catch (err) {
	      this.error(err);
	      return;
	    }

	    this._group(value, key);
	  };

	  GroupBySubscriber.prototype._group = function (value, key) {
	    var groups = this.groups;

	    if (!groups) {
	      groups = this.groups = new Map();
	    }

	    var group = groups.get(key);
	    var element;

	    if (this.elementSelector) {
	      try {
	        element = this.elementSelector(value);
	      } catch (err) {
	        this.error(err);
	      }
	    } else {
	      element = value;
	    }

	    if (!group) {
	      group = this.subjectSelector ? this.subjectSelector() : new Subject();
	      groups.set(key, group);
	      var groupedObservable = new GroupedObservable(key, group, this);
	      this.destination.next(groupedObservable);

	      if (this.durationSelector) {
	        var duration = void 0;

	        try {
	          duration = this.durationSelector(new GroupedObservable(key, group));
	        } catch (err) {
	          this.error(err);
	          return;
	        }

	        this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
	      }
	    }

	    if (!group.closed) {
	      group.next(element);
	    }
	  };

	  GroupBySubscriber.prototype._error = function (err) {
	    var groups = this.groups;

	    if (groups) {
	      groups.forEach(function (group, key) {
	        group.error(err);
	      });
	      groups.clear();
	    }

	    this.destination.error(err);
	  };

	  GroupBySubscriber.prototype._complete = function () {
	    var groups = this.groups;

	    if (groups) {
	      groups.forEach(function (group, key) {
	        group.complete();
	      });
	      groups.clear();
	    }

	    this.destination.complete();
	  };

	  GroupBySubscriber.prototype.removeGroup = function (key) {
	    this.groups.delete(key);
	  };

	  GroupBySubscriber.prototype.unsubscribe = function () {
	    if (!this.closed) {
	      this.attemptedToUnsubscribe = true;

	      if (this.count === 0) {
	        _super.prototype.unsubscribe.call(this);
	      }
	    }
	  };

	  return GroupBySubscriber;
	}(Subscriber);

	var GroupDurationSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(GroupDurationSubscriber, _super);

	  function GroupDurationSubscriber(key, group, parent) {
	    var _this = _super.call(this, group) || this;

	    _this.key = key;
	    _this.group = group;
	    _this.parent = parent;
	    return _this;
	  }

	  GroupDurationSubscriber.prototype._next = function (value) {
	    this.complete();
	  };

	  GroupDurationSubscriber.prototype._unsubscribe = function () {
	    var _a = this,
	        parent = _a.parent,
	        key = _a.key;

	    this.key = this.parent = null;

	    if (parent) {
	      parent.removeGroup(key);
	    }
	  };

	  return GroupDurationSubscriber;
	}(Subscriber);

	var GroupedObservable =
	/*@__PURE__*/
	function (_super) {
	  __extends(GroupedObservable, _super);

	  function GroupedObservable(key, groupSubject, refCountSubscription) {
	    var _this = _super.call(this) || this;

	    _this.key = key;
	    _this.groupSubject = groupSubject;
	    _this.refCountSubscription = refCountSubscription;
	    return _this;
	  }

	  GroupedObservable.prototype._subscribe = function (subscriber) {
	    var subscription = new Subscription();

	    var _a = this,
	        refCountSubscription = _a.refCountSubscription,
	        groupSubject = _a.groupSubject;

	    if (refCountSubscription && !refCountSubscription.closed) {
	      subscription.add(new InnerRefCountSubscription(refCountSubscription));
	    }

	    subscription.add(groupSubject.subscribe(subscriber));
	    return subscription;
	  };

	  return GroupedObservable;
	}(Observable);

	var InnerRefCountSubscription =
	/*@__PURE__*/
	function (_super) {
	  __extends(InnerRefCountSubscription, _super);

	  function InnerRefCountSubscription(parent) {
	    var _this = _super.call(this) || this;

	    _this.parent = parent;
	    parent.count++;
	    return _this;
	  }

	  InnerRefCountSubscription.prototype.unsubscribe = function () {
	    var parent = this.parent;

	    if (!parent.closed && !this.closed) {
	      _super.prototype.unsubscribe.call(this);

	      parent.count -= 1;

	      if (parent.count === 0 && parent.attemptedToUnsubscribe) {
	        parent.unsubscribe();
	      }
	    }
	  };

	  return InnerRefCountSubscription;
	}(Subscription);

	var BehaviorSubject =
	/*@__PURE__*/
	function (_super) {
	  __extends(BehaviorSubject, _super);

	  function BehaviorSubject(_value) {
	    var _this = _super.call(this) || this;

	    _this._value = _value;
	    return _this;
	  }

	  Object.defineProperty(BehaviorSubject.prototype, "value", {
	    get: function get() {
	      return this.getValue();
	    },
	    enumerable: true,
	    configurable: true
	  });

	  BehaviorSubject.prototype._subscribe = function (subscriber) {
	    var subscription = _super.prototype._subscribe.call(this, subscriber);

	    if (subscription && !subscription.closed) {
	      subscriber.next(this._value);
	    }

	    return subscription;
	  };

	  BehaviorSubject.prototype.getValue = function () {
	    if (this.hasError) {
	      throw this.thrownError;
	    } else if (this.closed) {
	      throw new ObjectUnsubscribedError();
	    } else {
	      return this._value;
	    }
	  };

	  BehaviorSubject.prototype.next = function (value) {
	    _super.prototype.next.call(this, this._value = value);
	  };

	  return BehaviorSubject;
	}(Subject);

	var gOPN$3 = _objectGopn.f;
	var gOPD$2 = _objectGopd.f;
	var dP$5 = _objectDp.f;
	var $trim = _stringTrim.trim;
	var NUMBER = 'Number';
	var $Number = _global[NUMBER];
	var Base$1 = $Number;
	var proto$2 = $Number.prototype;
	// Opera ~12 has broken Object#toString
	var BROKEN_COF = _cof(_objectCreate(proto$2)) == NUMBER;
	var TRIM = 'trim' in String.prototype;

	// 7.1.3 ToNumber(argument)
	var toNumber = function (argument) {
	  var it = _toPrimitive(argument, false);
	  if (typeof it == 'string' && it.length > 2) {
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0);
	    var third, radix, maxCode;
	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default: return +it;
	      }
	      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};

	if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
	  $Number = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? _fails(function () { proto$2.valueOf.call(that); }) : _cof(that) != NUMBER)
	        ? _inheritIfRequired(new Base$1(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for (var keys$1 = _descriptors ? gOPN$3(Base$1) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j$1 = 0, key$1; keys$1.length > j$1; j$1++) {
	    if (_has(Base$1, key$1 = keys$1[j$1]) && !_has($Number, key$1)) {
	      dP$5($Number, key$1, gOPD$2(Base$1, key$1));
	    }
	  }
	  $Number.prototype = proto$2;
	  proto$2.constructor = $Number;
	  _redefine(_global, NUMBER, $Number);
	}

	/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */

	var Action =
	/*@__PURE__*/
	function (_super) {
	  __extends(Action, _super);

	  function Action(scheduler, work) {
	    return _super.call(this) || this;
	  }

	  Action.prototype.schedule = function (state, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    return this;
	  };

	  return Action;
	}(Subscription);

	var AsyncAction =
	/*@__PURE__*/
	function (_super) {
	  __extends(AsyncAction, _super);

	  function AsyncAction(scheduler, work) {
	    var _this = _super.call(this, scheduler, work) || this;

	    _this.scheduler = scheduler;
	    _this.work = work;
	    _this.pending = false;
	    return _this;
	  }

	  AsyncAction.prototype.schedule = function (state, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    if (this.closed) {
	      return this;
	    }

	    this.state = state;
	    var id = this.id;
	    var scheduler = this.scheduler;

	    if (id != null) {
	      this.id = this.recycleAsyncId(scheduler, id, delay);
	    }

	    this.pending = true;
	    this.delay = delay;
	    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
	    return this;
	  };

	  AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    return setInterval(scheduler.flush.bind(scheduler, this), delay);
	  };

	  AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    if (delay !== null && this.delay === delay && this.pending === false) {
	      return id;
	    }

	    clearInterval(id);
	    return undefined;
	  };

	  AsyncAction.prototype.execute = function (state, delay) {
	    if (this.closed) {
	      return new Error('executing a cancelled action');
	    }

	    this.pending = false;

	    var error = this._execute(state, delay);

	    if (error) {
	      return error;
	    } else if (this.pending === false && this.id != null) {
	      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
	    }
	  };

	  AsyncAction.prototype._execute = function (state, delay) {
	    var errored = false;
	    var errorValue = undefined;

	    try {
	      this.work(state);
	    } catch (e) {
	      errored = true;
	      errorValue = !!e && e || new Error(e);
	    }

	    if (errored) {
	      this.unsubscribe();
	      return errorValue;
	    }
	  };

	  AsyncAction.prototype._unsubscribe = function () {
	    var id = this.id;
	    var scheduler = this.scheduler;
	    var actions = scheduler.actions;
	    var index = actions.indexOf(this);
	    this.work = null;
	    this.state = null;
	    this.pending = false;
	    this.scheduler = null;

	    if (index !== -1) {
	      actions.splice(index, 1);
	    }

	    if (id != null) {
	      this.id = this.recycleAsyncId(scheduler, id, null);
	    }

	    this.delay = null;
	  };

	  return AsyncAction;
	}(Action);

	/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */

	var QueueAction =
	/*@__PURE__*/
	function (_super) {
	  __extends(QueueAction, _super);

	  function QueueAction(scheduler, work) {
	    var _this = _super.call(this, scheduler, work) || this;

	    _this.scheduler = scheduler;
	    _this.work = work;
	    return _this;
	  }

	  QueueAction.prototype.schedule = function (state, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    if (delay > 0) {
	      return _super.prototype.schedule.call(this, state, delay);
	    }

	    this.delay = delay;
	    this.state = state;
	    this.scheduler.flush(this);
	    return this;
	  };

	  QueueAction.prototype.execute = function (state, delay) {
	    return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
	  };

	  QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
	      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	    }

	    return scheduler.flush(this);
	  };

	  return QueueAction;
	}(AsyncAction);

	// 20.3.3.1 / 15.9.4.4 Date.now()


	_export(_export.S, 'Date', { now: function () { return new Date().getTime(); } });

	var Scheduler =
	/*@__PURE__*/
	function () {
	  function Scheduler(SchedulerAction, now) {
	    if (now === void 0) {
	      now = Scheduler.now;
	    }

	    this.SchedulerAction = SchedulerAction;
	    this.now = now;
	  }

	  Scheduler.prototype.schedule = function (work, delay, state) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    return new this.SchedulerAction(this, work).schedule(state, delay);
	  };

	  Scheduler.now = function () {
	    return Date.now();
	  };

	  return Scheduler;
	}();

	/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */

	var AsyncScheduler =
	/*@__PURE__*/
	function (_super) {
	  __extends(AsyncScheduler, _super);

	  function AsyncScheduler(SchedulerAction, now) {
	    if (now === void 0) {
	      now = Scheduler.now;
	    }

	    var _this = _super.call(this, SchedulerAction, function () {
	      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
	        return AsyncScheduler.delegate.now();
	      } else {
	        return now();
	      }
	    }) || this;

	    _this.actions = [];
	    _this.active = false;
	    _this.scheduled = undefined;
	    return _this;
	  }

	  AsyncScheduler.prototype.schedule = function (work, delay, state) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
	      return AsyncScheduler.delegate.schedule(work, delay, state);
	    } else {
	      return _super.prototype.schedule.call(this, work, delay, state);
	    }
	  };

	  AsyncScheduler.prototype.flush = function (action) {
	    var actions = this.actions;

	    if (this.active) {
	      actions.push(action);
	      return;
	    }

	    var error;
	    this.active = true;

	    do {
	      if (error = action.execute(action.state, action.delay)) {
	        break;
	      }
	    } while (action = actions.shift());

	    this.active = false;

	    if (error) {
	      while (action = actions.shift()) {
	        action.unsubscribe();
	      }

	      throw error;
	    }
	  };

	  return AsyncScheduler;
	}(Scheduler);

	/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */

	var QueueScheduler =
	/*@__PURE__*/
	function (_super) {
	  __extends(QueueScheduler, _super);

	  function QueueScheduler() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }

	  return QueueScheduler;
	}(AsyncScheduler);

	/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */
	var queue$1 =
	/*@__PURE__*/
	new QueueScheduler(QueueAction);

	/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
	var EMPTY =
	/*@__PURE__*/
	new Observable(function (subscriber) {
	  return subscriber.complete();
	});
	function empty$2(scheduler) {
	  return scheduler ? emptyScheduled(scheduler) : EMPTY;
	}

	function emptyScheduled(scheduler) {
	  return new Observable(function (subscriber) {
	    return scheduler.schedule(function () {
	      return subscriber.complete();
	    });
	  });
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function isScheduler(value) {
	  return value && typeof value.schedule === 'function';
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	var subscribeToArray = function subscribeToArray(array) {
	  return function (subscriber) {
	    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
	      subscriber.next(array[i]);
	    }

	    subscriber.complete();
	  };
	};

	/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
	function scheduleArray(input, scheduler) {
	  return new Observable(function (subscriber) {
	    var sub = new Subscription();
	    var i = 0;
	    sub.add(scheduler.schedule(function () {
	      if (i === input.length) {
	        subscriber.complete();
	        return;
	      }

	      subscriber.next(input[i++]);

	      if (!subscriber.closed) {
	        sub.add(this.schedule());
	      }
	    }));
	    return sub;
	  });
	}

	/** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */
	function fromArray(input, scheduler) {
	  if (!scheduler) {
	    return new Observable(subscribeToArray(input));
	  } else {
	    return scheduleArray(input, scheduler);
	  }
	}

	/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */
	function of() {
	  var args = [];

	  for (var _i = 0; _i < arguments.length; _i++) {
	    args[_i] = arguments[_i];
	  }

	  var scheduler = args[args.length - 1];

	  if (isScheduler(scheduler)) {
	    args.pop();
	    return scheduleArray(args, scheduler);
	  } else {
	    return fromArray(args);
	  }
	}

	/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
	function throwError(error, scheduler) {
	  if (!scheduler) {
	    return new Observable(function (subscriber) {
	      return subscriber.error(error);
	    });
	  } else {
	    return new Observable(function (subscriber) {
	      return scheduler.schedule(dispatch, 0, {
	        error: error,
	        subscriber: subscriber
	      });
	    });
	  }
	}

	function dispatch(_a) {
	  var error = _a.error,
	      subscriber = _a.subscriber;
	  subscriber.error(error);
	}

	/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */
	var NotificationKind;
	/*@__PURE__*/

	(function (NotificationKind) {
	  NotificationKind["NEXT"] = "N";
	  NotificationKind["ERROR"] = "E";
	  NotificationKind["COMPLETE"] = "C";
	})(NotificationKind || (NotificationKind = {}));

	var Notification =
	/*@__PURE__*/
	function () {
	  function Notification(kind, value, error) {
	    this.kind = kind;
	    this.value = value;
	    this.error = error;
	    this.hasValue = kind === 'N';
	  }

	  Notification.prototype.observe = function (observer) {
	    switch (this.kind) {
	      case 'N':
	        return observer.next && observer.next(this.value);

	      case 'E':
	        return observer.error && observer.error(this.error);

	      case 'C':
	        return observer.complete && observer.complete();
	    }
	  };

	  Notification.prototype.do = function (next, error, complete) {
	    var kind = this.kind;

	    switch (kind) {
	      case 'N':
	        return next && next(this.value);

	      case 'E':
	        return error && error(this.error);

	      case 'C':
	        return complete && complete();
	    }
	  };

	  Notification.prototype.accept = function (nextOrObserver, error, complete) {
	    if (nextOrObserver && typeof nextOrObserver.next === 'function') {
	      return this.observe(nextOrObserver);
	    } else {
	      return this.do(nextOrObserver, error, complete);
	    }
	  };

	  Notification.prototype.toObservable = function () {
	    var kind = this.kind;

	    switch (kind) {
	      case 'N':
	        return of(this.value);

	      case 'E':
	        return throwError(this.error);

	      case 'C':
	        return empty$2();
	    }

	    throw new Error('unexpected notification kind value');
	  };

	  Notification.createNext = function (value) {
	    if (typeof value !== 'undefined') {
	      return new Notification('N', value);
	    }

	    return Notification.undefinedValueNotification;
	  };

	  Notification.createError = function (err) {
	    return new Notification('E', undefined, err);
	  };

	  Notification.createComplete = function () {
	    return Notification.completeNotification;
	  };

	  Notification.completeNotification = new Notification('C');
	  Notification.undefinedValueNotification = new Notification('N', undefined);
	  return Notification;
	}();

	/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */

	var ObserveOnSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(ObserveOnSubscriber, _super);

	  function ObserveOnSubscriber(destination, scheduler, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    var _this = _super.call(this, destination) || this;

	    _this.scheduler = scheduler;
	    _this.delay = delay;
	    return _this;
	  }

	  ObserveOnSubscriber.dispatch = function (arg) {
	    var notification = arg.notification,
	        destination = arg.destination;
	    notification.observe(destination);
	    this.unsubscribe();
	  };

	  ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
	    var destination = this.destination;
	    destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
	  };

	  ObserveOnSubscriber.prototype._next = function (value) {
	    this.scheduleMessage(Notification.createNext(value));
	  };

	  ObserveOnSubscriber.prototype._error = function (err) {
	    this.scheduleMessage(Notification.createError(err));
	    this.unsubscribe();
	  };

	  ObserveOnSubscriber.prototype._complete = function () {
	    this.scheduleMessage(Notification.createComplete());
	    this.unsubscribe();
	  };

	  return ObserveOnSubscriber;
	}(Subscriber);

	var ObserveOnMessage =
	/*@__PURE__*/
	function () {
	  function ObserveOnMessage(notification, destination) {
	    this.notification = notification;
	    this.destination = destination;
	  }

	  return ObserveOnMessage;
	}();

	var ReplaySubject =
	/*@__PURE__*/
	function (_super) {
	  __extends(ReplaySubject, _super);

	  function ReplaySubject(bufferSize, windowTime, scheduler) {
	    if (bufferSize === void 0) {
	      bufferSize = Number.POSITIVE_INFINITY;
	    }

	    if (windowTime === void 0) {
	      windowTime = Number.POSITIVE_INFINITY;
	    }

	    var _this = _super.call(this) || this;

	    _this.scheduler = scheduler;
	    _this._events = [];
	    _this._infiniteTimeWindow = false;
	    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
	    _this._windowTime = windowTime < 1 ? 1 : windowTime;

	    if (windowTime === Number.POSITIVE_INFINITY) {
	      _this._infiniteTimeWindow = true;
	      _this.next = _this.nextInfiniteTimeWindow;
	    } else {
	      _this.next = _this.nextTimeWindow;
	    }

	    return _this;
	  }

	  ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
	    var _events = this._events;

	    _events.push(value);

	    if (_events.length > this._bufferSize) {
	      _events.shift();
	    }

	    _super.prototype.next.call(this, value);
	  };

	  ReplaySubject.prototype.nextTimeWindow = function (value) {
	    this._events.push(new ReplayEvent(this._getNow(), value));

	    this._trimBufferThenGetEvents();

	    _super.prototype.next.call(this, value);
	  };

	  ReplaySubject.prototype._subscribe = function (subscriber) {
	    var _infiniteTimeWindow = this._infiniteTimeWindow;

	    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();

	    var scheduler = this.scheduler;
	    var len = _events.length;
	    var subscription;

	    if (this.closed) {
	      throw new ObjectUnsubscribedError();
	    } else if (this.isStopped || this.hasError) {
	      subscription = Subscription.EMPTY;
	    } else {
	      this.observers.push(subscriber);
	      subscription = new SubjectSubscription(this, subscriber);
	    }

	    if (scheduler) {
	      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
	    }

	    if (_infiniteTimeWindow) {
	      for (var i = 0; i < len && !subscriber.closed; i++) {
	        subscriber.next(_events[i]);
	      }
	    } else {
	      for (var i = 0; i < len && !subscriber.closed; i++) {
	        subscriber.next(_events[i].value);
	      }
	    }

	    if (this.hasError) {
	      subscriber.error(this.thrownError);
	    } else if (this.isStopped) {
	      subscriber.complete();
	    }

	    return subscription;
	  };

	  ReplaySubject.prototype._getNow = function () {
	    return (this.scheduler || queue$1).now();
	  };

	  ReplaySubject.prototype._trimBufferThenGetEvents = function () {
	    var now = this._getNow();

	    var _bufferSize = this._bufferSize;
	    var _windowTime = this._windowTime;
	    var _events = this._events;
	    var eventsCount = _events.length;
	    var spliceCount = 0;

	    while (spliceCount < eventsCount) {
	      if (now - _events[spliceCount].time < _windowTime) {
	        break;
	      }

	      spliceCount++;
	    }

	    if (eventsCount > _bufferSize) {
	      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
	    }

	    if (spliceCount > 0) {
	      _events.splice(0, spliceCount);
	    }

	    return _events;
	  };

	  return ReplaySubject;
	}(Subject);

	var ReplayEvent =
	/*@__PURE__*/
	function () {
	  function ReplayEvent(time, value) {
	    this.time = time;
	    this.value = value;
	  }

	  return ReplayEvent;
	}();

	/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */

	var AsyncSubject =
	/*@__PURE__*/
	function (_super) {
	  __extends(AsyncSubject, _super);

	  function AsyncSubject() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;

	    _this.value = null;
	    _this.hasNext = false;
	    _this.hasCompleted = false;
	    return _this;
	  }

	  AsyncSubject.prototype._subscribe = function (subscriber) {
	    if (this.hasError) {
	      subscriber.error(this.thrownError);
	      return Subscription.EMPTY;
	    } else if (this.hasCompleted && this.hasNext) {
	      subscriber.next(this.value);
	      subscriber.complete();
	      return Subscription.EMPTY;
	    }

	    return _super.prototype._subscribe.call(this, subscriber);
	  };

	  AsyncSubject.prototype.next = function (value) {
	    if (!this.hasCompleted) {
	      this.value = value;
	      this.hasNext = true;
	    }
	  };

	  AsyncSubject.prototype.error = function (error) {
	    if (!this.hasCompleted) {
	      _super.prototype.error.call(this, error);
	    }
	  };

	  AsyncSubject.prototype.complete = function () {
	    this.hasCompleted = true;

	    if (this.hasNext) {
	      _super.prototype.next.call(this, this.value);
	    }

	    _super.prototype.complete.call(this);
	  };

	  return AsyncSubject;
	}(Subject);

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	var nextHandle = 1;
	var tasksByHandle = {};

	function runIfPresent(handle) {
	  var cb = tasksByHandle[handle];

	  if (cb) {
	    cb();
	  }
	}

	var Immediate = {
	  setImmediate: function setImmediate(cb) {
	    var handle = nextHandle++;
	    tasksByHandle[handle] = cb;
	    Promise.resolve().then(function () {
	      return runIfPresent(handle);
	    });
	    return handle;
	  },
	  clearImmediate: function clearImmediate(handle) {
	    delete tasksByHandle[handle];
	  }
	};

	var AsapAction =
	/*@__PURE__*/
	function (_super) {
	  __extends(AsapAction, _super);

	  function AsapAction(scheduler, work) {
	    var _this = _super.call(this, scheduler, work) || this;

	    _this.scheduler = scheduler;
	    _this.work = work;
	    return _this;
	  }

	  AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    if (delay !== null && delay > 0) {
	      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	    }

	    scheduler.actions.push(this);
	    return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
	  };

	  AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
	      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	    }

	    if (scheduler.actions.length === 0) {
	      Immediate.clearImmediate(id);
	      scheduler.scheduled = undefined;
	    }

	    return undefined;
	  };

	  return AsapAction;
	}(AsyncAction);

	/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */

	var AsapScheduler =
	/*@__PURE__*/
	function (_super) {
	  __extends(AsapScheduler, _super);

	  function AsapScheduler() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }

	  AsapScheduler.prototype.flush = function (action) {
	    this.active = true;
	    this.scheduled = undefined;
	    var actions = this.actions;
	    var error;
	    var index = -1;
	    var count = actions.length;
	    action = action || actions.shift();

	    do {
	      if (error = action.execute(action.state, action.delay)) {
	        break;
	      }
	    } while (++index < count && (action = actions.shift()));

	    this.active = false;

	    if (error) {
	      while (++index < count && (action = actions.shift())) {
	        action.unsubscribe();
	      }

	      throw error;
	    }
	  };

	  return AsapScheduler;
	}(AsyncScheduler);

	/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
	var asap =
	/*@__PURE__*/
	new AsapScheduler(AsapAction);

	/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
	var async =
	/*@__PURE__*/
	new AsyncScheduler(AsyncAction);

	/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */

	var AnimationFrameAction =
	/*@__PURE__*/
	function (_super) {
	  __extends(AnimationFrameAction, _super);

	  function AnimationFrameAction(scheduler, work) {
	    var _this = _super.call(this, scheduler, work) || this;

	    _this.scheduler = scheduler;
	    _this.work = work;
	    return _this;
	  }

	  AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    if (delay !== null && delay > 0) {
	      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	    }

	    scheduler.actions.push(this);
	    return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () {
	      return scheduler.flush(null);
	    }));
	  };

	  AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
	      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	    }

	    if (scheduler.actions.length === 0) {
	      cancelAnimationFrame(id);
	      scheduler.scheduled = undefined;
	    }

	    return undefined;
	  };

	  return AnimationFrameAction;
	}(AsyncAction);

	/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */

	var AnimationFrameScheduler =
	/*@__PURE__*/
	function (_super) {
	  __extends(AnimationFrameScheduler, _super);

	  function AnimationFrameScheduler() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }

	  AnimationFrameScheduler.prototype.flush = function (action) {
	    this.active = true;
	    this.scheduled = undefined;
	    var actions = this.actions;
	    var error;
	    var index = -1;
	    var count = actions.length;
	    action = action || actions.shift();

	    do {
	      if (error = action.execute(action.state, action.delay)) {
	        break;
	      }
	    } while (++index < count && (action = actions.shift()));

	    this.active = false;

	    if (error) {
	      while (++index < count && (action = actions.shift())) {
	        action.unsubscribe();
	      }

	      throw error;
	    }
	  };

	  return AnimationFrameScheduler;
	}(AsyncScheduler);

	/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */
	var animationFrame =
	/*@__PURE__*/
	new AnimationFrameScheduler(AnimationFrameAction);

	var VirtualTimeScheduler =
	/*@__PURE__*/
	function (_super) {
	  __extends(VirtualTimeScheduler, _super);

	  function VirtualTimeScheduler(SchedulerAction, maxFrames) {
	    if (SchedulerAction === void 0) {
	      SchedulerAction = VirtualAction;
	    }

	    if (maxFrames === void 0) {
	      maxFrames = Number.POSITIVE_INFINITY;
	    }

	    var _this = _super.call(this, SchedulerAction, function () {
	      return _this.frame;
	    }) || this;

	    _this.maxFrames = maxFrames;
	    _this.frame = 0;
	    _this.index = -1;
	    return _this;
	  }

	  VirtualTimeScheduler.prototype.flush = function () {
	    var _a = this,
	        actions = _a.actions,
	        maxFrames = _a.maxFrames;

	    var error, action;

	    while ((action = actions[0]) && action.delay <= maxFrames) {
	      actions.shift();
	      this.frame = action.delay;

	      if (error = action.execute(action.state, action.delay)) {
	        break;
	      }
	    }

	    if (error) {
	      while (action = actions.shift()) {
	        action.unsubscribe();
	      }

	      throw error;
	    }
	  };

	  VirtualTimeScheduler.frameTimeFactor = 10;
	  return VirtualTimeScheduler;
	}(AsyncScheduler);

	var VirtualAction =
	/*@__PURE__*/
	function (_super) {
	  __extends(VirtualAction, _super);

	  function VirtualAction(scheduler, work, index) {
	    if (index === void 0) {
	      index = scheduler.index += 1;
	    }

	    var _this = _super.call(this, scheduler, work) || this;

	    _this.scheduler = scheduler;
	    _this.work = work;
	    _this.index = index;
	    _this.active = true;
	    _this.index = scheduler.index = index;
	    return _this;
	  }

	  VirtualAction.prototype.schedule = function (state, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    if (!this.id) {
	      return _super.prototype.schedule.call(this, state, delay);
	    }

	    this.active = false;
	    var action = new VirtualAction(this.scheduler, this.work);
	    this.add(action);
	    return action.schedule(state, delay);
	  };

	  VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    this.delay = scheduler.frame + delay;
	    var actions = scheduler.actions;
	    actions.push(this);
	    actions.sort(VirtualAction.sortActions);
	    return true;
	  };

	  VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    return undefined;
	  };

	  VirtualAction.prototype._execute = function (state, delay) {
	    if (this.active === true) {
	      return _super.prototype._execute.call(this, state, delay);
	    }
	  };

	  VirtualAction.sortActions = function (a, b) {
	    if (a.delay === b.delay) {
	      if (a.index === b.index) {
	        return 0;
	      } else if (a.index > b.index) {
	        return 1;
	      } else {
	        return -1;
	      }
	    } else if (a.delay > b.delay) {
	      return 1;
	    } else {
	      return -1;
	    }
	  };

	  return VirtualAction;
	}(AsyncAction);

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function identity(x) {
	  return x;
	}

	/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function EmptyErrorImpl() {
	  Error.call(this);
	  this.message = 'no elements in sequence';
	  this.name = 'EmptyError';
	  return this;
	}

	EmptyErrorImpl.prototype =
	/*@__PURE__*/
	Object.create(Error.prototype);
	var EmptyError = EmptyErrorImpl;

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function map(project, thisArg) {
	  return function mapOperation(source) {
	    if (typeof project !== 'function') {
	      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
	    }

	    return source.lift(new MapOperator(project, thisArg));
	  };
	}

	var MapOperator =
	/*@__PURE__*/
	function () {
	  function MapOperator(project, thisArg) {
	    this.project = project;
	    this.thisArg = thisArg;
	  }

	  MapOperator.prototype.call = function (subscriber, source) {
	    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
	  };

	  return MapOperator;
	}();

	var MapSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(MapSubscriber, _super);

	  function MapSubscriber(destination, project, thisArg) {
	    var _this = _super.call(this, destination) || this;

	    _this.project = project;
	    _this.count = 0;
	    _this.thisArg = thisArg || _this;
	    return _this;
	  }

	  MapSubscriber.prototype._next = function (value) {
	    var result;

	    try {
	      result = this.project.call(this.thisArg, value, this.count++);
	    } catch (err) {
	      this.destination.error(err);
	      return;
	    }

	    this.destination.next(result);
	  };

	  return MapSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var OuterSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(OuterSubscriber, _super);

	  function OuterSubscriber() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }

	  OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.destination.next(innerValue);
	  };

	  OuterSubscriber.prototype.notifyError = function (error, innerSub) {
	    this.destination.error(error);
	  };

	  OuterSubscriber.prototype.notifyComplete = function (innerSub) {
	    this.destination.complete();
	  };

	  return OuterSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var InnerSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(InnerSubscriber, _super);

	  function InnerSubscriber(parent, outerValue, outerIndex) {
	    var _this = _super.call(this) || this;

	    _this.parent = parent;
	    _this.outerValue = outerValue;
	    _this.outerIndex = outerIndex;
	    _this.index = 0;
	    return _this;
	  }

	  InnerSubscriber.prototype._next = function (value) {
	    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
	  };

	  InnerSubscriber.prototype._error = function (error) {
	    this.parent.notifyError(error, this);
	    this.unsubscribe();
	  };

	  InnerSubscriber.prototype._complete = function () {
	    this.parent.notifyComplete(this);
	    this.unsubscribe();
	  };

	  return InnerSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
	var subscribeToPromise = function subscribeToPromise(promise) {
	  return function (subscriber) {
	    promise.then(function (value) {
	      if (!subscriber.closed) {
	        subscriber.next(value);
	        subscriber.complete();
	      }
	    }, function (err) {
	      return subscriber.error(err);
	    }).then(null, hostReportError);
	    return subscriber;
	  };
	};

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function getSymbolIterator() {
	  if (typeof Symbol !== 'function' || !Symbol.iterator) {
	    return '@@iterator';
	  }

	  return Symbol.iterator;
	}
	var iterator =
	/*@__PURE__*/
	getSymbolIterator();

	/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
	var subscribeToIterable = function subscribeToIterable(iterable) {
	  return function (subscriber) {
	    var iterator$$1 = iterable[iterator]();

	    do {
	      var item = iterator$$1.next();

	      if (item.done) {
	        subscriber.complete();
	        break;
	      }

	      subscriber.next(item.value);

	      if (subscriber.closed) {
	        break;
	      }
	    } while (true);

	    if (typeof iterator$$1.return === 'function') {
	      subscriber.add(function () {
	        if (iterator$$1.return) {
	          iterator$$1.return();
	        }
	      });
	    }

	    return subscriber;
	  };
	};

	/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
	var subscribeToObservable = function subscribeToObservable(obj) {
	  return function (subscriber) {
	    var obs = obj[observable]();

	    if (typeof obs.subscribe !== 'function') {
	      throw new TypeError('Provided object does not correctly implement Symbol.observable');
	    } else {
	      return obs.subscribe(subscriber);
	    }
	  };
	};

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	var isArrayLike = function isArrayLike(x) {
	  return x && typeof x.length === 'number' && typeof x !== 'function';
	};

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function isPromise(value) {
	  return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
	}

	/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
	var subscribeTo = function subscribeTo(result) {
	  if (!!result && typeof result[observable] === 'function') {
	    return subscribeToObservable(result);
	  } else if (isArrayLike(result)) {
	    return subscribeToArray(result);
	  } else if (isPromise(result)) {
	    return subscribeToPromise(result);
	  } else if (!!result && typeof result[iterator] === 'function') {
	    return subscribeToIterable(result);
	  } else {
	    var value = isObject(result) ? 'an invalid object' : "'" + result + "'";
	    var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
	    throw new TypeError(msg);
	  }
	};

	/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */
	function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
	  if (destination === void 0) {
	    destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
	  }

	  if (destination.closed) {
	    return undefined;
	  }

	  if (result instanceof Observable) {
	    return result.subscribe(destination);
	  }

	  return subscribeTo(result)(destination);
	}

	var NONE = {};

	var CombineLatestSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(CombineLatestSubscriber, _super);

	  function CombineLatestSubscriber(destination, resultSelector) {
	    var _this = _super.call(this, destination) || this;

	    _this.resultSelector = resultSelector;
	    _this.active = 0;
	    _this.values = [];
	    _this.observables = [];
	    return _this;
	  }

	  CombineLatestSubscriber.prototype._next = function (observable) {
	    this.values.push(NONE);
	    this.observables.push(observable);
	  };

	  CombineLatestSubscriber.prototype._complete = function () {
	    var observables = this.observables;
	    var len = observables.length;

	    if (len === 0) {
	      this.destination.complete();
	    } else {
	      this.active = len;
	      this.toRespond = len;

	      for (var i = 0; i < len; i++) {
	        var observable = observables[i];
	        this.add(subscribeToResult(this, observable, observable, i));
	      }
	    }
	  };

	  CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
	    if ((this.active -= 1) === 0) {
	      this.destination.complete();
	    }
	  };

	  CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    var values = this.values;
	    var oldVal = values[outerIndex];
	    var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
	    values[outerIndex] = innerValue;

	    if (toRespond === 0) {
	      if (this.resultSelector) {
	        this._tryResultSelector(values);
	      } else {
	        this.destination.next(values.slice());
	      }
	    }
	  };

	  CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
	    var result;

	    try {
	      result = this.resultSelector.apply(this, values);
	    } catch (err) {
	      this.destination.error(err);
	      return;
	    }

	    this.destination.next(result);
	  };

	  return CombineLatestSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */
	function scheduleObservable(input, scheduler) {
	  return new Observable(function (subscriber) {
	    var sub = new Subscription();
	    sub.add(scheduler.schedule(function () {
	      var observable$$1 = input[observable]();
	      sub.add(observable$$1.subscribe({
	        next: function next(value) {
	          sub.add(scheduler.schedule(function () {
	            return subscriber.next(value);
	          }));
	        },
	        error: function error(err) {
	          sub.add(scheduler.schedule(function () {
	            return subscriber.error(err);
	          }));
	        },
	        complete: function complete() {
	          sub.add(scheduler.schedule(function () {
	            return subscriber.complete();
	          }));
	        }
	      }));
	    }));
	    return sub;
	  });
	}

	/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
	function schedulePromise(input, scheduler) {
	  return new Observable(function (subscriber) {
	    var sub = new Subscription();
	    sub.add(scheduler.schedule(function () {
	      return input.then(function (value) {
	        sub.add(scheduler.schedule(function () {
	          subscriber.next(value);
	          sub.add(scheduler.schedule(function () {
	            return subscriber.complete();
	          }));
	        }));
	      }, function (err) {
	        sub.add(scheduler.schedule(function () {
	          return subscriber.error(err);
	        }));
	      });
	    }));
	    return sub;
	  });
	}

	/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */
	function scheduleIterable(input, scheduler) {
	  if (!input) {
	    throw new Error('Iterable cannot be null');
	  }

	  return new Observable(function (subscriber) {
	    var sub = new Subscription();
	    var iterator$$1;
	    sub.add(function () {
	      if (iterator$$1 && typeof iterator$$1.return === 'function') {
	        iterator$$1.return();
	      }
	    });
	    sub.add(scheduler.schedule(function () {
	      iterator$$1 = input[iterator]();
	      sub.add(scheduler.schedule(function () {
	        if (subscriber.closed) {
	          return;
	        }

	        var value;
	        var done;

	        try {
	          var result = iterator$$1.next();
	          value = result.value;
	          done = result.done;
	        } catch (err) {
	          subscriber.error(err);
	          return;
	        }

	        if (done) {
	          subscriber.complete();
	        } else {
	          subscriber.next(value);
	          this.schedule();
	        }
	      }));
	    }));
	    return sub;
	  });
	}

	/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
	function isInteropObservable(input) {
	  return input && typeof input[observable] === 'function';
	}

	/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
	function isIterable(input) {
	  return input && typeof input[iterator] === 'function';
	}

	function scheduled(input, scheduler) {
	  if (input != null) {
	    if (isInteropObservable(input)) {
	      return scheduleObservable(input, scheduler);
	    } else if (isPromise(input)) {
	      return schedulePromise(input, scheduler);
	    } else if (isArrayLike(input)) {
	      return scheduleArray(input, scheduler);
	    } else if (isIterable(input) || typeof input === 'string') {
	      return scheduleIterable(input, scheduler);
	    }
	  }

	  throw new TypeError((input !== null && _typeof(input) || input) + ' is not observable');
	}

	/** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */
	function from(input, scheduler) {
	  if (!scheduler) {
	    if (input instanceof Observable) {
	      return input;
	    }

	    return new Observable(subscribeTo(input));
	  } else {
	    return scheduled(input, scheduler);
	  }
	}

	function mergeMap(project, resultSelector, concurrent) {
	  if (concurrent === void 0) {
	    concurrent = Number.POSITIVE_INFINITY;
	  }

	  if (typeof resultSelector === 'function') {
	    return function (source) {
	      return source.pipe(mergeMap(function (a, i) {
	        return from(project(a, i)).pipe(map(function (b, ii) {
	          return resultSelector(a, b, i, ii);
	        }));
	      }, concurrent));
	    };
	  } else if (typeof resultSelector === 'number') {
	    concurrent = resultSelector;
	  }

	  return function (source) {
	    return source.lift(new MergeMapOperator(project, concurrent));
	  };
	}

	var MergeMapOperator =
	/*@__PURE__*/
	function () {
	  function MergeMapOperator(project, concurrent) {
	    if (concurrent === void 0) {
	      concurrent = Number.POSITIVE_INFINITY;
	    }

	    this.project = project;
	    this.concurrent = concurrent;
	  }

	  MergeMapOperator.prototype.call = function (observer, source) {
	    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
	  };

	  return MergeMapOperator;
	}();

	var MergeMapSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(MergeMapSubscriber, _super);

	  function MergeMapSubscriber(destination, project, concurrent) {
	    if (concurrent === void 0) {
	      concurrent = Number.POSITIVE_INFINITY;
	    }

	    var _this = _super.call(this, destination) || this;

	    _this.project = project;
	    _this.concurrent = concurrent;
	    _this.hasCompleted = false;
	    _this.buffer = [];
	    _this.active = 0;
	    _this.index = 0;
	    return _this;
	  }

	  MergeMapSubscriber.prototype._next = function (value) {
	    if (this.active < this.concurrent) {
	      this._tryNext(value);
	    } else {
	      this.buffer.push(value);
	    }
	  };

	  MergeMapSubscriber.prototype._tryNext = function (value) {
	    var result;
	    var index = this.index++;

	    try {
	      result = this.project(value, index);
	    } catch (err) {
	      this.destination.error(err);
	      return;
	    }

	    this.active++;

	    this._innerSub(result, value, index);
	  };

	  MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
	    var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
	    var destination = this.destination;
	    destination.add(innerSubscriber);
	    subscribeToResult(this, ish, value, index, innerSubscriber);
	  };

	  MergeMapSubscriber.prototype._complete = function () {
	    this.hasCompleted = true;

	    if (this.active === 0 && this.buffer.length === 0) {
	      this.destination.complete();
	    }

	    this.unsubscribe();
	  };

	  MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.destination.next(innerValue);
	  };

	  MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
	    var buffer = this.buffer;
	    this.remove(innerSub);
	    this.active--;

	    if (buffer.length > 0) {
	      this._next(buffer.shift());
	    } else if (this.active === 0 && this.hasCompleted) {
	      this.destination.complete();
	    }
	  };

	  return MergeMapSubscriber;
	}(OuterSubscriber);

	function mergeAll(concurrent) {
	  if (concurrent === void 0) {
	    concurrent = Number.POSITIVE_INFINITY;
	  }

	  return mergeMap(identity, concurrent);
	}

	/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
	function isNumeric(val) {
	  return !isArray(val) && val - parseFloat(val) + 1 >= 0;
	}

	/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */

	function merge() {
	  var observables = [];

	  for (var _i = 0; _i < arguments.length; _i++) {
	    observables[_i] = arguments[_i];
	  }

	  var concurrent = Number.POSITIVE_INFINITY;
	  var scheduler = null;
	  var last = observables[observables.length - 1];

	  if (isScheduler(last)) {
	    scheduler = observables.pop();

	    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
	      concurrent = observables.pop();
	    }
	  } else if (typeof last === 'number') {
	    concurrent = observables.pop();
	  }

	  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
	    return observables[0];
	  }

	  return mergeAll(concurrent)(fromArray(observables, scheduler));
	}

	/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */
	var NEVER =
	/*@__PURE__*/
	new Observable(noop);

	/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var FilterSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(FilterSubscriber, _super);

	  function FilterSubscriber(destination, predicate, thisArg) {
	    var _this = _super.call(this, destination) || this;

	    _this.predicate = predicate;
	    _this.thisArg = thisArg;
	    _this.count = 0;
	    return _this;
	  }

	  FilterSubscriber.prototype._next = function (value) {
	    var result;

	    try {
	      result = this.predicate.call(this.thisArg, value, this.count++);
	    } catch (err) {
	      this.destination.error(err);
	      return;
	    }

	    if (result) {
	      this.destination.next(value);
	    }
	  };

	  return FilterSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START _util_not,_util_subscribeTo,_operators_filter,_Observable PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var RaceSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(RaceSubscriber, _super);

	  function RaceSubscriber(destination) {
	    var _this = _super.call(this, destination) || this;

	    _this.hasFirst = false;
	    _this.observables = [];
	    _this.subscriptions = [];
	    return _this;
	  }

	  RaceSubscriber.prototype._next = function (observable) {
	    this.observables.push(observable);
	  };

	  RaceSubscriber.prototype._complete = function () {
	    var observables = this.observables;
	    var len = observables.length;

	    if (len === 0) {
	      this.destination.complete();
	    } else {
	      for (var i = 0; i < len && !this.hasFirst; i++) {
	        var observable = observables[i];
	        var subscription = subscribeToResult(this, observable, observable, i);

	        if (this.subscriptions) {
	          this.subscriptions.push(subscription);
	        }

	        this.add(subscription);
	      }

	      this.observables = null;
	    }
	  };

	  RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    if (!this.hasFirst) {
	      this.hasFirst = true;

	      for (var i = 0; i < this.subscriptions.length; i++) {
	        if (i !== outerIndex) {
	          var subscription = this.subscriptions[i];
	          subscription.unsubscribe();
	          this.remove(subscription);
	        }
	      }

	      this.subscriptions = null;
	    }

	    this.destination.next(innerValue);
	  };

	  return RaceSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */

	var ZipSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(ZipSubscriber, _super);

	  function ZipSubscriber(destination, resultSelector, values) {
	    if (values === void 0) {
	      values = Object.create(null);
	    }

	    var _this = _super.call(this, destination) || this;

	    _this.iterators = [];
	    _this.active = 0;
	    _this.resultSelector = typeof resultSelector === 'function' ? resultSelector : null;
	    _this.values = values;
	    return _this;
	  }

	  ZipSubscriber.prototype._next = function (value) {
	    var iterators = this.iterators;

	    if (isArray(value)) {
	      iterators.push(new StaticArrayIterator(value));
	    } else if (typeof value[iterator] === 'function') {
	      iterators.push(new StaticIterator(value[iterator]()));
	    } else {
	      iterators.push(new ZipBufferIterator(this.destination, this, value));
	    }
	  };

	  ZipSubscriber.prototype._complete = function () {
	    var iterators = this.iterators;
	    var len = iterators.length;
	    this.unsubscribe();

	    if (len === 0) {
	      this.destination.complete();
	      return;
	    }

	    this.active = len;

	    for (var i = 0; i < len; i++) {
	      var iterator$$1 = iterators[i];

	      if (iterator$$1.stillUnsubscribed) {
	        var destination = this.destination;
	        destination.add(iterator$$1.subscribe(iterator$$1, i));
	      } else {
	        this.active--;
	      }
	    }
	  };

	  ZipSubscriber.prototype.notifyInactive = function () {
	    this.active--;

	    if (this.active === 0) {
	      this.destination.complete();
	    }
	  };

	  ZipSubscriber.prototype.checkIterators = function () {
	    var iterators = this.iterators;
	    var len = iterators.length;
	    var destination = this.destination;

	    for (var i = 0; i < len; i++) {
	      var iterator$$1 = iterators[i];

	      if (typeof iterator$$1.hasValue === 'function' && !iterator$$1.hasValue()) {
	        return;
	      }
	    }

	    var shouldComplete = false;
	    var args = [];

	    for (var i = 0; i < len; i++) {
	      var iterator$$1 = iterators[i];
	      var result = iterator$$1.next();

	      if (iterator$$1.hasCompleted()) {
	        shouldComplete = true;
	      }

	      if (result.done) {
	        destination.complete();
	        return;
	      }

	      args.push(result.value);
	    }

	    if (this.resultSelector) {
	      this._tryresultSelector(args);
	    } else {
	      destination.next(args);
	    }

	    if (shouldComplete) {
	      destination.complete();
	    }
	  };

	  ZipSubscriber.prototype._tryresultSelector = function (args) {
	    var result;

	    try {
	      result = this.resultSelector.apply(this, args);
	    } catch (err) {
	      this.destination.error(err);
	      return;
	    }

	    this.destination.next(result);
	  };

	  return ZipSubscriber;
	}(Subscriber);

	var StaticIterator =
	/*@__PURE__*/
	function () {
	  function StaticIterator(iterator$$1) {
	    this.iterator = iterator$$1;
	    this.nextResult = iterator$$1.next();
	  }

	  StaticIterator.prototype.hasValue = function () {
	    return true;
	  };

	  StaticIterator.prototype.next = function () {
	    var result = this.nextResult;
	    this.nextResult = this.iterator.next();
	    return result;
	  };

	  StaticIterator.prototype.hasCompleted = function () {
	    var nextResult = this.nextResult;
	    return nextResult && nextResult.done;
	  };

	  return StaticIterator;
	}();

	var StaticArrayIterator =
	/*@__PURE__*/
	function () {
	  function StaticArrayIterator(array) {
	    this.array = array;
	    this.index = 0;
	    this.length = 0;
	    this.length = array.length;
	  }

	  StaticArrayIterator.prototype[iterator] = function () {
	    return this;
	  };

	  StaticArrayIterator.prototype.next = function (value) {
	    var i = this.index++;
	    var array = this.array;
	    return i < this.length ? {
	      value: array[i],
	      done: false
	    } : {
	      value: null,
	      done: true
	    };
	  };

	  StaticArrayIterator.prototype.hasValue = function () {
	    return this.array.length > this.index;
	  };

	  StaticArrayIterator.prototype.hasCompleted = function () {
	    return this.array.length === this.index;
	  };

	  return StaticArrayIterator;
	}();

	var ZipBufferIterator =
	/*@__PURE__*/
	function (_super) {
	  __extends(ZipBufferIterator, _super);

	  function ZipBufferIterator(destination, parent, observable) {
	    var _this = _super.call(this, destination) || this;

	    _this.parent = parent;
	    _this.observable = observable;
	    _this.stillUnsubscribed = true;
	    _this.buffer = [];
	    _this.isComplete = false;
	    return _this;
	  }

	  ZipBufferIterator.prototype[iterator] = function () {
	    return this;
	  };

	  ZipBufferIterator.prototype.next = function () {
	    var buffer = this.buffer;

	    if (buffer.length === 0 && this.isComplete) {
	      return {
	        value: null,
	        done: true
	      };
	    } else {
	      return {
	        value: buffer.shift(),
	        done: false
	      };
	    }
	  };

	  ZipBufferIterator.prototype.hasValue = function () {
	    return this.buffer.length > 0;
	  };

	  ZipBufferIterator.prototype.hasCompleted = function () {
	    return this.buffer.length === 0 && this.isComplete;
	  };

	  ZipBufferIterator.prototype.notifyComplete = function () {
	    if (this.buffer.length > 0) {
	      this.isComplete = true;
	      this.parent.notifyInactive();
	    } else {
	      this.destination.complete();
	    }
	  };

	  ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.buffer.push(innerValue);
	    this.parent.checkIterators();
	  };

	  ZipBufferIterator.prototype.subscribe = function (value, index) {
	    return subscribeToResult(this, this.observable, this, index);
	  };

	  return ZipBufferIterator;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var AuditSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(AuditSubscriber, _super);

	  function AuditSubscriber(destination, durationSelector) {
	    var _this = _super.call(this, destination) || this;

	    _this.durationSelector = durationSelector;
	    _this.hasValue = false;
	    return _this;
	  }

	  AuditSubscriber.prototype._next = function (value) {
	    this.value = value;
	    this.hasValue = true;

	    if (!this.throttled) {
	      var duration = void 0;

	      try {
	        var durationSelector = this.durationSelector;
	        duration = durationSelector(value);
	      } catch (err) {
	        return this.destination.error(err);
	      }

	      var innerSubscription = subscribeToResult(this, duration);

	      if (!innerSubscription || innerSubscription.closed) {
	        this.clearThrottle();
	      } else {
	        this.add(this.throttled = innerSubscription);
	      }
	    }
	  };

	  AuditSubscriber.prototype.clearThrottle = function () {
	    var _a = this,
	        value = _a.value,
	        hasValue = _a.hasValue,
	        throttled = _a.throttled;

	    if (throttled) {
	      this.remove(throttled);
	      this.throttled = null;
	      throttled.unsubscribe();
	    }

	    if (hasValue) {
	      this.value = null;
	      this.hasValue = false;
	      this.destination.next(value);
	    }
	  };

	  AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
	    this.clearThrottle();
	  };

	  AuditSubscriber.prototype.notifyComplete = function () {
	    this.clearThrottle();
	  };

	  return AuditSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var BufferSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(BufferSubscriber, _super);

	  function BufferSubscriber(destination, closingNotifier) {
	    var _this = _super.call(this, destination) || this;

	    _this.buffer = [];

	    _this.add(subscribeToResult(_this, closingNotifier));

	    return _this;
	  }

	  BufferSubscriber.prototype._next = function (value) {
	    this.buffer.push(value);
	  };

	  BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    var buffer = this.buffer;
	    this.buffer = [];
	    this.destination.next(buffer);
	  };

	  return BufferSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var BufferCountSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(BufferCountSubscriber, _super);

	  function BufferCountSubscriber(destination, bufferSize) {
	    var _this = _super.call(this, destination) || this;

	    _this.bufferSize = bufferSize;
	    _this.buffer = [];
	    return _this;
	  }

	  BufferCountSubscriber.prototype._next = function (value) {
	    var buffer = this.buffer;
	    buffer.push(value);

	    if (buffer.length == this.bufferSize) {
	      this.destination.next(buffer);
	      this.buffer = [];
	    }
	  };

	  BufferCountSubscriber.prototype._complete = function () {
	    var buffer = this.buffer;

	    if (buffer.length > 0) {
	      this.destination.next(buffer);
	    }

	    _super.prototype._complete.call(this);
	  };

	  return BufferCountSubscriber;
	}(Subscriber);

	var BufferSkipCountSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(BufferSkipCountSubscriber, _super);

	  function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
	    var _this = _super.call(this, destination) || this;

	    _this.bufferSize = bufferSize;
	    _this.startBufferEvery = startBufferEvery;
	    _this.buffers = [];
	    _this.count = 0;
	    return _this;
	  }

	  BufferSkipCountSubscriber.prototype._next = function (value) {
	    var _a = this,
	        bufferSize = _a.bufferSize,
	        startBufferEvery = _a.startBufferEvery,
	        buffers = _a.buffers,
	        count = _a.count;

	    this.count++;

	    if (count % startBufferEvery === 0) {
	      buffers.push([]);
	    }

	    for (var i = buffers.length; i--;) {
	      var buffer = buffers[i];
	      buffer.push(value);

	      if (buffer.length === bufferSize) {
	        buffers.splice(i, 1);
	        this.destination.next(buffer);
	      }
	    }
	  };

	  BufferSkipCountSubscriber.prototype._complete = function () {
	    var _a = this,
	        buffers = _a.buffers,
	        destination = _a.destination;

	    while (buffers.length > 0) {
	      var buffer = buffers.shift();

	      if (buffer.length > 0) {
	        destination.next(buffer);
	      }
	    }

	    _super.prototype._complete.call(this);
	  };

	  return BufferSkipCountSubscriber;
	}(Subscriber);

	var Context =
	/*@__PURE__*/
	function () {
	  function Context() {
	    this.buffer = [];
	  }

	  return Context;
	}();

	var BufferTimeSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(BufferTimeSubscriber, _super);

	  function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
	    var _this = _super.call(this, destination) || this;

	    _this.bufferTimeSpan = bufferTimeSpan;
	    _this.bufferCreationInterval = bufferCreationInterval;
	    _this.maxBufferSize = maxBufferSize;
	    _this.scheduler = scheduler;
	    _this.contexts = [];

	    var context = _this.openContext();

	    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;

	    if (_this.timespanOnly) {
	      var timeSpanOnlyState = {
	        subscriber: _this,
	        context: context,
	        bufferTimeSpan: bufferTimeSpan
	      };

	      _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
	    } else {
	      var closeState = {
	        subscriber: _this,
	        context: context
	      };
	      var creationState = {
	        bufferTimeSpan: bufferTimeSpan,
	        bufferCreationInterval: bufferCreationInterval,
	        subscriber: _this,
	        scheduler: scheduler
	      };

	      _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));

	      _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
	    }

	    return _this;
	  }

	  BufferTimeSubscriber.prototype._next = function (value) {
	    var contexts = this.contexts;
	    var len = contexts.length;
	    var filledBufferContext;

	    for (var i = 0; i < len; i++) {
	      var context_1 = contexts[i];
	      var buffer = context_1.buffer;
	      buffer.push(value);

	      if (buffer.length == this.maxBufferSize) {
	        filledBufferContext = context_1;
	      }
	    }

	    if (filledBufferContext) {
	      this.onBufferFull(filledBufferContext);
	    }
	  };

	  BufferTimeSubscriber.prototype._error = function (err) {
	    this.contexts.length = 0;

	    _super.prototype._error.call(this, err);
	  };

	  BufferTimeSubscriber.prototype._complete = function () {
	    var _a = this,
	        contexts = _a.contexts,
	        destination = _a.destination;

	    while (contexts.length > 0) {
	      var context_2 = contexts.shift();
	      destination.next(context_2.buffer);
	    }

	    _super.prototype._complete.call(this);
	  };

	  BufferTimeSubscriber.prototype._unsubscribe = function () {
	    this.contexts = null;
	  };

	  BufferTimeSubscriber.prototype.onBufferFull = function (context) {
	    this.closeContext(context);
	    var closeAction = context.closeAction;
	    closeAction.unsubscribe();
	    this.remove(closeAction);

	    if (!this.closed && this.timespanOnly) {
	      context = this.openContext();
	      var bufferTimeSpan = this.bufferTimeSpan;
	      var timeSpanOnlyState = {
	        subscriber: this,
	        context: context,
	        bufferTimeSpan: bufferTimeSpan
	      };
	      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
	    }
	  };

	  BufferTimeSubscriber.prototype.openContext = function () {
	    var context = new Context();
	    this.contexts.push(context);
	    return context;
	  };

	  BufferTimeSubscriber.prototype.closeContext = function (context) {
	    this.destination.next(context.buffer);
	    var contexts = this.contexts;
	    var spliceIndex = contexts ? contexts.indexOf(context) : -1;

	    if (spliceIndex >= 0) {
	      contexts.splice(contexts.indexOf(context), 1);
	    }
	  };

	  return BufferTimeSubscriber;
	}(Subscriber);

	function dispatchBufferTimeSpanOnly(state) {
	  var subscriber = state.subscriber;
	  var prevContext = state.context;

	  if (prevContext) {
	    subscriber.closeContext(prevContext);
	  }

	  if (!subscriber.closed) {
	    state.context = subscriber.openContext();
	    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
	  }
	}

	function dispatchBufferCreation(state) {
	  var bufferCreationInterval = state.bufferCreationInterval,
	      bufferTimeSpan = state.bufferTimeSpan,
	      subscriber = state.subscriber,
	      scheduler = state.scheduler;
	  var context = subscriber.openContext();
	  var action = this;

	  if (!subscriber.closed) {
	    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {
	      subscriber: subscriber,
	      context: context
	    }));
	    action.schedule(state, bufferCreationInterval);
	  }
	}

	function dispatchBufferClose(arg) {
	  var subscriber = arg.subscriber,
	      context = arg.context;
	  subscriber.closeContext(context);
	}

	var BufferToggleSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(BufferToggleSubscriber, _super);

	  function BufferToggleSubscriber(destination, openings, closingSelector) {
	    var _this = _super.call(this, destination) || this;

	    _this.openings = openings;
	    _this.closingSelector = closingSelector;
	    _this.contexts = [];

	    _this.add(subscribeToResult(_this, openings));

	    return _this;
	  }

	  BufferToggleSubscriber.prototype._next = function (value) {
	    var contexts = this.contexts;
	    var len = contexts.length;

	    for (var i = 0; i < len; i++) {
	      contexts[i].buffer.push(value);
	    }
	  };

	  BufferToggleSubscriber.prototype._error = function (err) {
	    var contexts = this.contexts;

	    while (contexts.length > 0) {
	      var context_1 = contexts.shift();
	      context_1.subscription.unsubscribe();
	      context_1.buffer = null;
	      context_1.subscription = null;
	    }

	    this.contexts = null;

	    _super.prototype._error.call(this, err);
	  };

	  BufferToggleSubscriber.prototype._complete = function () {
	    var contexts = this.contexts;

	    while (contexts.length > 0) {
	      var context_2 = contexts.shift();
	      this.destination.next(context_2.buffer);
	      context_2.subscription.unsubscribe();
	      context_2.buffer = null;
	      context_2.subscription = null;
	    }

	    this.contexts = null;

	    _super.prototype._complete.call(this);
	  };

	  BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
	  };

	  BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
	    this.closeBuffer(innerSub.context);
	  };

	  BufferToggleSubscriber.prototype.openBuffer = function (value) {
	    try {
	      var closingSelector = this.closingSelector;
	      var closingNotifier = closingSelector.call(this, value);

	      if (closingNotifier) {
	        this.trySubscribe(closingNotifier);
	      }
	    } catch (err) {
	      this._error(err);
	    }
	  };

	  BufferToggleSubscriber.prototype.closeBuffer = function (context) {
	    var contexts = this.contexts;

	    if (contexts && context) {
	      var buffer = context.buffer,
	          subscription = context.subscription;
	      this.destination.next(buffer);
	      contexts.splice(contexts.indexOf(context), 1);
	      this.remove(subscription);
	      subscription.unsubscribe();
	    }
	  };

	  BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
	    var contexts = this.contexts;
	    var buffer = [];
	    var subscription = new Subscription();
	    var context = {
	      buffer: buffer,
	      subscription: subscription
	    };
	    contexts.push(context);
	    var innerSubscription = subscribeToResult(this, closingNotifier, context);

	    if (!innerSubscription || innerSubscription.closed) {
	      this.closeBuffer(context);
	    } else {
	      innerSubscription.context = context;
	      this.add(innerSubscription);
	      subscription.add(innerSubscription);
	    }
	  };

	  return BufferToggleSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var BufferWhenSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(BufferWhenSubscriber, _super);

	  function BufferWhenSubscriber(destination, closingSelector) {
	    var _this = _super.call(this, destination) || this;

	    _this.closingSelector = closingSelector;
	    _this.subscribing = false;

	    _this.openBuffer();

	    return _this;
	  }

	  BufferWhenSubscriber.prototype._next = function (value) {
	    this.buffer.push(value);
	  };

	  BufferWhenSubscriber.prototype._complete = function () {
	    var buffer = this.buffer;

	    if (buffer) {
	      this.destination.next(buffer);
	    }

	    _super.prototype._complete.call(this);
	  };

	  BufferWhenSubscriber.prototype._unsubscribe = function () {
	    this.buffer = null;
	    this.subscribing = false;
	  };

	  BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.openBuffer();
	  };

	  BufferWhenSubscriber.prototype.notifyComplete = function () {
	    if (this.subscribing) {
	      this.complete();
	    } else {
	      this.openBuffer();
	    }
	  };

	  BufferWhenSubscriber.prototype.openBuffer = function () {
	    var closingSubscription = this.closingSubscription;

	    if (closingSubscription) {
	      this.remove(closingSubscription);
	      closingSubscription.unsubscribe();
	    }

	    var buffer = this.buffer;

	    if (this.buffer) {
	      this.destination.next(buffer);
	    }

	    this.buffer = [];
	    var closingNotifier;

	    try {
	      var closingSelector = this.closingSelector;
	      closingNotifier = closingSelector();
	    } catch (err) {
	      return this.error(err);
	    }

	    closingSubscription = new Subscription();
	    this.closingSubscription = closingSubscription;
	    this.add(closingSubscription);
	    this.subscribing = true;
	    closingSubscription.add(subscribeToResult(this, closingNotifier));
	    this.subscribing = false;
	  };

	  return BufferWhenSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var CatchSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(CatchSubscriber, _super);

	  function CatchSubscriber(destination, selector, caught) {
	    var _this = _super.call(this, destination) || this;

	    _this.selector = selector;
	    _this.caught = caught;
	    return _this;
	  }

	  CatchSubscriber.prototype.error = function (err) {
	    if (!this.isStopped) {
	      var result = void 0;

	      try {
	        result = this.selector(err, this.caught);
	      } catch (err2) {
	        _super.prototype.error.call(this, err2);

	        return;
	      }

	      this._unsubscribeAndRecycle();

	      var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
	      this.add(innerSubscriber);
	      subscribeToResult(this, result, undefined, undefined, innerSubscriber);
	    }
	  };

	  return CatchSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var CountSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(CountSubscriber, _super);

	  function CountSubscriber(destination, predicate, source) {
	    var _this = _super.call(this, destination) || this;

	    _this.predicate = predicate;
	    _this.source = source;
	    _this.count = 0;
	    _this.index = 0;
	    return _this;
	  }

	  CountSubscriber.prototype._next = function (value) {
	    if (this.predicate) {
	      this._tryPredicate(value);
	    } else {
	      this.count++;
	    }
	  };

	  CountSubscriber.prototype._tryPredicate = function (value) {
	    var result;

	    try {
	      result = this.predicate(value, this.index++, this.source);
	    } catch (err) {
	      this.destination.error(err);
	      return;
	    }

	    if (result) {
	      this.count++;
	    }
	  };

	  CountSubscriber.prototype._complete = function () {
	    this.destination.next(this.count);
	    this.destination.complete();
	  };

	  return CountSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var DebounceSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(DebounceSubscriber, _super);

	  function DebounceSubscriber(destination, durationSelector) {
	    var _this = _super.call(this, destination) || this;

	    _this.durationSelector = durationSelector;
	    _this.hasValue = false;
	    _this.durationSubscription = null;
	    return _this;
	  }

	  DebounceSubscriber.prototype._next = function (value) {
	    try {
	      var result = this.durationSelector.call(this, value);

	      if (result) {
	        this._tryNext(value, result);
	      }
	    } catch (err) {
	      this.destination.error(err);
	    }
	  };

	  DebounceSubscriber.prototype._complete = function () {
	    this.emitValue();
	    this.destination.complete();
	  };

	  DebounceSubscriber.prototype._tryNext = function (value, duration) {
	    var subscription = this.durationSubscription;
	    this.value = value;
	    this.hasValue = true;

	    if (subscription) {
	      subscription.unsubscribe();
	      this.remove(subscription);
	    }

	    subscription = subscribeToResult(this, duration);

	    if (subscription && !subscription.closed) {
	      this.add(this.durationSubscription = subscription);
	    }
	  };

	  DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.emitValue();
	  };

	  DebounceSubscriber.prototype.notifyComplete = function () {
	    this.emitValue();
	  };

	  DebounceSubscriber.prototype.emitValue = function () {
	    if (this.hasValue) {
	      var value = this.value;
	      var subscription = this.durationSubscription;

	      if (subscription) {
	        this.durationSubscription = null;
	        subscription.unsubscribe();
	        this.remove(subscription);
	      }

	      this.value = null;
	      this.hasValue = false;

	      _super.prototype._next.call(this, value);
	    }
	  };

	  return DebounceSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */

	var DebounceTimeSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(DebounceTimeSubscriber, _super);

	  function DebounceTimeSubscriber(destination, dueTime, scheduler) {
	    var _this = _super.call(this, destination) || this;

	    _this.dueTime = dueTime;
	    _this.scheduler = scheduler;
	    _this.debouncedSubscription = null;
	    _this.lastValue = null;
	    _this.hasValue = false;
	    return _this;
	  }

	  DebounceTimeSubscriber.prototype._next = function (value) {
	    this.clearDebounce();
	    this.lastValue = value;
	    this.hasValue = true;
	    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$2, this.dueTime, this));
	  };

	  DebounceTimeSubscriber.prototype._complete = function () {
	    this.debouncedNext();
	    this.destination.complete();
	  };

	  DebounceTimeSubscriber.prototype.debouncedNext = function () {
	    this.clearDebounce();

	    if (this.hasValue) {
	      var lastValue = this.lastValue;
	      this.lastValue = null;
	      this.hasValue = false;
	      this.destination.next(lastValue);
	    }
	  };

	  DebounceTimeSubscriber.prototype.clearDebounce = function () {
	    var debouncedSubscription = this.debouncedSubscription;

	    if (debouncedSubscription !== null) {
	      this.remove(debouncedSubscription);
	      debouncedSubscription.unsubscribe();
	      this.debouncedSubscription = null;
	    }
	  };

	  return DebounceTimeSubscriber;
	}(Subscriber);

	function dispatchNext$2(subscriber) {
	  subscriber.debouncedNext();
	}

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var DefaultIfEmptySubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(DefaultIfEmptySubscriber, _super);

	  function DefaultIfEmptySubscriber(destination, defaultValue) {
	    var _this = _super.call(this, destination) || this;

	    _this.defaultValue = defaultValue;
	    _this.isEmpty = true;
	    return _this;
	  }

	  DefaultIfEmptySubscriber.prototype._next = function (value) {
	    this.isEmpty = false;
	    this.destination.next(value);
	  };

	  DefaultIfEmptySubscriber.prototype._complete = function () {
	    if (this.isEmpty) {
	      this.destination.next(this.defaultValue);
	    }

	    this.destination.complete();
	  };

	  return DefaultIfEmptySubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */

	var DelaySubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(DelaySubscriber, _super);

	  function DelaySubscriber(destination, delay, scheduler) {
	    var _this = _super.call(this, destination) || this;

	    _this.delay = delay;
	    _this.scheduler = scheduler;
	    _this.queue = [];
	    _this.active = false;
	    _this.errored = false;
	    return _this;
	  }

	  DelaySubscriber.dispatch = function (state) {
	    var source = state.source;
	    var queue = source.queue;
	    var scheduler = state.scheduler;
	    var destination = state.destination;

	    while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
	      queue.shift().notification.observe(destination);
	    }

	    if (queue.length > 0) {
	      var delay_1 = Math.max(0, queue[0].time - scheduler.now());
	      this.schedule(state, delay_1);
	    } else {
	      this.unsubscribe();
	      source.active = false;
	    }
	  };

	  DelaySubscriber.prototype._schedule = function (scheduler) {
	    this.active = true;
	    var destination = this.destination;
	    destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
	      source: this,
	      destination: this.destination,
	      scheduler: scheduler
	    }));
	  };

	  DelaySubscriber.prototype.scheduleNotification = function (notification) {
	    if (this.errored === true) {
	      return;
	    }

	    var scheduler = this.scheduler;
	    var message = new DelayMessage(scheduler.now() + this.delay, notification);
	    this.queue.push(message);

	    if (this.active === false) {
	      this._schedule(scheduler);
	    }
	  };

	  DelaySubscriber.prototype._next = function (value) {
	    this.scheduleNotification(Notification.createNext(value));
	  };

	  DelaySubscriber.prototype._error = function (err) {
	    this.errored = true;
	    this.queue = [];
	    this.destination.error(err);
	    this.unsubscribe();
	  };

	  DelaySubscriber.prototype._complete = function () {
	    this.scheduleNotification(Notification.createComplete());
	    this.unsubscribe();
	  };

	  return DelaySubscriber;
	}(Subscriber);

	var DelayMessage =
	/*@__PURE__*/
	function () {
	  function DelayMessage(time, notification) {
	    this.time = time;
	    this.notification = notification;
	  }

	  return DelayMessage;
	}();

	var DelayWhenSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(DelayWhenSubscriber, _super);

	  function DelayWhenSubscriber(destination, delayDurationSelector) {
	    var _this = _super.call(this, destination) || this;

	    _this.delayDurationSelector = delayDurationSelector;
	    _this.completed = false;
	    _this.delayNotifierSubscriptions = [];
	    _this.index = 0;
	    return _this;
	  }

	  DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.destination.next(outerValue);
	    this.removeSubscription(innerSub);
	    this.tryComplete();
	  };

	  DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
	    this._error(error);
	  };

	  DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
	    var value = this.removeSubscription(innerSub);

	    if (value) {
	      this.destination.next(value);
	    }

	    this.tryComplete();
	  };

	  DelayWhenSubscriber.prototype._next = function (value) {
	    var index = this.index++;

	    try {
	      var delayNotifier = this.delayDurationSelector(value, index);

	      if (delayNotifier) {
	        this.tryDelay(delayNotifier, value);
	      }
	    } catch (err) {
	      this.destination.error(err);
	    }
	  };

	  DelayWhenSubscriber.prototype._complete = function () {
	    this.completed = true;
	    this.tryComplete();
	    this.unsubscribe();
	  };

	  DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
	    subscription.unsubscribe();
	    var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);

	    if (subscriptionIdx !== -1) {
	      this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
	    }

	    return subscription.outerValue;
	  };

	  DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
	    var notifierSubscription = subscribeToResult(this, delayNotifier, value);

	    if (notifierSubscription && !notifierSubscription.closed) {
	      var destination = this.destination;
	      destination.add(notifierSubscription);
	      this.delayNotifierSubscriptions.push(notifierSubscription);
	    }
	  };

	  DelayWhenSubscriber.prototype.tryComplete = function () {
	    if (this.completed && this.delayNotifierSubscriptions.length === 0) {
	      this.destination.complete();
	    }
	  };

	  return DelayWhenSubscriber;
	}(OuterSubscriber);

	var SubscriptionDelayObservable =
	/*@__PURE__*/
	function (_super) {
	  __extends(SubscriptionDelayObservable, _super);

	  function SubscriptionDelayObservable(source, subscriptionDelay) {
	    var _this = _super.call(this) || this;

	    _this.source = source;
	    _this.subscriptionDelay = subscriptionDelay;
	    return _this;
	  }

	  SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
	    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
	  };

	  return SubscriptionDelayObservable;
	}(Observable);

	var SubscriptionDelaySubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(SubscriptionDelaySubscriber, _super);

	  function SubscriptionDelaySubscriber(parent, source) {
	    var _this = _super.call(this) || this;

	    _this.parent = parent;
	    _this.source = source;
	    _this.sourceSubscribed = false;
	    return _this;
	  }

	  SubscriptionDelaySubscriber.prototype._next = function (unused) {
	    this.subscribeToSource();
	  };

	  SubscriptionDelaySubscriber.prototype._error = function (err) {
	    this.unsubscribe();
	    this.parent.error(err);
	  };

	  SubscriptionDelaySubscriber.prototype._complete = function () {
	    this.unsubscribe();
	    this.subscribeToSource();
	  };

	  SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
	    if (!this.sourceSubscribed) {
	      this.sourceSubscribed = true;
	      this.unsubscribe();
	      this.source.subscribe(this.parent);
	    }
	  };

	  return SubscriptionDelaySubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var DeMaterializeSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(DeMaterializeSubscriber, _super);

	  function DeMaterializeSubscriber(destination) {
	    return _super.call(this, destination) || this;
	  }

	  DeMaterializeSubscriber.prototype._next = function (value) {
	    value.observe(this.destination);
	  };

	  return DeMaterializeSubscriber;
	}(Subscriber);

	var DistinctSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(DistinctSubscriber, _super);

	  function DistinctSubscriber(destination, keySelector, flushes) {
	    var _this = _super.call(this, destination) || this;

	    _this.keySelector = keySelector;
	    _this.values = new Set();

	    if (flushes) {
	      _this.add(subscribeToResult(_this, flushes));
	    }

	    return _this;
	  }

	  DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.values.clear();
	  };

	  DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
	    this._error(error);
	  };

	  DistinctSubscriber.prototype._next = function (value) {
	    if (this.keySelector) {
	      this._useKeySelector(value);
	    } else {
	      this._finalizeNext(value, value);
	    }
	  };

	  DistinctSubscriber.prototype._useKeySelector = function (value) {
	    var key;
	    var destination = this.destination;

	    try {
	      key = this.keySelector(value);
	    } catch (err) {
	      destination.error(err);
	      return;
	    }

	    this._finalizeNext(key, value);
	  };

	  DistinctSubscriber.prototype._finalizeNext = function (key, value) {
	    var values = this.values;

	    if (!values.has(key)) {
	      values.add(key);
	      this.destination.next(value);
	    }
	  };

	  return DistinctSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var DistinctUntilChangedSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(DistinctUntilChangedSubscriber, _super);

	  function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
	    var _this = _super.call(this, destination) || this;

	    _this.keySelector = keySelector;
	    _this.hasKey = false;

	    if (typeof compare === 'function') {
	      _this.compare = compare;
	    }

	    return _this;
	  }

	  DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
	    return x === y;
	  };

	  DistinctUntilChangedSubscriber.prototype._next = function (value) {
	    var key;

	    try {
	      var keySelector = this.keySelector;
	      key = keySelector ? keySelector(value) : value;
	    } catch (err) {
	      return this.destination.error(err);
	    }

	    var result = false;

	    if (this.hasKey) {
	      try {
	        var compare = this.compare;
	        result = compare(this.key, key);
	      } catch (err) {
	        return this.destination.error(err);
	      }
	    } else {
	      this.hasKey = true;
	    }

	    if (!result) {
	      this.key = key;
	      this.destination.next(value);
	    }
	  };

	  return DistinctUntilChangedSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_util_EmptyError,_Subscriber PURE_IMPORTS_END */

	var ThrowIfEmptySubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(ThrowIfEmptySubscriber, _super);

	  function ThrowIfEmptySubscriber(destination, errorFactory) {
	    var _this = _super.call(this, destination) || this;

	    _this.errorFactory = errorFactory;
	    _this.hasValue = false;
	    return _this;
	  }

	  ThrowIfEmptySubscriber.prototype._next = function (value) {
	    this.hasValue = true;
	    this.destination.next(value);
	  };

	  ThrowIfEmptySubscriber.prototype._complete = function () {
	    if (!this.hasValue) {
	      var err = void 0;

	      try {
	        err = this.errorFactory();
	      } catch (e) {
	        err = e;
	      }

	      this.destination.error(err);
	    } else {
	      return this.destination.complete();
	    }
	  };

	  return ThrowIfEmptySubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */

	var TakeSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(TakeSubscriber, _super);

	  function TakeSubscriber(destination, total) {
	    var _this = _super.call(this, destination) || this;

	    _this.total = total;
	    _this.count = 0;
	    return _this;
	  }

	  TakeSubscriber.prototype._next = function (value) {
	    var total = this.total;
	    var count = ++this.count;

	    if (count <= total) {
	      this.destination.next(value);

	      if (count === total) {
	        this.destination.complete();
	        this.unsubscribe();
	      }
	    }
	  };

	  return TakeSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var EverySubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(EverySubscriber, _super);

	  function EverySubscriber(destination, predicate, thisArg, source) {
	    var _this = _super.call(this, destination) || this;

	    _this.predicate = predicate;
	    _this.thisArg = thisArg;
	    _this.source = source;
	    _this.index = 0;
	    _this.thisArg = thisArg || _this;
	    return _this;
	  }

	  EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
	    this.destination.next(everyValueMatch);
	    this.destination.complete();
	  };

	  EverySubscriber.prototype._next = function (value) {
	    var result = false;

	    try {
	      result = this.predicate.call(this.thisArg, value, this.index++, this.source);
	    } catch (err) {
	      this.destination.error(err);
	      return;
	    }

	    if (!result) {
	      this.notifyComplete(false);
	    }
	  };

	  EverySubscriber.prototype._complete = function () {
	    this.notifyComplete(true);
	  };

	  return EverySubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var SwitchFirstSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(SwitchFirstSubscriber, _super);

	  function SwitchFirstSubscriber(destination) {
	    var _this = _super.call(this, destination) || this;

	    _this.hasCompleted = false;
	    _this.hasSubscription = false;
	    return _this;
	  }

	  SwitchFirstSubscriber.prototype._next = function (value) {
	    if (!this.hasSubscription) {
	      this.hasSubscription = true;
	      this.add(subscribeToResult(this, value));
	    }
	  };

	  SwitchFirstSubscriber.prototype._complete = function () {
	    this.hasCompleted = true;

	    if (!this.hasSubscription) {
	      this.destination.complete();
	    }
	  };

	  SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
	    this.remove(innerSub);
	    this.hasSubscription = false;

	    if (this.hasCompleted) {
	      this.destination.complete();
	    }
	  };

	  return SwitchFirstSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */

	var ExhaustMapSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(ExhaustMapSubscriber, _super);

	  function ExhaustMapSubscriber(destination, project) {
	    var _this = _super.call(this, destination) || this;

	    _this.project = project;
	    _this.hasSubscription = false;
	    _this.hasCompleted = false;
	    _this.index = 0;
	    return _this;
	  }

	  ExhaustMapSubscriber.prototype._next = function (value) {
	    if (!this.hasSubscription) {
	      this.tryNext(value);
	    }
	  };

	  ExhaustMapSubscriber.prototype.tryNext = function (value) {
	    var result;
	    var index = this.index++;

	    try {
	      result = this.project(value, index);
	    } catch (err) {
	      this.destination.error(err);
	      return;
	    }

	    this.hasSubscription = true;

	    this._innerSub(result, value, index);
	  };

	  ExhaustMapSubscriber.prototype._innerSub = function (result, value, index) {
	    var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
	    var destination = this.destination;
	    destination.add(innerSubscriber);
	    subscribeToResult(this, result, value, index, innerSubscriber);
	  };

	  ExhaustMapSubscriber.prototype._complete = function () {
	    this.hasCompleted = true;

	    if (!this.hasSubscription) {
	      this.destination.complete();
	    }

	    this.unsubscribe();
	  };

	  ExhaustMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.destination.next(innerValue);
	  };

	  ExhaustMapSubscriber.prototype.notifyError = function (err) {
	    this.destination.error(err);
	  };

	  ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {
	    var destination = this.destination;
	    destination.remove(innerSub);
	    this.hasSubscription = false;

	    if (this.hasCompleted) {
	      this.destination.complete();
	    }
	  };

	  return ExhaustMapSubscriber;
	}(OuterSubscriber);

	var ExpandSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(ExpandSubscriber, _super);

	  function ExpandSubscriber(destination, project, concurrent, scheduler) {
	    var _this = _super.call(this, destination) || this;

	    _this.project = project;
	    _this.concurrent = concurrent;
	    _this.scheduler = scheduler;
	    _this.index = 0;
	    _this.active = 0;
	    _this.hasCompleted = false;

	    if (concurrent < Number.POSITIVE_INFINITY) {
	      _this.buffer = [];
	    }

	    return _this;
	  }

	  ExpandSubscriber.dispatch = function (arg) {
	    var subscriber = arg.subscriber,
	        result = arg.result,
	        value = arg.value,
	        index = arg.index;
	    subscriber.subscribeToProjection(result, value, index);
	  };

	  ExpandSubscriber.prototype._next = function (value) {
	    var destination = this.destination;

	    if (destination.closed) {
	      this._complete();

	      return;
	    }

	    var index = this.index++;

	    if (this.active < this.concurrent) {
	      destination.next(value);

	      try {
	        var project = this.project;
	        var result = project(value, index);

	        if (!this.scheduler) {
	          this.subscribeToProjection(result, value, index);
	        } else {
	          var state = {
	            subscriber: this,
	            result: result,
	            value: value,
	            index: index
	          };
	          var destination_1 = this.destination;
	          destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
	        }
	      } catch (e) {
	        destination.error(e);
	      }
	    } else {
	      this.buffer.push(value);
	    }
	  };

	  ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
	    this.active++;
	    var destination = this.destination;
	    destination.add(subscribeToResult(this, result, value, index));
	  };

	  ExpandSubscriber.prototype._complete = function () {
	    this.hasCompleted = true;

	    if (this.hasCompleted && this.active === 0) {
	      this.destination.complete();
	    }

	    this.unsubscribe();
	  };

	  ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this._next(innerValue);
	  };

	  ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
	    var buffer = this.buffer;
	    var destination = this.destination;
	    destination.remove(innerSub);
	    this.active--;

	    if (buffer && buffer.length > 0) {
	      this._next(buffer.shift());
	    }

	    if (this.hasCompleted && this.active === 0) {
	      this.destination.complete();
	    }
	  };

	  return ExpandSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */

	var FinallySubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(FinallySubscriber, _super);

	  function FinallySubscriber(destination, callback) {
	    var _this = _super.call(this, destination) || this;

	    _this.add(new Subscription(callback));

	    return _this;
	  }

	  return FinallySubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var FindValueSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(FindValueSubscriber, _super);

	  function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
	    var _this = _super.call(this, destination) || this;

	    _this.predicate = predicate;
	    _this.source = source;
	    _this.yieldIndex = yieldIndex;
	    _this.thisArg = thisArg;
	    _this.index = 0;
	    return _this;
	  }

	  FindValueSubscriber.prototype.notifyComplete = function (value) {
	    var destination = this.destination;
	    destination.next(value);
	    destination.complete();
	    this.unsubscribe();
	  };

	  FindValueSubscriber.prototype._next = function (value) {
	    var _a = this,
	        predicate = _a.predicate,
	        thisArg = _a.thisArg;

	    var index = this.index++;

	    try {
	      var result = predicate.call(thisArg || this, value, index, this.source);

	      if (result) {
	        this.notifyComplete(this.yieldIndex ? index : value);
	      }
	    } catch (err) {
	      this.destination.error(err);
	    }
	  };

	  FindValueSubscriber.prototype._complete = function () {
	    this.notifyComplete(this.yieldIndex ? -1 : undefined);
	  };

	  return FindValueSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var IgnoreElementsSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(IgnoreElementsSubscriber, _super);

	  function IgnoreElementsSubscriber() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }

	  IgnoreElementsSubscriber.prototype._next = function (unused) {};

	  return IgnoreElementsSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var IsEmptySubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(IsEmptySubscriber, _super);

	  function IsEmptySubscriber(destination) {
	    return _super.call(this, destination) || this;
	  }

	  IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
	    var destination = this.destination;
	    destination.next(isEmpty);
	    destination.complete();
	  };

	  IsEmptySubscriber.prototype._next = function (value) {
	    this.notifyComplete(false);
	  };

	  IsEmptySubscriber.prototype._complete = function () {
	    this.notifyComplete(true);
	  };

	  return IsEmptySubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */

	var TakeLastSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(TakeLastSubscriber, _super);

	  function TakeLastSubscriber(destination, total) {
	    var _this = _super.call(this, destination) || this;

	    _this.total = total;
	    _this.ring = new Array();
	    _this.count = 0;
	    return _this;
	  }

	  TakeLastSubscriber.prototype._next = function (value) {
	    var ring = this.ring;
	    var total = this.total;
	    var count = this.count++;

	    if (ring.length < total) {
	      ring.push(value);
	    } else {
	      var index = count % total;
	      ring[index] = value;
	    }
	  };

	  TakeLastSubscriber.prototype._complete = function () {
	    var destination = this.destination;
	    var count = this.count;

	    if (count > 0) {
	      var total = this.count >= this.total ? this.total : this.count;
	      var ring = this.ring;

	      for (var i = 0; i < total; i++) {
	        var idx = count++ % total;
	        destination.next(ring[idx]);
	      }
	    }

	    destination.complete();
	  };

	  return TakeLastSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var MapToSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(MapToSubscriber, _super);

	  function MapToSubscriber(destination, value) {
	    var _this = _super.call(this, destination) || this;

	    _this.value = value;
	    return _this;
	  }

	  MapToSubscriber.prototype._next = function (x) {
	    this.destination.next(this.value);
	  };

	  return MapToSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */

	var MaterializeSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(MaterializeSubscriber, _super);

	  function MaterializeSubscriber(destination) {
	    return _super.call(this, destination) || this;
	  }

	  MaterializeSubscriber.prototype._next = function (value) {
	    this.destination.next(Notification.createNext(value));
	  };

	  MaterializeSubscriber.prototype._error = function (err) {
	    var destination = this.destination;
	    destination.next(Notification.createError(err));
	    destination.complete();
	  };

	  MaterializeSubscriber.prototype._complete = function () {
	    var destination = this.destination;
	    destination.next(Notification.createComplete());
	    destination.complete();
	  };

	  return MaterializeSubscriber;
	}(Subscriber);

	var ScanSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(ScanSubscriber, _super);

	  function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
	    var _this = _super.call(this, destination) || this;

	    _this.accumulator = accumulator;
	    _this._seed = _seed;
	    _this.hasSeed = hasSeed;
	    _this.index = 0;
	    return _this;
	  }

	  Object.defineProperty(ScanSubscriber.prototype, "seed", {
	    get: function get() {
	      return this._seed;
	    },
	    set: function set(value) {
	      this.hasSeed = true;
	      this._seed = value;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  ScanSubscriber.prototype._next = function (value) {
	    if (!this.hasSeed) {
	      this.seed = value;
	      this.destination.next(value);
	    } else {
	      return this._tryNext(value);
	    }
	  };

	  ScanSubscriber.prototype._tryNext = function (value) {
	    var index = this.index++;
	    var result;

	    try {
	      result = this.accumulator(this.seed, value, index);
	    } catch (err) {
	      this.destination.error(err);
	    }

	    this.seed = result;
	    this.destination.next(result);
	  };

	  return ScanSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */

	var MergeScanSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(MergeScanSubscriber, _super);

	  function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
	    var _this = _super.call(this, destination) || this;

	    _this.accumulator = accumulator;
	    _this.acc = acc;
	    _this.concurrent = concurrent;
	    _this.hasValue = false;
	    _this.hasCompleted = false;
	    _this.buffer = [];
	    _this.active = 0;
	    _this.index = 0;
	    return _this;
	  }

	  MergeScanSubscriber.prototype._next = function (value) {
	    if (this.active < this.concurrent) {
	      var index = this.index++;
	      var destination = this.destination;
	      var ish = void 0;

	      try {
	        var accumulator = this.accumulator;
	        ish = accumulator(this.acc, value, index);
	      } catch (e) {
	        return destination.error(e);
	      }

	      this.active++;

	      this._innerSub(ish, value, index);
	    } else {
	      this.buffer.push(value);
	    }
	  };

	  MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
	    var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
	    var destination = this.destination;
	    destination.add(innerSubscriber);
	    subscribeToResult(this, ish, value, index, innerSubscriber);
	  };

	  MergeScanSubscriber.prototype._complete = function () {
	    this.hasCompleted = true;

	    if (this.active === 0 && this.buffer.length === 0) {
	      if (this.hasValue === false) {
	        this.destination.next(this.acc);
	      }

	      this.destination.complete();
	    }

	    this.unsubscribe();
	  };

	  MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    var destination = this.destination;
	    this.acc = innerValue;
	    this.hasValue = true;
	    destination.next(innerValue);
	  };

	  MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
	    var buffer = this.buffer;
	    var destination = this.destination;
	    destination.remove(innerSub);
	    this.active--;

	    if (buffer.length > 0) {
	      this._next(buffer.shift());
	    } else if (this.active === 0 && this.hasCompleted) {
	      if (this.hasValue === false) {
	        this.destination.next(this.acc);
	      }

	      this.destination.complete();
	    }
	  };

	  return MergeScanSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

	function multicast(subjectOrSubjectFactory, selector) {
	  return function multicastOperatorFunction(source) {
	    var subjectFactory;

	    if (typeof subjectOrSubjectFactory === 'function') {
	      subjectFactory = subjectOrSubjectFactory;
	    } else {
	      subjectFactory = function subjectFactory() {
	        return subjectOrSubjectFactory;
	      };
	    }

	    if (typeof selector === 'function') {
	      return source.lift(new MulticastOperator(subjectFactory, selector));
	    }

	    var connectable = Object.create(source, connectableObservableDescriptor);
	    connectable.source = source;
	    connectable.subjectFactory = subjectFactory;
	    return connectable;
	  };
	}

	var MulticastOperator =
	/*@__PURE__*/
	function () {
	  function MulticastOperator(subjectFactory, selector) {
	    this.subjectFactory = subjectFactory;
	    this.selector = selector;
	  }

	  MulticastOperator.prototype.call = function (subscriber, source) {
	    var selector = this.selector;
	    var subject = this.subjectFactory();
	    var subscription = selector(subject).subscribe(subscriber);
	    subscription.add(source.subscribe(subject));
	    return subscription;
	  };

	  return MulticastOperator;
	}();

	/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var OnErrorResumeNextSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(OnErrorResumeNextSubscriber, _super);

	  function OnErrorResumeNextSubscriber(destination, nextSources) {
	    var _this = _super.call(this, destination) || this;

	    _this.destination = destination;
	    _this.nextSources = nextSources;
	    return _this;
	  }

	  OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
	    this.subscribeToNextSource();
	  };

	  OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
	    this.subscribeToNextSource();
	  };

	  OnErrorResumeNextSubscriber.prototype._error = function (err) {
	    this.subscribeToNextSource();
	    this.unsubscribe();
	  };

	  OnErrorResumeNextSubscriber.prototype._complete = function () {
	    this.subscribeToNextSource();
	    this.unsubscribe();
	  };

	  OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
	    var next = this.nextSources.shift();

	    if (!!next) {
	      var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
	      var destination = this.destination;
	      destination.add(innerSubscriber);
	      subscribeToResult(this, next, undefined, undefined, innerSubscriber);
	    } else {
	      this.destination.complete();
	    }
	  };

	  return OnErrorResumeNextSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var PairwiseSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(PairwiseSubscriber, _super);

	  function PairwiseSubscriber(destination) {
	    var _this = _super.call(this, destination) || this;

	    _this.hasPrev = false;
	    return _this;
	  }

	  PairwiseSubscriber.prototype._next = function (value) {
	    if (this.hasPrev) {
	      this.destination.next([this.prev, value]);
	    } else {
	      this.hasPrev = true;
	    }

	    this.prev = value;
	  };

	  return PairwiseSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _map PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */

	var RepeatSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(RepeatSubscriber, _super);

	  function RepeatSubscriber(destination, count, source) {
	    var _this = _super.call(this, destination) || this;

	    _this.count = count;
	    _this.source = source;
	    return _this;
	  }

	  RepeatSubscriber.prototype.complete = function () {
	    if (!this.isStopped) {
	      var _a = this,
	          source = _a.source,
	          count = _a.count;

	      if (count === 0) {
	        return _super.prototype.complete.call(this);
	      } else if (count > -1) {
	        this.count = count - 1;
	      }

	      source.subscribe(this._unsubscribeAndRecycle());
	    }
	  };

	  return RepeatSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var RepeatWhenSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(RepeatWhenSubscriber, _super);

	  function RepeatWhenSubscriber(destination, notifier, source) {
	    var _this = _super.call(this, destination) || this;

	    _this.notifier = notifier;
	    _this.source = source;
	    _this.sourceIsBeingSubscribedTo = true;
	    return _this;
	  }

	  RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.sourceIsBeingSubscribedTo = true;
	    this.source.subscribe(this);
	  };

	  RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
	    if (this.sourceIsBeingSubscribedTo === false) {
	      return _super.prototype.complete.call(this);
	    }
	  };

	  RepeatWhenSubscriber.prototype.complete = function () {
	    this.sourceIsBeingSubscribedTo = false;

	    if (!this.isStopped) {
	      if (!this.retries) {
	        this.subscribeToRetries();
	      }

	      if (!this.retriesSubscription || this.retriesSubscription.closed) {
	        return _super.prototype.complete.call(this);
	      }

	      this._unsubscribeAndRecycle();

	      this.notifications.next();
	    }
	  };

	  RepeatWhenSubscriber.prototype._unsubscribe = function () {
	    var _a = this,
	        notifications = _a.notifications,
	        retriesSubscription = _a.retriesSubscription;

	    if (notifications) {
	      notifications.unsubscribe();
	      this.notifications = null;
	    }

	    if (retriesSubscription) {
	      retriesSubscription.unsubscribe();
	      this.retriesSubscription = null;
	    }

	    this.retries = null;
	  };

	  RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
	    var _unsubscribe = this._unsubscribe;
	    this._unsubscribe = null;

	    _super.prototype._unsubscribeAndRecycle.call(this);

	    this._unsubscribe = _unsubscribe;
	    return this;
	  };

	  RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
	    this.notifications = new Subject();
	    var retries;

	    try {
	      var notifier = this.notifier;
	      retries = notifier(this.notifications);
	    } catch (e) {
	      return _super.prototype.complete.call(this);
	    }

	    this.retries = retries;
	    this.retriesSubscription = subscribeToResult(this, retries);
	  };

	  return RepeatWhenSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var RetrySubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(RetrySubscriber, _super);

	  function RetrySubscriber(destination, count, source) {
	    var _this = _super.call(this, destination) || this;

	    _this.count = count;
	    _this.source = source;
	    return _this;
	  }

	  RetrySubscriber.prototype.error = function (err) {
	    if (!this.isStopped) {
	      var _a = this,
	          source = _a.source,
	          count = _a.count;

	      if (count === 0) {
	        return _super.prototype.error.call(this, err);
	      } else if (count > -1) {
	        this.count = count - 1;
	      }

	      source.subscribe(this._unsubscribeAndRecycle());
	    }
	  };

	  return RetrySubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var RetryWhenSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(RetryWhenSubscriber, _super);

	  function RetryWhenSubscriber(destination, notifier, source) {
	    var _this = _super.call(this, destination) || this;

	    _this.notifier = notifier;
	    _this.source = source;
	    return _this;
	  }

	  RetryWhenSubscriber.prototype.error = function (err) {
	    if (!this.isStopped) {
	      var errors = this.errors;
	      var retries = this.retries;
	      var retriesSubscription = this.retriesSubscription;

	      if (!retries) {
	        errors = new Subject();

	        try {
	          var notifier = this.notifier;
	          retries = notifier(errors);
	        } catch (e) {
	          return _super.prototype.error.call(this, e);
	        }

	        retriesSubscription = subscribeToResult(this, retries);
	      } else {
	        this.errors = null;
	        this.retriesSubscription = null;
	      }

	      this._unsubscribeAndRecycle();

	      this.errors = errors;
	      this.retries = retries;
	      this.retriesSubscription = retriesSubscription;
	      errors.next(err);
	    }
	  };

	  RetryWhenSubscriber.prototype._unsubscribe = function () {
	    var _a = this,
	        errors = _a.errors,
	        retriesSubscription = _a.retriesSubscription;

	    if (errors) {
	      errors.unsubscribe();
	      this.errors = null;
	    }

	    if (retriesSubscription) {
	      retriesSubscription.unsubscribe();
	      this.retriesSubscription = null;
	    }

	    this.retries = null;
	  };

	  RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    var _unsubscribe = this._unsubscribe;
	    this._unsubscribe = null;

	    this._unsubscribeAndRecycle();

	    this._unsubscribe = _unsubscribe;
	    this.source.subscribe(this);
	  };

	  return RetryWhenSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var SampleSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(SampleSubscriber, _super);

	  function SampleSubscriber() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;

	    _this.hasValue = false;
	    return _this;
	  }

	  SampleSubscriber.prototype._next = function (value) {
	    this.value = value;
	    this.hasValue = true;
	  };

	  SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.emitValue();
	  };

	  SampleSubscriber.prototype.notifyComplete = function () {
	    this.emitValue();
	  };

	  SampleSubscriber.prototype.emitValue = function () {
	    if (this.hasValue) {
	      this.hasValue = false;
	      this.destination.next(this.value);
	    }
	  };

	  return SampleSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */

	var SampleTimeSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(SampleTimeSubscriber, _super);

	  function SampleTimeSubscriber(destination, period, scheduler) {
	    var _this = _super.call(this, destination) || this;

	    _this.period = period;
	    _this.scheduler = scheduler;
	    _this.hasValue = false;

	    _this.add(scheduler.schedule(dispatchNotification, period, {
	      subscriber: _this,
	      period: period
	    }));

	    return _this;
	  }

	  SampleTimeSubscriber.prototype._next = function (value) {
	    this.lastValue = value;
	    this.hasValue = true;
	  };

	  SampleTimeSubscriber.prototype.notifyNext = function () {
	    if (this.hasValue) {
	      this.hasValue = false;
	      this.destination.next(this.lastValue);
	    }
	  };

	  return SampleTimeSubscriber;
	}(Subscriber);

	function dispatchNotification(state) {
	  var subscriber = state.subscriber,
	      period = state.period;
	  subscriber.notifyNext();
	  this.schedule(state, period);
	}

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var SequenceEqualSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(SequenceEqualSubscriber, _super);

	  function SequenceEqualSubscriber(destination, compareTo, comparator) {
	    var _this = _super.call(this, destination) || this;

	    _this.compareTo = compareTo;
	    _this.comparator = comparator;
	    _this._a = [];
	    _this._b = [];
	    _this._oneComplete = false;

	    _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));

	    return _this;
	  }

	  SequenceEqualSubscriber.prototype._next = function (value) {
	    if (this._oneComplete && this._b.length === 0) {
	      this.emit(false);
	    } else {
	      this._a.push(value);

	      this.checkValues();
	    }
	  };

	  SequenceEqualSubscriber.prototype._complete = function () {
	    if (this._oneComplete) {
	      this.emit(this._a.length === 0 && this._b.length === 0);
	    } else {
	      this._oneComplete = true;
	    }

	    this.unsubscribe();
	  };

	  SequenceEqualSubscriber.prototype.checkValues = function () {
	    var _c = this,
	        _a = _c._a,
	        _b = _c._b,
	        comparator = _c.comparator;

	    while (_a.length > 0 && _b.length > 0) {
	      var a = _a.shift();

	      var b = _b.shift();

	      var areEqual = false;

	      try {
	        areEqual = comparator ? comparator(a, b) : a === b;
	      } catch (e) {
	        this.destination.error(e);
	      }

	      if (!areEqual) {
	        this.emit(false);
	      }
	    }
	  };

	  SequenceEqualSubscriber.prototype.emit = function (value) {
	    var destination = this.destination;
	    destination.next(value);
	    destination.complete();
	  };

	  SequenceEqualSubscriber.prototype.nextB = function (value) {
	    if (this._oneComplete && this._a.length === 0) {
	      this.emit(false);
	    } else {
	      this._b.push(value);

	      this.checkValues();
	    }
	  };

	  SequenceEqualSubscriber.prototype.completeB = function () {
	    if (this._oneComplete) {
	      this.emit(this._a.length === 0 && this._b.length === 0);
	    } else {
	      this._oneComplete = true;
	    }
	  };

	  return SequenceEqualSubscriber;
	}(Subscriber);

	var SequenceEqualCompareToSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(SequenceEqualCompareToSubscriber, _super);

	  function SequenceEqualCompareToSubscriber(destination, parent) {
	    var _this = _super.call(this, destination) || this;

	    _this.parent = parent;
	    return _this;
	  }

	  SequenceEqualCompareToSubscriber.prototype._next = function (value) {
	    this.parent.nextB(value);
	  };

	  SequenceEqualCompareToSubscriber.prototype._error = function (err) {
	    this.parent.error(err);
	    this.unsubscribe();
	  };

	  SequenceEqualCompareToSubscriber.prototype._complete = function () {
	    this.parent.completeB();
	    this.unsubscribe();
	  };

	  return SequenceEqualCompareToSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */

	function shareSubjectFactory() {
	  return new Subject();
	}

	function share() {
	  return function (source) {
	    return refCount()(multicast(shareSubjectFactory)(source));
	  };
	}

	/** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */

	var SingleSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(SingleSubscriber, _super);

	  function SingleSubscriber(destination, predicate, source) {
	    var _this = _super.call(this, destination) || this;

	    _this.predicate = predicate;
	    _this.source = source;
	    _this.seenValue = false;
	    _this.index = 0;
	    return _this;
	  }

	  SingleSubscriber.prototype.applySingleValue = function (value) {
	    if (this.seenValue) {
	      this.destination.error('Sequence contains more than one element');
	    } else {
	      this.seenValue = true;
	      this.singleValue = value;
	    }
	  };

	  SingleSubscriber.prototype._next = function (value) {
	    var index = this.index++;

	    if (this.predicate) {
	      this.tryNext(value, index);
	    } else {
	      this.applySingleValue(value);
	    }
	  };

	  SingleSubscriber.prototype.tryNext = function (value, index) {
	    try {
	      if (this.predicate(value, index, this.source)) {
	        this.applySingleValue(value);
	      }
	    } catch (err) {
	      this.destination.error(err);
	    }
	  };

	  SingleSubscriber.prototype._complete = function () {
	    var destination = this.destination;

	    if (this.index > 0) {
	      destination.next(this.seenValue ? this.singleValue : undefined);
	      destination.complete();
	    } else {
	      destination.error(new EmptyError());
	    }
	  };

	  return SingleSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var SkipSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(SkipSubscriber, _super);

	  function SkipSubscriber(destination, total) {
	    var _this = _super.call(this, destination) || this;

	    _this.total = total;
	    _this.count = 0;
	    return _this;
	  }

	  SkipSubscriber.prototype._next = function (x) {
	    if (++this.count > this.total) {
	      this.destination.next(x);
	    }
	  };

	  return SkipSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */

	var SkipLastSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(SkipLastSubscriber, _super);

	  function SkipLastSubscriber(destination, _skipCount) {
	    var _this = _super.call(this, destination) || this;

	    _this._skipCount = _skipCount;
	    _this._count = 0;
	    _this._ring = new Array(_skipCount);
	    return _this;
	  }

	  SkipLastSubscriber.prototype._next = function (value) {
	    var skipCount = this._skipCount;
	    var count = this._count++;

	    if (count < skipCount) {
	      this._ring[count] = value;
	    } else {
	      var currentIndex = count % skipCount;
	      var ring = this._ring;
	      var oldValue = ring[currentIndex];
	      ring[currentIndex] = value;
	      this.destination.next(oldValue);
	    }
	  };

	  return SkipLastSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var SkipUntilSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(SkipUntilSubscriber, _super);

	  function SkipUntilSubscriber(destination, notifier) {
	    var _this = _super.call(this, destination) || this;

	    _this.hasValue = false;
	    var innerSubscriber = new InnerSubscriber(_this, undefined, undefined);

	    _this.add(innerSubscriber);

	    _this.innerSubscription = innerSubscriber;
	    subscribeToResult(_this, notifier, undefined, undefined, innerSubscriber);
	    return _this;
	  }

	  SkipUntilSubscriber.prototype._next = function (value) {
	    if (this.hasValue) {
	      _super.prototype._next.call(this, value);
	    }
	  };

	  SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.hasValue = true;

	    if (this.innerSubscription) {
	      this.innerSubscription.unsubscribe();
	    }
	  };

	  SkipUntilSubscriber.prototype.notifyComplete = function () {};

	  return SkipUntilSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var SkipWhileSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(SkipWhileSubscriber, _super);

	  function SkipWhileSubscriber(destination, predicate) {
	    var _this = _super.call(this, destination) || this;

	    _this.predicate = predicate;
	    _this.skipping = true;
	    _this.index = 0;
	    return _this;
	  }

	  SkipWhileSubscriber.prototype._next = function (value) {
	    var destination = this.destination;

	    if (this.skipping) {
	      this.tryCallPredicate(value);
	    }

	    if (!this.skipping) {
	      destination.next(value);
	    }
	  };

	  SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
	    try {
	      var result = this.predicate(value, this.index++);
	      this.skipping = Boolean(result);
	    } catch (err) {
	      this.destination.error(err);
	    }
	  };

	  return SkipWhileSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START _observable_concat,_util_isScheduler PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */

	var SubscribeOnObservable =
	/*@__PURE__*/
	function (_super) {
	  __extends(SubscribeOnObservable, _super);

	  function SubscribeOnObservable(source, delayTime, scheduler) {
	    if (delayTime === void 0) {
	      delayTime = 0;
	    }

	    if (scheduler === void 0) {
	      scheduler = asap;
	    }

	    var _this = _super.call(this) || this;

	    _this.source = source;
	    _this.delayTime = delayTime;
	    _this.scheduler = scheduler;

	    if (!isNumeric(delayTime) || delayTime < 0) {
	      _this.delayTime = 0;
	    }

	    if (!scheduler || typeof scheduler.schedule !== 'function') {
	      _this.scheduler = asap;
	    }

	    return _this;
	  }

	  SubscribeOnObservable.create = function (source, delay, scheduler) {
	    if (delay === void 0) {
	      delay = 0;
	    }

	    if (scheduler === void 0) {
	      scheduler = asap;
	    }

	    return new SubscribeOnObservable(source, delay, scheduler);
	  };

	  SubscribeOnObservable.dispatch = function (arg) {
	    var source = arg.source,
	        subscriber = arg.subscriber;
	    return this.add(source.subscribe(subscriber));
	  };

	  SubscribeOnObservable.prototype._subscribe = function (subscriber) {
	    var delay = this.delayTime;
	    var source = this.source;
	    var scheduler = this.scheduler;
	    return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
	      source: source,
	      subscriber: subscriber
	    });
	  };

	  return SubscribeOnObservable;
	}(Observable);

	/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */

	var SwitchMapSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(SwitchMapSubscriber, _super);

	  function SwitchMapSubscriber(destination, project) {
	    var _this = _super.call(this, destination) || this;

	    _this.project = project;
	    _this.index = 0;
	    return _this;
	  }

	  SwitchMapSubscriber.prototype._next = function (value) {
	    var result;
	    var index = this.index++;

	    try {
	      result = this.project(value, index);
	    } catch (error) {
	      this.destination.error(error);
	      return;
	    }

	    this._innerSub(result, value, index);
	  };

	  SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
	    var innerSubscription = this.innerSubscription;

	    if (innerSubscription) {
	      innerSubscription.unsubscribe();
	    }

	    var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
	    var destination = this.destination;
	    destination.add(innerSubscriber);
	    this.innerSubscription = subscribeToResult(this, result, value, index, innerSubscriber);
	  };

	  SwitchMapSubscriber.prototype._complete = function () {
	    var innerSubscription = this.innerSubscription;

	    if (!innerSubscription || innerSubscription.closed) {
	      _super.prototype._complete.call(this);
	    }

	    this.unsubscribe();
	  };

	  SwitchMapSubscriber.prototype._unsubscribe = function () {
	    this.innerSubscription = null;
	  };

	  SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
	    var destination = this.destination;
	    destination.remove(innerSub);
	    this.innerSubscription = null;

	    if (this.isStopped) {
	      _super.prototype._complete.call(this);
	    }
	  };

	  SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.destination.next(innerValue);
	  };

	  return SwitchMapSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var TakeUntilSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(TakeUntilSubscriber, _super);

	  function TakeUntilSubscriber(destination) {
	    var _this = _super.call(this, destination) || this;

	    _this.seenValue = false;
	    return _this;
	  }

	  TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.seenValue = true;
	    this.complete();
	  };

	  TakeUntilSubscriber.prototype.notifyComplete = function () {};

	  return TakeUntilSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	var TakeWhileSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(TakeWhileSubscriber, _super);

	  function TakeWhileSubscriber(destination, predicate, inclusive) {
	    var _this = _super.call(this, destination) || this;

	    _this.predicate = predicate;
	    _this.inclusive = inclusive;
	    _this.index = 0;
	    return _this;
	  }

	  TakeWhileSubscriber.prototype._next = function (value) {
	    var destination = this.destination;
	    var result;

	    try {
	      result = this.predicate(value, this.index++);
	    } catch (err) {
	      destination.error(err);
	      return;
	    }

	    this.nextOrComplete(value, result);
	  };

	  TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
	    var destination = this.destination;

	    if (Boolean(predicateResult)) {
	      destination.next(value);
	    } else {
	      if (this.inclusive) {
	        destination.next(value);
	      }

	      destination.complete();
	    }
	  };

	  return TakeWhileSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */

	var TapSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(TapSubscriber, _super);

	  function TapSubscriber(destination, observerOrNext, error, complete) {
	    var _this = _super.call(this, destination) || this;

	    _this._tapNext = noop;
	    _this._tapError = noop;
	    _this._tapComplete = noop;
	    _this._tapError = error || noop;
	    _this._tapComplete = complete || noop;

	    if (isFunction(observerOrNext)) {
	      _this._context = _this;
	      _this._tapNext = observerOrNext;
	    } else if (observerOrNext) {
	      _this._context = observerOrNext;
	      _this._tapNext = observerOrNext.next || noop;
	      _this._tapError = observerOrNext.error || noop;
	      _this._tapComplete = observerOrNext.complete || noop;
	    }

	    return _this;
	  }

	  TapSubscriber.prototype._next = function (value) {
	    try {
	      this._tapNext.call(this._context, value);
	    } catch (err) {
	      this.destination.error(err);
	      return;
	    }

	    this.destination.next(value);
	  };

	  TapSubscriber.prototype._error = function (err) {
	    try {
	      this._tapError.call(this._context, err);
	    } catch (err) {
	      this.destination.error(err);
	      return;
	    }

	    this.destination.error(err);
	  };

	  TapSubscriber.prototype._complete = function () {
	    try {
	      this._tapComplete.call(this._context);
	    } catch (err) {
	      this.destination.error(err);
	      return;
	    }

	    return this.destination.complete();
	  };

	  return TapSubscriber;
	}(Subscriber);

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var ThrottleSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(ThrottleSubscriber, _super);

	  function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
	    var _this = _super.call(this, destination) || this;

	    _this.destination = destination;
	    _this.durationSelector = durationSelector;
	    _this._leading = _leading;
	    _this._trailing = _trailing;
	    _this._hasValue = false;
	    return _this;
	  }

	  ThrottleSubscriber.prototype._next = function (value) {
	    this._hasValue = true;
	    this._sendValue = value;

	    if (!this._throttled) {
	      if (this._leading) {
	        this.send();
	      } else {
	        this.throttle(value);
	      }
	    }
	  };

	  ThrottleSubscriber.prototype.send = function () {
	    var _a = this,
	        _hasValue = _a._hasValue,
	        _sendValue = _a._sendValue;

	    if (_hasValue) {
	      this.destination.next(_sendValue);
	      this.throttle(_sendValue);
	    }

	    this._hasValue = false;
	    this._sendValue = null;
	  };

	  ThrottleSubscriber.prototype.throttle = function (value) {
	    var duration = this.tryDurationSelector(value);

	    if (!!duration) {
	      this.add(this._throttled = subscribeToResult(this, duration));
	    }
	  };

	  ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
	    try {
	      return this.durationSelector(value);
	    } catch (err) {
	      this.destination.error(err);
	      return null;
	    }
	  };

	  ThrottleSubscriber.prototype.throttlingDone = function () {
	    var _a = this,
	        _throttled = _a._throttled,
	        _trailing = _a._trailing;

	    if (_throttled) {
	      _throttled.unsubscribe();
	    }

	    this._throttled = null;

	    if (_trailing) {
	      this.send();
	    }
	  };

	  ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.throttlingDone();
	  };

	  ThrottleSubscriber.prototype.notifyComplete = function () {
	    this.throttlingDone();
	  };

	  return ThrottleSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */

	var ThrottleTimeSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(ThrottleTimeSubscriber, _super);

	  function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
	    var _this = _super.call(this, destination) || this;

	    _this.duration = duration;
	    _this.scheduler = scheduler;
	    _this.leading = leading;
	    _this.trailing = trailing;
	    _this._hasTrailingValue = false;
	    _this._trailingValue = null;
	    return _this;
	  }

	  ThrottleTimeSubscriber.prototype._next = function (value) {
	    if (this.throttled) {
	      if (this.trailing) {
	        this._trailingValue = value;
	        this._hasTrailingValue = true;
	      }
	    } else {
	      this.add(this.throttled = this.scheduler.schedule(dispatchNext$3, this.duration, {
	        subscriber: this
	      }));

	      if (this.leading) {
	        this.destination.next(value);
	      } else if (this.trailing) {
	        this._trailingValue = value;
	        this._hasTrailingValue = true;
	      }
	    }
	  };

	  ThrottleTimeSubscriber.prototype._complete = function () {
	    if (this._hasTrailingValue) {
	      this.destination.next(this._trailingValue);
	      this.destination.complete();
	    } else {
	      this.destination.complete();
	    }
	  };

	  ThrottleTimeSubscriber.prototype.clearThrottle = function () {
	    var throttled = this.throttled;

	    if (throttled) {
	      if (this.trailing && this._hasTrailingValue) {
	        this.destination.next(this._trailingValue);
	        this._trailingValue = null;
	        this._hasTrailingValue = false;
	      }

	      throttled.unsubscribe();
	      this.remove(throttled);
	      this.throttled = null;
	    }
	  };

	  return ThrottleTimeSubscriber;
	}(Subscriber);

	function dispatchNext$3(arg) {
	  var subscriber = arg.subscriber;
	  subscriber.clearThrottle();
	}

	/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var TimeoutWithSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(TimeoutWithSubscriber, _super);

	  function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
	    var _this = _super.call(this, destination) || this;

	    _this.absoluteTimeout = absoluteTimeout;
	    _this.waitFor = waitFor;
	    _this.withObservable = withObservable;
	    _this.scheduler = scheduler;
	    _this.action = null;

	    _this.scheduleTimeout();

	    return _this;
	  }

	  TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
	    var withObservable = subscriber.withObservable;

	    subscriber._unsubscribeAndRecycle();

	    subscriber.add(subscribeToResult(subscriber, withObservable));
	  };

	  TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
	    var action = this.action;

	    if (action) {
	      this.action = action.schedule(this, this.waitFor);
	    } else {
	      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
	    }
	  };

	  TimeoutWithSubscriber.prototype._next = function (value) {
	    if (!this.absoluteTimeout) {
	      this.scheduleTimeout();
	    }

	    _super.prototype._next.call(this, value);
	  };

	  TimeoutWithSubscriber.prototype._unsubscribe = function () {
	    this.action = null;
	    this.scheduler = null;
	    this.withObservable = null;
	  };

	  return TimeoutWithSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var WindowSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(WindowSubscriber, _super);

	  function WindowSubscriber(destination) {
	    var _this = _super.call(this, destination) || this;

	    _this.window = new Subject();
	    destination.next(_this.window);
	    return _this;
	  }

	  WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.openWindow();
	  };

	  WindowSubscriber.prototype.notifyError = function (error, innerSub) {
	    this._error(error);
	  };

	  WindowSubscriber.prototype.notifyComplete = function (innerSub) {
	    this._complete();
	  };

	  WindowSubscriber.prototype._next = function (value) {
	    this.window.next(value);
	  };

	  WindowSubscriber.prototype._error = function (err) {
	    this.window.error(err);
	    this.destination.error(err);
	  };

	  WindowSubscriber.prototype._complete = function () {
	    this.window.complete();
	    this.destination.complete();
	  };

	  WindowSubscriber.prototype._unsubscribe = function () {
	    this.window = null;
	  };

	  WindowSubscriber.prototype.openWindow = function () {
	    var prevWindow = this.window;

	    if (prevWindow) {
	      prevWindow.complete();
	    }

	    var destination = this.destination;
	    var newWindow = this.window = new Subject();
	    destination.next(newWindow);
	  };

	  return WindowSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */

	var WindowCountSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(WindowCountSubscriber, _super);

	  function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
	    var _this = _super.call(this, destination) || this;

	    _this.destination = destination;
	    _this.windowSize = windowSize;
	    _this.startWindowEvery = startWindowEvery;
	    _this.windows = [new Subject()];
	    _this.count = 0;
	    destination.next(_this.windows[0]);
	    return _this;
	  }

	  WindowCountSubscriber.prototype._next = function (value) {
	    var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
	    var destination = this.destination;
	    var windowSize = this.windowSize;
	    var windows = this.windows;
	    var len = windows.length;

	    for (var i = 0; i < len && !this.closed; i++) {
	      windows[i].next(value);
	    }

	    var c = this.count - windowSize + 1;

	    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
	      windows.shift().complete();
	    }

	    if (++this.count % startWindowEvery === 0 && !this.closed) {
	      var window_1 = new Subject();
	      windows.push(window_1);
	      destination.next(window_1);
	    }
	  };

	  WindowCountSubscriber.prototype._error = function (err) {
	    var windows = this.windows;

	    if (windows) {
	      while (windows.length > 0 && !this.closed) {
	        windows.shift().error(err);
	      }
	    }

	    this.destination.error(err);
	  };

	  WindowCountSubscriber.prototype._complete = function () {
	    var windows = this.windows;

	    if (windows) {
	      while (windows.length > 0 && !this.closed) {
	        windows.shift().complete();
	      }
	    }

	    this.destination.complete();
	  };

	  WindowCountSubscriber.prototype._unsubscribe = function () {
	    this.count = 0;
	    this.windows = null;
	  };

	  return WindowCountSubscriber;
	}(Subscriber);

	var CountedSubject =
	/*@__PURE__*/
	function (_super) {
	  __extends(CountedSubject, _super);

	  function CountedSubject() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;

	    _this._numberOfNextedValues = 0;
	    return _this;
	  }

	  CountedSubject.prototype.next = function (value) {
	    this._numberOfNextedValues++;

	    _super.prototype.next.call(this, value);
	  };

	  Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
	    get: function get() {
	      return this._numberOfNextedValues;
	    },
	    enumerable: true,
	    configurable: true
	  });
	  return CountedSubject;
	}(Subject);

	var WindowTimeSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(WindowTimeSubscriber, _super);

	  function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
	    var _this = _super.call(this, destination) || this;

	    _this.destination = destination;
	    _this.windowTimeSpan = windowTimeSpan;
	    _this.windowCreationInterval = windowCreationInterval;
	    _this.maxWindowSize = maxWindowSize;
	    _this.scheduler = scheduler;
	    _this.windows = [];

	    var window = _this.openWindow();

	    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
	      var closeState = {
	        subscriber: _this,
	        window: window,
	        context: null
	      };
	      var creationState = {
	        windowTimeSpan: windowTimeSpan,
	        windowCreationInterval: windowCreationInterval,
	        subscriber: _this,
	        scheduler: scheduler
	      };

	      _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));

	      _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
	    } else {
	      var timeSpanOnlyState = {
	        subscriber: _this,
	        window: window,
	        windowTimeSpan: windowTimeSpan
	      };

	      _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
	    }

	    return _this;
	  }

	  WindowTimeSubscriber.prototype._next = function (value) {
	    var windows = this.windows;
	    var len = windows.length;

	    for (var i = 0; i < len; i++) {
	      var window_1 = windows[i];

	      if (!window_1.closed) {
	        window_1.next(value);

	        if (window_1.numberOfNextedValues >= this.maxWindowSize) {
	          this.closeWindow(window_1);
	        }
	      }
	    }
	  };

	  WindowTimeSubscriber.prototype._error = function (err) {
	    var windows = this.windows;

	    while (windows.length > 0) {
	      windows.shift().error(err);
	    }

	    this.destination.error(err);
	  };

	  WindowTimeSubscriber.prototype._complete = function () {
	    var windows = this.windows;

	    while (windows.length > 0) {
	      var window_2 = windows.shift();

	      if (!window_2.closed) {
	        window_2.complete();
	      }
	    }

	    this.destination.complete();
	  };

	  WindowTimeSubscriber.prototype.openWindow = function () {
	    var window = new CountedSubject();
	    this.windows.push(window);
	    var destination = this.destination;
	    destination.next(window);
	    return window;
	  };

	  WindowTimeSubscriber.prototype.closeWindow = function (window) {
	    window.complete();
	    var windows = this.windows;
	    windows.splice(windows.indexOf(window), 1);
	  };

	  return WindowTimeSubscriber;
	}(Subscriber);

	function dispatchWindowTimeSpanOnly(state) {
	  var subscriber = state.subscriber,
	      windowTimeSpan = state.windowTimeSpan,
	      window = state.window;

	  if (window) {
	    subscriber.closeWindow(window);
	  }

	  state.window = subscriber.openWindow();
	  this.schedule(state, windowTimeSpan);
	}

	function dispatchWindowCreation(state) {
	  var windowTimeSpan = state.windowTimeSpan,
	      subscriber = state.subscriber,
	      scheduler = state.scheduler,
	      windowCreationInterval = state.windowCreationInterval;
	  var window = subscriber.openWindow();
	  var action = this;
	  var context = {
	    action: action,
	    subscription: null
	  };
	  var timeSpanState = {
	    subscriber: subscriber,
	    window: window,
	    context: context
	  };
	  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
	  action.add(context.subscription);
	  action.schedule(state, windowCreationInterval);
	}

	function dispatchWindowClose(state) {
	  var subscriber = state.subscriber,
	      window = state.window,
	      context = state.context;

	  if (context && context.action && context.subscription) {
	    context.action.remove(context.subscription);
	  }

	  subscriber.closeWindow(window);
	}

	var WindowToggleSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(WindowToggleSubscriber, _super);

	  function WindowToggleSubscriber(destination, openings, closingSelector) {
	    var _this = _super.call(this, destination) || this;

	    _this.openings = openings;
	    _this.closingSelector = closingSelector;
	    _this.contexts = [];

	    _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));

	    return _this;
	  }

	  WindowToggleSubscriber.prototype._next = function (value) {
	    var contexts = this.contexts;

	    if (contexts) {
	      var len = contexts.length;

	      for (var i = 0; i < len; i++) {
	        contexts[i].window.next(value);
	      }
	    }
	  };

	  WindowToggleSubscriber.prototype._error = function (err) {
	    var contexts = this.contexts;
	    this.contexts = null;

	    if (contexts) {
	      var len = contexts.length;
	      var index = -1;

	      while (++index < len) {
	        var context_1 = contexts[index];
	        context_1.window.error(err);
	        context_1.subscription.unsubscribe();
	      }
	    }

	    _super.prototype._error.call(this, err);
	  };

	  WindowToggleSubscriber.prototype._complete = function () {
	    var contexts = this.contexts;
	    this.contexts = null;

	    if (contexts) {
	      var len = contexts.length;
	      var index = -1;

	      while (++index < len) {
	        var context_2 = contexts[index];
	        context_2.window.complete();
	        context_2.subscription.unsubscribe();
	      }
	    }

	    _super.prototype._complete.call(this);
	  };

	  WindowToggleSubscriber.prototype._unsubscribe = function () {
	    var contexts = this.contexts;
	    this.contexts = null;

	    if (contexts) {
	      var len = contexts.length;
	      var index = -1;

	      while (++index < len) {
	        var context_3 = contexts[index];
	        context_3.window.unsubscribe();
	        context_3.subscription.unsubscribe();
	      }
	    }
	  };

	  WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    if (outerValue === this.openings) {
	      var closingNotifier = void 0;

	      try {
	        var closingSelector = this.closingSelector;
	        closingNotifier = closingSelector(innerValue);
	      } catch (e) {
	        return this.error(e);
	      }

	      var window_1 = new Subject();
	      var subscription = new Subscription();
	      var context_4 = {
	        window: window_1,
	        subscription: subscription
	      };
	      this.contexts.push(context_4);
	      var innerSubscription = subscribeToResult(this, closingNotifier, context_4);

	      if (innerSubscription.closed) {
	        this.closeWindow(this.contexts.length - 1);
	      } else {
	        innerSubscription.context = context_4;
	        subscription.add(innerSubscription);
	      }

	      this.destination.next(window_1);
	    } else {
	      this.closeWindow(this.contexts.indexOf(outerValue));
	    }
	  };

	  WindowToggleSubscriber.prototype.notifyError = function (err) {
	    this.error(err);
	  };

	  WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
	    if (inner !== this.openSubscription) {
	      this.closeWindow(this.contexts.indexOf(inner.context));
	    }
	  };

	  WindowToggleSubscriber.prototype.closeWindow = function (index) {
	    if (index === -1) {
	      return;
	    }

	    var contexts = this.contexts;
	    var context = contexts[index];
	    var window = context.window,
	        subscription = context.subscription;
	    contexts.splice(index, 1);
	    window.complete();
	    subscription.unsubscribe();
	  };

	  return WindowToggleSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

	var WindowSubscriber$1 =
	/*@__PURE__*/
	function (_super) {
	  __extends(WindowSubscriber, _super);

	  function WindowSubscriber(destination, closingSelector) {
	    var _this = _super.call(this, destination) || this;

	    _this.destination = destination;
	    _this.closingSelector = closingSelector;

	    _this.openWindow();

	    return _this;
	  }

	  WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.openWindow(innerSub);
	  };

	  WindowSubscriber.prototype.notifyError = function (error, innerSub) {
	    this._error(error);
	  };

	  WindowSubscriber.prototype.notifyComplete = function (innerSub) {
	    this.openWindow(innerSub);
	  };

	  WindowSubscriber.prototype._next = function (value) {
	    this.window.next(value);
	  };

	  WindowSubscriber.prototype._error = function (err) {
	    this.window.error(err);
	    this.destination.error(err);
	    this.unsubscribeClosingNotification();
	  };

	  WindowSubscriber.prototype._complete = function () {
	    this.window.complete();
	    this.destination.complete();
	    this.unsubscribeClosingNotification();
	  };

	  WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
	    if (this.closingNotification) {
	      this.closingNotification.unsubscribe();
	    }
	  };

	  WindowSubscriber.prototype.openWindow = function (innerSub) {
	    if (innerSub === void 0) {
	      innerSub = null;
	    }

	    if (innerSub) {
	      this.remove(innerSub);
	      innerSub.unsubscribe();
	    }

	    var prevWindow = this.window;

	    if (prevWindow) {
	      prevWindow.complete();
	    }

	    var window = this.window = new Subject();
	    this.destination.next(window);
	    var closingNotifier;

	    try {
	      var closingSelector = this.closingSelector;
	      closingNotifier = closingSelector();
	    } catch (e) {
	      this.destination.error(e);
	      this.window.error(e);
	      return;
	    }

	    this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
	  };

	  return WindowSubscriber;
	}(OuterSubscriber);

	var WithLatestFromSubscriber =
	/*@__PURE__*/
	function (_super) {
	  __extends(WithLatestFromSubscriber, _super);

	  function WithLatestFromSubscriber(destination, observables, project) {
	    var _this = _super.call(this, destination) || this;

	    _this.observables = observables;
	    _this.project = project;
	    _this.toRespond = [];
	    var len = observables.length;
	    _this.values = new Array(len);

	    for (var i = 0; i < len; i++) {
	      _this.toRespond.push(i);
	    }

	    for (var i = 0; i < len; i++) {
	      var observable = observables[i];

	      _this.add(subscribeToResult(_this, observable, observable, i));
	    }

	    return _this;
	  }

	  WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.values[outerIndex] = innerValue;
	    var toRespond = this.toRespond;

	    if (toRespond.length > 0) {
	      var found = toRespond.indexOf(outerIndex);

	      if (found !== -1) {
	        toRespond.splice(found, 1);
	      }
	    }
	  };

	  WithLatestFromSubscriber.prototype.notifyComplete = function () {};

	  WithLatestFromSubscriber.prototype._next = function (value) {
	    if (this.toRespond.length === 0) {
	      var args = [value].concat(this.values);

	      if (this.project) {
	        this._tryProject(args);
	      } else {
	        this.destination.next(args);
	      }
	    }
	  };

	  WithLatestFromSubscriber.prototype._tryProject = function (args) {
	    var result;

	    try {
	      result = this.project.apply(this, args);
	    } catch (err) {
	      this.destination.error(err);
	      return;
	    }

	    this.destination.next(result);
	  };

	  return WithLatestFromSubscriber;
	}(OuterSubscriber);

	/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var ANNOTATIONS='__annotations__';var PARAMETERS='__parameters__';var PROP_METADATA='__prop__metadata__';/**
	 * @suppress {globalThis}
	 */function makeDecorator(name,props,parentClass,additionalProcessing,typeFn){var metaCtor=makeMetadataCtor(props);function DecoratorFactory(){var _a;var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}if(this instanceof DecoratorFactory){metaCtor.call.apply(metaCtor,__spread([this],args));return this;}var annotationInstance=new((_a=DecoratorFactory).bind.apply(_a,__spread([void 0],args)))();return function TypeDecorator(cls){if(typeFn)typeFn.apply(void 0,__spread([cls],args));// Use of Object.defineProperty is important since it creates non-enumerable property which
	// prevents the property is copied during subclassing.
	var annotations=cls.hasOwnProperty(ANNOTATIONS)?cls[ANNOTATIONS]:Object.defineProperty(cls,ANNOTATIONS,{value:[]})[ANNOTATIONS];annotations.push(annotationInstance);if(additionalProcessing)additionalProcessing(cls);return cls;};}if(parentClass){DecoratorFactory.prototype=Object.create(parentClass.prototype);}DecoratorFactory.prototype.ngMetadataName=name;DecoratorFactory.annotationCls=DecoratorFactory;return DecoratorFactory;}function makeMetadataCtor(props){return function ctor(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}if(props){var values=props.apply(void 0,__spread(args));for(var propName in values){this[propName]=values[propName];}}};}function makeParamDecorator(name,props,parentClass){var metaCtor=makeMetadataCtor(props);function ParamDecoratorFactory(){var _a;var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}if(this instanceof ParamDecoratorFactory){metaCtor.apply(this,args);return this;}var annotationInstance=new((_a=ParamDecoratorFactory).bind.apply(_a,__spread([void 0],args)))();ParamDecorator.annotation=annotationInstance;return ParamDecorator;function ParamDecorator(cls,unusedKey,index){// Use of Object.defineProperty is important since it creates non-enumerable property which
	// prevents the property is copied during subclassing.
	var parameters=cls.hasOwnProperty(PARAMETERS)?cls[PARAMETERS]:Object.defineProperty(cls,PARAMETERS,{value:[]})[PARAMETERS];// there might be gaps if some in between parameters do not have annotations.
	// we pad with nulls.
	while(parameters.length<=index){parameters.push(null);}(parameters[index]=parameters[index]||[]).push(annotationInstance);return cls;}}if(parentClass){ParamDecoratorFactory.prototype=Object.create(parentClass.prototype);}ParamDecoratorFactory.prototype.ngMetadataName=name;ParamDecoratorFactory.annotationCls=ParamDecoratorFactory;return ParamDecoratorFactory;}function makePropDecorator(name,props,parentClass,additionalProcessing){var metaCtor=makeMetadataCtor(props);function PropDecoratorFactory(){var _a;var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}if(this instanceof PropDecoratorFactory){metaCtor.apply(this,args);return this;}var decoratorInstance=new((_a=PropDecoratorFactory).bind.apply(_a,__spread([void 0],args)))();function PropDecorator(target,name){var constructor=target.constructor;// Use of Object.defineProperty is important since it creates non-enumerable property which
	// prevents the property is copied during subclassing.
	var meta=constructor.hasOwnProperty(PROP_METADATA)?constructor[PROP_METADATA]:Object.defineProperty(constructor,PROP_METADATA,{value:{}})[PROP_METADATA];meta[name]=meta.hasOwnProperty(name)&&meta[name]||[];meta[name].unshift(decoratorInstance);if(additionalProcessing)additionalProcessing.apply(void 0,__spread([target,name],args));}return PropDecorator;}if(parentClass){PropDecoratorFactory.prototype=Object.create(parentClass.prototype);}PropDecoratorFactory.prototype.ngMetadataName=name;PropDecoratorFactory.annotationCls=PropDecoratorFactory;return PropDecoratorFactory;}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var Éµ0=function Éµ0(token){return {token:token};};/**
	 * Inject decorator and metadata.
	 *
	 * @Annotation
	 * @publicApi
	 */var Inject=makeParamDecorator('Inject',Éµ0);/**
	 * Optional decorator and metadata.
	 *
	 * @Annotation
	 * @publicApi
	 */var Optional=makeParamDecorator('Optional');/**
	 * Self decorator and metadata.
	 *
	 * @Annotation
	 * @publicApi
	 */var Self=makeParamDecorator('Self');/**
	 * SkipSelf decorator and metadata.
	 *
	 * @Annotation
	 * @publicApi
	 */var SkipSelf=makeParamDecorator('SkipSelf');/**
	 * Host decorator and metadata.
	 *
	 * @Annotation
	 * @publicApi
	 */var Host=makeParamDecorator('Host');var Éµ1=function Éµ1(attributeName){return {attributeName:attributeName};};/**
	 * Attribute decorator and metadata.
	 *
	 * @Annotation
	 * @publicApi
	 */var Attribute=makeParamDecorator('Attribute',Éµ1);/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Injection flags for DI.
	 *
	 * @publicApi
	 */var InjectFlags;(function(InjectFlags){// TODO(alxhub): make this 'const' when ngc no longer writes exports of it into ngfactory files.
	/** Check self and check parent injector if needed */InjectFlags[InjectFlags["Default"]=0]="Default";/**
	     * Specifies that an injector should retrieve a dependency from any injector until reaching the
	     * host element of the current component. (Only used with Element Injector)
	     */InjectFlags[InjectFlags["Host"]=1]="Host";/** Don't ascend to ancestors of the node requesting injection. */InjectFlags[InjectFlags["Self"]=2]="Self";/** Skip the node that is requesting injection. */InjectFlags[InjectFlags["SkipSelf"]=4]="SkipSelf";/** Inject `defaultValue` instead if token not found. */InjectFlags[InjectFlags["Optional"]=8]="Optional";})(InjectFlags||(InjectFlags={}));/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function getClosureSafeProperty(objWithPropertyToExtract){for(var key in objWithPropertyToExtract){if(objWithPropertyToExtract[key]===getClosureSafeProperty){return key;}}throw Error('Could not find renamed property on target object.');}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Construct an `InjectableDef` which defines how a token will be constructed by the DI system, and
	 * in which injectors (if any) it will be available.
	 *
	 * This should be assigned to a static `ngInjectableDef` field on a type, which will then be an
	 * `InjectableType`.
	 *
	 * Options:
	 * * `providedIn` determines which injectors will include the injectable, by either associating it
	 *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be
	 *   provided in the `'root'` injector, which will be the application-level injector in most apps.
	 * * `factory` gives the zero argument function which will create an instance of the injectable.
	 *   The factory can call `inject` to access the `Injector` and request injection of dependencies.
	 *
	 * @codeGenApi
	 */function ÉµÉµdefineInjectable(opts){return {token:opts.token,providedIn:opts.providedIn||null,factory:opts.factory,value:undefined};}/**
	 * Construct an `InjectorDef` which configures an injector.
	 *
	 * This should be assigned to a static `ngInjectorDef` field on a type, which will then be an
	 * `InjectorType`.
	 *
	 * Options:
	 *
	 * * `factory`: an `InjectorType` is an instantiable type, so a zero argument `factory` function to
	 *   create the type must be provided. If that factory function needs to inject arguments, it can
	 *   use the `inject` function.
	 * * `providers`: an optional array of providers to add to the injector. Each provider must
	 *   either have a factory or point to a type which has an `ngInjectableDef` static property (the
	 *   type must be an `InjectableType`).
	 * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s
	 *   whose providers will also be added to the injector. Locally provided types will override
	 *   providers from imports.
	 *
	 * @publicApi
	 */function ÉµÉµdefineInjector(options){return {factory:options.factory,providers:options.providers||[],imports:options.imports||[]};}/**
	 * Read the `ngInjectableDef` for `type` in a way which is immune to accidentally reading inherited
	 * value.
	 *
	 * @param type A type which may have its own (non-inherited) `ngInjectableDef`.
	 */function getInjectableDef(type){var def=type[NG_INJECTABLE_DEF];// The definition read above may come from a base class. `hasOwnProperty` is not sufficient to
	// distinguish this case, as in older browsers (e.g. IE10) static property inheritance is
	// implemented by copying the properties.
	//
	// Instead, the ngInjectableDef's token is compared to the type, and if they don't match then the
	// property was not defined directly on the type itself, and was likely inherited. The definition
	// is only returned if the type matches the def.token.
	return def&&def.token===type?def:null;}/**
	 * Read the `ngInjectableDef` for `type` or read the `ngInjectableDef` from one of its ancestors.
	 *
	 * @param type A type which may have `ngInjectableDef`, via inheritance.
	 *
	 * @deprecated Will be removed in v10, where an error will occur in the scenario if we find the
	 * `ngInjectableDef` on an ancestor only.
	 */function getInheritedInjectableDef(type){if(type&&type[NG_INJECTABLE_DEF]){// TODO(FW-1307): Re-add ngDevMode when closure can handle it
	// ngDevMode &&
	console.warn("DEPRECATED: DI is instantiating a token \""+type.name+"\" that inherits its @Injectable decorator but does not provide one itself.\n"+("This will become an error in v10. Please add @Injectable() to the \""+type.name+"\" class."));return type[NG_INJECTABLE_DEF];}else{return null;}}/**
	 * Read the `ngInjectorDef` type in a way which is immune to accidentally reading inherited value.
	 *
	 * @param type type which may have `ngInjectorDef`
	 */function getInjectorDef(type){return type&&type.hasOwnProperty(NG_INJECTOR_DEF)?type[NG_INJECTOR_DEF]:null;}var NG_INJECTABLE_DEF=getClosureSafeProperty({ngInjectableDef:getClosureSafeProperty});var NG_INJECTOR_DEF=getClosureSafeProperty({ngInjectorDef:getClosureSafeProperty});/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function stringify(token){if(typeof token==='string'){return token;}if(token instanceof Array){return '['+token.map(stringify).join(', ')+']';}if(token==null){return ''+token;}if(token.overriddenName){return ""+token.overriddenName;}if(token.name){return ""+token.name;}var res=token.toString();if(res==null){return ''+res;}var newLineIndex=res.indexOf('\n');return newLineIndex===-1?res:res.substring(0,newLineIndex);}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var __forward_ref__=getClosureSafeProperty({__forward_ref__:getClosureSafeProperty});/**
	 * Allows to refer to references which are not yet defined.
	 *
	 * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
	 * DI is declared, but not yet defined. It is also used when the `token` which we use when creating
	 * a query is not yet defined.
	 *
	 * @usageNotes
	 * ### Example
	 * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
	 * @publicApi
	 */function forwardRef(forwardRefFn){forwardRefFn.__forward_ref__=forwardRef;forwardRefFn.toString=function(){return stringify(this());};return forwardRefFn;}/**
	 * Lazily retrieves the reference value from a forwardRef.
	 *
	 * Acts as the identity function when given a non-forward-ref value.
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
	 *
	 * @see `forwardRef`
	 * @publicApi
	 */function resolveForwardRef(type){var fn=type;if(typeof fn==='function'&&fn.hasOwnProperty(__forward_ref__)&&fn.__forward_ref__===forwardRef){return fn();}else{return type;}}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var __globalThis=typeof globalThis!=='undefined'&&globalThis;var __window=typeof window!=='undefined'&&window;var __self=typeof self!=='undefined'&&typeof WorkerGlobalScope!=='undefined'&&self instanceof WorkerGlobalScope&&self;var __global=typeof global!=='undefined'&&global;// Always use __globalThis if available, which is the spec-defined global variable across all
	// environments, then fallback to __global first, because in Node tests both __global and
	// __window may be defined and _global should be __global in that case.
	var _global$1=__globalThis||__global||__window||__self;/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var R3ResolvedDependencyType;(function(R3ResolvedDependencyType){R3ResolvedDependencyType[R3ResolvedDependencyType["Token"]=0]="Token";R3ResolvedDependencyType[R3ResolvedDependencyType["Attribute"]=1]="Attribute";R3ResolvedDependencyType[R3ResolvedDependencyType["ChangeDetectorRef"]=2]="ChangeDetectorRef";})(R3ResolvedDependencyType||(R3ResolvedDependencyType={}));/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Creates a token that can be used in a DI Provider.
	 *
	 * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a
	 * runtime representation) such as when injecting an interface, callable type, array or
	 * parameterized type.
	 *
	 * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by
	 * the `Injector`. This provides additional level of type safety.
	 *
	 * ```
	 * interface MyInterface {...}
	 * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));
	 * // myInterface is inferred to be MyInterface.
	 * ```
	 *
	 * When creating an `InjectionToken`, you can optionally specify a factory function which returns
	 * (possibly by creating) a default value of the parameterized type `T`. This sets up the
	 * `InjectionToken` using this factory as a provider as if it was defined explicitly in the
	 * application's root injector. If the factory function, which takes zero arguments, needs to inject
	 * dependencies, it can do so using the `inject` function. See below for an example.
	 *
	 * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which
	 * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As
	 * mentioned above, `'root'` is the default value for `providedIn`.
	 *
	 * @usageNotes
	 * ### Basic Example
	 *
	 * ### Plain InjectionToken
	 *
	 * {@example core/di/ts/injector_spec.ts region='InjectionToken'}
	 *
	 * ### Tree-shakable InjectionToken
	 *
	 * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}
	 *
	 *
	 * @publicApi
	 */var InjectionToken=/** @class */function(){function InjectionToken(_desc,options){this._desc=_desc;/** @internal */this.ngMetadataName='InjectionToken';this.ngInjectableDef=undefined;if(typeof options=='number'){// This is a special hack to assign __NG_ELEMENT_ID__ to this instance.
	// __NG_ELEMENT_ID__ is Used by Ivy to determine bloom filter id.
	// We are using it to assign `-1` which is used to identify `Injector`.
	this.__NG_ELEMENT_ID__=options;}else if(options!==undefined){this.ngInjectableDef=ÉµÉµdefineInjectable({token:this,providedIn:options.providedIn||'root',factory:options.factory});}}InjectionToken.prototype.toString=function(){return "InjectionToken "+this._desc;};return InjectionToken;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.
	 *
	 * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a
	 * project.
	 *
	 * @publicApi
	 */var INJECTOR=new InjectionToken('INJECTOR',-1// `-1` is used by Ivy DI system as special value to recognize it as `Injector`.
	);var _THROW_IF_NOT_FOUND=new Object();var THROW_IF_NOT_FOUND=_THROW_IF_NOT_FOUND;var NG_TEMP_TOKEN_PATH='ngTempTokenPath';var NG_TOKEN_PATH='ngTokenPath';var NEW_LINE=/\n/gm;var NO_NEW_LINE='Éµ';var SOURCE='__source';var Éµ0$1=getClosureSafeProperty;var USE_VALUE=getClosureSafeProperty({provide:String,useValue:Éµ0$1});/**
	 * Current injector value used by `inject`.
	 * - `undefined`: it is an error to call `inject`
	 * - `null`: `inject` can be called but there is no injector (limp-mode).
	 * - Injector instance: Use the injector for resolution.
	 */var _currentInjector=undefined;function setCurrentInjector(injector){var former=_currentInjector;_currentInjector=injector;return former;}/**
	 * Current implementation of inject.
	 *
	 * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed
	 * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this
	 * way for two reasons:
	 *  1. `Injector` should not depend on ivy logic.
	 *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.
	 */var _injectImplementation;/**
	 * Sets the current inject implementation.
	 */function setInjectImplementation(impl){var previous=_injectImplementation;_injectImplementation=impl;return previous;}function injectInjectorOnly(token,flags){if(flags===void 0){flags=InjectFlags.Default;}if(_currentInjector===undefined){throw new Error("inject() must be called from an injection context");}else if(_currentInjector===null){return injectRootLimpMode(token,undefined,flags);}else{return _currentInjector.get(token,flags&InjectFlags.Optional?null:undefined,flags);}}function ÉµÉµinject(token,flags){if(flags===void 0){flags=InjectFlags.Default;}return (_injectImplementation||injectInjectorOnly)(token,flags);}/**
	 * Injects `root` tokens in limp mode.
	 *
	 * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to
	 * `"root"`. This is known as the limp mode injection. In such case the value is stored in the
	 * `InjectableDef`.
	 */function injectRootLimpMode(token,notFoundValue,flags){var injectableDef=getInjectableDef(token);if(injectableDef&&injectableDef.providedIn=='root'){return injectableDef.value===undefined?injectableDef.value=injectableDef.factory():injectableDef.value;}if(flags&InjectFlags.Optional)return null;if(notFoundValue!==undefined)return notFoundValue;throw new Error("Injector: NOT_FOUND ["+stringify(token)+"]");}function injectArgs(types){var args=[];for(var i=0;i<types.length;i++){var arg=resolveForwardRef(types[i]);if(Array.isArray(arg)){if(arg.length===0){throw new Error('Arguments array must have arguments.');}var type=undefined;var flags=InjectFlags.Default;for(var j=0;j<arg.length;j++){var meta=arg[j];if(meta instanceof Optional||meta.ngMetadataName==='Optional'||meta===Optional){flags|=InjectFlags.Optional;}else if(meta instanceof SkipSelf||meta.ngMetadataName==='SkipSelf'||meta===SkipSelf){flags|=InjectFlags.SkipSelf;}else if(meta instanceof Self||meta.ngMetadataName==='Self'||meta===Self){flags|=InjectFlags.Self;}else if(meta instanceof Inject||meta===Inject){type=meta.token;}else{type=meta;}}args.push(ÉµÉµinject(type,flags));}else{args.push(ÉµÉµinject(arg));}}return args;}var NullInjector=/** @class */function(){function NullInjector(){}NullInjector.prototype.get=function(token,notFoundValue){if(notFoundValue===void 0){notFoundValue=THROW_IF_NOT_FOUND;}if(notFoundValue===THROW_IF_NOT_FOUND){// Intentionally left behind: With dev tools open the debugger will stop here. There is no
	// reason why correctly written application should cause this exception.
	// TODO(misko): uncomment the next line once `ngDevMode` works with closure.
	// if(ngDevMode) debugger;
	var error=new Error("NullInjectorError: No provider for "+stringify(token)+"!");error.name='NullInjectorError';throw error;}return notFoundValue;};return NullInjector;}();function catchInjectorError(e,token,injectorErrorName,source){var tokenPath=e[NG_TEMP_TOKEN_PATH];if(token[SOURCE]){tokenPath.unshift(token[SOURCE]);}e.message=formatError('\n'+e.message,tokenPath,injectorErrorName,source);e[NG_TOKEN_PATH]=tokenPath;e[NG_TEMP_TOKEN_PATH]=null;throw e;}function formatError(text,obj,injectorErrorName,source){if(source===void 0){source=null;}text=text&&text.charAt(0)==='\n'&&text.charAt(1)==NO_NEW_LINE?text.substr(2):text;var context=stringify(obj);if(obj instanceof Array){context=obj.map(stringify).join(' -> ');}else if(_typeof(obj)==='object'){var parts=[];for(var key in obj){if(obj.hasOwnProperty(key)){var value=obj[key];parts.push(key+':'+(typeof value==='string'?JSON.stringify(value):stringify(value)));}}context="{"+parts.join(', ')+"}";}return ""+injectorErrorName+(source?'('+source+')':'')+"["+context+"]: "+text.replace(NEW_LINE,'\n  ');}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Represents an instance of an NgModule created via a {@link NgModuleFactory}.
	 *
	 * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
	 * NgModule Instance.
	 *
	 * @publicApi
	 */var NgModuleRef=/** @class */function(){function NgModuleRef(){}return NgModuleRef;}();/**
	 * @publicApi
	 */var NgModuleFactory=/** @class */function(){function NgModuleFactory(){}return NgModuleFactory;}();/**
	 * Flattens an array.
	 */function flatten(list,dst){if(dst===undefined)dst=list;for(var i=0;i<list.length;i++){var item=list[i];if(Array.isArray(item)){// we need to inline it.
	if(dst===list){// Our assumption that the list was already flat was wrong and
	// we need to clone flat since we need to write to it.
	dst=list.slice(0,i);}flatten(item,dst);}else if(dst!==list){dst.push(item);}}return dst;}function deepForEach(input,fn){input.forEach(function(value){return Array.isArray(value)?deepForEach(value,fn):fn(value);});}function addToArray(arr,index,value){// perf: array.push is faster than array.splice!
	if(index>=arr.length){arr.push(value);}else{arr.splice(index,0,value);}}function removeFromArray(arr,index){// perf: array.pop is faster than array.splice!
	if(index>=arr.length-1){return arr.pop();}else{return arr.splice(index,1)[0];}}function assertEqual(actual,expected,msg){if(actual!=expected){throwError$1(msg);}}function assertNotEqual(actual,expected,msg){if(actual==expected){throwError$1(msg);}}function assertLessThan(actual,expected,msg){if(actual>=expected){throwError$1(msg);}}function assertGreaterThan(actual,expected,msg){if(actual<=expected){throwError$1(msg);}}function assertDefined(actual,msg){if(actual==null){throwError$1(msg);}}function throwError$1(msg){// tslint:disable-next-line
	debugger;// Left intentionally for better debugger experience.
	throw new Error("ASSERTION ERROR: "+msg);}function assertDomNode(node){// If we're in a worker, `Node` will not be defined.
	assertEqual(typeof Node!=='undefined'&&node instanceof Node||_typeof(node)==='object'&&node!=null&&node.constructor.name==='WebWorkerRenderNode',true,"The provided value must be an instance of a DOM Node but got "+stringify(node));}function assertDataInRange(arr,index){var maxLen=arr?arr.length:0;assertLessThan(index,maxLen,"Index expected to be less than "+maxLen+" but got "+index);}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function ngDevModeResetPerfCounters(){var locationString=typeof location!=='undefined'?location.toString():'';var newCounters={namedConstructors:locationString.indexOf('ngDevMode=namedConstructors')!=-1,firstTemplatePass:0,tNode:0,tView:0,rendererCreateTextNode:0,rendererSetText:0,rendererCreateElement:0,rendererAddEventListener:0,rendererSetAttribute:0,rendererRemoveAttribute:0,rendererSetProperty:0,rendererSetClassName:0,rendererAddClass:0,rendererRemoveClass:0,rendererSetStyle:0,rendererRemoveStyle:0,rendererDestroy:0,rendererDestroyNode:0,rendererMoveNode:0,rendererRemoveNode:0,rendererAppendChild:0,rendererInsertBefore:0,rendererCreateComment:0,styleMap:0,styleMapCacheMiss:0,classMap:0,classMapCacheMiss:0,styleProp:0,stylePropCacheMiss:0,classProp:0,classPropCacheMiss:0,flushStyling:0,classesApplied:0,stylesApplied:0,stylingWritePersistedState:0,stylingReadPersistedState:0};// Make sure to refer to ngDevMode as ['ngDevMode'] for closure.
	var allowNgDevModeTrue=locationString.indexOf('ngDevMode=false')===-1;_global$1['ngDevMode']=allowNgDevModeTrue&&newCounters;return newCounters;}/**
	 * This checks to see if the `ngDevMode` has been set. If yes,
	 * then we honor it, otherwise we default to dev mode with additional checks.
	 *
	 * The idea is that unless we are doing production build where we explicitly
	 * set `ngDevMode == false` we should be helping the developer by providing
	 * as much early warning and errors as possible.
	 *
	 * NOTE: changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.
	 */if(typeof ngDevMode==='undefined'||ngDevMode){ngDevModeResetPerfCounters();}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * The strategy that the default change detector uses to detect changes.
	 * When set, takes effect the next time change detection is triggered.
	 *
	 * @publicApi
	 */var ChangeDetectionStrategy;(function(ChangeDetectionStrategy){/**
	     * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated
	     * until reactivated by setting the strategy to `Default` (`CheckAlways`).
	     * Change detection can still be explicitly invoked.
	     * This strategy applies to all child directives and cannot be overridden.
	     */ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"]=0]="OnPush";/**
	     * Use the default `CheckAlways` strategy, in which change detection is automatic until
	     * explicitly deactivated.
	     */ChangeDetectionStrategy[ChangeDetectionStrategy["Default"]=1]="Default";})(ChangeDetectionStrategy||(ChangeDetectionStrategy={}));/**
	 * Defines the possible states of the default change detector.
	 * @see `ChangeDetectorRef`
	 */var ChangeDetectorStatus;(function(ChangeDetectorStatus){/**
	     * A state in which, after calling `detectChanges()`, the change detector
	     * state becomes `Checked`, and must be explicitly invoked or reactivated.
	     */ChangeDetectorStatus[ChangeDetectorStatus["CheckOnce"]=0]="CheckOnce";/**
	     * A state in which change detection is skipped until the change detector mode
	     * becomes `CheckOnce`.
	     */ChangeDetectorStatus[ChangeDetectorStatus["Checked"]=1]="Checked";/**
	     * A state in which change detection continues automatically until explicitly
	     * deactivated.
	     */ChangeDetectorStatus[ChangeDetectorStatus["CheckAlways"]=2]="CheckAlways";/**
	     * A state in which a change detector sub tree is not a part of the main tree and
	     * should be skipped.
	     */ChangeDetectorStatus[ChangeDetectorStatus["Detached"]=3]="Detached";/**
	     * Indicates that the change detector encountered an error checking a binding
	     * or calling a directive lifecycle method and is now in an inconsistent state. Change
	     * detectors in this state do not detect changes.
	     */ChangeDetectorStatus[ChangeDetectorStatus["Errored"]=4]="Errored";/**
	     * Indicates that the change detector has been destroyed.
	     */ChangeDetectorStatus[ChangeDetectorStatus["Destroyed"]=5]="Destroyed";})(ChangeDetectorStatus||(ChangeDetectorStatus={}));/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Defines template and style encapsulation options available for Component's {@link Component}.
	 *
	 * See {@link Component#encapsulation encapsulation}.
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * {@example core/ts/metadata/encapsulation.ts region='longform'}
	 *
	 * @publicApi
	 */var ViewEncapsulation;(function(ViewEncapsulation){/**
	     * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
	     * Element and pre-processing the style rules provided via {@link Component#styles styles} or
	     * {@link Component#styleUrls styleUrls}, and adding the new Host Element attribute to all
	     * selectors.
	     *
	     * This is the default option.
	     */ViewEncapsulation[ViewEncapsulation["Emulated"]=0]="Emulated";/**
	     * @deprecated v6.1.0 - use {ViewEncapsulation.ShadowDom} instead.
	     * Use the native encapsulation mechanism of the renderer.
	     *
	     * For the DOM this means using the deprecated [Shadow DOM
	     * v0](https://w3c.github.io/webcomponents/spec/shadow/) and
	     * creating a ShadowRoot for Component's Host Element.
	     */ViewEncapsulation[ViewEncapsulation["Native"]=1]="Native";/**
	     * Don't provide any template or style encapsulation.
	     */ViewEncapsulation[ViewEncapsulation["None"]=2]="None";/**
	     * Use Shadow DOM to encapsulate styles.
	     *
	     * For the DOM this means using modern [Shadow
	     * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
	     * creating a ShadowRoot for Component's Host Element.
	     */ViewEncapsulation[ViewEncapsulation["ShadowDom"]=3]="ShadowDom";})(ViewEncapsulation||(ViewEncapsulation={}));/**
	* @license
	* Copyright Google Inc. All Rights Reserved.
	*
	* Use of this source code is governed by an MIT-style license that can be
	* found in the LICENSE file at https://angular.io/license
	*/ /**
	 * This file contains reuseable "empty" symbols that can be used as default return values
	 * in different parts of the rendering code. Because the same symbols are returned, this
	 * allows for identity checks against these values to be consistently used by the framework
	 * code.
	 */var EMPTY_OBJ={};var EMPTY_ARRAY=[];// freezing the values prevents any code from accidentally inserting new values in
	if(typeof ngDevMode!=='undefined'&&ngDevMode){// These property accesses can be ignored because ngDevMode will be set to false
	// when optimizing code and the whole if statement will be dropped.
	// tslint:disable-next-line:no-toplevel-property-access
	Object.freeze(EMPTY_OBJ);// tslint:disable-next-line:no-toplevel-property-access
	Object.freeze(EMPTY_ARRAY);}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var NG_COMPONENT_DEF=getClosureSafeProperty({ngComponentDef:getClosureSafeProperty});var NG_DIRECTIVE_DEF=getClosureSafeProperty({ngDirectiveDef:getClosureSafeProperty});var NG_PIPE_DEF=getClosureSafeProperty({ngPipeDef:getClosureSafeProperty});var NG_MODULE_DEF=getClosureSafeProperty({ngModuleDef:getClosureSafeProperty});var NG_LOCALE_ID_DEF=getClosureSafeProperty({ngLocaleIdDef:getClosureSafeProperty});var NG_BASE_DEF=getClosureSafeProperty({ngBaseDef:getClosureSafeProperty});/**
	 * If a directive is diPublic, bloomAdd sets a property on the type with this constant as
	 * the key and the directive's unique ID as the value. This allows us to map directives to their
	 * bloom filter bit for DI.
	 */ // TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.
	var NG_ELEMENT_ID=getClosureSafeProperty({__NG_ELEMENT_ID__:getClosureSafeProperty});/**
	 * The following getter methods retrieve the definition form the type. Currently the retrieval
	 * honors inheritance, but in the future we may change the rule to require that definitions are
	 * explicit. This would require some sort of migration strategy.
	 */function getComponentDef(type){return type[NG_COMPONENT_DEF]||null;}function getNgModuleDef(type,throwNotFound){var ngModuleDef=type[NG_MODULE_DEF]||null;if(!ngModuleDef&&throwNotFound===true){throw new Error("Type "+stringify(type)+" does not have 'ngModuleDef' property.");}return ngModuleDef;}function getNgLocaleIdDef(type){return type[NG_LOCALE_ID_DEF]||null;}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ // Below are constants for LView indices to help us look up LView members
	// without having to remember the specific indices.
	// Uglify will inline these when minifying so there shouldn't be a cost.
	var HOST=0;var TVIEW=1;var FLAGS=2;var PARENT=3;var NEXT=4;var QUERIES=5;var T_HOST=6;var BINDING_INDEX=7;var CLEANUP=8;var CONTEXT=9;var INJECTOR$1=10;var RENDERER_FACTORY=11;var RENDERER=12;var SANITIZER=13;var CHILD_HEAD=14;var CHILD_TAIL=15;var DECLARATION_VIEW=16;var DECLARATION_LCONTAINER=17;var PREORDER_HOOK_FLAGS=18;/** Size of LView's header. Necessary to adjust for it when setting slots.  */var HEADER_OFFSET=19;// Note: This hack is necessary so we don't erroneously get a circular dependency
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Special location which allows easy identification of type. If we have an array which was
	 * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is
	 * `LContainer`.
	 */var TYPE=1;/**
	 * Below are constants for LContainer indices to help us look up LContainer members
	 * without having to remember the specific indices.
	 * Uglify will inline these when minifying so there shouldn't be a cost.
	 */var ACTIVE_INDEX=2;// PARENT and NEXT are indices 3 and 4
	// As we already have these constants in LView, we don't need to re-create them.
	var MOVED_VIEWS=5;// T_HOST is index 6
	// We already have this constants in LView, we don't need to re-create it.
	var NATIVE=7;/**
	 * Size of LContainer's header. Represents the index after which all views in the
	 * container will be inserted. We need to keep a record of current views so we know
	 * which views are already in the DOM (and don't need to be re-added) and so we can
	 * remove views from the DOM when they are no longer required.
	 */var CONTAINER_HEADER_OFFSET=9;// Note: This hack is necessary so we don't erroneously get a circular dependency
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	* True if `value` is `LView`.
	* @param value wrapped value of `RNode`, `LView`, `LContainer`
	*/function isLView(value){return Array.isArray(value)&&_typeof(value[TYPE])==='object';}/**
	 * True if `value` is `LContainer`.
	 * @param value wrapped value of `RNode`, `LView`, `LContainer`
	 */function isLContainer(value){return Array.isArray(value)&&value[TYPE]===true;}function isComponent(tNode){return (tNode.flags&1/* isComponent */)===1/* isComponent */;}function isComponentDef(def){return def.template!==null;}function isRootView(target){return (target[FLAGS]&512/* IsRoot */)!==0;}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function assertTNodeForLView(tNode,lView){tNode.hasOwnProperty('tView_')&&assertEqual(tNode.tView_,lView[TVIEW],'This TNode does not belong to this LView.');}function assertComponentType(actual,msg){if(msg===void 0){msg='Type passed in is not ComponentType, it does not have \'ngComponentDef\' property.';}if(!getComponentDef(actual)){throwError$1(msg);}}function assertPreviousIsParent(isParent){assertEqual(isParent,true,'previousOrParentTNode should be a parent');}function assertLContainer(value){assertDefined(value,'LContainer must be defined');assertEqual(isLContainer(value),true,'Expecting LContainer');}function assertLViewOrUndefined(value){value&&assertEqual(isLView(value),true,'Expecting LView or undefined or null');}function assertLView(value){assertDefined(value,'LView must be defined');assertEqual(isLView(value),true,'Expecting LView');}function assertFirstTemplatePass(tView,errMessage){assertEqual(tView.firstTemplatePass,true,errMessage);}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var TNODE=8;var PARENT_INJECTOR=8;var INJECTOR_BLOOM_PARENT_SIZE=9;var NO_PARENT_INJECTOR=-1;/**
	 * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in
	 * `TView.data`. This allows us to store information about the current node's tokens (which
	 * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be
	 * shared, so they live in `LView`).
	 *
	 * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter
	 * determines whether a directive is available on the associated node or not. This prevents us
	 * from searching the directives array at this level unless it's probable the directive is in it.
	 *
	 * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.
	 *
	 * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed
	 * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`
	 * will differ based on where it is flattened into the main array, so it's not possible to know
	 * the indices ahead of time and save their types here. The interfaces are still included here
	 * for documentation purposes.
	 *
	 * export interface LInjector extends Array<any> {
	 *
	 *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)
	 *    [0]: number;
	 *
	 *    // Cumulative bloom for directive IDs 32-63
	 *    [1]: number;
	 *
	 *    // Cumulative bloom for directive IDs 64-95
	 *    [2]: number;
	 *
	 *    // Cumulative bloom for directive IDs 96-127
	 *    [3]: number;
	 *
	 *    // Cumulative bloom for directive IDs 128-159
	 *    [4]: number;
	 *
	 *    // Cumulative bloom for directive IDs 160 - 191
	 *    [5]: number;
	 *
	 *    // Cumulative bloom for directive IDs 192 - 223
	 *    [6]: number;
	 *
	 *    // Cumulative bloom for directive IDs 224 - 255
	 *    [7]: number;
	 *
	 *    // We need to store a reference to the injector's parent so DI can keep looking up
	 *    // the injector tree until it finds the dependency it's looking for.
	 *    [PARENT_INJECTOR]: number;
	 * }
	 *
	 * export interface TInjector extends Array<any> {
	 *
	 *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)
	 *    [0]: number;
	 *
	 *    // Shared node bloom for directive IDs 32-63
	 *    [1]: number;
	 *
	 *    // Shared node bloom for directive IDs 64-95
	 *    [2]: number;
	 *
	 *    // Shared node bloom for directive IDs 96-127
	 *    [3]: number;
	 *
	 *    // Shared node bloom for directive IDs 128-159
	 *    [4]: number;
	 *
	 *    // Shared node bloom for directive IDs 160 - 191
	 *    [5]: number;
	 *
	 *    // Shared node bloom for directive IDs 192 - 223
	 *    [6]: number;
	 *
	 *    // Shared node bloom for directive IDs 224 - 255
	 *    [7]: number;
	 *
	 *    // Necessary to find directive indices for a particular node.
	 *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;
	 *  }
	 */ /**
	* Factory for creating instances of injectors in the NodeInjector.
	*
	* This factory is complicated by the fact that it can resolve `multi` factories as well.
	*
	* NOTE: Some of the fields are optional which means that this class has two hidden classes.
	* - One without `multi` support (most common)
	* - One with `multi` values, (rare).
	*
	* Since VMs can cache up to 4 inline hidden classes this is OK.
	*
	* - Single factory: Only `resolving` and `factory` is defined.
	* - `providers` factory: `componentProviders` is a number and `index = -1`.
	* - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.
	*/var NodeInjectorFactory=/** @class */function(){function NodeInjectorFactory(/**
	     * Factory to invoke in order to create a new instance.
	     */factory,/**
	     * Set to `true` if the token is declared in `viewProviders` (or if it is component).
	     */isViewProvider,injectImplementation){this.factory=factory;/**
	         * Marker set to true during factory invocation to see if we get into recursive loop.
	         * Recursive loop causes an error to be displayed.
	         */this.resolving=false;this.canSeeViewProviders=isViewProvider;this.injectImpl=injectImplementation;}return NodeInjectorFactory;}();function isFactory(obj){// See: https://jsperf.com/instanceof-vs-getprototypeof
	return obj!==null&&_typeof(obj)=='object'&&Object.getPrototypeOf(obj)==NodeInjectorFactory.prototype;}// Note: This hack is necessary so we don't erroneously get a circular dependency
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function assertNodeType(tNode,type){assertDefined(tNode,'should be called with a TNode');assertEqual(tNode.type,type,"should be a "+typeName(type));}function assertNodeOfPossibleTypes(tNode){var types=[];for(var _i=1;_i<arguments.length;_i++){types[_i-1]=arguments[_i];}assertDefined(tNode,'should be called with a TNode');var found=types.some(function(type){return tNode.type===type;});assertEqual(found,true,"Should be one of "+types.map(typeName).join(', ')+" but got "+typeName(tNode.type));}function typeName(type){if(type==1/* Projection */)return 'Projection';if(type==0/* Container */)return 'Container';if(type==2/* View */)return 'View';if(type==3/* Element */)return 'Element';if(type==4/* ElementContainer */)return 'ElementContainer';return '<unknown>';}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Adds all directive lifecycle hooks from the given `DirectiveDef` to the given `TView`.
	 *
	 * Must be run *only* on the first template pass.
	 *
	 * Sets up the pre-order hooks on the provided `tView`,
	 * see {@link HookData} for details about the data structure.
	 *
	 * @param directiveIndex The index of the directive in LView
	 * @param directiveDef The definition containing the hooks to setup in tView
	 * @param tView The current TView
	 * @param nodeIndex The index of the node to which the directive is attached
	 * @param initialPreOrderHooksLength the number of pre-order hooks already registered before the
	 * current process, used to know if the node index has to be added to the array. If it is -1,
	 * the node index is never added.
	 * @param initialPreOrderCheckHooksLength same as previous for pre-order check hooks
	 */function registerPreOrderHooks(directiveIndex,directiveDef,tView,nodeIndex,initialPreOrderHooksLength,initialPreOrderCheckHooksLength){ngDevMode&&assertEqual(tView.firstTemplatePass,true,'Should only be called on first template pass');var onChanges=directiveDef.onChanges,onInit=directiveDef.onInit,doCheck=directiveDef.doCheck;if(initialPreOrderHooksLength>=0&&(!tView.preOrderHooks||initialPreOrderHooksLength===tView.preOrderHooks.length)&&(onChanges||onInit||doCheck)){(tView.preOrderHooks||(tView.preOrderHooks=[])).push(nodeIndex);}if(initialPreOrderCheckHooksLength>=0&&(!tView.preOrderCheckHooks||initialPreOrderCheckHooksLength===tView.preOrderCheckHooks.length)&&(onChanges||doCheck)){(tView.preOrderCheckHooks||(tView.preOrderCheckHooks=[])).push(nodeIndex);}if(onChanges){(tView.preOrderHooks||(tView.preOrderHooks=[])).push(directiveIndex,onChanges);(tView.preOrderCheckHooks||(tView.preOrderCheckHooks=[])).push(directiveIndex,onChanges);}if(onInit){(tView.preOrderHooks||(tView.preOrderHooks=[])).push(-directiveIndex,onInit);}if(doCheck){(tView.preOrderHooks||(tView.preOrderHooks=[])).push(directiveIndex,doCheck);(tView.preOrderCheckHooks||(tView.preOrderCheckHooks=[])).push(directiveIndex,doCheck);}}/**
	 *
	 * Loops through the directives on the provided `tNode` and queues hooks to be
	 * run that are not initialization hooks.
	 *
	 * Should be executed during `elementEnd()` and similar to
	 * preserve hook execution order. Content, view, and destroy hooks for projected
	 * components and directives must be called *before* their hosts.
	 *
	 * Sets up the content, view, and destroy hooks on the provided `tView`,
	 * see {@link HookData} for details about the data structure.
	 *
	 * NOTE: This does not set up `onChanges`, `onInit` or `doCheck`, those are set up
	 * separately at `elementStart`.
	 *
	 * @param tView The current TView
	 * @param tNode The TNode whose directives are to be searched for hooks to queue
	 */function registerPostOrderHooks(tView,tNode){if(tView.firstTemplatePass){// It's necessary to loop through the directives at elementEnd() (rather than processing in
	// directiveCreate) so we can preserve the current hook order. Content, view, and destroy
	// hooks for projected components and directives must be called *before* their hosts.
	for(var i=tNode.directiveStart,end=tNode.directiveEnd;i<end;i++){var directiveDef=tView.data[i];if(directiveDef.afterContentInit){(tView.contentHooks||(tView.contentHooks=[])).push(-i,directiveDef.afterContentInit);}if(directiveDef.afterContentChecked){(tView.contentHooks||(tView.contentHooks=[])).push(i,directiveDef.afterContentChecked);(tView.contentCheckHooks||(tView.contentCheckHooks=[])).push(i,directiveDef.afterContentChecked);}if(directiveDef.afterViewInit){(tView.viewHooks||(tView.viewHooks=[])).push(-i,directiveDef.afterViewInit);}if(directiveDef.afterViewChecked){(tView.viewHooks||(tView.viewHooks=[])).push(i,directiveDef.afterViewChecked);(tView.viewCheckHooks||(tView.viewCheckHooks=[])).push(i,directiveDef.afterViewChecked);}if(directiveDef.onDestroy!=null){(tView.destroyHooks||(tView.destroyHooks=[])).push(i,directiveDef.onDestroy);}}}}/**
	 * Executing hooks requires complex logic as we need to deal with 2 constraints.
	 *
	 * 1. Init hooks (ngOnInit, ngAfterContentInit, ngAfterViewInit) must all be executed once and only
	 * once, across many change detection cycles. This must be true even if some hooks throw, or if
	 * some recursively trigger a change detection cycle.
	 * To solve that, it is required to track the state of the execution of these init hooks.
	 * This is done by storing and maintaining flags in the view: the {@link InitPhaseState},
	 * and the index within that phase. They can be seen as a cursor in the following structure:
	 * [[onInit1, onInit2], [afterContentInit1], [afterViewInit1, afterViewInit2, afterViewInit3]]
	 * They are are stored as flags in LView[FLAGS].
	 *
	 * 2. Pre-order hooks can be executed in batches, because of the select instruction.
	 * To be able to pause and resume their execution, we also need some state about the hook's array
	 * that is being processed:
	 * - the index of the next hook to be executed
	 * - the number of init hooks already found in the processed part of the  array
	 * They are are stored as flags in LView[PREORDER_HOOK_FLAGS].
	 */ /**
	 * Executes necessary hooks at the start of executing a template.
	 *
	 * Executes hooks that are to be run during the initialization of a directive such
	 * as `onChanges`, `onInit`, and `doCheck`.
	 *
	 * @param lView The current view
	 * @param tView Static data for the view containing the hooks to be executed
	 * @param checkNoChangesMode Whether or not we're in checkNoChanges mode.
	 * @param @param currentNodeIndex 2 cases depending the the value:
	 * - undefined: execute hooks only from the saved index until the end of the array (pre-order case,
	 * when flushing the remaining hooks)
	 * - number: execute hooks only from the saved index until that node index exclusive (pre-order
	 * case, when executing select(number))
	 */function executePreOrderHooks(currentView,tView,checkNoChangesMode,currentNodeIndex){if(!checkNoChangesMode){executeHooks(currentView,tView.preOrderHooks,tView.preOrderCheckHooks,checkNoChangesMode,0/* OnInitHooksToBeRun */,currentNodeIndex!==undefined?currentNodeIndex:null);}}/**
	 * Executes hooks against the given `LView` based off of whether or not
	 * This is the first pass.
	 *
	 * @param currentView The view instance data to run the hooks against
	 * @param firstPassHooks An array of hooks to run if we're in the first view pass
	 * @param checkHooks An Array of hooks to run if we're not in the first view pass.
	 * @param checkNoChangesMode Whether or not we're in no changes mode.
	 * @param initPhaseState the current state of the init phase
	 * @param currentNodeIndex 3 cases depending the the value:
	 * - undefined: all hooks from the array should be executed (post-order case)
	 * - null: execute hooks only from the saved index until the end of the array (pre-order case, when
	 * flushing the remaining hooks)
	 * - number: execute hooks only from the saved index until that node index exclusive (pre-order
	 * case, when executing select(number))
	 */function executeHooks(currentView,firstPassHooks,checkHooks,checkNoChangesMode,initPhaseState,currentNodeIndex){if(checkNoChangesMode)return;var hooksToCall=(currentView[FLAGS]&3/* InitPhaseStateMask */)===initPhaseState?firstPassHooks:checkHooks;if(hooksToCall){callHooks(currentView,hooksToCall,initPhaseState,currentNodeIndex);}// The init phase state must be always checked here as it may have been recursively updated
	if(currentNodeIndex==null&&(currentView[FLAGS]&3/* InitPhaseStateMask */)===initPhaseState&&initPhaseState!==3/* InitPhaseCompleted */){currentView[FLAGS]&=1023/* IndexWithinInitPhaseReset */;currentView[FLAGS]+=1/* InitPhaseStateIncrementer */;}}/**
	 * Calls lifecycle hooks with their contexts, skipping init hooks if it's not
	 * the first LView pass
	 *
	 * @param currentView The current view
	 * @param arr The array in which the hooks are found
	 * @param initPhaseState the current state of the init phase
	 * @param currentNodeIndex 3 cases depending the the value:
	 * - undefined: all hooks from the array should be executed (post-order case)
	 * - null: execute hooks only from the saved index until the end of the array (pre-order case, when
	 * flushing the remaining hooks)
	 * - number: execute hooks only from the saved index until that node index exclusive (pre-order
	 * case, when executing select(number))
	 */function callHooks(currentView,arr,initPhase,currentNodeIndex){var startIndex=currentNodeIndex!==undefined?currentView[PREORDER_HOOK_FLAGS]&65535/* IndexOfTheNextPreOrderHookMaskMask */:0;var nodeIndexLimit=currentNodeIndex!=null?currentNodeIndex:-1;var lastNodeIndexFound=0;for(var i=startIndex;i<arr.length;i++){var hook=arr[i+1];if(typeof hook==='number'){lastNodeIndexFound=arr[i];if(currentNodeIndex!=null&&lastNodeIndexFound>=currentNodeIndex){break;}}else{var isInitHook=arr[i]<0;if(isInitHook)currentView[PREORDER_HOOK_FLAGS]+=65536/* NumberOfInitHooksCalledIncrementer */;if(lastNodeIndexFound<nodeIndexLimit||nodeIndexLimit==-1){callHook(currentView,initPhase,arr,i);currentView[PREORDER_HOOK_FLAGS]=(currentView[PREORDER_HOOK_FLAGS]&4294901760/* NumberOfInitHooksCalledMask */)+i+2;}i++;}}}/**
	 * Execute one hook against the current `LView`.
	 *
	 * @param currentView The current view
	 * @param initPhaseState the current state of the init phase
	 * @param arr The array in which the hooks are found
	 * @param i The current index within the hook data array
	 */function callHook(currentView,initPhase,arr,i){var isInitHook=arr[i]<0;var hook=arr[i+1];var directiveIndex=isInitHook?-arr[i]:arr[i];var directive=currentView[directiveIndex];if(isInitHook){var indexWithintInitPhase=currentView[FLAGS]>>10/* IndexWithinInitPhaseShift */;// The init phase state must be always checked here as it may have been recursively
	// updated
	if(indexWithintInitPhase<currentView[PREORDER_HOOK_FLAGS]>>16/* NumberOfInitHooksCalledShift */&&(currentView[FLAGS]&3/* InitPhaseStateMask */)===initPhase){currentView[FLAGS]+=1024/* IndexWithinInitPhaseIncrementer */;hook.call(directive);}}else{hook.call(directive);}}var _stateStorage=new Map();// this value is not used outside this file and is only here
	function resetAllStylingState(){_stateStorage.clear();}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * This property will be monkey-patched on elements, components and directives
	 */var MONKEY_PATCH_KEY_NAME='__ngContext__';/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)
	 * in same location in `LView`. This is because we don't want to pre-allocate space for it
	 * because the storage is sparse. This file contains utilities for dealing with such data types.
	 *
	 * How do we know what is stored at a given location in `LView`.
	 * - `Array.isArray(value) === false` => `RNode` (The normal storage value)
	 * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.
	 *   - `typeof value[TYPE] === 'object'` => `LView`
	 *      - This happens when we have a component at a given location
	 *   - `typeof value[TYPE] === true` => `LContainer`
	 *      - This happens when we have `LContainer` binding at a given location.
	 *
	 *
	 * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.
	 */ /**
	 * Returns `RNode`.
	 * @param value wrapped value of `RNode`, `LView`, `LContainer`
	 */function unwrapRNode(value){while(Array.isArray(value)){value=value[HOST];}return value;}/**
	 * Retrieve an `RNode` for a given `TNode` and `LView`.
	 *
	 * This function guarantees in dev mode to retrieve a non-null `RNode`.
	 *
	 * @param tNode
	 * @param lView
	 */function getNativeByTNode(tNode,lView){ngDevMode&&assertTNodeForLView(tNode,lView);ngDevMode&&assertDataInRange(lView,tNode.index);var node=unwrapRNode(lView[tNode.index]);ngDevMode&&assertDomNode(node);return node;}/**
	 * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.
	 *
	 * Some `TNode`s don't have associated `RNode`s. For example `Projection`
	 *
	 * @param tNode
	 * @param lView
	 */function getNativeByTNodeOrNull(tNode,lView){ngDevMode&&assertTNodeForLView(tNode,lView);var index=tNode.index;var node=index==-1?null:unwrapRNode(lView[index]);ngDevMode&&node!==null&&assertDomNode(node);return node;}function getTNode(index,view){ngDevMode&&assertGreaterThan(index,-1,'wrong index for TNode');ngDevMode&&assertLessThan(index,view[TVIEW].data.length,'wrong index for TNode');return view[TVIEW].data[index+HEADER_OFFSET];}function getComponentViewByIndex(nodeIndex,hostView){// Could be an LView or an LContainer. If LContainer, unwrap to find LView.
	var slotValue=hostView[nodeIndex];var lView=isLView(slotValue)?slotValue:slotValue[HOST];return lView;}/**
	 * Returns the monkey-patch value data present on the target (which could be
	 * a component, directive or a DOM node).
	 */function readPatchedData(target){ngDevMode&&assertDefined(target,'Target expected');return target[MONKEY_PATCH_KEY_NAME];}function readPatchedLView(target){var value=readPatchedData(target);if(value){return Array.isArray(value)?value:value.lView;}return null;}/**
	 * Returns a boolean for whether the view is attached to the change detection tree.
	 *
	 * Note: This determines whether a view should be checked, not whether it's inserted
	 * into a container. For that, you'll want `viewAttachedToContainer` below.
	 */function viewAttachedToChangeDetector(view){return (view[FLAGS]&128/* Attached */)===128/* Attached */;}/**
	 * Resets the pre-order hook flags of the view.
	 * @param lView the LView on which the flags are reset
	 */function resetPreOrderHookFlags(lView){lView[PREORDER_HOOK_FLAGS]=0;}function getLView(){return lView;}/** Used to set the parent property when nodes are created and track query results. */var previousOrParentTNode;function getPreviousOrParentTNode(){// top level variables should not be exported for performance reasons (PERF_NOTES.md)
	return previousOrParentTNode;}function setPreviousOrParentTNode(tNode,_isParent){previousOrParentTNode=tNode;isParent=_isParent;}function setTNodeAndViewData(tNode,view){ngDevMode&&assertLViewOrUndefined(view);previousOrParentTNode=tNode;lView=view;}/**
	 * If `isParent` is:
	 *  - `true`: then `previousOrParentTNode` points to a parent node.
	 *  - `false`: then `previousOrParentTNode` points to previous node (sibling).
	 */var isParent;function getIsParent(){// top level variables should not be exported for performance reasons (PERF_NOTES.md)
	return isParent;}/** Checks whether a given view is in creation mode */function isCreationMode(view){if(view===void 0){view=lView;}return (view[FLAGS]&4/* CreationMode */)===4/* CreationMode */;}/**
	 * State of the current view being processed.
	 *
	 * An array of nodes (text, element, container, etc), pipes, their bindings, and
	 * any local variables that need to be stored between invocations.
	 */var lView;/**
	 * The last viewData retrieved by nextContext().
	 * Allows building nextContext() and reference() calls.
	 *
	 * e.g. const inner = x().$implicit; const outer = x().$implicit;
	 */var contextLView=null;/**
	 * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.
	 *
	 * Necessary to support ChangeDetectorRef.checkNoChanges().
	 */var checkNoChangesMode=false;function getCheckNoChangesMode(){// top level variables should not be exported for performance reasons (PERF_NOTES.md)
	return checkNoChangesMode;}function setCheckNoChangesMode(mode){checkNoChangesMode=mode;}/**
	 * The root index from which pure function instructions should calculate their binding
	 * indices. In component views, this is TView.bindingStartIndex. In a host binding
	 * context, this is the TView.expandoStartIndex + any dirs/hostVars before the given dir.
	 */var bindingRootIndex=-1;// top level variables should not be exported for performance reasons (PERF_NOTES.md)
	function setBindingRoot(value){bindingRootIndex=value;}/**
	 * Swap the current state with a new state.
	 *
	 * For performance reasons we store the state in the top level of the module.
	 * This way we minimize the number of properties to read. Whenever a new view
	 * is entered we have to store the state for later, and when the view is
	 * exited the state has to be restored
	 *
	 * @param newView New state to become active
	 * @param host Element to which the View is a child of
	 * @returns the previous state;
	 */function enterView(newView,hostTNode){ngDevMode&&assertLViewOrUndefined(newView);var oldView=lView;if(newView){var tView=newView[TVIEW];bindingRootIndex=tView.bindingStartIndex;}previousOrParentTNode=hostTNode;isParent=true;lView=contextLView=newView;return oldView;}/**
	 * Resets the application state.
	 */function resetComponentState(){isParent=false;previousOrParentTNode=null;setCurrentStyleSanitizer(null);resetAllStylingState();}/**
	 * Used in lieu of enterView to make it clear when we are exiting a child view. This makes
	 * the direction of traversal (up or down the view tree) a bit clearer.
	 *
	 * @param newView New state to become active
	 * @param safeToRunHooks Whether the runtime is in a state where running lifecycle hooks is valid.
	 * This is not always the case (for example, the application may have crashed and `leaveView` is
	 * being executed while unwinding the call stack).
	 */function leaveView(newView,safeToRunHooks){var tView=lView[TVIEW];if(isCreationMode(lView)){lView[FLAGS]&=~4/* CreationMode */;}else{try{resetPreOrderHookFlags(lView);safeToRunHooks&&executeHooks(lView,tView.viewHooks,tView.viewCheckHooks,checkNoChangesMode,2/* AfterViewInitHooksToBeRun */,undefined);}finally{// Views are clean and in update mode after being checked, so these bits are cleared
	lView[FLAGS]&=~(64/* Dirty */|8/* FirstLViewPass */);lView[BINDING_INDEX]=tView.bindingStartIndex;}}enterView(newView,null);}var _currentNamespace=null;/**
	 * Sets the namespace used to create elements to `null`, which forces element creation to use
	 * `createElement` rather than `createElementNS`.
	 */function namespaceHTMLInternal(){_currentNamespace=null;}function getNamespace(){return _currentNamespace;}var _currentSanitizer;function setCurrentStyleSanitizer(sanitizer){_currentSanitizer=sanitizer;}function getCurrentStyleSanitizer(){return _currentSanitizer;}/**
	 * Used for stringify render output in Ivy.
	 * Important! This function is very performance-sensitive and we should
	 * be extra careful not to introduce megamorphic reads in it.
	 */function renderStringify(value){if(typeof value==='string')return value;if(value==null)return '';return ''+value;}/**
	 * Used to stringify a value so that it can be displayed in an error message.
	 * Important! This function contains a megamorphic read and should only be
	 * used for error messages.
	 */function stringifyForError(value){if(typeof value==='function')return value.name||value.toString();if(_typeof(value)==='object'&&value!=null&&typeof value.type==='function'){return value.type.name||value.type.toString();}return renderStringify(value);}var Éµ0$2=function Éµ0$2(){return (typeof requestAnimationFrame!=='undefined'&&requestAnimationFrame||// browser only
	setTimeout// everything else
	).bind(_global$1);};var defaultScheduler=Éµ0$2();/**
	 * The special delimiter we use to separate property names, prefixes, and suffixes
	 * in property binding metadata. See storeBindingMetadata().
	 *
	 * We intentionally use the Unicode "REPLACEMENT CHARACTER" (U+FFFD) as a delimiter
	 * because it is a very uncommon character that is unlikely to be part of a user's
	 * property names or interpolation strings. If it is in fact used in a property
	 * binding, DebugElement.properties will not return the correct value for that
	 * binding. However, there should be no runtime effect for real applications.
	 *
	 * This character is typically rendered as a question mark inside of a diamond.
	 * See https://en.wikipedia.org/wiki/Specials_(Unicode_block)
	 *
	 */var INTERPOLATION_DELIMITER="\uFFFD";/**
	 * Determines whether or not the given string is a property metadata string.
	 * See storeBindingMetadata().
	 */function isPropMetadataString(str){return str.indexOf(INTERPOLATION_DELIMITER)>=0;}/**
	 * Unwrap a value which might be behind a closure (for forward declaration reasons).
	 */function maybeUnwrapFn(value){if(value instanceof Function){return value();}else{return value;}}function getConfig(context){return context[1/* ConfigPosition */];}function getProp(context,index){return context[index+2/* PropOffset */];}function getPropConfig(context,index){return context[index+0/* ConfigAndGuardOffset */]&1/* Mask */;}function isSanitizationRequired(context,index){return (getPropConfig(context,index)&1/* SanitizationRequired */)>0;}function getGuardMask(context,index){var configGuardValue=context[index+0/* ConfigAndGuardOffset */];return configGuardValue>>1/* TotalBits */;}function getValuesCount(context,index){return context[index+1/* ValuesCountOffset */];}function getBindingValue(context,index,offset){return context[index+3/* BindingsStartOffset */+offset];}function getDefaultValue(context,index){var valuesCount=getValuesCount(context,index);return context[index+3/* BindingsStartOffset */+valuesCount-1];}function isContextLocked(context){return (getConfig(context)&1/* Locked */)>0;}function getPropValuesStartPosition(context){return 6/* MapBindingsBindingsStartPosition */+context[4/* MapBindingsValuesCountPosition */];}/**
	 * Determines whether the provided styling value is truthy or falsy.
	 */function isStylingValueDefined(value){// the reason why null is compared against is because
	// a CSS class value that is set to `false` must be
	// respected (otherwise it would be treated as falsy).
	// Empty string values are because developers usually
	// set a value to an empty string to remove it.
	return value!=null&&value!=='';}function isStylingContext(value){// the StylingMapArray is in the format of [initial, prop, string, prop, string]
	// and this is the defining value to distinguish between arrays
	return Array.isArray(value)&&value.length>=6/* MapBindingsBindingsStartPosition */&&typeof value[1]!=='string';}function getMapProp(map$$1,index){return map$$1[index+0/* PropOffset */];}function getMapValue(map$$1,index){return map$$1[index+1/* ValueOffset */];}var RendererStyleFlags3;(function(RendererStyleFlags3){RendererStyleFlags3[RendererStyleFlags3["Important"]=1]="Important";RendererStyleFlags3[RendererStyleFlags3["DashCase"]=2]="DashCase";})(RendererStyleFlags3||(RendererStyleFlags3={}));/** Returns whether the `renderer` is a `ProceduralRenderer3` */function isProceduralRenderer(renderer){return !!renderer.listen;}var Éµ0$3=function Éµ0$3(hostElement,rendererType){return document;};var domRendererFactory3={createRenderer:Éµ0$3};// Note: This hack is necessary so we don't erroneously get a circular dependency
	function hasParentInjector(parentLocation){return parentLocation!==NO_PARENT_INJECTOR;}function getParentInjectorIndex(parentLocation){return parentLocation&32767/* InjectorIndexMask */;}function getParentInjectorViewOffset(parentLocation){return parentLocation>>16/* ViewOffsetShift */;}/**
	 * Unwraps a parent injector location number to find the view offset from the current injector,
	 * then walks up the declaration view tree until the view is found that contains the parent
	 * injector.
	 *
	 * @param location The location of the parent injector, which contains the view offset
	 * @param startView The LView instance from which to start walking up the view tree
	 * @returns The LView instance that contains the parent injector
	 */function getParentInjectorView(location,startView){var viewOffset=getParentInjectorViewOffset(location);var parentView=startView;// For most cases, the parent injector can be found on the host node (e.g. for component
	// or container), but we must keep the loop here to support the rarer case of deeply nested
	// <ng-template> tags or inline views, where the parent injector might live many views
	// above the child injector.
	while(viewOffset>0){parentView=parentView[DECLARATION_VIEW];viewOffset--;}return parentView;}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of
	 * that LContainer, which is an LView
	 * @param lView the lView whose parent to get
	 */function getLViewParent(lView){ngDevMode&&assertLView(lView);var parent=lView[PARENT];return isLContainer(parent)?parent[PARENT]:parent;}/**
	 * Retrieve the root view from any component or `LView` by walking the parent `LView` until
	 * reaching the root `LView`.
	 *
	 * @param componentOrLView any component or `LView`
	 */function getRootView(componentOrLView){ngDevMode&&assertDefined(componentOrLView,'component');var lView=isLView(componentOrLView)?componentOrLView:readPatchedLView(componentOrLView);while(lView&&!(lView[FLAGS]&512/* IsRoot */)){lView=getLViewParent(lView);}ngDevMode&&assertLView(lView);return lView;}/**
	 * Given an `LView`, find the closest declaration view which is not an embedded view.
	 *
	 * This method searches for the `LView` associated with the component which declared the `LView`.
	 *
	 * This function may return itself if the `LView` passed in is not an embedded `LView`. Otherwise
	 * it walks the declaration parents until it finds a component view (non-embedded-view.)
	 *
	 * @param lView LView for which we want a host element node
	 * @returns The host node
	 */function findComponentView(lView){var rootTNode=lView[T_HOST];while(rootTNode!==null&&rootTNode.type===2/* View */){ngDevMode&&assertDefined(lView[DECLARATION_VIEW],'lView[DECLARATION_VIEW]');lView=lView[DECLARATION_VIEW];rootTNode=lView[T_HOST];}ngDevMode&&assertLView(lView);return lView;}/**
	 * Returns the `RootContext` instance that is associated with
	 * the application where the target is situated. It does this by walking the parent views until it
	 * gets to the root view, then getting the context off of that.
	 *
	 * @param viewOrComponent the `LView` or component to get the root context for.
	 */function getRootContext(viewOrComponent){var rootView=getRootView(viewOrComponent);ngDevMode&&assertDefined(rootView[CONTEXT],'RootView has no context. Perhaps it is disconnected?');return rootView[CONTEXT];}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Defines if the call to `inject` should include `viewProviders` in its resolution.
	 *
	 * This is set to true when we try to instantiate a component. This value is reset in
	 * `getNodeInjectable` to a value which matches the declaration location of the token about to be
	 * instantiated. This is done so that if we are injecting a token which was declared outside of
	 * `viewProviders` we don't accidentally pull `viewProviders` in.
	 *
	 * Example:
	 *
	 * ```
	 * @Injectable()
	 * class MyService {
	 *   constructor(public value: String) {}
	 * }
	 *
	 * @Component({
	 *   providers: [
	 *     MyService,
	 *     {provide: String, value: 'providers' }
	 *   ]
	 *   viewProviders: [
	 *     {provide: String, value: 'viewProviders'}
	 *   ]
	 * })
	 * class MyComponent {
	 *   constructor(myService: MyService, value: String) {
	 *     // We expect that Component can see into `viewProviders`.
	 *     expect(value).toEqual('viewProviders');
	 *     // `MyService` was not declared in `viewProviders` hence it can't see it.
	 *     expect(myService.value).toEqual('providers');
	 *   }
	 * }
	 *
	 * ```
	 */var includeViewProviders=true;function setIncludeViewProviders(v){var oldValue=includeViewProviders;includeViewProviders=v;return oldValue;}/**
	 * The number of slots in each bloom filter (used by DI). The larger this number, the fewer
	 * directives that will share slots, and thus, the fewer false positives when checking for
	 * the existence of a directive.
	 */var BLOOM_SIZE=256;var BLOOM_MASK=BLOOM_SIZE-1;/** Counter used to generate unique IDs for directives. */var nextNgElementId=0;/**
	 * Registers this directive as present in its node's injector by flipping the directive's
	 * corresponding bit in the injector's bloom filter.
	 *
	 * @param injectorIndex The index of the node injector where this token should be registered
	 * @param tView The TView for the injector's bloom filters
	 * @param type The directive token to register
	 */function bloomAdd(injectorIndex,tView,type){ngDevMode&&assertEqual(tView.firstTemplatePass,true,'expected firstTemplatePass to be true');var id=typeof type!=='string'?type[NG_ELEMENT_ID]:type.charCodeAt(0)||0;// Set a unique ID on the directive type, so if something tries to inject the directive,
	// we can easily retrieve the ID and hash it into the bloom bit that should be checked.
	if(id==null){id=type[NG_ELEMENT_ID]=nextNgElementId++;}// We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),
	// so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.
	var bloomBit=id&BLOOM_MASK;// Create a mask that targets the specific bit associated with the directive.
	// JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding
	// to bit positions 0 - 31 in a 32 bit integer.
	var mask=1<<bloomBit;// Use the raw bloomBit number to determine which bloom filter bucket we should check
	// e.g: bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc
	var b7=bloomBit&0x80;var b6=bloomBit&0x40;var b5=bloomBit&0x20;var tData=tView.data;if(b7){b6?b5?tData[injectorIndex+7]|=mask:tData[injectorIndex+6]|=mask:b5?tData[injectorIndex+5]|=mask:tData[injectorIndex+4]|=mask;}else{b6?b5?tData[injectorIndex+3]|=mask:tData[injectorIndex+2]|=mask:b5?tData[injectorIndex+1]|=mask:tData[injectorIndex]|=mask;}}/**
	 * Creates (or gets an existing) injector for a given element or container.
	 *
	 * @param tNode for which an injector should be retrieved / created.
	 * @param hostView View where the node is stored
	 * @returns Node injector
	 */function getOrCreateNodeInjectorForNode(tNode,hostView){var existingInjectorIndex=getInjectorIndex(tNode,hostView);if(existingInjectorIndex!==-1){return existingInjectorIndex;}var tView=hostView[TVIEW];if(tView.firstTemplatePass){tNode.injectorIndex=hostView.length;insertBloom(tView.data,tNode);// foundation for node bloom
	insertBloom(hostView,null);// foundation for cumulative bloom
	insertBloom(tView.blueprint,null);ngDevMode&&assertEqual(tNode.flags===0||tNode.flags===1/* isComponent */,true,'expected tNode.flags to not be initialized');}var parentLoc=getParentInjectorLocation(tNode,hostView);var parentIndex=getParentInjectorIndex(parentLoc);var parentLView=getParentInjectorView(parentLoc,hostView);var injectorIndex=tNode.injectorIndex;// If a parent injector can't be found, its location is set to -1.
	// In that case, we don't need to set up a cumulative bloom
	if(hasParentInjector(parentLoc)){var parentData=parentLView[TVIEW].data;// Creates a cumulative bloom filter that merges the parent's bloom filter
	// and its own cumulative bloom (which contains tokens for all ancestors)
	for(var i=0;i<8;i++){hostView[injectorIndex+i]=parentLView[parentIndex+i]|parentData[parentIndex+i];}}hostView[injectorIndex+PARENT_INJECTOR]=parentLoc;return injectorIndex;}function insertBloom(arr,footer){arr.push(0,0,0,0,0,0,0,0,footer);}function getInjectorIndex(tNode,hostView){if(tNode.injectorIndex===-1||// If the injector index is the same as its parent's injector index, then the index has been
	// copied down from the parent node. No injector has been created yet on this node.
	tNode.parent&&tNode.parent.injectorIndex===tNode.injectorIndex||// After the first template pass, the injector index might exist but the parent values
	// might not have been calculated yet for this instance
	hostView[tNode.injectorIndex+PARENT_INJECTOR]==null){return -1;}else{return tNode.injectorIndex;}}/**
	 * Finds the index of the parent injector, with a view offset if applicable. Used to set the
	 * parent injector initially.
	 *
	 * Returns a combination of number of `ViewData` we have to go up and index in that `Viewdata`
	 */function getParentInjectorLocation(tNode,view){if(tNode.parent&&tNode.parent.injectorIndex!==-1){return tNode.parent.injectorIndex;// ViewOffset is 0
	}// For most cases, the parent injector index can be found on the host node (e.g. for component
	// or container), so this loop will be skipped, but we must keep the loop here to support
	// the rarer case of deeply nested <ng-template> tags or inline views.
	var hostTNode=view[T_HOST];var viewOffset=1;while(hostTNode&&hostTNode.injectorIndex===-1){view=view[DECLARATION_VIEW];hostTNode=view?view[T_HOST]:null;viewOffset++;}return hostTNode?hostTNode.injectorIndex|viewOffset<<16/* ViewOffsetShift */:-1;}/**
	 * Makes a type or an injection token public to the DI system by adding it to an
	 * injector's bloom filter.
	 *
	 * @param di The node injector in which a directive will be added
	 * @param token The type or the injection token to be made public
	 */function diPublicInInjector(injectorIndex,tView,token){bloomAdd(injectorIndex,tView,token);}/**
	 * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.
	 *
	 * Look for the injector providing the token by walking up the node injector tree and then
	 * the module injector tree.
	 *
	 * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom
	 * filter. Negative values are reserved for special objects.
	 *   - `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)
	 *
	 * @param tNode The Node where the search for the injector should start
	 * @param lView The `LView` that contains the `tNode`
	 * @param token The token to look for
	 * @param flags Injection flags
	 * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`
	 * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided
	 */function getOrCreateInjectable(tNode,lView,token,flags,notFoundValue){if(flags===void 0){flags=InjectFlags.Default;}if(tNode){var bloomHash=bloomHashBitOrFactory(token);// If the ID stored here is a function, this is a special object like ElementRef or TemplateRef
	// so just call the factory function to create it.
	if(typeof bloomHash==='function'){var savePreviousOrParentTNode=getPreviousOrParentTNode();var saveLView=getLView();setTNodeAndViewData(tNode,lView);try{var value=bloomHash();if(value==null&&!(flags&InjectFlags.Optional)){throw new Error("No provider for "+stringifyForError(token)+"!");}else{return value;}}finally{setTNodeAndViewData(savePreviousOrParentTNode,saveLView);}}else if(typeof bloomHash=='number'){if(bloomHash===-1){// `-1` is a special value used to identify `Injector` types.
	return new NodeInjector(tNode,lView);}// If the token has a bloom hash, then it is a token which could be in NodeInjector.
	// A reference to the previous injector TView that was found while climbing the element
	// injector tree. This is used to know if viewProviders can be accessed on the current
	// injector.
	var previousTView=null;var injectorIndex=getInjectorIndex(tNode,lView);var parentLocation=NO_PARENT_INJECTOR;var hostTElementNode=flags&InjectFlags.Host?findComponentView(lView)[T_HOST]:null;// If we should skip this injector, or if there is no injector on this node, start by
	// searching
	// the parent injector.
	if(injectorIndex===-1||flags&InjectFlags.SkipSelf){parentLocation=injectorIndex===-1?getParentInjectorLocation(tNode,lView):lView[injectorIndex+PARENT_INJECTOR];if(!shouldSearchParent(flags,false)){injectorIndex=-1;}else{previousTView=lView[TVIEW];injectorIndex=getParentInjectorIndex(parentLocation);lView=getParentInjectorView(parentLocation,lView);}}// Traverse up the injector tree until we find a potential match or until we know there
	// *isn't* a match.
	while(injectorIndex!==-1){parentLocation=lView[injectorIndex+PARENT_INJECTOR];// Check the current injector. If it matches, see if it contains token.
	var tView=lView[TVIEW];if(bloomHasToken(bloomHash,injectorIndex,tView.data)){// At this point, we have an injector which *may* contain the token, so we step through
	// the providers and directives associated with the injector's corresponding node to get
	// the instance.
	var instance=searchTokensOnInjector(injectorIndex,lView,token,previousTView,flags,hostTElementNode);if(instance!==NOT_FOUND){return instance;}}if(shouldSearchParent(flags,lView[TVIEW].data[injectorIndex+TNODE]===hostTElementNode)&&bloomHasToken(bloomHash,injectorIndex,lView)){// The def wasn't found anywhere on this node, so it was a false positive.
	// Traverse up the tree and continue searching.
	previousTView=tView;injectorIndex=getParentInjectorIndex(parentLocation);lView=getParentInjectorView(parentLocation,lView);}else{// If we should not search parent OR If the ancestor bloom filter value does not have the
	// bit corresponding to the directive we can give up on traversing up to find the specific
	// injector.
	injectorIndex=-1;}}}}if(flags&InjectFlags.Optional&&notFoundValue===undefined){// This must be set or the NullInjector will throw for optional deps
	notFoundValue=null;}if((flags&(InjectFlags.Self|InjectFlags.Host))===0){var moduleInjector=lView[INJECTOR$1];// switch to `injectInjectorOnly` implementation for module injector, since module injector
	// should not have access to Component/Directive DI scope (that may happen through
	// `directiveInject` implementation)
	var previousInjectImplementation=setInjectImplementation(undefined);try{if(moduleInjector){return moduleInjector.get(token,notFoundValue,flags&InjectFlags.Optional);}else{return injectRootLimpMode(token,notFoundValue,flags&InjectFlags.Optional);}}finally{setInjectImplementation(previousInjectImplementation);}}if(flags&InjectFlags.Optional){return notFoundValue;}else{throw new Error("NodeInjector: NOT_FOUND ["+stringifyForError(token)+"]");}}var NOT_FOUND={};function searchTokensOnInjector(injectorIndex,lView,token,previousTView,flags,hostTElementNode){var currentTView=lView[TVIEW];var tNode=currentTView.data[injectorIndex+TNODE];// First, we need to determine if view providers can be accessed by the starting element.
	// There are two possibities
	var canAccessViewProviders=previousTView==null?// 1) This is the first invocation `previousTView == null` which means that we are at the
	// `TNode` of where injector is starting to look. In such a case the only time we are allowed
	// to look into the ViewProviders is if:
	// - we are on a component
	// - AND the injector set `includeViewProviders` to true (implying that the token can see
	// ViewProviders because it is the Component or a Service which itself was declared in
	// ViewProviders)
	isComponent(tNode)&&includeViewProviders:// 2) `previousTView != null` which means that we are now walking across the parent nodes.
	// In such a case we are only allowed to look into the ViewProviders if:
	// - We just crossed from child View to Parent View `previousTView != currentTView`
	// - AND the parent TNode is an Element.
	// This means that we just came from the Component's View and therefore are allowed to see
	// into the ViewProviders.
	previousTView!=currentTView&&tNode.type===3/* Element */;// This special case happens when there is a @host on the inject and when we are searching
	// on the host element node.
	var isHostSpecialCase=flags&InjectFlags.Host&&hostTElementNode===tNode;var injectableIdx=locateDirectiveOrProvider(tNode,currentTView,token,canAccessViewProviders,isHostSpecialCase);if(injectableIdx!==null){return getNodeInjectable(currentTView.data,lView,injectableIdx,tNode);}else{return NOT_FOUND;}}/**
	 * Searches for the given token among the node's directives and providers.
	 *
	 * @param tNode TNode on which directives are present.
	 * @param tView The tView we are currently processing
	 * @param token Provider token or type of a directive to look for.
	 * @param canAccessViewProviders Whether view providers should be considered.
	 * @param isHostSpecialCase Whether the host special case applies.
	 * @returns Index of a found directive or provider, or null when none found.
	 */function locateDirectiveOrProvider(tNode,tView,token,canAccessViewProviders,isHostSpecialCase){var nodeProviderIndexes=tNode.providerIndexes;var tInjectables=tView.data;var injectablesStart=nodeProviderIndexes&65535/* ProvidersStartIndexMask */;var directivesStart=tNode.directiveStart;var directiveEnd=tNode.directiveEnd;var cptViewProvidersCount=nodeProviderIndexes>>16/* CptViewProvidersCountShift */;var startingIndex=canAccessViewProviders?injectablesStart:injectablesStart+cptViewProvidersCount;// When the host special case applies, only the viewProviders and the component are visible
	var endIndex=isHostSpecialCase?injectablesStart+cptViewProvidersCount:directiveEnd;for(var i=startingIndex;i<endIndex;i++){var providerTokenOrDef=tInjectables[i];if(i<directivesStart&&token===providerTokenOrDef||i>=directivesStart&&providerTokenOrDef.type===token){return i;}}if(isHostSpecialCase){var dirDef=tInjectables[directivesStart];if(dirDef&&isComponentDef(dirDef)&&dirDef.type===token){return directivesStart;}}return null;}/**
	* Retrieve or instantiate the injectable from the `lData` at particular `index`.
	*
	* This function checks to see if the value has already been instantiated and if so returns the
	* cached `injectable`. Otherwise if it detects that the value is still a factory it
	* instantiates the `injectable` and caches the value.
	*/function getNodeInjectable(tData,lData,index,tNode){var value=lData[index];if(isFactory(value)){var factory=value;if(factory.resolving){throw new Error("Circular dep for "+stringifyForError(tData[index]));}var previousIncludeViewProviders=setIncludeViewProviders(factory.canSeeViewProviders);factory.resolving=true;var previousInjectImplementation=void 0;if(factory.injectImpl){previousInjectImplementation=setInjectImplementation(factory.injectImpl);}var savePreviousOrParentTNode=getPreviousOrParentTNode();var saveLView=getLView();setTNodeAndViewData(tNode,lData);try{value=lData[index]=factory.factory(undefined,tData,lData,tNode);}finally{if(factory.injectImpl)setInjectImplementation(previousInjectImplementation);setIncludeViewProviders(previousIncludeViewProviders);factory.resolving=false;setTNodeAndViewData(savePreviousOrParentTNode,saveLView);}}return value;}/**
	 * Returns the bit in an injector's bloom filter that should be used to determine whether or not
	 * the directive might be provided by the injector.
	 *
	 * When a directive is public, it is added to the bloom filter and given a unique ID that can be
	 * retrieved on the Type. When the directive isn't public or the token is not a directive `null`
	 * is returned as the node injector can not possibly provide that token.
	 *
	 * @param token the injection token
	 * @returns the matching bit to check in the bloom filter or `null` if the token is not known.
	 *   When the returned value is negative then it represents special values such as `Injector`.
	 */function bloomHashBitOrFactory(token){ngDevMode&&assertDefined(token,'token must be defined');if(typeof token==='string'){return token.charCodeAt(0)||0;}var tokenId=token[NG_ELEMENT_ID];// Negative token IDs are used for special objects such as `Injector`
	return typeof tokenId==='number'&&tokenId>0?tokenId&BLOOM_MASK:tokenId;}function bloomHasToken(bloomHash,injectorIndex,injectorView){// Create a mask that targets the specific bit associated with the directive we're looking for.
	// JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding
	// to bit positions 0 - 31 in a 32 bit integer.
	var mask=1<<bloomHash;var b7=bloomHash&0x80;var b6=bloomHash&0x40;var b5=bloomHash&0x20;// Our bloom filter size is 256 bits, which is eight 32-bit bloom filter buckets:
	// bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc.
	// Get the bloom filter value from the appropriate bucket based on the directive's bloomBit.
	var value;if(b7){value=b6?b5?injectorView[injectorIndex+7]:injectorView[injectorIndex+6]:b5?injectorView[injectorIndex+5]:injectorView[injectorIndex+4];}else{value=b6?b5?injectorView[injectorIndex+3]:injectorView[injectorIndex+2]:b5?injectorView[injectorIndex+1]:injectorView[injectorIndex];}// If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,
	// this injector is a potential match.
	return !!(value&mask);}/** Returns true if flags prevent parent injector from being searched for tokens */function shouldSearchParent(flags,isFirstHostTNode){return !(flags&InjectFlags.Self)&&!(flags&InjectFlags.Host&&isFirstHostTNode);}var NodeInjector=/** @class */function(){function NodeInjector(_tNode,_lView){this._tNode=_tNode;this._lView=_lView;}NodeInjector.prototype.get=function(token,notFoundValue){return getOrCreateInjectable(this._tNode,this._lView,token,undefined,notFoundValue);};return NodeInjector;}();var ERROR_DEBUG_CONTEXT='ngDebugContext';var ERROR_ORIGINAL_ERROR='ngOriginalError';var ERROR_LOGGER='ngErrorLogger';function wrappedError(message,originalError){var msg=message+" caused by: "+(originalError instanceof Error?originalError.message:originalError);var error=Error(msg);error[ERROR_ORIGINAL_ERROR]=originalError;return error;}function getDebugContext(error){return error[ERROR_DEBUG_CONTEXT];}function getOriginalError(error){return error[ERROR_ORIGINAL_ERROR];}function getErrorLogger(error){return error[ERROR_LOGGER]||defaultErrorLogger;}function defaultErrorLogger(console){var values=[];for(var _i=1;_i<arguments.length;_i++){values[_i-1]=arguments[_i];}console.error.apply(console,__spread(values));}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Provides a hook for centralized exception handling.
	 *
	 * The default implementation of `ErrorHandler` prints error messages to the `console`. To
	 * intercept error handling, write a custom exception handler that replaces this default as
	 * appropriate for your app.
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * ```
	 * class MyErrorHandler implements ErrorHandler {
	 *   handleError(error) {
	 *     // do something with the exception
	 *   }
	 * }
	 *
	 * @NgModule({
	 *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
	 * })
	 * class MyModule {}
	 * ```
	 *
	 * @publicApi
	 */var ErrorHandler=/** @class */function(){function ErrorHandler(){/**
	         * @internal
	         */this._console=console;}ErrorHandler.prototype.handleError=function(error){var originalError=this._findOriginalError(error);var context=this._findContext(error);// Note: Browser consoles show the place from where console.error was called.
	// We can use this to give users additional information about the error.
	var errorLogger=getErrorLogger(error);errorLogger(this._console,"ERROR",error);if(originalError){errorLogger(this._console,"ORIGINAL ERROR",originalError);}if(context){errorLogger(this._console,'ERROR CONTEXT',context);}};/** @internal */ErrorHandler.prototype._findContext=function(error){if(error){return getDebugContext(error)?getDebugContext(error):this._findContext(getOriginalError(error));}return null;};/** @internal */ErrorHandler.prototype._findOriginalError=function(error){var e=getOriginalError(error);while(e&&getOriginalError(e)){e=getOriginalError(e);}return e;};return ErrorHandler;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * This file is used to control if the default rendering pipeline should be `ViewEngine` or `Ivy`.
	 *
	 * For more information on how to run and debug tests with either Ivy or View Engine (legacy),
	 * please see [BAZEL.md](./docs/BAZEL.md).
	 */var _devMode=true;/**
	 * Returns whether Angular is in development mode. After called once,
	 * the value is locked and won't change any more.
	 *
	 * By default, this is true, unless a user calls `enableProdMode` before calling this.
	 *
	 * @publicApi
	 */function isDevMode(){return _devMode;}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function tagSet(tags){var e_1,_a;var res={};try{for(var _b=__values(tags.split(',')),_c=_b.next();!_c.done;_c=_b.next()){var t=_c.value;res[t]=true;}}catch(e_1_1){e_1={error:e_1_1};}finally{try{if(_c&&!_c.done&&(_a=_b.return))_a.call(_b);}finally{if(e_1)throw e_1.error;}}return res;}function merge$2(){var e_2,_a;var sets=[];for(var _i=0;_i<arguments.length;_i++){sets[_i]=arguments[_i];}var res={};try{for(var sets_1=__values(sets),sets_1_1=sets_1.next();!sets_1_1.done;sets_1_1=sets_1.next()){var s=sets_1_1.value;for(var v in s){if(s.hasOwnProperty(v))res[v]=true;}}}catch(e_2_1){e_2={error:e_2_1};}finally{try{if(sets_1_1&&!sets_1_1.done&&(_a=sets_1.return))_a.call(sets_1);}finally{if(e_2)throw e_2.error;}}return res;}// Good source of info about elements and attributes
	// http://dev.w3.org/html5/spec/Overview.html#semantics
	// http://simon.html5.org/html-elements
	// Safe Void Elements - HTML5
	// http://dev.w3.org/html5/spec/Overview.html#void-elements
	var VOID_ELEMENTS=tagSet('area,br,col,hr,img,wbr');// Elements that you can, intentionally, leave open (and which close themselves)
	// http://dev.w3.org/html5/spec/Overview.html#optional-tags
	var OPTIONAL_END_TAG_BLOCK_ELEMENTS=tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');var OPTIONAL_END_TAG_INLINE_ELEMENTS=tagSet('rp,rt');var OPTIONAL_END_TAG_ELEMENTS=merge$2(OPTIONAL_END_TAG_INLINE_ELEMENTS,OPTIONAL_END_TAG_BLOCK_ELEMENTS);// Safe Block Elements - HTML5
	var BLOCK_ELEMENTS=merge$2(OPTIONAL_END_TAG_BLOCK_ELEMENTS,tagSet('address,article,'+'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,'+'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));// Inline Elements - HTML5
	var INLINE_ELEMENTS=merge$2(OPTIONAL_END_TAG_INLINE_ELEMENTS,tagSet('a,abbr,acronym,audio,b,'+'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,'+'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));var VALID_ELEMENTS=merge$2(VOID_ELEMENTS,BLOCK_ELEMENTS,INLINE_ELEMENTS,OPTIONAL_END_TAG_ELEMENTS);// Attributes that have href and hence need to be sanitized
	var URI_ATTRS=tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');// Attributes that have special href set hence need to be sanitized
	var SRCSET_ATTRS=tagSet('srcset');var HTML_ATTRS=tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,'+'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,'+'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,'+'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,'+'valign,value,vspace,width');// Accessibility attributes as per WAI-ARIA 1.1 (W3C Working Draft 14 December 2018)
	var ARIA_ATTRS=tagSet('aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,'+'aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,'+'aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,'+'aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,'+'aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,'+'aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,'+'aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext');// NB: This currently consciously doesn't support SVG. SVG sanitization has had several security
	// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via
	// innerHTML is required, SVG attributes should be added here.
	// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those
	// can be sanitized, but they increase security surface area without a legitimate use case, so they
	// are left out here.
	var VALID_ATTRS=merge$2(URI_ATTRS,SRCSET_ATTRS,HTML_ATTRS,ARIA_ATTRS);// Elements whose content should not be traversed/preserved, if the elements themselves are invalid.
	//
	// Typically, `<invalid>Some content</invalid>` would traverse (and in this case preserve)
	// `Some content`, but strip `invalid-element` opening/closing tags. For some elements, though, we
	// don't want to preserve the content, if the elements themselves are going to be removed.
	var SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS=tagSet('script,style,template');/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property
	 * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly
	 * handled.
	 *
	 * See DomSanitizer for more details on security in Angular applications.
	 *
	 * @publicApi
	 */var SecurityContext;(function(SecurityContext){SecurityContext[SecurityContext["NONE"]=0]="NONE";SecurityContext[SecurityContext["HTML"]=1]="HTML";SecurityContext[SecurityContext["STYLE"]=2]="STYLE";SecurityContext[SecurityContext["SCRIPT"]=3]="SCRIPT";SecurityContext[SecurityContext["URL"]=4]="URL";SecurityContext[SecurityContext["RESOURCE_URL"]=5]="RESOURCE_URL";})(SecurityContext||(SecurityContext={}));/**
	 * Sanitizer is used by the views to sanitize potentially dangerous values.
	 *
	 * @publicApi
	 */var Sanitizer=/** @class */function(){function Sanitizer(){}return Sanitizer;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * THIS FILE CONTAINS CODE WHICH SHOULD BE TREE SHAKEN AND NEVER CALLED FROM PRODUCTION CODE!!!
	 */ /**
	 * Creates an `Array` construction with a given name. This is useful when
	 * looking for memory consumption to see what time of array it is.
	 *
	 *
	 * @param name Name to give to the constructor
	 * @returns A subclass of `Array` if possible. This can only be done in
	 *          environments which support `class` construct.
	 */function createNamedArrayType(name){// This should never be called in prod mode, so let's verify that is the case.
	if(ngDevMode){try{// We need to do it this way so that TypeScript does not down-level the below code.
	var FunctionConstructor=createNamedArrayType.constructor;return new FunctionConstructor('Array',"return class ABC extends Array{}")(Array);}catch(e){// If it does not work just give up and fall back to regular Array.
	return Array;}}else{throw new Error('Looks like we are in \'prod mode\', but we are creating a named Array type, which is wrong! Check your code');}}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function normalizeDebugBindingName(name){// Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers
	name=camelCaseToDashCase(name.replace(/[$@]/g,'_'));return "ng-reflect-"+name;}var CAMEL_CASE_REGEXP=/([A-Z])/g;function camelCaseToDashCase(input){return input.replace(CAMEL_CASE_REGEXP,function(){var m=[];for(var _i=0;_i<arguments.length;_i++){m[_i]=arguments[_i];}return '-'+m[1].toLowerCase();});}function normalizeDebugBindingValue(value){try{// Limit the size of the value as otherwise the DOM just gets polluted.
	return value!=null?value.toString().slice(0,30):value;}catch(e){return '[ERROR] Exception while trying to serialize the value';}}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /** Returns the matching `LContext` data for a given DOM node, directive or component instance.
	 *
	 * This function will examine the provided DOM element, component, or directive instance\'s
	 * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched
	 * value will be that of the newly created `LContext`.
	 *
	 * If the monkey-patched value is the `LView` instance then the context value for that
	 * target will be created and the monkey-patch reference will be updated. Therefore when this
	 * function is called it may mutate the provided element\'s, component\'s or any of the associated
	 * directive\'s monkey-patch values.
	 *
	 * If the monkey-patch value is not detected then the code will walk up the DOM until an element
	 * is found which contains a monkey-patch reference. When that occurs then the provided element
	 * will be updated with a new context (which is then returned). If the monkey-patch value is not
	 * detected for a component/directive instance then it will throw an error (all components and
	 * directives should be automatically monkey-patched by ivy).
	 *
	 * @param target Component, Directive or DOM Node.
	 */function getLContext(target){var mpValue=readPatchedData(target);if(mpValue){// only when it's an array is it considered an LView instance
	// ... otherwise it's an already constructed LContext instance
	if(Array.isArray(mpValue)){var lView=mpValue;var nodeIndex=void 0;var component=undefined;var directives=undefined;if(isComponentInstance(target)){nodeIndex=findViaComponent(lView,target);if(nodeIndex==-1){throw new Error('The provided component was not found in the application');}component=target;}else if(isDirectiveInstance(target)){nodeIndex=findViaDirective(lView,target);if(nodeIndex==-1){throw new Error('The provided directive was not found in the application');}directives=getDirectivesAtNodeIndex(nodeIndex,lView,false);}else{nodeIndex=findViaNativeElement(lView,target);if(nodeIndex==-1){return null;}}// the goal is not to fill the entire context full of data because the lookups
	// are expensive. Instead, only the target data (the element, component, container, ICU
	// expression or directive details) are filled into the context. If called multiple times
	// with different target values then the missing target data will be filled in.
	var native=unwrapRNode(lView[nodeIndex]);var existingCtx=readPatchedData(native);var context=existingCtx&&!Array.isArray(existingCtx)?existingCtx:createLContext(lView,nodeIndex,native);// only when the component has been discovered then update the monkey-patch
	if(component&&context.component===undefined){context.component=component;attachPatchData(context.component,context);}// only when the directives have been discovered then update the monkey-patch
	if(directives&&context.directives===undefined){context.directives=directives;for(var i=0;i<directives.length;i++){attachPatchData(directives[i],context);}}attachPatchData(context.native,context);mpValue=context;}}else{var rElement=target;ngDevMode&&assertDomNode(rElement);// if the context is not found then we need to traverse upwards up the DOM
	// to find the nearest element that has already been monkey patched with data
	var parent_1=rElement;while(parent_1=parent_1.parentNode){var parentContext=readPatchedData(parent_1);if(parentContext){var lView=void 0;if(Array.isArray(parentContext)){lView=parentContext;}else{lView=parentContext.lView;}// the edge of the app was also reached here through another means
	// (maybe because the DOM was changed manually).
	if(!lView){return null;}var index=findViaNativeElement(lView,rElement);if(index>=0){var native=unwrapRNode(lView[index]);var context=createLContext(lView,index,native);attachPatchData(native,context);mpValue=context;break;}}}}return mpValue||null;}/**
	 * Creates an empty instance of a `LContext` context
	 */function createLContext(lView,nodeIndex,native){return {lView:lView,nodeIndex:nodeIndex,native:native,component:undefined,directives:undefined,localRefs:undefined};}/**
	 * Assigns the given data to the given target (which could be a component,
	 * directive or DOM node instance) using monkey-patching.
	 */function attachPatchData(target,data){target[MONKEY_PATCH_KEY_NAME]=data;}function isComponentInstance(instance){return instance&&instance.constructor&&instance.constructor.ngComponentDef;}function isDirectiveInstance(instance){return instance&&instance.constructor&&instance.constructor.ngDirectiveDef;}/**
	 * Locates the element within the given LView and returns the matching index
	 */function findViaNativeElement(lView,target){var tNode=lView[TVIEW].firstChild;while(tNode){var native=getNativeByTNodeOrNull(tNode,lView);if(native===target){return tNode.index;}tNode=traverseNextElement(tNode);}return -1;}/**
	 * Locates the next tNode (child, sibling or parent).
	 */function traverseNextElement(tNode){if(tNode.child){return tNode.child;}else if(tNode.next){return tNode.next;}else{// Let's take the following template: <div><span>text</span></div><component/>
	// After checking the text node, we need to find the next parent that has a "next" TNode,
	// in this case the parent `div`, so that we can find the component.
	while(tNode.parent&&!tNode.parent.next){tNode=tNode.parent;}return tNode.parent&&tNode.parent.next;}}/**
	 * Locates the component within the given LView and returns the matching index
	 */function findViaComponent(lView,componentInstance){var componentIndices=lView[TVIEW].components;if(componentIndices){for(var i=0;i<componentIndices.length;i++){var elementComponentIndex=componentIndices[i];var componentView=getComponentViewByIndex(elementComponentIndex,lView);if(componentView[CONTEXT]===componentInstance){return elementComponentIndex;}}}else{var rootComponentView=getComponentViewByIndex(HEADER_OFFSET,lView);var rootComponent=rootComponentView[CONTEXT];if(rootComponent===componentInstance){// we are dealing with the root element here therefore we know that the
	// element is the very first element after the HEADER data in the lView
	return HEADER_OFFSET;}}return -1;}/**
	 * Locates the directive within the given LView and returns the matching index
	 */function findViaDirective(lView,directiveInstance){// if a directive is monkey patched then it will (by default)
	// have a reference to the LView of the current view. The
	// element bound to the directive being search lives somewhere
	// in the view data. We loop through the nodes and check their
	// list of directives for the instance.
	var tNode=lView[TVIEW].firstChild;while(tNode){var directiveIndexStart=tNode.directiveStart;var directiveIndexEnd=tNode.directiveEnd;for(var i=directiveIndexStart;i<directiveIndexEnd;i++){if(lView[i]===directiveInstance){return tNode.index;}}tNode=traverseNextElement(tNode);}return -1;}/**
	 * Returns a list of directives extracted from the given view based on the
	 * provided list of directive index values.
	 *
	 * @param nodeIndex The node index
	 * @param lView The target view data
	 * @param includeComponents Whether or not to include components in returned directives
	 */function getDirectivesAtNodeIndex(nodeIndex,lView,includeComponents){var tNode=lView[TVIEW].data[nodeIndex];var directiveStartIndex=tNode.directiveStart;if(directiveStartIndex==0)return EMPTY_ARRAY;var directiveEndIndex=tNode.directiveEnd;if(!includeComponents&&tNode.flags&1/* isComponent */)directiveStartIndex++;return lView.slice(directiveStartIndex,directiveEndIndex);}function getComponentAtNodeIndex(nodeIndex,lView){var tNode=lView[TVIEW].data[nodeIndex];var directiveStartIndex=tNode.directiveStart;return tNode.flags&1/* isComponent */?lView[directiveStartIndex]:null;}/**
	 * Returns a map of local references (local reference name => element or directive instance) that
	 * exist on a given element.
	 */function discoverLocalRefs(lView,nodeIndex){var tNode=lView[TVIEW].data[nodeIndex];if(tNode&&tNode.localNames){var result={};var localIndex=tNode.index+1;for(var i=0;i<tNode.localNames.length;i+=2){result[tNode.localNames[i]]=lView[localIndex];localIndex++;}return result;}return null;}/** Called when directives inject each other (creating a circular dependency) */function throwCyclicDependencyError(token){throw new Error("Cannot instantiate cyclic dependency! "+token);}function throwMixedMultiProviderError(){throw new Error("Cannot mix multi providers and regular providers");}function throwInvalidProviderError(ngModuleType,providers,provider){var ngModuleDetail='';if(ngModuleType&&providers){var providerDetail=providers.map(function(v){return v==provider?'?'+provider+'?':'...';});ngModuleDetail=" - only instances of Provider and Type are allowed, got: ["+providerDetail.join(', ')+"]";}throw new Error("Invalid provider for the NgModule '"+stringify(ngModuleType)+"'"+ngModuleDetail);}// Note: This hack is necessary so we don't erroneously get a circular dependency
	/**
	 * Runs through the provided styling context and applies each value to
	 * the provided element (via the renderer) if one or more values are present.
	 *
	 * This function will iterate over all entries present in the provided
	 * `TStylingContext` array (both prop-based and map-based bindings).-
	 *
	 * Each entry, within the `TStylingContext` array, is stored alphabetically
	 * and this means that each prop/value entry will be applied in order
	 * (so long as it is marked dirty in the provided `bitMask` value).
	 *
	 * If there are any map-based entries present (which are applied to the
	 * element via the `[style]` and `[class]` bindings) then those entries
	 * will be applied as well. However, the code for that is not a part of
	 * this function. Instead, each time a property is visited, then the
	 * code below will call an external function called `stylingMapsSyncFn`
	 * and, if present, it will keep the application of styling values in
	 * map-based bindings up to sync with the application of prop-based
	 * bindings.
	 *
	 * Visit `styling_next/map_based_bindings.ts` to learn more about how the
	 * algorithm works for map-based styling bindings.
	 *
	 * Note that this function is not designed to be called in isolation (use
	 * `applyClasses` and `applyStyles` to actually apply styling values).
	 */function applyStyling(context,renderer,element,bindingData,bitMaskValue,applyStylingFn,sanitizer){var bitMask=normalizeBitMaskValue(bitMaskValue);var stylingMapsSyncFn=getStylingMapsSyncFn();var mapsGuardMask=getGuardMask(context,3/* MapBindingsPosition */);var applyAllValues=(bitMask&mapsGuardMask)>0;var mapsMode=applyAllValues?1/* ApplyAllValues */:0/* TraverseValues */;var i=getPropValuesStartPosition(context);while(i<context.length){var valuesCount=getValuesCount(context,i);var guardMask=getGuardMask(context,i);if(bitMask&guardMask){var valueApplied=false;var prop=getProp(context,i);var valuesCountUpToDefault=valuesCount-1;var defaultValue=getBindingValue(context,i,valuesCountUpToDefault);// case 1: apply prop-based values
	// try to apply the binding values and see if a non-null
	// value gets set for the styling binding
	for(var j=0;j<valuesCountUpToDefault;j++){var bindingIndex=getBindingValue(context,i,j);var value=bindingData[bindingIndex];if(isStylingValueDefined(value)){var finalValue=sanitizer&&isSanitizationRequired(context,i)?sanitizer(prop,value,2/* SanitizeOnly */):value;applyStylingFn(renderer,element,prop,finalValue,bindingIndex);valueApplied=true;break;}}// case 2: apply map-based values
	// traverse through each map-based styling binding and update all values up to
	// the provided `prop` value. If the property was not applied in the loop above
	// then it will be attempted to be applied in the maps sync code below.
	if(stylingMapsSyncFn){// determine whether or not to apply the target property or to skip it
	var mode=mapsMode|(valueApplied?4/* SkipTargetProp */:2/* ApplyTargetProp */);var valueAppliedWithinMap=stylingMapsSyncFn(context,renderer,element,bindingData,applyStylingFn,sanitizer,mode,prop,defaultValue);valueApplied=valueApplied||valueAppliedWithinMap;}// case 3: apply the default value
	// if the value has not yet been applied then a truthy value does not exist in the
	// prop-based or map-based bindings code. If and when this happens, just apply the
	// default value (even if the default value is `null`).
	if(!valueApplied){applyStylingFn(renderer,element,prop,defaultValue);}}i+=3/* BindingsStartOffset */+valuesCount;}// the map-based styling entries may have not applied all their
	// values. For this reason, one more call to the sync function
	// needs to be issued at the end.
	if(stylingMapsSyncFn){stylingMapsSyncFn(context,renderer,element,bindingData,applyStylingFn,sanitizer,mapsMode);}}function normalizeBitMaskValue(value){// if pass => apply all values (-1 implies that all bits are flipped to true)
	if(value===true)return -1;// if pass => skip all values
	if(value===false)return 0;// return the bit mask value as is
	return value;}var _activeStylingMapApplyFn=null;function getStylingMapsSyncFn(){return _activeStylingMapApplyFn;}function setStylingMapsSyncFn(fn){_activeStylingMapApplyFn=fn;}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /** A special value which designates that a value has not changed. */var NO_CHANGE={};/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Marks that the next string is for element.
	 *
	 * See `I18nMutateOpCodes` documentation.
	 */var ELEMENT_MARKER={marker:'element'};/**
	 * Marks that the next string is for comment.
	 *
	 * See `I18nMutateOpCodes` documentation.
	 */var COMMENT_MARKER={marker:'comment'};// Note: This hack is necessary so we don't erroneously get a circular dependency
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function attachDebugObject(obj,debug){Object.defineProperty(obj,'debug',{value:debug,enumerable:false});}/**
	 * --------
	 *
	 * This file contains the algorithm logic for applying map-based bindings
	 * such as `[style]` and `[class]`.
	 *
	 * --------
	 */ /**
	 * Used to apply styling values presently within any map-based bindings on an element.
	 *
	 * Angular supports map-based styling bindings which can be applied via the
	 * `[style]` and `[class]` bindings which can be placed on any HTML element.
	 * These bindings can work independently, together or alongside prop-based
	 * styling bindings (e.g. `<div [style]="x" [style.width]="w">`).
	 *
	 * If a map-based styling binding is detected by the compiler, the following
	 * AOT code is produced:
	 *
	 * ```typescript
	 * styleMap(ctx.styles); // styles = {key:value}
	 * classMap(ctx.classes); // classes = {key:value}|string
	 * ```
	 *
	 * If and when either of the instructions above are evaluated, then the code
	 * present in this file is included into the bundle. The mechanism used, to
	 * activate support for map-based bindings at runtime is possible via the
	 * `activeStylingMapFeature` function (which is also present in this file).
	 *
	 * # The Algorithm
	 * Whenever a map-based binding updates (which is when the identity of the
	 * map-value changes) then the map is iterated over and a `StylingMapArray` array
	 * is produced. The `StylingMapArray` instance is stored in the binding location
	 * where the `BINDING_INDEX` is situated when the `styleMap()` or `classMap()`
	 * instruction were called. Once the binding changes, then the internal `bitMask`
	 * value is marked as dirty.
	 *
	 * Styling values are applied once CD exits the element (which happens when
	 * the `select(n)` instruction is called or the template function exits). When
	 * this occurs, all prop-based bindings are applied. If a map-based binding is
	 * present then a special flushing function (called a sync function) is made
	 * available and it will be called each time a styling property is flushed.
	 *
	 * The flushing algorithm is designed to apply styling for a property (which is
	 * a CSS property or a className value) one by one. If map-based bindings
	 * are present, then the flushing algorithm will keep calling the maps styling
	 * sync function each time a property is visited. This way, the flushing
	 * behavior of map-based bindings will always be at the same property level
	 * as the current prop-based property being iterated over (because everything
	 * is alphabetically sorted).
	 *
	 * Let's imagine we have the following HTML template code:
	 *
	 * ```html
	 * <div [style]="{width:'100px', height:'200px', 'z-index':'10'}"
	 *      [style.width.px]="200">...</div>
	 * ```
	 *
	 * When CD occurs, both the `[style]` and `[style.width]` bindings
	 * are evaluated. Then when the styles are flushed on screen, the
	 * following operations happen:
	 *
	 * 1. `[style.width]` is attempted to be written to the element.
	 *
	 * 2.  Once that happens, the algorithm instructs the map-based
	 *     entries (`[style]` in this case) to "catch up" and apply
	 *     all values up to the `width` value. When this happens the
	 *     `height` value is applied to the element (since it is
	 *     alphabetically situated before the `width` property).
	 *
	 * 3. Since there are no more prop-based entries anymore, the
	 *    loop exits and then, just before the flushing ends, it
	 *    instructs all map-based bindings to "finish up" applying
	 *    their values.
	 *
	 * 4. The only remaining value within the map-based entries is
	 *    the `z-index` value (`width` got skipped because it was
	 *    successfully applied via the prop-based `[style.width]`
	 *    binding). Since all map-based entries are told to "finish up",
	 *    the `z-index` value is iterated over and it is then applied
	 *    to the element.
	 *
	 * The most important thing to take note of here is that prop-based
	 * bindings are evaluated in order alongside map-based bindings.
	 * This allows all styling across an element to be applied in O(n)
	 * time (a similar algorithm is that of the array merge algorithm
	 * in merge sort).
	 */var syncStylingMap=function syncStylingMap(context,renderer,element,data,applyStylingFn,sanitizer,mode,targetProp,defaultValue){var targetPropValueWasApplied=false;// once the map-based styling code is activate it is never deactivated. For this reason a
	// check to see if the current styling context has any map based bindings is required.
	var totalMaps=getValuesCount(context,3/* MapBindingsPosition */);if(totalMaps){var runTheSyncAlgorithm=true;var loopUntilEnd=!targetProp;// If the code is told to finish up (run until the end), but the mode
	// hasn't been flagged to apply values (it only traverses values) then
	// there is no point in iterating over the array because nothing will
	// be applied to the element.
	if(loopUntilEnd&&mode&~1/* ApplyAllValues */){runTheSyncAlgorithm=false;targetPropValueWasApplied=true;}if(runTheSyncAlgorithm){targetPropValueWasApplied=innerSyncStylingMap(context,renderer,element,data,applyStylingFn,sanitizer,mode,targetProp||null,0,defaultValue||null);}if(loopUntilEnd){resetSyncCursors();}}return targetPropValueWasApplied;};/**
	 * Recursive function designed to apply map-based styling to an element one map at a time.
	 *
	 * This function is designed to be called from the `syncStylingMap` function and will
	 * apply map-based styling data one map at a time to the provided `element`.
	 *
	 * This function is recursive and it will call itself if a follow-up map value is to be
	 * processed. To learn more about how the algorithm works, see `syncStylingMap`.
	 */function innerSyncStylingMap(context,renderer,element,data,applyStylingFn,sanitizer,mode,targetProp,currentMapIndex,defaultValue){var targetPropValueWasApplied=false;var totalMaps=getValuesCount(context,3/* MapBindingsPosition */);if(currentMapIndex<totalMaps){var bindingIndex=getBindingValue(context,3/* MapBindingsPosition */,currentMapIndex);var stylingMapArr=data[bindingIndex];var cursor=getCurrentSyncCursor(currentMapIndex);while(cursor<stylingMapArr.length){var prop=getMapProp(stylingMapArr,cursor);var iteratedTooFar=targetProp&&prop>targetProp;var isTargetPropMatched=!iteratedTooFar&&prop===targetProp;var value=getMapValue(stylingMapArr,cursor);var valueIsDefined=isStylingValueDefined(value);// the recursive code is designed to keep applying until
	// it reaches or goes past the target prop. If and when
	// this happens then it will stop processing values, but
	// all other map values must also catch up to the same
	// point. This is why a recursive call is still issued
	// even if the code has iterated too far.
	var innerMode=iteratedTooFar?mode:resolveInnerMapMode(mode,valueIsDefined,isTargetPropMatched);var innerProp=iteratedTooFar?targetProp:prop;var valueApplied=innerSyncStylingMap(context,renderer,element,data,applyStylingFn,sanitizer,innerMode,innerProp,currentMapIndex+1,defaultValue);if(iteratedTooFar){if(!targetPropValueWasApplied){targetPropValueWasApplied=valueApplied;}break;}if(!valueApplied&&isValueAllowedToBeApplied(mode,isTargetPropMatched)){var useDefault=isTargetPropMatched&&!valueIsDefined;var valueToApply=useDefault?defaultValue:value;var bindingIndexToApply=useDefault?bindingIndex:null;var finalValue=sanitizer?sanitizer(prop,valueToApply,3/* ValidateAndSanitize */):valueToApply;applyStylingFn(renderer,element,prop,finalValue,bindingIndexToApply);valueApplied=true;}targetPropValueWasApplied=valueApplied&&isTargetPropMatched;cursor+=2/* TupleSize */;}setCurrentSyncCursor(currentMapIndex,cursor);// this is a fallback case in the event that the styling map is `null` for this
	// binding but there are other map-based bindings that need to be evaluated
	// afterwards. If the `prop` value is falsy then the intention is to cycle
	// through all of the properties in the remaining maps as well. If the current
	// styling map is too short then there are no values to iterate over. In either
	// case the follow-up maps need to be iterated over.
	if(stylingMapArr.length===1/* ValuesStartPosition */||!targetProp){return innerSyncStylingMap(context,renderer,element,data,applyStylingFn,sanitizer,mode,targetProp,currentMapIndex+1,defaultValue);}}return targetPropValueWasApplied;}/**
	 * Enables support for map-based styling bindings (e.g. `[style]` and `[class]` bindings).
	 */function activateStylingMapFeature(){setStylingMapsSyncFn(syncStylingMap);}/**
	 * Used to determine the mode for the inner recursive call.
	 *
	 * If an inner map is iterated on then this is done so for one
	 * of two reasons:
	 *
	 * - value is being applied:
	 *   if the value is being applied from this current styling
	 *   map then there is no need to apply it in a deeper map.
	 *
	 * - value is being not applied:
	 *   apply the value if it is found in a deeper map.
	 *
	 * When these reasons are encountered the flags will for the
	 * inner map mode will be configured.
	 */function resolveInnerMapMode(currentMode,valueIsDefined,isExactMatch){var innerMode=currentMode;if(!valueIsDefined&&!(currentMode&4/* SkipTargetProp */)&&(isExactMatch||currentMode&1/* ApplyAllValues */)){// case 1: set the mode to apply the targeted prop value if it
	// ends up being encountered in another map value
	innerMode|=2/* ApplyTargetProp */;innerMode&=~4/* SkipTargetProp */;}else{// case 2: set the mode to skip the targeted prop value if it
	// ends up being encountered in another map value
	innerMode|=4/* SkipTargetProp */;innerMode&=~2/* ApplyTargetProp */;}return innerMode;}/**
	 * Decides whether or not a prop/value entry will be applied to an element.
	 *
	 * To determine whether or not a value is to be applied,
	 * the following procedure is evaluated:
	 *
	 * First check to see the current `mode` status:
	 *  1. If the mode value permits all props to be applied then allow.
	 *    - But do not allow if the current prop is set to be skipped.
	 *  2. Otherwise if the current prop is permitted then allow.
	 */function isValueAllowedToBeApplied(mode,isTargetPropMatched){var doApplyValue=(mode&1/* ApplyAllValues */)>0;if(!doApplyValue){if(mode&2/* ApplyTargetProp */){doApplyValue=isTargetPropMatched;}}else if(mode&4/* SkipTargetProp */&&isTargetPropMatched){doApplyValue=false;}return doApplyValue;}/**
	 * Used to keep track of concurrent cursor values for multiple map-based styling bindings present on
	 * an element.
	 */var MAP_CURSORS=[];/**
	 * Used to reset the state of each cursor value being used to iterate over map-based styling
	 * bindings.
	 */function resetSyncCursors(){for(var i=0;i<MAP_CURSORS.length;i++){MAP_CURSORS[i]=1/* ValuesStartPosition */;}}/**
	 * Returns an active cursor value at a given mapIndex location.
	 */function getCurrentSyncCursor(mapIndex){if(mapIndex>=MAP_CURSORS.length){MAP_CURSORS.push(1/* ValuesStartPosition */);}return MAP_CURSORS[mapIndex];}/**
	 * Sets a cursor value at a given mapIndex location.
	 */function setCurrentSyncCursor(mapIndex,indexValue){MAP_CURSORS[mapIndex]=indexValue;}/**
	 * Converts the provided styling map array into a key value map.
	 */function stylingMapToStringMap(map$$1){var stringMap={};if(map$$1){for(var i=1/* ValuesStartPosition */;i<map$$1.length;i+=2/* TupleSize */){var prop=getMapProp(map$$1,i);var value=getMapValue(map$$1,i);stringMap[prop]=value;}}return stringMap;}/**
	 * A human-readable debug summary of the styling data present within `TStylingContext`.
	 *
	 * This class is designed to be used within testing code or when an
	 * application has `ngDevMode` activated.
	 */var TStylingContextDebug=/** @class */function(){function TStylingContextDebug(context){this.context=context;}Object.defineProperty(TStylingContextDebug.prototype,"isLocked",{get:function get(){return isContextLocked(this.context);},enumerable:true,configurable:true});Object.defineProperty(TStylingContextDebug.prototype,"entries",{/**
	         * Returns a detailed summary of each styling entry in the context.
	         *
	         * See `TStylingTupleSummary`.
	         */get:function get(){var context=this.context;var entries={};var start=3/* MapBindingsPosition */;var i=start;while(i<context.length){var valuesCount=getValuesCount(context,i);// the context may contain placeholder values which are populated ahead of time,
	// but contain no actual binding values. In this situation there is no point in
	// classifying this as an "entry" since no real data is stored here yet.
	if(valuesCount){var prop=getProp(context,i);var guardMask=getGuardMask(context,i);var defaultValue=getDefaultValue(context,i);var sanitizationRequired=isSanitizationRequired(context,i);var bindingsStartPosition=i+3/* BindingsStartOffset */;var sources=[];for(var j=0;j<valuesCount;j++){sources.push(context[bindingsStartPosition+j]);}entries[prop]={prop:prop,guardMask:guardMask,sanitizationRequired:sanitizationRequired,valuesCount:valuesCount,defaultValue:defaultValue,sources:sources};}i+=3/* BindingsStartOffset */+valuesCount;}return entries;},enumerable:true,configurable:true});return TStylingContextDebug;}();/**
	 * A human-readable debug summary of the styling data present for a `DebugNode` instance.
	 *
	 * This class is designed to be used within testing code or when an
	 * application has `ngDevMode` activated.
	 */var NodeStylingDebug=/** @class */function(){function NodeStylingDebug(context,_data,_isClassBased){this.context=context;this._data=_data;this._isClassBased=_isClassBased;this._sanitizer=null;}/**
	     * Overrides the sanitizer used to process styles.
	     */NodeStylingDebug.prototype.overrideSanitizer=function(sanitizer){this._sanitizer=sanitizer;};Object.defineProperty(NodeStylingDebug.prototype,"summary",{/**
	         * Returns a detailed summary of each styling entry in the context and
	         * what their runtime representation is.
	         *
	         * See `LStylingSummary`.
	         */get:function get(){var entries={};this._mapValues(function(prop,value,bindingIndex){entries[prop]={prop:prop,value:value,bindingIndex:bindingIndex};});return entries;},enumerable:true,configurable:true});Object.defineProperty(NodeStylingDebug.prototype,"values",{/**
	         * Returns a key/value map of all the styles/classes that were last applied to the element.
	         */get:function get(){var entries={};this._mapValues(function(prop,value){entries[prop]=value;});return entries;},enumerable:true,configurable:true});NodeStylingDebug.prototype._mapValues=function(fn){// there is no need to store/track an element instance. The
	// element is only used when the styling algorithm attempts to
	// style the value (and we mock out the stylingApplyFn anyway).
	var mockElement={};var hasMaps=getValuesCount(this.context,3/* MapBindingsPosition */)>0;if(hasMaps){activateStylingMapFeature();}var mapFn=function mapFn(renderer,element,prop,value,bindingIndex){fn(prop,value,bindingIndex||null);};var sanitizer=this._isClassBased?null:this._sanitizer||getCurrentStyleSanitizer();applyStyling(this.context,null,mockElement,this._data,true,mapFn,sanitizer);};return NodeStylingDebug;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /*
	 * This file contains conditionally attached classes which provide human readable (debug) level
	 * information for `LView`, `LContainer` and other internal data structures. These data structures
	 * are stored internally as array which makes it very difficult during debugging to reason about the
	 * current state of the system.
	 *
	 * Patching the array with extra property does change the array's hidden class' but it does not
	 * change the cost of access, therefore this patching should not have significant if any impact in
	 * `ngDevMode` mode. (see: https://jsperf.com/array-vs-monkey-patch-array)
	 *
	 * So instead of seeing:
	 * ```
	 * Array(30) [Object, 659, null, â¦]
	 * ```
	 *
	 * You get to see:
	 * ```
	 * LViewDebug {
	 *   views: [...],
	 *   flags: {attached: true, ...}
	 *   nodes: [
	 *     {html: '<div id="123">', ..., nodes: [
	 *       {html: '<span>', ..., nodes: null}
	 *     ]}
	 *   ]
	 * }
	 * ```
	 */var LViewArray=ngDevMode&&createNamedArrayType('LView');var LVIEW_EMPTY;// can't initialize here or it will not be tree shaken, because `LView`
	// constructor could have side-effects.
	/**
	 * This function clones a blueprint and creates LView.
	 *
	 * Simple slice will keep the same type, and we need it to be LView
	 */function cloneToLView(list){if(LVIEW_EMPTY===undefined)LVIEW_EMPTY=new LViewArray();return LVIEW_EMPTY.concat(list);}/**
	 * This class is a debug version of Object literal so that we can have constructor name show up in
	 * debug tools in ngDevMode.
	 */var TViewConstructor=/** @class */function(){function TView(id,//
	blueprint,//
	template,//
	queries,//
	viewQuery,//
	node,//
	data,//
	bindingStartIndex,//
	expandoStartIndex,//
	expandoInstructions,//
	firstTemplatePass,//
	staticViewQueries,//
	staticContentQueries,//
	preOrderHooks,//
	preOrderCheckHooks,//
	contentHooks,//
	contentCheckHooks,//
	viewHooks,//
	viewCheckHooks,//
	destroyHooks,//
	cleanup,//
	contentQueries,//
	components,//
	directiveRegistry,//
	pipeRegistry,//
	firstChild,//
	schemas){this.id=id;this.blueprint=blueprint;this.template=template;this.queries=queries;this.viewQuery=viewQuery;this.node=node;this.data=data;this.bindingStartIndex=bindingStartIndex;this.expandoStartIndex=expandoStartIndex;this.expandoInstructions=expandoInstructions;this.firstTemplatePass=firstTemplatePass;this.staticViewQueries=staticViewQueries;this.staticContentQueries=staticContentQueries;this.preOrderHooks=preOrderHooks;this.preOrderCheckHooks=preOrderCheckHooks;this.contentHooks=contentHooks;this.contentCheckHooks=contentCheckHooks;this.viewHooks=viewHooks;this.viewCheckHooks=viewCheckHooks;this.destroyHooks=destroyHooks;this.cleanup=cleanup;this.contentQueries=contentQueries;this.components=components;this.directiveRegistry=directiveRegistry;this.pipeRegistry=pipeRegistry;this.firstChild=firstChild;this.schemas=schemas;}return TView;}();var TNodeConstructor=/** @class */function(){function TNode(tView_,//
	type,//
	index,//
	injectorIndex,//
	directiveStart,//
	directiveEnd,//
	propertyMetadataStartIndex,//
	propertyMetadataEndIndex,//
	flags,//
	providerIndexes,//
	tagName,//
	attrs,//
	localNames,//
	initialInputs,//
	inputs,//
	outputs,//
	tViews,//
	next,//
	projectionNext,//
	child,//
	parent,//
	projection,//
	styles,//
	classes){this.tView_=tView_;this.type=type;this.index=index;this.injectorIndex=injectorIndex;this.directiveStart=directiveStart;this.directiveEnd=directiveEnd;this.propertyMetadataStartIndex=propertyMetadataStartIndex;this.propertyMetadataEndIndex=propertyMetadataEndIndex;this.flags=flags;this.providerIndexes=providerIndexes;this.tagName=tagName;this.attrs=attrs;this.localNames=localNames;this.initialInputs=initialInputs;this.inputs=inputs;this.outputs=outputs;this.tViews=tViews;this.next=next;this.projectionNext=projectionNext;this.child=child;this.parent=parent;this.projection=projection;this.styles=styles;this.classes=classes;}Object.defineProperty(TNode.prototype,"type_",{get:function get(){switch(this.type){case 0/* Container */:return 'TNodeType.Container';case 3/* Element */:return 'TNodeType.Element';case 4/* ElementContainer */:return 'TNodeType.ElementContainer';case 5/* IcuContainer */:return 'TNodeType.IcuContainer';case 1/* Projection */:return 'TNodeType.Projection';case 2/* View */:return 'TNodeType.View';default:return 'TNodeType.???';}},enumerable:true,configurable:true});Object.defineProperty(TNode.prototype,"flags_",{get:function get(){var flags=[];if(this.flags&8/* hasClassInput */)flags.push('TNodeFlags.hasClassInput');if(this.flags&4/* hasContentQuery */)flags.push('TNodeFlags.hasContentQuery');if(this.flags&16/* hasStyleInput */)flags.push('TNodeFlags.hasStyleInput');if(this.flags&1/* isComponent */)flags.push('TNodeFlags.isComponent');if(this.flags&32/* isDetached */)flags.push('TNodeFlags.isDetached');if(this.flags&2/* isProjected */)flags.push('TNodeFlags.isProjected');return flags.join('|');},enumerable:true,configurable:true});return TNode;}();var TViewData=ngDevMode&&createNamedArrayType('TViewData');var TVIEWDATA_EMPTY;// can't initialize here or it will not be tree shaken, because `LView`
	// constructor could have side-effects.
	/**
	 * This function clones a blueprint and creates TData.
	 *
	 * Simple slice will keep the same type, and we need it to be TData
	 */function cloneToTViewData(list){if(TVIEWDATA_EMPTY===undefined)TVIEWDATA_EMPTY=new TViewData();return TVIEWDATA_EMPTY.concat(list);}var LViewBlueprint=ngDevMode&&createNamedArrayType('LViewBlueprint');var MatchesArray=ngDevMode&&createNamedArrayType('MatchesArray');var TViewComponents=ngDevMode&&createNamedArrayType('TViewComponents');var TNodeLocalNames=ngDevMode&&createNamedArrayType('TNodeLocalNames');var TNodeInitialInputs=ngDevMode&&createNamedArrayType('TNodeInitialInputs');var TNodeInitialData=ngDevMode&&createNamedArrayType('TNodeInitialData');var LCleanup=ngDevMode&&createNamedArrayType('LCleanup');var TCleanup=ngDevMode&&createNamedArrayType('TCleanup');function attachLViewDebug(lView){attachDebugObject(lView,new LViewDebug(lView));}function toDebug(obj){if(obj){var debug=obj.debug;assertDefined(debug,'Object does not have a debug representation.');return debug;}else{return obj;}}/**
	 * Use this method to unwrap a native element in `LView` and convert it into HTML for easier
	 * reading.
	 *
	 * @param value possibly wrapped native DOM node.
	 * @param includeChildren If `true` then the serialized HTML form will include child elements (same
	 * as `outerHTML`). If `false` then the serialized HTML form will only contain the element itself
	 * (will not serialize child elements).
	 */function toHtml(value,includeChildren){if(includeChildren===void 0){includeChildren=false;}var node=unwrapRNode(value);if(node){var isTextNode=node.nodeType===Node.TEXT_NODE;var outerHTML=(isTextNode?node.textContent:node.outerHTML)||'';if(includeChildren||isTextNode){return outerHTML;}else{var innerHTML=node.innerHTML;return outerHTML.split(innerHTML)[0]||null;}}else{return null;}}var LViewDebug=/** @class */function(){function LViewDebug(_raw_lView){this._raw_lView=_raw_lView;}Object.defineProperty(LViewDebug.prototype,"flags",{/**
	         * Flags associated with the `LView` unpacked into a more readable state.
	         */get:function get(){var flags=this._raw_lView[FLAGS];return {__raw__flags__:flags,initPhaseState:flags&3/* InitPhaseStateMask */,creationMode:!!(flags&4/* CreationMode */),firstViewPass:!!(flags&8/* FirstLViewPass */),checkAlways:!!(flags&16/* CheckAlways */),dirty:!!(flags&64/* Dirty */),attached:!!(flags&128/* Attached */),destroyed:!!(flags&256/* Destroyed */),isRoot:!!(flags&512/* IsRoot */),indexWithinInitPhase:flags>>10/* IndexWithinInitPhaseShift */};},enumerable:true,configurable:true});Object.defineProperty(LViewDebug.prototype,"parent",{get:function get(){return toDebug(this._raw_lView[PARENT]);},enumerable:true,configurable:true});Object.defineProperty(LViewDebug.prototype,"host",{get:function get(){return toHtml(this._raw_lView[HOST],true);},enumerable:true,configurable:true});Object.defineProperty(LViewDebug.prototype,"context",{get:function get(){return this._raw_lView[CONTEXT];},enumerable:true,configurable:true});Object.defineProperty(LViewDebug.prototype,"nodes",{/**
	         * The tree of nodes associated with the current `LView`. The nodes have been normalized into a
	         * tree structure with relevant details pulled out for readability.
	         */get:function get(){var lView=this._raw_lView;var tNode=lView[TVIEW].firstChild;return toDebugNodes(tNode,lView);},enumerable:true,configurable:true});Object.defineProperty(LViewDebug.prototype,"__other__",{/**
	         * Additional information which is hidden behind a property. The extra level of indirection is
	         * done so that the debug view would not be cluttered with properties which are only rarely
	         * relevant to the developer.
	         */get:function get(){return {tView:this._raw_lView[TVIEW],cleanup:this._raw_lView[CLEANUP],injector:this._raw_lView[INJECTOR$1],rendererFactory:this._raw_lView[RENDERER_FACTORY],renderer:this._raw_lView[RENDERER],sanitizer:this._raw_lView[SANITIZER],childHead:toDebug(this._raw_lView[CHILD_HEAD]),next:toDebug(this._raw_lView[NEXT]),childTail:toDebug(this._raw_lView[CHILD_TAIL]),declarationView:toDebug(this._raw_lView[DECLARATION_VIEW]),queries:null,tHost:this._raw_lView[T_HOST],bindingIndex:this._raw_lView[BINDING_INDEX]};},enumerable:true,configurable:true});Object.defineProperty(LViewDebug.prototype,"childViews",{/**
	         * Normalized view of child views (and containers) attached at this location.
	         */get:function get(){var childViews=[];var child=this.__other__.childHead;while(child){childViews.push(child);child=child.__other__.next;}return childViews;},enumerable:true,configurable:true});return LViewDebug;}();/**
	 * Turns a flat list of nodes into a tree by walking the associated `TNode` tree.
	 *
	 * @param tNode
	 * @param lView
	 */function toDebugNodes(tNode,lView){if(tNode){var debugNodes=[];var tNodeCursor=tNode;while(tNodeCursor){var rawValue=lView[tNode.index];var native=unwrapRNode(rawValue);var componentLViewDebug=toDebug(readLViewValue(rawValue));var styles=isStylingContext(tNode.styles)?new NodeStylingDebug(tNode.styles,lView):null;var classes=isStylingContext(tNode.classes)?new NodeStylingDebug(tNode.classes,lView,true):null;debugNodes.push({html:toHtml(native),native:native,styles:styles,classes:classes,nodes:toDebugNodes(tNode.child,lView),component:componentLViewDebug});tNodeCursor=tNodeCursor.next;}return debugNodes;}else{return null;}}var LContainerDebug=/** @class */function(){function LContainerDebug(_raw_lContainer){this._raw_lContainer=_raw_lContainer;}Object.defineProperty(LContainerDebug.prototype,"activeIndex",{get:function get(){return this._raw_lContainer[ACTIVE_INDEX];},enumerable:true,configurable:true});Object.defineProperty(LContainerDebug.prototype,"views",{get:function get(){return this._raw_lContainer.slice(CONTAINER_HEADER_OFFSET).map(toDebug);},enumerable:true,configurable:true});Object.defineProperty(LContainerDebug.prototype,"parent",{get:function get(){return toDebug(this._raw_lContainer[PARENT]);},enumerable:true,configurable:true});Object.defineProperty(LContainerDebug.prototype,"movedViews",{get:function get(){return this._raw_lContainer[MOVED_VIEWS];},enumerable:true,configurable:true});Object.defineProperty(LContainerDebug.prototype,"host",{get:function get(){return this._raw_lContainer[HOST];},enumerable:true,configurable:true});Object.defineProperty(LContainerDebug.prototype,"native",{get:function get(){return this._raw_lContainer[NATIVE];},enumerable:true,configurable:true});Object.defineProperty(LContainerDebug.prototype,"__other__",{get:function get(){return {next:toDebug(this._raw_lContainer[NEXT])};},enumerable:true,configurable:true});return LContainerDebug;}();/**
	 * Return an `LView` value if found.
	 *
	 * @param value `LView` if any
	 */function readLViewValue(value){while(Array.isArray(value)){// This check is not quite right, as it does not take into account `StylingContext`
	// This is why it is in debug, not in util.ts
	if(value.length>=HEADER_OFFSET-1)return value;value=value[HOST];}return null;}var I18NDebugItem=/** @class */function(){function I18NDebugItem(__raw_opCode,_lView,nodeIndex,type){this.__raw_opCode=__raw_opCode;this._lView=_lView;this.nodeIndex=nodeIndex;this.type=type;}Object.defineProperty(I18NDebugItem.prototype,"tNode",{get:function get(){return getTNode(this.nodeIndex,this._lView);},enumerable:true,configurable:true});return I18NDebugItem;}();var I18nMutateOpCodesDebug=/** @class */function(){function I18nMutateOpCodesDebug(__raw_opCodes,__lView){this.__raw_opCodes=__raw_opCodes;this.__lView=__lView;}Object.defineProperty(I18nMutateOpCodesDebug.prototype,"operations",{/**
	         * A list of operation information about how the OpCodes will act on the view.
	         */get:function get(){var _a=this,__lView=_a.__lView,__raw_opCodes=_a.__raw_opCodes;var results=[];for(var i=0;i<__raw_opCodes.length;i++){var opCode=__raw_opCodes[i];var result=void 0;if(typeof opCode==='string'){result={__raw_opCode:opCode,type:'Create Text Node',nodeIndex:__raw_opCodes[++i],text:opCode};}if(typeof opCode==='number'){switch(opCode&7/* MASK_OPCODE */){case 1/* AppendChild */:var destinationNodeIndex=opCode>>>17/* SHIFT_PARENT */;result=new I18NDebugItem(opCode,__lView,destinationNodeIndex,'AppendChild');break;case 0/* Select */:var nodeIndex=opCode>>>3/* SHIFT_REF */;result=new I18NDebugItem(opCode,__lView,nodeIndex,'Select');break;case 5/* ElementEnd */:var elementIndex=opCode>>>3/* SHIFT_REF */;result=new I18NDebugItem(opCode,__lView,elementIndex,'ElementEnd');break;case 4/* Attr */:elementIndex=opCode>>>3/* SHIFT_REF */;result=new I18NDebugItem(opCode,__lView,elementIndex,'Attr');result['attrName']=__raw_opCodes[++i];result['attrValue']=__raw_opCodes[++i];break;}}if(!result){switch(opCode){case COMMENT_MARKER:result={__raw_opCode:opCode,type:'COMMENT_MARKER',commentValue:__raw_opCodes[++i],nodeIndex:__raw_opCodes[++i]};break;case ELEMENT_MARKER:result={__raw_opCode:opCode,type:'ELEMENT_MARKER'};break;}}if(!result){result={__raw_opCode:opCode,type:'Unknown Op Code',code:opCode};}results.push(result);}return results;},enumerable:true,configurable:true});return I18nMutateOpCodesDebug;}();var I18nUpdateOpCodesDebug=/** @class */function(){function I18nUpdateOpCodesDebug(__raw_opCodes,icus,__lView){this.__raw_opCodes=__raw_opCodes;this.icus=icus;this.__lView=__lView;}Object.defineProperty(I18nUpdateOpCodesDebug.prototype,"operations",{/**
	         * A list of operation information about how the OpCodes will act on the view.
	         */get:function get(){var _a=this,__lView=_a.__lView,__raw_opCodes=_a.__raw_opCodes,icus=_a.icus;var results=[];for(var i=0;i<__raw_opCodes.length;i++){// bit code to check if we should apply the next update
	var checkBit=__raw_opCodes[i];// Number of opCodes to skip until next set of update codes
	var skipCodes=__raw_opCodes[++i];var value='';for(var j=i+1;j<=i+skipCodes;j++){var opCode=__raw_opCodes[j];if(typeof opCode==='string'){value+=opCode;}else if(typeof opCode=='number'){if(opCode<0){// It's a binding index whose value is negative
	// We cannot know the value of the binding so we only show the index
	value+="\uFFFD"+(-opCode-1)+"\uFFFD";}else{var nodeIndex=opCode>>>2/* SHIFT_REF */;var tIcuIndex=void 0;var tIcu=void 0;switch(opCode&3/* MASK_OPCODE */){case 1/* Attr */:var attrName=__raw_opCodes[++j];var sanitizeFn=__raw_opCodes[++j];results.push({__raw_opCode:opCode,checkBit:checkBit,type:'Attr',attrValue:value,attrName:attrName,sanitizeFn:sanitizeFn});break;case 0/* Text */:results.push({__raw_opCode:opCode,checkBit:checkBit,type:'Text',nodeIndex:nodeIndex,text:value});break;case 2/* IcuSwitch */:tIcuIndex=__raw_opCodes[++j];tIcu=icus[tIcuIndex];var result=new I18NDebugItem(opCode,__lView,nodeIndex,'IcuSwitch');result['tIcuIndex']=tIcuIndex;result['checkBit']=checkBit;result['mainBinding']=value;result['tIcu']=tIcu;results.push(result);break;case 3/* IcuUpdate */:tIcuIndex=__raw_opCodes[++j];tIcu=icus[tIcuIndex];result=new I18NDebugItem(opCode,__lView,nodeIndex,'IcuUpdate');result['tIcuIndex']=tIcuIndex;result['checkBit']=checkBit;result['tIcu']=tIcu;results.push(result);break;}}}}i+=skipCodes;}return results;},enumerable:true,configurable:true});return I18nUpdateOpCodesDebug;}();function selectInternal(lView,index){// Flush the initial hooks for elements in the view that have been added up to this point.
	executePreOrderHooks(lView,lView[TVIEW],getCheckNoChangesMode(),index);// We must set the selected index *after* running the hooks, because hooks may have side-effects
	}var Éµ0$5=function Éµ0$5(){return Promise.resolve(null);};/**
	 * A permanent marker promise which signifies that the current CD tree is
	 * clean.
	 */var _CLEAN_PROMISE=Éµ0$5();/**
	 * Refreshes the view, executing the following steps in that order:
	 * triggers init hooks, refreshes dynamic embedded views, triggers content hooks, sets host
	 * bindings, refreshes child components.
	 * Note: view hooks are triggered later when leaving the view.
	 */function refreshDescendantViews(lView){var tView=lView[TVIEW];var creationMode=isCreationMode(lView);// This needs to be set before children are processed to support recursive components
	tView.firstTemplatePass=false;// Resetting the bindingIndex of the current LView as the next steps may trigger change detection.
	lView[BINDING_INDEX]=tView.bindingStartIndex;// If this is a creation pass, we should not call lifecycle hooks or evaluate bindings.
	// This will be done in the update pass.
	if(!creationMode){var checkNoChangesMode=getCheckNoChangesMode();executePreOrderHooks(lView,tView,checkNoChangesMode,undefined);refreshDynamicEmbeddedViews(lView);// Content query results must be refreshed before content hooks are called.
	refreshContentQueries(tView,lView);resetPreOrderHookFlags(lView);executeHooks(lView,tView.contentHooks,tView.contentCheckHooks,checkNoChangesMode,1/* AfterContentInitHooksToBeRun */,undefined);setHostBindings(tView,lView);}// We resolve content queries specifically marked as `static` in creation mode. Dynamic
	// content queries are resolved during change detection (i.e. update mode), after embedded
	// views are refreshed (see block above).
	if(creationMode&&tView.staticContentQueries){refreshContentQueries(tView,lView);}// We must materialize query results before child components are processed
	// in case a child component has projected a container. The LContainer needs
	// to exist so the embedded views are properly attached by the container.
	if(!creationMode||tView.staticViewQueries){executeViewQueryFn(2/* Update */,tView,lView[CONTEXT]);}refreshChildComponents(lView,tView.components);}/** Sets the host bindings for the current view. */function setHostBindings(tView,viewData){try{if(tView.expandoInstructions){var bindingRootIndex=viewData[BINDING_INDEX]=tView.expandoStartIndex;setBindingRoot(bindingRootIndex);var currentDirectiveIndex=-1;var currentElementIndex=-1;for(var i=0;i<tView.expandoInstructions.length;i++){var instruction=tView.expandoInstructions[i];if(typeof instruction==='number'){if(instruction<=0){// Negative numbers mean that we are starting new EXPANDO block and need to update
	// the current element and directive index.
	currentElementIndex=-instruction;var providerCount=tView.expandoInstructions[++i];bindingRootIndex+=INJECTOR_BLOOM_PARENT_SIZE+providerCount;currentDirectiveIndex=bindingRootIndex;}else{// This is either the injector size (so the binding root can skip over directives
	// and get to the first set of host bindings on this node) or the host var count
	// (to get to the next set of host bindings on this node).
	bindingRootIndex+=instruction;}setBindingRoot(bindingRootIndex);}else{// If it's not a number, it's a host binding function that needs to be executed.
	if(instruction!==null){viewData[BINDING_INDEX]=bindingRootIndex;var hostCtx=unwrapRNode(viewData[currentDirectiveIndex]);instruction(2/* Update */,hostCtx,currentElementIndex);// Each directive gets a uniqueId value that is the same for both
	}currentDirectiveIndex++;}}}}finally{}}/** Refreshes all content queries declared by directives in a given view */function refreshContentQueries(tView,lView){var contentQueries=tView.contentQueries;if(contentQueries!==null){for(var i=0;i<contentQueries.length;i+=2){var queryStartIdx=contentQueries[i];var directiveDefIdx=contentQueries[i+1];if(directiveDefIdx!==-1){var directiveDef=tView.data[directiveDefIdx];ngDevMode&&assertDefined(directiveDef.contentQueries,'contentQueries function should be defined');directiveDef.contentQueries(2/* Update */,lView[directiveDefIdx],directiveDefIdx);}}}}/** Refreshes child components in the current view. */function refreshChildComponents(hostLView,components){if(components!=null){for(var i=0;i<components.length;i++){componentRefresh(hostLView,components[i]);}}}/**
	 * Creates a native element from a tag name, using a renderer.
	 * @param name the tag name
	 * @param overriddenRenderer Optional A renderer to override the default one
	 * @returns the element created
	 */function elementCreate(name,overriddenRenderer){var native;var rendererToUse=overriddenRenderer||getLView()[RENDERER];var namespace=getNamespace();if(isProceduralRenderer(rendererToUse)){native=rendererToUse.createElement(name,namespace);}else{if(namespace===null){native=rendererToUse.createElement(name);}else{native=rendererToUse.createElementNS(namespace,name);}}return native;}function createLView(parentLView,tView,context,flags,host,tHostNode,rendererFactory,renderer,sanitizer,injector){var lView=ngDevMode?cloneToLView(tView.blueprint):tView.blueprint.slice();lView[HOST]=host;lView[FLAGS]=flags|4/* CreationMode */|128/* Attached */|8/* FirstLViewPass */;resetPreOrderHookFlags(lView);lView[PARENT]=lView[DECLARATION_VIEW]=parentLView;lView[CONTEXT]=context;lView[RENDERER_FACTORY]=rendererFactory||parentLView&&parentLView[RENDERER_FACTORY];ngDevMode&&assertDefined(lView[RENDERER_FACTORY],'RendererFactory is required');lView[RENDERER]=renderer||parentLView&&parentLView[RENDERER];ngDevMode&&assertDefined(lView[RENDERER],'Renderer is required');lView[SANITIZER]=sanitizer||parentLView&&parentLView[SANITIZER]||null;lView[INJECTOR$1]=injector||parentLView&&parentLView[INJECTOR$1]||null;lView[T_HOST]=tHostNode;ngDevMode&&attachLViewDebug(lView);return lView;}function getOrCreateTNode(tView,tHostNode,index,type,name,attrs){// Keep this function short, so that the VM will inline it.
	var adjustedIndex=index+HEADER_OFFSET;var tNode=tView.data[adjustedIndex]||createTNodeAtIndex(tView,tHostNode,adjustedIndex,type,name,attrs,index);setPreviousOrParentTNode(tNode,true);return tNode;}function createTNodeAtIndex(tView,tHostNode,adjustedIndex,type,name,attrs,index){var previousOrParentTNode=getPreviousOrParentTNode();var isParent=getIsParent();var parent=isParent?previousOrParentTNode:previousOrParentTNode&&previousOrParentTNode.parent;// Parents cannot cross component boundaries because components will be used in multiple places,
	// so it's only set if the view is the same.
	var parentInSameView=parent&&parent!==tHostNode;var tParentNode=parentInSameView?parent:null;var tNode=tView.data[adjustedIndex]=createTNode(tView,tParentNode,type,adjustedIndex,name,attrs);// The first node is not always the one at index 0, in case of i18n, index 0 can be the
	// instruction `i18nStart` and the first node has the index 1 or more
	if(index===0||!tView.firstChild){tView.firstChild=tNode;}// Now link ourselves into the tree.
	if(previousOrParentTNode){if(isParent&&previousOrParentTNode.child==null&&(tNode.parent!==null||previousOrParentTNode.type===2/* View */)){// We are in the same view, which means we are adding content node to the parent view.
	previousOrParentTNode.child=tNode;}else if(!isParent){previousOrParentTNode.next=tNode;}}return tNode;}function assignTViewNodeToLView(tView,tParentNode,index,lView){// View nodes are not stored in data because they can be added / removed at runtime (which
	// would cause indices to change). Their TNodes are instead stored in tView.node.
	var tNode=tView.node;if(tNode==null){ngDevMode&&tParentNode&&assertNodeOfPossibleTypes(tParentNode,3/* Element */,0/* Container */);tView.node=tNode=createTNode(tView,tParentNode,//
	2/* View */,index,null,null);}return lView[T_HOST]=tNode;}/**
	 * Used for rendering embedded views (e.g. dynamically created views)
	 *
	 * Dynamically created views must store/retrieve their TViews differently from component views
	 * because their template functions are nested in the template functions of their hosts, creating
	 * closures. If their host template happens to be an embedded template in a loop (e.g. ngFor
	 * inside
	 * an ngFor), the nesting would mean we'd have multiple instances of the template function, so we
	 * can't store TViews in the template function itself (as we do for comps). Instead, we store the
	 * TView for dynamically created views on their host TNode, which only has one instance.
	 */function renderEmbeddedTemplate(viewToRender,tView,context){var _isParent=getIsParent();var _previousOrParentTNode=getPreviousOrParentTNode();var oldView;if(viewToRender[FLAGS]&512/* IsRoot */){// This is a root view inside the view tree
	tickRootContext(getRootContext(viewToRender));}else{// Will become true if the `try` block executes with no errors.
	var safeToRunHooks=false;try{setPreviousOrParentTNode(null,true);oldView=enterView(viewToRender,viewToRender[T_HOST]);resetPreOrderHookFlags(viewToRender);executeTemplate(viewToRender,tView.template,getRenderFlags(viewToRender),context);// This must be set to false immediately after the first creation run because in an
	// ngFor loop, all the views will be created together before update mode runs and turns
	// off firstTemplatePass. If we don't set it here, instances will perform directive
	// matching, etc again and again.
	tView.firstTemplatePass=false;refreshDescendantViews(viewToRender);safeToRunHooks=true;}finally{leaveView(oldView,safeToRunHooks);setPreviousOrParentTNode(_previousOrParentTNode,_isParent);}}}function renderComponentOrTemplate(hostView,context,templateFn){var rendererFactory=hostView[RENDERER_FACTORY];var oldView=enterView(hostView,hostView[T_HOST]);var normalExecutionPath=!getCheckNoChangesMode();var creationModeIsActive=isCreationMode(hostView);// Will become true if the `try` block executes with no errors.
	var safeToRunHooks=false;try{if(normalExecutionPath&&!creationModeIsActive&&rendererFactory.begin){rendererFactory.begin();}if(creationModeIsActive){// creation mode pass
	templateFn&&executeTemplate(hostView,templateFn,1/* Create */,context);refreshDescendantViews(hostView);hostView[FLAGS]&=~4/* CreationMode */;}// update mode pass
	resetPreOrderHookFlags(hostView);templateFn&&executeTemplate(hostView,templateFn,2/* Update */,context);refreshDescendantViews(hostView);safeToRunHooks=true;}finally{if(normalExecutionPath&&!creationModeIsActive&&rendererFactory.end){rendererFactory.end();}leaveView(oldView,safeToRunHooks);}}function executeTemplate(lView,templateFn,rf,context){namespaceHTMLInternal();try{if(rf&2/* Update */){// When we're updating, have an inherent ÉµÉµselect(0) so we don't have to generate that
	// instruction for most update blocks
	selectInternal(lView,0);}templateFn(rf,context);}finally{}}/**
	 * This function returns the default configuration of rendering flags depending on when the
	 * template is in creation mode or update mode. Update block and create block are
	 * always run separately.
	 */function getRenderFlags(view){return isCreationMode(view)?1/* Create */:2/* Update */;}//////////////////////////
	/**
	 * Gets TView from a template function or creates a new TView
	 * if it doesn't already exist.
	 *
	 * @param def ComponentDef
	 * @returns TView
	 */function getOrCreateTView(def){return def.tView||(def.tView=createTView(-1,def.template,def.consts,def.vars,def.directiveDefs,def.pipeDefs,def.viewQuery,def.schemas));}/**
	 * Creates a TView instance
	 *
	 * @param viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic
	 * @param templateFn Template function
	 * @param consts The number of nodes, local refs, and pipes in this template
	 * @param directives Registry of directives for this view
	 * @param pipes Registry of pipes for this view
	 * @param viewQuery View queries for this view
	 * @param schemas Schemas for this view
	 */function createTView(viewIndex,templateFn,consts,vars,directives,pipes,viewQuery,schemas){ngDevMode&&ngDevMode.tView++;var bindingStartIndex=HEADER_OFFSET+consts;// This length does not yet contain host bindings from child directives because at this point,
	// we don't know which directives are active on this template. As soon as a directive is matched
	// that has a host binding, we will update the blueprint with that def's hostVars count.
	var initialViewLength=bindingStartIndex+vars;var blueprint=createViewBlueprint(bindingStartIndex,initialViewLength);return blueprint[TVIEW]=ngDevMode?new TViewConstructor(viewIndex,// id: number,
	blueprint,// blueprint: LView,
	templateFn,// template: ComponentTemplate<{}>|null,
	null,// queries: TQueries|null
	viewQuery,// viewQuery: ViewQueriesFunction<{}>|null,
	null,// node: TViewNode|TElementNode|null,
	cloneToTViewData(blueprint).fill(null,bindingStartIndex),// data: TData,
	bindingStartIndex,// bindingStartIndex: number,
	initialViewLength,// expandoStartIndex: number,
	null,// expandoInstructions: ExpandoInstructions|null,
	true,// firstTemplatePass: boolean,
	false,// staticViewQueries: boolean,
	false,// staticContentQueries: boolean,
	null,// preOrderHooks: HookData|null,
	null,// preOrderCheckHooks: HookData|null,
	null,// contentHooks: HookData|null,
	null,// contentCheckHooks: HookData|null,
	null,// viewHooks: HookData|null,
	null,// viewCheckHooks: HookData|null,
	null,// destroyHooks: HookData|null,
	null,// cleanup: any[]|null,
	null,// contentQueries: number[]|null,
	null,// components: number[]|null,
	typeof directives==='function'?directives():directives,// directiveRegistry: DirectiveDefList|null,
	typeof pipes==='function'?pipes():pipes,// pipeRegistry: PipeDefList|null,
	null,// firstChild: TNode|null,
	schemas):{id:viewIndex,blueprint:blueprint,template:templateFn,queries:null,viewQuery:viewQuery,node:null,data:blueprint.slice().fill(null,bindingStartIndex),bindingStartIndex:bindingStartIndex,expandoStartIndex:initialViewLength,expandoInstructions:null,firstTemplatePass:true,staticViewQueries:false,staticContentQueries:false,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:typeof directives==='function'?directives():directives,pipeRegistry:typeof pipes==='function'?pipes():pipes,firstChild:null,schemas:schemas};}function createViewBlueprint(bindingStartIndex,initialViewLength){var blueprint=new(ngDevMode?LViewBlueprint:Array)(initialViewLength).fill(null,0,bindingStartIndex).fill(NO_CHANGE,bindingStartIndex);blueprint[BINDING_INDEX]=bindingStartIndex;return blueprint;}function createError(text,token){return new Error("Renderer: "+text+" ["+stringifyForError(token)+"]");}/**
	 * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.
	 *
	 * @param elementOrSelector Render element or CSS selector to locate the element.
	 */function locateHostElement(factory,elementOrSelector){var defaultRenderer=factory.createRenderer(null,null);var rNode=typeof elementOrSelector==='string'?isProceduralRenderer(defaultRenderer)?defaultRenderer.selectRootElement(elementOrSelector):defaultRenderer.querySelector(elementOrSelector):elementOrSelector;if(ngDevMode&&!rNode){if(typeof elementOrSelector==='string'){throw createError('Host node with selector not found:',elementOrSelector);}else{throw createError('Host node is required:',elementOrSelector);}}return rNode;}/**
	 * Saves the cleanup function itself in LView.cleanupInstances.
	 *
	 * This is necessary for functions that are wrapped with their contexts, like in renderer2
	 * listeners.
	 *
	 * On the first template pass, the index of the cleanup function is saved in TView.
	 */function storeCleanupFn(view,cleanupFn){getCleanup(view).push(cleanupFn);if(view[TVIEW].firstTemplatePass){getTViewCleanup(view).push(view[CLEANUP].length-1,null);}}/**
	 * Constructs a TNode object from the arguments.
	 *
	 * @param tView `TView` to which this `TNode` belongs (used only in `ngDevMode`)
	 * @param type The type of the node
	 * @param adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET
	 * @param tagName The tag name of the node
	 * @param attrs The attributes defined on this node
	 * @param tViews Any TViews attached to this node
	 * @returns the TNode object
	 */function createTNode(tView,tParent,type,adjustedIndex,tagName,attrs){ngDevMode&&ngDevMode.tNode++;var injectorIndex=tParent?tParent.injectorIndex:-1;return ngDevMode?new TNodeConstructor(tView,// tView_: TView
	type,// type: TNodeType
	adjustedIndex,// index: number
	injectorIndex,// injectorIndex: number
	-1,// directiveStart: number
	-1,// directiveEnd: number
	-1,// propertyMetadataStartIndex: number
	-1,// propertyMetadataEndIndex: number
	0,// flags: TNodeFlags
	0,// providerIndexes: TNodeProviderIndexes
	tagName,// tagName: string|null
	attrs,// attrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null
	null,// localNames: (string|number)[]|null
	undefined,// initialInputs: (string[]|null)[]|null|undefined
	undefined,// inputs: PropertyAliases|null|undefined
	undefined,// outputs: PropertyAliases|null|undefined
	null,// tViews: ITView|ITView[]|null
	null,// next: ITNode|null
	null,// projectionNext: ITNode|null
	null,// child: ITNode|null
	tParent,// parent: TElementNode|TContainerNode|null
	null,// projection: number|(ITNode|RNode[])[]|null
	null,// styles: TStylingContext|null
	null):{type:type,index:adjustedIndex,injectorIndex:injectorIndex,directiveStart:-1,directiveEnd:-1,propertyMetadataStartIndex:-1,propertyMetadataEndIndex:-1,flags:0,providerIndexes:0,tagName:tagName,attrs:attrs,localNames:null,initialInputs:undefined,inputs:undefined,outputs:undefined,tViews:null,next:null,projectionNext:null,child:null,parent:tParent,projection:null,styles:null,classes:null};}/**
	 * Instantiate a root component.
	 */function instantiateRootComponent(tView,viewData,def){var rootTNode=getPreviousOrParentTNode();if(tView.firstTemplatePass){if(def.providersResolver)def.providersResolver(def);generateExpandoInstructionBlock(tView,rootTNode,1);baseResolveDirective(tView,viewData,def,def.factory);}var directive=getNodeInjectable(tView.data,viewData,viewData.length-1,rootTNode);postProcessBaseDirective(viewData,rootTNode,directive);return directive;}function invokeHostBindingsInCreationMode(def,expando,directive,tNode,firstTemplatePass){var previousExpandoLength=expando.length;var elementIndex=tNode.index-HEADER_OFFSET;def.hostBindings(1/* Create */,directive,elementIndex);// (e.g. it may not if it only contains host listeners), so we need to check whether
	// `expandoInstructions` has changed and if not - we still push `hostBindings` to
	// expando block, to make sure we execute it for DI cycle
	if(previousExpandoLength===expando.length&&firstTemplatePass){expando.push(def.hostBindings);}}/**
	* Generates a new block in TView.expandoInstructions for this node.
	*
	* Each expando block starts with the element index (turned negative so we can distinguish
	* it from the hostVar count) and the directive count. See more in VIEW_DATA.md.
	*/function generateExpandoInstructionBlock(tView,tNode,directiveCount){ngDevMode&&assertEqual(tView.firstTemplatePass,true,'Expando block should only be generated on first template pass.');var elementIndex=-(tNode.index-HEADER_OFFSET);var providerStartIndex=tNode.providerIndexes&65535/* ProvidersStartIndexMask */;var providerCount=tView.data.length-providerStartIndex;(tView.expandoInstructions||(tView.expandoInstructions=[])).push(elementIndex,providerCount,directiveCount);}/**
	 * A lighter version of postProcessDirective() that is used for the root component.
	 */function postProcessBaseDirective(lView,previousOrParentTNode,directive){var native=getNativeByTNode(previousOrParentTNode,lView);ngDevMode&&assertEqual(lView[BINDING_INDEX],lView[TVIEW].bindingStartIndex,'directives should be created before any bindings');ngDevMode&&assertPreviousIsParent(getIsParent());attachPatchData(directive,lView);if(native){attachPatchData(native,lView);}}/** Stores index of component's host element so it will be queued for view refresh during CD. */function queueComponentIndexForCheck(previousOrParentTNode){var tView=getLView()[TVIEW];ngDevMode&&assertEqual(tView.firstTemplatePass,true,'Should only be called in first template pass.');(tView.components||(tView.components=ngDevMode?new TViewComponents():[])).push(previousOrParentTNode.index);}/**
	 * Initializes the flags on the current node, setting all indices to the initial index,
	 * the directive count to 0, and adding the isComponent flag.
	 * @param index the initial index
	 */function initNodeFlags(tNode,index,numberOfDirectives){var flags=tNode.flags;ngDevMode&&assertEqual(flags===0||flags===1/* isComponent */,true,'expected node flags to not be initialized');ngDevMode&&assertNotEqual(numberOfDirectives,tNode.directiveEnd-tNode.directiveStart,'Reached the max number of directives');// When the first directive is created on a node, save the index
	tNode.flags=flags&1/* isComponent */;tNode.directiveStart=index;tNode.directiveEnd=index+numberOfDirectives;tNode.providerIndexes=index;}function baseResolveDirective(tView,viewData,def,directiveFactory){tView.data.push(def);var nodeInjectorFactory=new NodeInjectorFactory(directiveFactory,isComponentDef(def),null);tView.blueprint.push(nodeInjectorFactory);viewData.push(nodeInjectorFactory);}//// ViewContainer & View
	//////////////////////////
	// Not sure why I need to do `any` here but TS complains later.
	var LContainerArray=ngDevMode&&createNamedArrayType('LContainer');/**
	 * Goes over dynamic embedded views (ones created through ViewContainerRef APIs) and refreshes
	 * them
	 * by executing an associated template function.
	 */function refreshDynamicEmbeddedViews(lView){for(var current=lView[CHILD_HEAD];current!==null;current=current[NEXT]){// Note: current can be an LView or an LContainer instance, but here we are only interested
	// in LContainer. We can tell it's an LContainer because its length is less than the LView
	// header.
	if(current[ACTIVE_INDEX]===-1&&isLContainer(current)){for(var i=CONTAINER_HEADER_OFFSET;i<current.length;i++){var dynamicViewData=current[i];// The directives and pipes are not needed here as an existing view is only being
	// refreshed.
	ngDevMode&&assertDefined(dynamicViewData[TVIEW],'TView must be allocated');renderEmbeddedTemplate(dynamicViewData,dynamicViewData[TVIEW],dynamicViewData[CONTEXT]);}}}}/////////////
	/**
	 * Refreshes components by entering the component view and processing its bindings, queries, etc.
	 *
	 * @param adjustedElementIndex  Element index in LView[] (adjusted for HEADER_OFFSET)
	 */function componentRefresh(hostLView,adjustedElementIndex){ngDevMode&&assertDataInRange(hostLView,adjustedElementIndex);var componentView=getComponentViewByIndex(adjustedElementIndex,hostLView);ngDevMode&&assertNodeType(hostLView[TVIEW].data[adjustedElementIndex],3/* Element */);// Only components in creation mode, attached CheckAlways
	// components or attached, dirty OnPush components should be checked
	if((viewAttachedToChangeDetector(componentView)||isCreationMode(hostLView))&&componentView[FLAGS]&(16/* CheckAlways */|64/* Dirty */)){syncViewWithBlueprint(componentView);checkView(componentView,componentView[CONTEXT]);}}/**
	 * Syncs an LView instance with its blueprint if they have gotten out of sync.
	 *
	 * Typically, blueprints and their view instances should always be in sync, so the loop here
	 * will be skipped. However, consider this case of two components side-by-side:
	 *
	 * App template:
	 * ```
	 * <comp></comp>
	 * <comp></comp>
	 * ```
	 *
	 * The following will happen:
	 * 1. App template begins processing.
	 * 2. First <comp> is matched as a component and its LView is created.
	 * 3. Second <comp> is matched as a component and its LView is created.
	 * 4. App template completes processing, so it's time to check child templates.
	 * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.
	 * 6. Second <comp> template is checked. Its blueprint has been updated by the first
	 * <comp> template, but its LView was created before this update, so it is out of sync.
	 *
	 * Note that embedded views inside ngFor loops will never be out of sync because these views
	 * are processed as soon as they are created.
	 *
	 * @param componentView The view to sync
	 */function syncViewWithBlueprint(componentView){var componentTView=componentView[TVIEW];for(var i=componentView.length;i<componentTView.blueprint.length;i++){componentView[i]=componentTView.blueprint[i];}}/**
	 * Adds LView or LContainer to the end of the current view tree.
	 *
	 * This structure will be used to traverse through nested views to remove listeners
	 * and call onDestroy callbacks.
	 *
	 * @param lView The view where LView or LContainer should be added
	 * @param adjustedHostIndex Index of the view's host node in LView[], adjusted for header
	 * @param lViewOrLContainer The LView or LContainer to add to the view tree
	 * @returns The state passed in
	 */function addToViewTree(lView,lViewOrLContainer){// TODO(benlesh/misko): This implementation is incorrect, because it always adds the LContainer
	// to
	// the end of the queue, which means if the developer retrieves the LContainers from RNodes out
	// of
	// order, the change detection will run out of order, as the act of retrieving the the
	// LContainer
	// from the RNode is what adds it to the queue.
	if(lView[CHILD_HEAD]){lView[CHILD_TAIL][NEXT]=lViewOrLContainer;}else{lView[CHILD_HEAD]=lViewOrLContainer;}lView[CHILD_TAIL]=lViewOrLContainer;return lViewOrLContainer;}///////////////////////////////
	//// Change detection
	///////////////////////////////
	/**
	 * Marks current view and all ancestors dirty.
	 *
	 * Returns the root view because it is found as a byproduct of marking the view tree
	 * dirty, and can be used by methods that consume markViewDirty() to easily schedule
	 * change detection. Otherwise, such methods would need to traverse up the view tree
	 * an additional time to get the root view and schedule a tick on it.
	 *
	 * @param lView The starting LView to mark dirty
	 * @returns the root LView
	 */function markViewDirty(lView){while(lView){lView[FLAGS]|=64/* Dirty */;var parent_1=getLViewParent(lView);// Stop traversing up as soon as you find a root view that wasn't attached to any container
	if(isRootView(lView)&&!parent_1){return lView;}// continue otherwise
	lView=parent_1;}return null;}function tickRootContext(rootContext){for(var i=0;i<rootContext.components.length;i++){var rootComponent=rootContext.components[i];renderComponentOrTemplate(readPatchedLView(rootComponent),rootComponent);}}function detectChangesInternal(view,context){var rendererFactory=view[RENDERER_FACTORY];if(rendererFactory.begin)rendererFactory.begin();try{if(isCreationMode(view)){checkView(view,context);// creation mode pass
	}checkView(view,context);// update mode pass
	}catch(error){handleError(view,error);throw error;}finally{if(rendererFactory.end)rendererFactory.end();}}/**
	 * Synchronously perform change detection on a root view and its components.
	 *
	 * @param lView The view which the change detection should be performed on.
	 */function detectChangesInRootView(lView){tickRootContext(lView[CONTEXT]);}function checkNoChangesInternal(view,context){setCheckNoChangesMode(true);try{detectChangesInternal(view,context);}finally{setCheckNoChangesMode(false);}}/**
	 * Checks the change detector on a root view and its components, and throws if any changes are
	 * detected.
	 *
	 * This is used in development mode to verify that running change detection doesn't
	 * introduce other changes.
	 *
	 * @param lView The view which the change detection should be checked on.
	 */function checkNoChangesInRootView(lView){setCheckNoChangesMode(true);try{detectChangesInRootView(lView);}finally{setCheckNoChangesMode(false);}}/** Checks the view of the component provided. Does not gate on dirty checks or execute doCheck.
	 */function checkView(hostView,component){var hostTView=hostView[TVIEW];var oldView=enterView(hostView,hostView[T_HOST]);var templateFn=hostTView.template;var creationMode=isCreationMode(hostView);// Will become true if the `try` block executes with no errors.
	var safeToRunHooks=false;try{resetPreOrderHookFlags(hostView);creationMode&&executeViewQueryFn(1/* Create */,hostTView,component);executeTemplate(hostView,templateFn,getRenderFlags(hostView),component);refreshDescendantViews(hostView);safeToRunHooks=true;}finally{leaveView(oldView,safeToRunHooks);}}function executeViewQueryFn(flags,tView,component){var viewQuery=tView.viewQuery;if(viewQuery!==null){viewQuery(flags,component);}}///////////////////////////////
	var CLEAN_PROMISE=_CLEAN_PROMISE;function getCleanup(view){// top level variables should not be exported for performance reasons (PERF_NOTES.md)
	return view[CLEANUP]||(view[CLEANUP]=ngDevMode?new LCleanup():[]);}function getTViewCleanup(view){return view[TVIEW].cleanup||(view[TVIEW].cleanup=ngDevMode?new TCleanup():[]);}/** Handles an error thrown in an LView. */function handleError(lView,error){var injector=lView[INJECTOR$1];var errorHandler=injector?injector.get(ErrorHandler,null):null;errorHandler&&errorHandler.handleError(error);}function getLContainer(tNode,embeddedView){ngDevMode&&assertLView(embeddedView);var container=embeddedView[PARENT];if(tNode.index===-1){// This is a dynamically created view inside a dynamic container.
	// The parent isn't an LContainer if the embedded view hasn't been attached yet.
	return isLContainer(container)?container:null;}else{ngDevMode&&assertLContainer(container);// This is a inline view node (e.g. embeddedViewStart)
	return container;}}/**
	 * NOTE: for performance reasons, the possible actions are inlined within the function instead of
	 * being passed as an argument.
	 */function executeActionOnElementOrContainer(action,renderer,parent,lNodeToHandle,beforeNode){// If this slot was allocated for a text node dynamically created by i18n, the text node itself
	// won't be created until i18nApply() in the update block, so this node should be skipped.
	// For more info, see "ICU expressions should work inside an ngTemplateOutlet inside an ngFor"
	// in `i18n_spec.ts`.
	if(lNodeToHandle!=null){var lContainer=void 0;var isComponent=false;// We are expecting an RNode, but in the case of a component or LContainer the `RNode` is
	// wrapped
	// in an array which needs to be unwrapped. We need to know if it is a component and if
	// it has LContainer so that we can process all of those cases appropriately.
	if(isLContainer(lNodeToHandle)){lContainer=lNodeToHandle;}else if(isLView(lNodeToHandle)){isComponent=true;ngDevMode&&assertDefined(lNodeToHandle[HOST],'HOST must be defined for a component LView');lNodeToHandle=lNodeToHandle[HOST];}var rNode=unwrapRNode(lNodeToHandle);ngDevMode&&assertDomNode(rNode);if(action===0/* Insert */){nativeInsertBefore(renderer,parent,rNode,beforeNode||null);}else if(action===1/* Detach */){nativeRemoveNode(renderer,rNode,isComponent);}else if(action===2/* Destroy */){ngDevMode&&ngDevMode.rendererDestroyNode++;renderer.destroyNode(rNode);}if(lContainer!=null){executeActionOnContainer(renderer,action,lContainer,parent,beforeNode);}}}/**
	 * Detach a `LView` from the DOM by detaching its nodes.
	 *
	 * @param lView the `LView` to be detached.
	 */function renderDetachView(lView){executeActionOnView(lView[RENDERER],1/* Detach */,lView,null,null);}/**
	 * Traverses down and up the tree of views and containers to remove listeners and
	 * call onDestroy callbacks.
	 *
	 * Notes:
	 *  - Because it's used for onDestroy calls, it needs to be bottom-up.
	 *  - Must process containers instead of their views to avoid splicing
	 *  when views are destroyed and re-added.
	 *  - Using a while loop because it's faster than recursion
	 *  - Destroy only called on movement to sibling or movement to parent (laterally or up)
	 *
	 *  @param rootView The view to destroy
	 */function destroyViewTree(rootView){// If the view has no children, we can clean it up and return early.
	var lViewOrLContainer=rootView[CHILD_HEAD];if(!lViewOrLContainer){return cleanUpView(rootView);}while(lViewOrLContainer){var next=null;if(isLView(lViewOrLContainer)){// If LView, traverse down to child.
	next=lViewOrLContainer[CHILD_HEAD];}else{ngDevMode&&assertLContainer(lViewOrLContainer);// If container, traverse down to its first LView.
	var firstView=lViewOrLContainer[CONTAINER_HEADER_OFFSET];if(firstView)next=firstView;}if(!next){// Only clean up view when moving to the side or up, as destroy hooks
	// should be called in order from the bottom up.
	while(lViewOrLContainer&&!lViewOrLContainer[NEXT]&&lViewOrLContainer!==rootView){cleanUpView(lViewOrLContainer);lViewOrLContainer=getParentState(lViewOrLContainer,rootView);}cleanUpView(lViewOrLContainer||rootView);next=lViewOrLContainer&&lViewOrLContainer[NEXT];}lViewOrLContainer=next;}}function detachMovedView(declarationContainer,lView){ngDevMode&&assertLContainer(declarationContainer);ngDevMode&&assertDefined(declarationContainer[MOVED_VIEWS],'A projected view should belong to a non-empty projected views collection');var projectedViews=declarationContainer[MOVED_VIEWS];var declaredViewIndex=projectedViews.indexOf(lView);projectedViews.splice(declaredViewIndex,1);}/**
	 * A standalone function which destroys an LView,
	 * conducting cleanup (e.g. removing listeners, calling onDestroys).
	 *
	 * @param lView The view to be destroyed.
	 */function destroyLView(lView){if(!(lView[FLAGS]&256/* Destroyed */)){var renderer=lView[RENDERER];if(isProceduralRenderer(renderer)&&renderer.destroyNode){executeActionOnView(renderer,2/* Destroy */,lView,null,null);}destroyViewTree(lView);}}/**
	 * Determines which LViewOrLContainer to jump to when traversing back up the
	 * tree in destroyViewTree.
	 *
	 * Normally, the view's parent LView should be checked, but in the case of
	 * embedded views, the container (which is the view node's parent, but not the
	 * LView's parent) needs to be checked for a possible next property.
	 *
	 * @param lViewOrLContainer The LViewOrLContainer for which we need a parent state
	 * @param rootView The rootView, so we don't propagate too far up the view tree
	 * @returns The correct parent LViewOrLContainer
	 */function getParentState(lViewOrLContainer,rootView){var tNode;if(isLView(lViewOrLContainer)&&(tNode=lViewOrLContainer[T_HOST])&&tNode.type===2/* View */){// if it's an embedded view, the state needs to go up to the container, in case the
	// container has a next
	return getLContainer(tNode,lViewOrLContainer);}else{// otherwise, use parent view for containers or component views
	return lViewOrLContainer[PARENT]===rootView?null:lViewOrLContainer[PARENT];}}/**
	 * Calls onDestroys hooks for all directives and pipes in a given view and then removes all
	 * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks
	 * can be propagated to @Output listeners.
	 *
	 * @param view The LView to clean up
	 */function cleanUpView(view){if(isLView(view)&&!(view[FLAGS]&256/* Destroyed */)){// Usually the Attached flag is removed when the view is detached from its parent, however
	// if it's a root view, the flag won't be unset hence why we're also removing on destroy.
	view[FLAGS]&=~128/* Attached */;// Mark the LView as destroyed *before* executing the onDestroy hooks. An onDestroy hook
	// runs arbitrary user code, which could include its own `viewRef.destroy()` (or similar). If
	// We don't flag the view as destroyed before the hooks, this could lead to an infinite loop.
	// This also aligns with the ViewEngine behavior. It also means that the onDestroy hook is
	// really more of an "afterDestroy" hook if you think about it.
	view[FLAGS]|=256/* Destroyed */;executeOnDestroys(view);removeListeners(view);var hostTNode=view[T_HOST];// For component views only, the local renderer is destroyed as clean up time.
	if(hostTNode&&hostTNode.type===3/* Element */&&isProceduralRenderer(view[RENDERER])){ngDevMode&&ngDevMode.rendererDestroy++;view[RENDERER].destroy();}var declarationContainer=view[DECLARATION_LCONTAINER];// we are dealing with an embedded view that is still inserted into a container
	if(declarationContainer!==null&&isLContainer(view[PARENT])){// and this is a projected view
	if(declarationContainer!==view[PARENT]){detachMovedView(declarationContainer,view);}// For embedded views still attached to a container: remove query result from this view.
	var lQueries=view[QUERIES];if(lQueries!==null){lQueries.detachView(view[TVIEW]);}}}}/** Removes listeners and unsubscribes from output subscriptions */function removeListeners(lView){var tCleanup=lView[TVIEW].cleanup;if(tCleanup!==null){var lCleanup=lView[CLEANUP];for(var i=0;i<tCleanup.length-1;i+=2){if(typeof tCleanup[i]==='string'){// This is a native DOM listener
	var idxOrTargetGetter=tCleanup[i+1];var target=typeof idxOrTargetGetter==='function'?idxOrTargetGetter(lView):unwrapRNode(lView[idxOrTargetGetter]);var listener=lCleanup[tCleanup[i+2]];var useCaptureOrSubIdx=tCleanup[i+3];if(typeof useCaptureOrSubIdx==='boolean'){// native DOM listener registered with Renderer3
	target.removeEventListener(tCleanup[i],listener,useCaptureOrSubIdx);}else{if(useCaptureOrSubIdx>=0){// unregister
	lCleanup[useCaptureOrSubIdx]();}else{// Subscription
	lCleanup[-useCaptureOrSubIdx].unsubscribe();}}i+=2;}else{// This is a cleanup function that is grouped with the index of its context
	var context=lCleanup[tCleanup[i+1]];tCleanup[i].call(context);}}lView[CLEANUP]=null;}}/** Calls onDestroy hooks for this view */function executeOnDestroys(view){var tView=view[TVIEW];var destroyHooks;if(tView!=null&&(destroyHooks=tView.destroyHooks)!=null){for(var i=0;i<destroyHooks.length;i+=2){var context=view[destroyHooks[i]];// Only call the destroy hook if the context has been requested.
	if(!(context instanceof NodeInjectorFactory)){destroyHooks[i+1].call(context);}}}}/**
	 * Inserts a native node before another native node for a given parent using {@link Renderer3}.
	 * This is a utility function that can be used when native nodes were determined - it abstracts an
	 * actual renderer being used.
	 */function nativeInsertBefore(renderer,parent,child,beforeNode){ngDevMode&&ngDevMode.rendererInsertBefore++;if(isProceduralRenderer(renderer)){renderer.insertBefore(parent,child,beforeNode);}else{parent.insertBefore(child,beforeNode,true);}}/** Removes a node from the DOM given its native parent. */function nativeRemoveChild(renderer,parent,child,isHostElement){if(isProceduralRenderer(renderer)){renderer.removeChild(parent,child,isHostElement);}else{parent.removeChild(child);}}/**
	 * Returns a native parent of a given native node.
	 */function nativeParentNode(renderer,node){return isProceduralRenderer(renderer)?renderer.parentNode(node):node.parentNode;}/**
	 * Removes a native node itself using a given renderer. To remove the node we are looking up its
	 * parent from the native tree as not all platforms / browsers support the equivalent of
	 * node.remove().
	 *
	 * @param renderer A renderer to be used
	 * @param rNode The native node that should be removed
	 * @param isHostElement A flag indicating if a node to be removed is a host of a component.
	 */function nativeRemoveNode(renderer,rNode,isHostElement){var nativeParent=nativeParentNode(renderer,rNode);if(nativeParent){nativeRemoveChild(renderer,nativeParent,rNode,isHostElement);}}/**
	 * `executeActionOnView` performs an operation on the view as specified in `action` (insert, detach,
	 * destroy)
	 *
	 * Inserting a view without projection or containers at top level is simple. Just iterate over the
	 * root nodes of the View, and for each node perform the `action`.
	 *
	 * Things get more complicated with containers and projections. That is because coming across:
	 * - Container: implies that we have to insert/remove/destroy the views of that container as well
	 *              which in turn can have their own Containers at the View roots.
	 * - Projection: implies that we have to insert/remove/destroy the nodes of the projection. The
	 *               complication is that the nodes we are projecting can themselves have Containers
	 *               or other Projections.
	 *
	 * As you can see this is a very recursive problem. While the recursive implementation is not the
	 * most efficient one, trying to unroll the nodes non-recursively results in very complex code that
	 * is very hard (to maintain). We are sacrificing a bit of performance for readability using a
	 * recursive implementation.
	 *
	 * @param renderer Renderer to use
	 * @param action action to perform (insert, detach, destroy)
	 * @param lView The LView which needs to be inserted, detached, destroyed.
	 * @param renderParent parent DOM element for insertion/removal.
	 * @param beforeNode Before which node the insertions should happen.
	 */function executeActionOnView(renderer,action,lView,renderParent,beforeNode){var tView=lView[TVIEW];ngDevMode&&assertNodeType(tView.node,2/* View */);var viewRootTNode=tView.node.child;while(viewRootTNode!==null){executeActionOnNode(renderer,action,lView,viewRootTNode,renderParent,beforeNode);viewRootTNode=viewRootTNode.next;}}/**
	 * `executeActionOnProjection` performs an operation on the projection specified by `action`
	 * (insert, detach, destroy).
	 *
	 * Inserting a projection requires us to locate the projected nodes from the parent component. The
	 * complication is that those nodes themselves could be re-projected from their parent component.
	 *
	 * @param renderer Renderer to use
	 * @param action action to perform (insert, detach, destroy)
	 * @param lView The LView which needs to be inserted, detached, destroyed.
	 * @param tProjectionNode projection TNode to process
	 * @param renderParent parent DOM element for insertion/removal.
	 * @param beforeNode Before which node the insertions should happen.
	 */function executeActionOnProjection(renderer,action,lView,tProjectionNode,renderParent,beforeNode){var componentLView=findComponentView(lView);var componentNode=componentLView[T_HOST];ngDevMode&&assertDefined(componentNode.projection,'Element nodes for which projection is processed must have projection defined.');var nodeToProject=componentNode.projection[tProjectionNode.projection];if(nodeToProject!==undefined){if(Array.isArray(nodeToProject)){for(var i=0;i<nodeToProject.length;i++){var rNode=nodeToProject[i];ngDevMode&&assertDomNode(rNode);executeActionOnElementOrContainer(action,renderer,renderParent,rNode,beforeNode);}}else{var projectionTNode=nodeToProject;var projectedComponentLView=componentLView[PARENT];while(projectionTNode!==null){executeActionOnNode(renderer,action,projectedComponentLView,projectionTNode,renderParent,beforeNode);projectionTNode=projectionTNode.projectionNext;}}}}/**
	 * `executeActionOnContainer` performs an operation on the container and its views as specified by
	 * `action` (insert, detach, destroy)
	 *
	 * Inserting a Container is complicated by the fact that the container may have Views which
	 * themselves have containers or projections.
	 *
	 * @param renderer Renderer to use
	 * @param action action to perform (insert, detach, destroy)
	 * @param lContainer The LContainer which needs to be inserted, detached, destroyed.
	 * @param renderParent parent DOM element for insertion/removal.
	 * @param beforeNode Before which node the insertions should happen.
	 */function executeActionOnContainer(renderer,action,lContainer,renderParent,beforeNode){ngDevMode&&assertLContainer(lContainer);var anchor=lContainer[NATIVE];// LContainer has its own before node.
	var native=unwrapRNode(lContainer);// An LContainer can be created dynamically on any node by injecting ViewContainerRef.
	// Asking for a ViewContainerRef on an element will result in a creation of a separate anchor node
	// (comment in the DOM) that will be different from the LContainer's host node. In this particular
	// case we need to execute action on 2 nodes:
	// - container's host node (this is done in the executeNodeAction)
	// - container's host node (this is done here)
	if(anchor!==native){executeActionOnElementOrContainer(action,renderer,renderParent,anchor,beforeNode);}for(var i=CONTAINER_HEADER_OFFSET;i<lContainer.length;i++){var lView=lContainer[i];executeActionOnView(renderer,action,lView,renderParent,anchor);}}/**
	 * `executeActionOnElementContainerOrIcuContainer` performs an operation on the ng-container node
	 * and its child nodes as specified by the `action` (insert, detach, destroy).
	 *
	 * @param renderer Renderer to use
	 * @param action action to perform (insert, detach, destroy)
	 * @param lView The LView which needs to be inserted, detached, destroyed.
	 * @param tNode The TNode associated with the `ElementContainer` or `IcuContainer`.
	 * @param renderParent parent DOM element for insertion/removal.
	 * @param beforeNode Before which node the insertions should happen.
	 */function executeActionOnElementContainerOrIcuContainer(renderer,action,lView,tNode,renderParent,beforeNode){var node=lView[tNode.index];executeActionOnElementOrContainer(action,renderer,renderParent,node,beforeNode);var childTNode=tNode.child;while(childTNode){executeActionOnNode(renderer,action,lView,childTNode,renderParent,beforeNode);childTNode=childTNode.next;}}function executeActionOnNode(renderer,action,lView,tNode,renderParent,beforeNode){var nodeType=tNode.type;if(!(tNode.flags&32/* isDetached */)){if(nodeType===4/* ElementContainer */||nodeType===5/* IcuContainer */){executeActionOnElementContainerOrIcuContainer(renderer,action,lView,tNode,renderParent,beforeNode);}else if(nodeType===1/* Projection */){executeActionOnProjection(renderer,action,lView,tNode,renderParent,beforeNode);}else{ngDevMode&&assertNodeOfPossibleTypes(tNode,3/* Element */,0/* Container */);executeActionOnElementOrContainer(action,renderer,renderParent,lView[tNode.index],beforeNode);}}}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var ViewRef=/** @class */function(){function ViewRef(_lView,_context,_componentIndex){this._context=_context;this._componentIndex=_componentIndex;this._appRef=null;this._viewContainerRef=null;/**
	         * @internal
	         */this._tViewNode=null;this._lView=_lView;}Object.defineProperty(ViewRef.prototype,"rootNodes",{get:function get(){if(this._lView[HOST]==null){var tView=this._lView[T_HOST];return collectNativeNodes(this._lView,tView,[]);}return [];},enumerable:true,configurable:true});Object.defineProperty(ViewRef.prototype,"context",{get:function get(){return this._context?this._context:this._lookUpContext();},enumerable:true,configurable:true});Object.defineProperty(ViewRef.prototype,"destroyed",{get:function get(){return (this._lView[FLAGS]&256/* Destroyed */)===256/* Destroyed */;},enumerable:true,configurable:true});ViewRef.prototype.destroy=function(){if(this._appRef){this._appRef.detachView(this);}else if(this._viewContainerRef){var index=this._viewContainerRef.indexOf(this);if(index>-1){this._viewContainerRef.detach(index);}this._viewContainerRef=null;}destroyLView(this._lView);};ViewRef.prototype.onDestroy=function(callback){storeCleanupFn(this._lView,callback);};/**
	     * Marks a view and all of its ancestors dirty.
	     *
	     * It also triggers change detection by calling `scheduleTick` internally, which coalesces
	     * multiple `markForCheck` calls to into one change detection run.
	     *
	     * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is
	     * checked when it needs to be re-rendered but the two normal triggers haven't marked it
	     * dirty (i.e. inputs haven't changed and events haven't fired in the view).
	     *
	     * <!-- TODO: Add a link to a chapter on OnPush components -->
	     *
	     * @usageNotes
	     * ### Example
	     *
	     * ```typescript
	     * @Component({
	     *   selector: 'my-app',
	     *   template: `Number of ticks: {{numberOfTicks}}`
	     *   changeDetection: ChangeDetectionStrategy.OnPush,
	     * })
	     * class AppComponent {
	     *   numberOfTicks = 0;
	     *
	     *   constructor(private ref: ChangeDetectorRef) {
	     *     setInterval(() => {
	     *       this.numberOfTicks++;
	     *       // the following is required, otherwise the view will not be updated
	     *       this.ref.markForCheck();
	     *     }, 1000);
	     *   }
	     * }
	     * ```
	     */ViewRef.prototype.markForCheck=function(){markViewDirty(this._lView);};/**
	     * Detaches the view from the change detection tree.
	     *
	     * Detached views will not be checked during change detection runs until they are
	     * re-attached, even if they are dirty. `detach` can be used in combination with
	     * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change
	     * detection checks.
	     *
	     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
	     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
	     *
	     * @usageNotes
	     * ### Example
	     *
	     * The following example defines a component with a large list of readonly data.
	     * Imagine the data changes constantly, many times per second. For performance reasons,
	     * we want to check and update the list every five seconds. We can do that by detaching
	     * the component's change detector and doing a local check every five seconds.
	     *
	     * ```typescript
	     * class DataProvider {
	     *   // in a real application the returned data will be different every time
	     *   get data() {
	     *     return [1,2,3,4,5];
	     *   }
	     * }
	     *
	     * @Component({
	     *   selector: 'giant-list',
	     *   template: `
	     *     <li *ngFor="let d of dataProvider.data">Data {{d}}</li>
	     *   `,
	     * })
	     * class GiantList {
	     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {
	     *     ref.detach();
	     *     setInterval(() => {
	     *       this.ref.detectChanges();
	     *     }, 5000);
	     *   }
	     * }
	     *
	     * @Component({
	     *   selector: 'app',
	     *   providers: [DataProvider],
	     *   template: `
	     *     <giant-list><giant-list>
	     *   `,
	     * })
	     * class App {
	     * }
	     * ```
	     */ViewRef.prototype.detach=function(){this._lView[FLAGS]&=~128/* Attached */;};/**
	     * Re-attaches a view to the change detection tree.
	     *
	     * This can be used to re-attach views that were previously detached from the tree
	     * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.
	     *
	     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
	     *
	     * @usageNotes
	     * ### Example
	     *
	     * The following example creates a component displaying `live` data. The component will detach
	     * its change detector from the main change detector tree when the component's live property
	     * is set to false.
	     *
	     * ```typescript
	     * class DataProvider {
	     *   data = 1;
	     *
	     *   constructor() {
	     *     setInterval(() => {
	     *       this.data = this.data * 2;
	     *     }, 500);
	     *   }
	     * }
	     *
	     * @Component({
	     *   selector: 'live-data',
	     *   inputs: ['live'],
	     *   template: 'Data: {{dataProvider.data}}'
	     * })
	     * class LiveData {
	     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}
	     *
	     *   set live(value) {
	     *     if (value) {
	     *       this.ref.reattach();
	     *     } else {
	     *       this.ref.detach();
	     *     }
	     *   }
	     * }
	     *
	     * @Component({
	     *   selector: 'my-app',
	     *   providers: [DataProvider],
	     *   template: `
	     *     Live Update: <input type="checkbox" [(ngModel)]="live">
	     *     <live-data [live]="live"><live-data>
	     *   `,
	     * })
	     * class AppComponent {
	     *   live = true;
	     * }
	     * ```
	     */ViewRef.prototype.reattach=function(){this._lView[FLAGS]|=128/* Attached */;};/**
	     * Checks the view and its children.
	     *
	     * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement
	     * local change detection checks.
	     *
	     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
	     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
	     *
	     * @usageNotes
	     * ### Example
	     *
	     * The following example defines a component with a large list of readonly data.
	     * Imagine, the data changes constantly, many times per second. For performance reasons,
	     * we want to check and update the list every five seconds.
	     *
	     * We can do that by detaching the component's change detector and doing a local change detection
	     * check every five seconds.
	     *
	     * See {@link ChangeDetectorRef#detach detach} for more information.
	     */ViewRef.prototype.detectChanges=function(){detectChangesInternal(this._lView,this.context);};/**
	     * Checks the change detector and its children, and throws if any changes are detected.
	     *
	     * This is used in development mode to verify that running change detection doesn't
	     * introduce other changes.
	     */ViewRef.prototype.checkNoChanges=function(){checkNoChangesInternal(this._lView,this.context);};ViewRef.prototype.attachToViewContainerRef=function(vcRef){if(this._appRef){throw new Error('This view is already attached directly to the ApplicationRef!');}this._viewContainerRef=vcRef;};ViewRef.prototype.detachFromAppRef=function(){this._appRef=null;renderDetachView(this._lView);};ViewRef.prototype.attachToAppRef=function(appRef){if(this._viewContainerRef){throw new Error('This view is already attached to a ViewContainer!');}this._appRef=appRef;};ViewRef.prototype._lookUpContext=function(){return this._context=getLViewParent(this._lView)[this._componentIndex];};return ViewRef;}();/** @internal */var RootViewRef=/** @class */function(_super){__extends(RootViewRef,_super);function RootViewRef(_view){var _this=_super.call(this,_view,null,-1)||this;_this._view=_view;return _this;}RootViewRef.prototype.detectChanges=function(){detectChangesInRootView(this._view);};RootViewRef.prototype.checkNoChanges=function(){checkNoChangesInRootView(this._view);};Object.defineProperty(RootViewRef.prototype,"context",{get:function get(){return null;},enumerable:true,configurable:true});return RootViewRef;}(ViewRef);function collectNativeNodes(lView,parentTNode,result){var tNodeChild=parentTNode.child;while(tNodeChild){var nativeNode=getNativeByTNodeOrNull(tNodeChild,lView);nativeNode&&result.push(nativeNode);if(tNodeChild.type===4/* ElementContainer */){collectNativeNodes(lView,tNodeChild,result);}else if(tNodeChild.type===1/* Projection */){var componentView=findComponentView(lView);var componentHost=componentView[T_HOST];var parentView=getLViewParent(componentView);var currentProjectedNode=componentHost.projection[tNodeChild.projection];while(currentProjectedNode&&parentView){result.push(getNativeByTNode(currentProjectedNode,parentView));currentProjectedNode=currentProjectedNode.next;}}tNodeChild=tNodeChild.next;}return result;}var R3ElementRef;/**
	 * Creates an ElementRef given a node.
	 *
	 * @param ElementRefToken The ElementRef type
	 * @param tNode The node for which you'd like an ElementRef
	 * @param view The view to which the node belongs
	 * @returns The ElementRef instance to use
	 */function createElementRef(ElementRefToken,tNode,view){if(!R3ElementRef){// TODO: Fix class name, should be ElementRef, but there appears to be a rollup bug
	R3ElementRef=/** @class */function(_super){__extends(ElementRef_,_super);function ElementRef_(){return _super!==null&&_super.apply(this,arguments)||this;}return ElementRef_;}(ElementRefToken);}return new R3ElementRef(getNativeByTNode(tNode,view));}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Base class for Angular Views, provides change detection functionality.
	 * A change-detection tree collects all views that are to be checked for changes.
	 * Use the methods to add and remove views from the tree, initiate change-detection,
	 * and explicitly mark views as _dirty_, meaning that they have changed and need to be rerendered.
	 *
	 * @usageNotes
	 *
	 * The following examples demonstrate how to modify default change-detection behavior
	 * to perform explicit detection when needed.
	 *
	 * ### Use `markForCheck()` with `CheckOnce` strategy
	 *
	 * The following example sets the `OnPush` change-detection strategy for a component
	 * (`CheckOnce`, rather than the default `CheckAlways`), then forces a second check
	 * after an interval. See [live demo](http://plnkr.co/edit/GC512b?p=preview).
	 *
	 * <code-example path="core/ts/change_detect/change-detection.ts"
	 * region="mark-for-check"></code-example>
	 *
	 * ### Detach change detector to limit how often check occurs
	 *
	 * The following example defines a component with a large list of read-only data
	 * that is expected to change constantly, many times per second.
	 * To improve performance, we want to check and update the list
	 * less often than the changes actually occur. To do that, we detach
	 * the component's change detector and perform an explicit local check every five seconds.
	 *
	 * <code-example path="core/ts/change_detect/change-detection.ts" region="detach"></code-example>
	 *
	 *
	 * ### Reattaching a detached component
	 *
	 * The following example creates a component displaying live data.
	 * The component detaches its change detector from the main change detector tree
	 * when the `live` property is set to false, and reattaches it when the property
	 * becomes true.
	 *
	 * <code-example path="core/ts/change_detect/change-detection.ts" region="reattach"></code-example>
	 *
	 * @publicApi
	 */var ChangeDetectorRef=/** @class */function(){function ChangeDetectorRef(){}/**
	     * @internal
	     * @nocollapse
	     */ChangeDetectorRef.__NG_ELEMENT_ID__=function(){return SWITCH_CHANGE_DETECTOR_REF_FACTORY();};return ChangeDetectorRef;}();var SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__=function SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}};var SWITCH_CHANGE_DETECTOR_REF_FACTORY=SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__;/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * @description
	 *
	 * Represents a type that a Component or other object is instances of.
	 *
	 * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
	 * the `MyCustomComponent` constructor function.
	 *
	 * @publicApi
	 */var Type=Function;function isType(v){return typeof v==='function';}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Attention: These regex has to hold even if the code is minified!
	 */var DELEGATE_CTOR=/^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*arguments\)/;var INHERITED_CLASS=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;var INHERITED_CLASS_WITH_CTOR=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;var INHERITED_CLASS_WITH_DELEGATE_CTOR=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{\s+super\(\.\.\.arguments\)/;/**
	 * Determine whether a stringified type is a class which delegates its constructor
	 * to its parent.
	 *
	 * This is not trivial since compiled code can actually contain a constructor function
	 * even if the original source code did not. For instance, when the child class contains
	 * an initialized instance property.
	 */function isDelegateCtor(typeStr){return DELEGATE_CTOR.test(typeStr)||INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr)||INHERITED_CLASS.test(typeStr)&&!INHERITED_CLASS_WITH_CTOR.test(typeStr);}var ReflectionCapabilities=/** @class */function(){function ReflectionCapabilities(reflect){this._reflect=reflect||_global$1['Reflect'];}ReflectionCapabilities.prototype.isReflectionEnabled=function(){return true;};ReflectionCapabilities.prototype.factory=function(t){return function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}return new(t.bind.apply(t,__spread([void 0],args)))();};};/** @internal */ReflectionCapabilities.prototype._zipTypesAndAnnotations=function(paramTypes,paramAnnotations){var result;if(typeof paramTypes==='undefined'){result=new Array(paramAnnotations.length);}else{result=new Array(paramTypes.length);}for(var i=0;i<result.length;i++){// TS outputs Object for parameters without types, while Traceur omits
	// the annotations. For now we preserve the Traceur behavior to aid
	// migration, but this can be revisited.
	if(typeof paramTypes==='undefined'){result[i]=[];}else if(paramTypes[i]&&paramTypes[i]!=Object){result[i]=[paramTypes[i]];}else{result[i]=[];}if(paramAnnotations&&paramAnnotations[i]!=null){result[i]=result[i].concat(paramAnnotations[i]);}}return result;};ReflectionCapabilities.prototype._ownParameters=function(type,parentCtor){var typeStr=type.toString();// If we have no decorators, we only have function.length as metadata.
	// In that case, to detect whether a child class declared an own constructor or not,
	// we need to look inside of that constructor to check whether it is
	// just calling the parent.
	// This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439
	// that sets 'design:paramtypes' to []
	// if a class inherits from another class but has no ctor declared itself.
	if(isDelegateCtor(typeStr)){return null;}// Prefer the direct API.
	if(type.parameters&&type.parameters!==parentCtor.parameters){return type.parameters;}// API of tsickle for lowering decorators to properties on the class.
	var tsickleCtorParams=type.ctorParameters;if(tsickleCtorParams&&tsickleCtorParams!==parentCtor.ctorParameters){// Newer tsickle uses a function closure
	// Retain the non-function case for compatibility with older tsickle
	var ctorParameters=typeof tsickleCtorParams==='function'?tsickleCtorParams():tsickleCtorParams;var paramTypes_1=ctorParameters.map(function(ctorParam){return ctorParam&&ctorParam.type;});var paramAnnotations_1=ctorParameters.map(function(ctorParam){return ctorParam&&convertTsickleDecoratorIntoMetadata(ctorParam.decorators);});return this._zipTypesAndAnnotations(paramTypes_1,paramAnnotations_1);}// API for metadata created by invoking the decorators.
	var paramAnnotations=type.hasOwnProperty(PARAMETERS)&&type[PARAMETERS];var paramTypes=this._reflect&&this._reflect.getOwnMetadata&&this._reflect.getOwnMetadata('design:paramtypes',type);if(paramTypes||paramAnnotations){return this._zipTypesAndAnnotations(paramTypes,paramAnnotations);}// If a class has no decorators, at least create metadata
	// based on function.length.
	// Note: We know that this is a real constructor as we checked
	// the content of the constructor above.
	return new Array(type.length).fill(undefined);};ReflectionCapabilities.prototype.parameters=function(type){// Note: only report metadata if we have at least one class decorator
	// to stay in sync with the static reflector.
	if(!isType(type)){return [];}var parentCtor=getParentCtor(type);var parameters=this._ownParameters(type,parentCtor);if(!parameters&&parentCtor!==Object){parameters=this.parameters(parentCtor);}return parameters||[];};ReflectionCapabilities.prototype._ownAnnotations=function(typeOrFunc,parentCtor){// Prefer the direct API.
	if(typeOrFunc.annotations&&typeOrFunc.annotations!==parentCtor.annotations){var annotations=typeOrFunc.annotations;if(typeof annotations==='function'&&annotations.annotations){annotations=annotations.annotations;}return annotations;}// API of tsickle for lowering decorators to properties on the class.
	if(typeOrFunc.decorators&&typeOrFunc.decorators!==parentCtor.decorators){return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);}// API for metadata created by invoking the decorators.
	if(typeOrFunc.hasOwnProperty(ANNOTATIONS)){return typeOrFunc[ANNOTATIONS];}return null;};ReflectionCapabilities.prototype.annotations=function(typeOrFunc){if(!isType(typeOrFunc)){return [];}var parentCtor=getParentCtor(typeOrFunc);var ownAnnotations=this._ownAnnotations(typeOrFunc,parentCtor)||[];var parentAnnotations=parentCtor!==Object?this.annotations(parentCtor):[];return parentAnnotations.concat(ownAnnotations);};ReflectionCapabilities.prototype._ownPropMetadata=function(typeOrFunc,parentCtor){// Prefer the direct API.
	if(typeOrFunc.propMetadata&&typeOrFunc.propMetadata!==parentCtor.propMetadata){var propMetadata=typeOrFunc.propMetadata;if(typeof propMetadata==='function'&&propMetadata.propMetadata){propMetadata=propMetadata.propMetadata;}return propMetadata;}// API of tsickle for lowering decorators to properties on the class.
	if(typeOrFunc.propDecorators&&typeOrFunc.propDecorators!==parentCtor.propDecorators){var propDecorators_1=typeOrFunc.propDecorators;var propMetadata_1={};Object.keys(propDecorators_1).forEach(function(prop){propMetadata_1[prop]=convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);});return propMetadata_1;}// API for metadata created by invoking the decorators.
	if(typeOrFunc.hasOwnProperty(PROP_METADATA)){return typeOrFunc[PROP_METADATA];}return null;};ReflectionCapabilities.prototype.propMetadata=function(typeOrFunc){if(!isType(typeOrFunc)){return {};}var parentCtor=getParentCtor(typeOrFunc);var propMetadata={};if(parentCtor!==Object){var parentPropMetadata_1=this.propMetadata(parentCtor);Object.keys(parentPropMetadata_1).forEach(function(propName){propMetadata[propName]=parentPropMetadata_1[propName];});}var ownPropMetadata=this._ownPropMetadata(typeOrFunc,parentCtor);if(ownPropMetadata){Object.keys(ownPropMetadata).forEach(function(propName){var decorators=[];if(propMetadata.hasOwnProperty(propName)){decorators.push.apply(decorators,__spread(propMetadata[propName]));}decorators.push.apply(decorators,__spread(ownPropMetadata[propName]));propMetadata[propName]=decorators;});}return propMetadata;};ReflectionCapabilities.prototype.ownPropMetadata=function(typeOrFunc){if(!isType(typeOrFunc)){return {};}return this._ownPropMetadata(typeOrFunc,getParentCtor(typeOrFunc))||{};};ReflectionCapabilities.prototype.hasLifecycleHook=function(type,lcProperty){return type instanceof Type&&lcProperty in type.prototype;};ReflectionCapabilities.prototype.guards=function(type){return {};};ReflectionCapabilities.prototype.getter=function(name){return new Function('o','return o.'+name+';');};ReflectionCapabilities.prototype.setter=function(name){return new Function('o','v','return o.'+name+' = v;');};ReflectionCapabilities.prototype.method=function(name){var functionBody="if (!o."+name+") throw new Error('\""+name+"\" is undefined');\n        return o."+name+".apply(o, args);";return new Function('o','args',functionBody);};// There is not a concept of import uri in Js, but this is useful in developing Dart applications.
	ReflectionCapabilities.prototype.importUri=function(type){// StaticSymbol
	if(_typeof(type)==='object'&&type['filePath']){return type['filePath'];}// Runtime type
	return "./"+stringify(type);};ReflectionCapabilities.prototype.resourceUri=function(type){return "./"+stringify(type);};ReflectionCapabilities.prototype.resolveIdentifier=function(name,moduleUrl,members,runtime){return runtime;};ReflectionCapabilities.prototype.resolveEnum=function(enumIdentifier,name){return enumIdentifier[name];};return ReflectionCapabilities;}();function convertTsickleDecoratorIntoMetadata(decoratorInvocations){if(!decoratorInvocations){return [];}return decoratorInvocations.map(function(decoratorInvocation){var decoratorType=decoratorInvocation.type;var annotationCls=decoratorType.annotationCls;var annotationArgs=decoratorInvocation.args?decoratorInvocation.args:[];return new(annotationCls.bind.apply(annotationCls,__spread([void 0],annotationArgs)))();});}function getParentCtor(ctor){var parentProto=ctor.prototype?Object.getPrototypeOf(ctor.prototype):null;var parentCtor=parentProto?parentProto.constructor:null;// Note: We always use `Object` as the null value
	// to simplify checking later on.
	return parentCtor||Object;}var Éµ0$7=getClosureSafeProperty;var USE_VALUE$1=getClosureSafeProperty({provide:String,useValue:Éµ0$7});/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var Éµ0$8=getClosureSafeProperty;var USE_VALUE$2=getClosureSafeProperty({provide:String,useValue:Éµ0$8});var EMPTY_ARRAY$1=[];function convertInjectableProviderToFactory(type,provider){if(!provider){var reflectionCapabilities=new ReflectionCapabilities();var deps_1=reflectionCapabilities.parameters(type);// TODO - convert to flags.
	return function(){return new(type.bind.apply(type,__spread([void 0],injectArgs(deps_1))))();};}if(USE_VALUE$2 in provider){var valueProvider_1=provider;return function(){return valueProvider_1.useValue;};}else if(provider.useExisting){var existingProvider_1=provider;return function(){return ÉµÉµinject(existingProvider_1.useExisting);};}else if(provider.useFactory){var factoryProvider_1=provider;return function(){return factoryProvider_1.useFactory.apply(factoryProvider_1,__spread(injectArgs(factoryProvider_1.deps||EMPTY_ARRAY$1)));};}else if(provider.useClass){var classProvider_1=provider;var deps_2=provider.deps;if(!deps_2){var reflectionCapabilities=new ReflectionCapabilities();deps_2=reflectionCapabilities.parameters(type);}return function(){var _a;return new((_a=classProvider_1.useClass).bind.apply(_a,__spread([void 0],injectArgs(deps_2))))();};}else{var deps_3=provider.deps;if(!deps_3){var reflectionCapabilities=new ReflectionCapabilities();deps_3=reflectionCapabilities.parameters(type);}return function(){return new(type.bind.apply(type,__spread([void 0],injectArgs(deps_3))))();};}}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var Éµ0$9=function Éµ0$9(type,meta){return SWITCH_COMPILE_INJECTABLE(type,meta);};/**
	 * Injectable decorator and metadata.
	 *
	 * @Annotation
	 * @publicApi
	 */var Injectable=makeDecorator('Injectable',undefined,undefined,undefined,Éµ0$9);/**
	 * Supports @Injectable() in JIT mode for Render2.
	 */function render2CompileInjectable(injectableType,options){if(options&&options.providedIn!==undefined&&!getInjectableDef(injectableType)){injectableType.ngInjectableDef=ÉµÉµdefineInjectable({token:injectableType,providedIn:options.providedIn,factory:convertInjectableProviderToFactory(injectableType,options)});}}var SWITCH_COMPILE_INJECTABLE__PRE_R3__=render2CompileInjectable;var SWITCH_COMPILE_INJECTABLE=SWITCH_COMPILE_INJECTABLE__PRE_R3__;/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * An internal token whose presence in an injector indicates that the injector should treat itself
	 * as a root scoped injector when processing requests for unknown tokens which may indicate
	 * they are provided in the root scope.
	 */var APP_ROOT=new InjectionToken('The presence of this token marks an injector as being the root injector.');/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Marker which indicates that a value has not yet been created from the factory function.
	 */var NOT_YET={};/**
	 * Marker which indicates that the factory function for a token is in the process of being called.
	 *
	 * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates
	 * injection of a dependency has recursively attempted to inject the original token, and there is
	 * a circular dependency among the providers.
	 */var CIRCULAR={};var EMPTY_ARRAY$2=[];/**
	 * A lazily initialized NullInjector.
	 */var NULL_INJECTOR=undefined;function getNullInjector(){if(NULL_INJECTOR===undefined){NULL_INJECTOR=new NullInjector();}return NULL_INJECTOR;}/**
	 * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.
	 *
	 * @publicApi
	 */function createInjector(defType,parent,additionalProviders,name){if(parent===void 0){parent=null;}if(additionalProviders===void 0){additionalProviders=null;}parent=parent||getNullInjector();return new R3Injector(defType,additionalProviders,parent,name);}var R3Injector=/** @class */function(){function R3Injector(def,additionalProviders,parent,source){var _this=this;if(source===void 0){source=null;}this.parent=parent;/**
	         * Map of tokens to records which contain the instances of those tokens.
	         */this.records=new Map();/**
	         * The transitive set of `InjectorType`s which define this injector.
	         */this.injectorDefTypes=new Set();/**
	         * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.
	         */this.onDestroy=new Set();this._destroyed=false;// Start off by creating Records for every provider declared in every InjectorType
	// included transitively in `def`.
	var dedupStack=[];deepForEach([def],function(injectorDef){return _this.processInjectorType(injectorDef,[],dedupStack);});additionalProviders&&deepForEach(additionalProviders,function(provider){return _this.processProvider(provider,def,additionalProviders);});// Make sure the INJECTOR token provides this injector.
	this.records.set(INJECTOR,makeRecord(undefined,this));// Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide
	// any injectable scoped to APP_ROOT_SCOPE.
	this.isRootInjector=this.records.has(APP_ROOT);// Eagerly instantiate the InjectorType classes themselves.
	this.injectorDefTypes.forEach(function(defType){return _this.get(defType);});// Source name, used for debugging
	this.source=source||(_typeof(def)==='object'?null:stringify(def));}Object.defineProperty(R3Injector.prototype,"destroyed",{/**
	         * Flag indicating that this injector was previously destroyed.
	         */get:function get(){return this._destroyed;},enumerable:true,configurable:true});/**
	     * Destroy the injector and release references to every instance or provider associated with it.
	     *
	     * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a
	     * hook was found.
	     */R3Injector.prototype.destroy=function(){this.assertNotDestroyed();// Set destroyed = true first, in case lifecycle hooks re-enter destroy().
	this._destroyed=true;try{// Call all the lifecycle hooks.
	this.onDestroy.forEach(function(service){return service.ngOnDestroy();});}finally{// Release all references.
	this.records.clear();this.onDestroy.clear();this.injectorDefTypes.clear();}};R3Injector.prototype.get=function(token,notFoundValue,flags){if(notFoundValue===void 0){notFoundValue=THROW_IF_NOT_FOUND;}if(flags===void 0){flags=InjectFlags.Default;}this.assertNotDestroyed();// Set the injection context.
	var previousInjector=setCurrentInjector(this);try{// Check for the SkipSelf flag.
	if(!(flags&InjectFlags.SkipSelf)){// SkipSelf isn't set, check if the record belongs to this injector.
	var record=this.records.get(token);if(record===undefined){// No record, but maybe the token is scoped to this injector. Look for an ngInjectableDef
	// with a scope matching this injector.
	var def=couldBeInjectableType(token)&&getInjectableDef(token);if(def&&this.injectableDefInScope(def)){// Found an ngInjectableDef and it's scoped to this injector. Pretend as if it was here
	// all along.
	record=makeRecord(injectableDefOrInjectorDefFactory(token),NOT_YET);this.records.set(token,record);}}// If a record was found, get the instance for it and return it.
	if(record!==undefined){return this.hydrate(token,record);}}// Select the next injector based on the Self flag - if self is set, the next injector is
	// the NullInjector, otherwise it's the parent.
	var nextInjector=!(flags&InjectFlags.Self)?this.parent:getNullInjector();return nextInjector.get(token,flags&InjectFlags.Optional?null:notFoundValue);}catch(e){if(e.name==='NullInjectorError'){var path=e[NG_TEMP_TOKEN_PATH]=e[NG_TEMP_TOKEN_PATH]||[];path.unshift(stringify(token));if(previousInjector){// We still have a parent injector, keep throwing
	throw e;}else{// Format & throw the final error message when we don't have any previous injector
	return catchInjectorError(e,token,'R3InjectorError',this.source);}}else{throw e;}}finally{// Lastly, clean up the state by restoring the previous injector.
	setCurrentInjector(previousInjector);}};R3Injector.prototype.toString=function(){var tokens=[],records=this.records;records.forEach(function(v,token){return tokens.push(stringify(token));});return "R3Injector["+tokens.join(', ')+"]";};R3Injector.prototype.assertNotDestroyed=function(){if(this._destroyed){throw new Error('Injector has already been destroyed.');}};/**
	     * Add an `InjectorType` or `InjectorTypeWithProviders` and all of its transitive providers
	     * to this injector.
	     *
	     * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,
	     * the function will return "true" to indicate that the providers of the type definition need
	     * to be processed. This allows us to process providers of injector types after all imports of
	     * an injector definition are processed. (following View Engine semantics: see FW-1349)
	     */R3Injector.prototype.processInjectorType=function(defOrWrappedDef,parents,dedupStack){var _this=this;defOrWrappedDef=resolveForwardRef(defOrWrappedDef);if(!defOrWrappedDef)return false;// Either the defOrWrappedDef is an InjectorType (with ngInjectorDef) or an
	// InjectorDefTypeWithProviders (aka ModuleWithProviders). Detecting either is a megamorphic
	// read, so care is taken to only do the read once.
	// First attempt to read the ngInjectorDef.
	var def=getInjectorDef(defOrWrappedDef);// If that's not present, then attempt to read ngModule from the InjectorDefTypeWithProviders.
	var ngModule=def==null&&defOrWrappedDef.ngModule||undefined;// Determine the InjectorType. In the case where `defOrWrappedDef` is an `InjectorType`,
	// then this is easy. In the case of an InjectorDefTypeWithProviders, then the definition type
	// is the `ngModule`.
	var defType=ngModule===undefined?defOrWrappedDef:ngModule;// Check for circular dependencies.
	if(ngDevMode&&parents.indexOf(defType)!==-1){var defName=stringify(defType);throw new Error("Circular dependency in DI detected for type "+defName+". Dependency path: "+parents.map(function(defType){return stringify(defType);}).join(' > ')+" > "+defName+".");}// Check for multiple imports of the same module
	var isDuplicate=dedupStack.indexOf(defType)!==-1;// Finally, if defOrWrappedType was an `InjectorDefTypeWithProviders`, then the actual
	// `InjectorDef` is on its `ngModule`.
	if(ngModule!==undefined){def=getInjectorDef(ngModule);}// If no definition was found, it might be from exports. Remove it.
	if(def==null){return false;}// Track the InjectorType and add a provider for it.
	this.injectorDefTypes.add(defType);this.records.set(defType,makeRecord(def.factory,NOT_YET));// Add providers in the same way that @NgModule resolution did:
	// First, include providers from any imports.
	if(def.imports!=null&&!isDuplicate){// Before processing defType's imports, add it to the set of parents. This way, if it ends
	// up deeply importing itself, this can be detected.
	ngDevMode&&parents.push(defType);// Add it to the set of dedups. This way we can detect multiple imports of the same module
	dedupStack.push(defType);var importTypesWithProviders_1;try{deepForEach(def.imports,function(imported){if(_this.processInjectorType(imported,parents,dedupStack)){if(importTypesWithProviders_1===undefined)importTypesWithProviders_1=[];// If the processed import is an injector type with providers, we store it in the
	// list of import types with providers, so that we can process those afterwards.
	importTypesWithProviders_1.push(imported);}});}finally{// Remove it from the parents set when finished.
	ngDevMode&&parents.pop();}// Imports which are declared with providers (TypeWithProviders) need to be processed
	// after all imported modules are processed. This is similar to how View Engine
	// processes/merges module imports in the metadata resolver. See: FW-1349.
	if(importTypesWithProviders_1!==undefined){var _loop_1=function _loop_1(i){var _a=importTypesWithProviders_1[i],ngModule_1=_a.ngModule,providers=_a.providers;deepForEach(providers,function(provider){return _this.processProvider(provider,ngModule_1,providers||EMPTY_ARRAY$2);});};for(var i=0;i<importTypesWithProviders_1.length;i++){_loop_1(i);}}}// Next, include providers listed on the definition itself.
	var defProviders=def.providers;if(defProviders!=null&&!isDuplicate){var injectorType_1=defOrWrappedDef;deepForEach(defProviders,function(provider){return _this.processProvider(provider,injectorType_1,defProviders);});}return ngModule!==undefined&&defOrWrappedDef.providers!==undefined;};/**
	     * Process a `SingleProvider` and add it.
	     */R3Injector.prototype.processProvider=function(provider,ngModuleType,providers){// Determine the token from the provider. Either it's its own token, or has a {provide: ...}
	// property.
	provider=resolveForwardRef(provider);var token=isTypeProvider(provider)?provider:resolveForwardRef(provider&&provider.provide);// Construct a `Record` for the provider.
	var record=providerToRecord(provider,ngModuleType,providers);if(!isTypeProvider(provider)&&provider.multi===true){// If the provider indicates that it's a multi-provider, process it specially.
	// First check whether it's been defined already.
	var multiRecord_1=this.records.get(token);if(multiRecord_1){// It has. Throw a nice error if
	if(multiRecord_1.multi===undefined){throwMixedMultiProviderError();}}else{multiRecord_1=makeRecord(undefined,NOT_YET,true);multiRecord_1.factory=function(){return injectArgs(multiRecord_1.multi);};this.records.set(token,multiRecord_1);}token=provider;multiRecord_1.multi.push(provider);}else{var existing=this.records.get(token);if(existing&&existing.multi!==undefined){throwMixedMultiProviderError();}}this.records.set(token,record);};R3Injector.prototype.hydrate=function(token,record){if(record.value===CIRCULAR){throwCyclicDependencyError(stringify(token));}else if(record.value===NOT_YET){record.value=CIRCULAR;record.value=record.factory();}if(_typeof(record.value)==='object'&&record.value&&hasOnDestroy(record.value)){this.onDestroy.add(record.value);}return record.value;};R3Injector.prototype.injectableDefInScope=function(def){if(!def.providedIn){return false;}else if(typeof def.providedIn==='string'){return def.providedIn==='any'||def.providedIn==='root'&&this.isRootInjector;}else{return this.injectorDefTypes.has(def.providedIn);}};return R3Injector;}();function injectableDefOrInjectorDefFactory(token){// Most tokens will have an ngInjectableDef directly on them, which specifies a factory directly.
	var injectableDef=getInjectableDef(token);if(injectableDef!==null){return injectableDef.factory;}// If the token is an NgModule, it's also injectable but the factory is on its ngInjectorDef.
	var injectorDef=getInjectorDef(token);if(injectorDef!==null){return injectorDef.factory;}// InjectionTokens should have an ngInjectableDef and thus should be handled above.
	// If it's missing that, it's an error.
	if(token instanceof InjectionToken){throw new Error("Token "+stringify(token)+" is missing an ngInjectableDef definition.");}// Undecorated types can sometimes be created if they have no constructor arguments.
	if(token instanceof Function){return getUndecoratedInjectableFactory(token);}// There was no way to resolve a factory for this token.
	throw new Error('unreachable');}function getUndecoratedInjectableFactory(token){// If the token has parameters then it has dependencies that we cannot resolve implicitly.
	var paramLength=token.length;if(paramLength>0){var args=new Array(paramLength).fill('?');throw new Error("Can't resolve all parameters for "+stringify(token)+": ("+args.join(', ')+").");}// The constructor function appears to have no parameters.
	// This might be because it inherits from a super-class. In which case, use an ngInjectableDef
	// from an ancestor if there is one.
	// Otherwise this really is a simple class with no dependencies, so return a factory that
	// just instantiates the zero-arg constructor.
	var inheritedInjectableDef=getInheritedInjectableDef(token);if(inheritedInjectableDef!==null){return function(){return inheritedInjectableDef.factory(token);};}else{return function(){return new token();};}}function providerToRecord(provider,ngModuleType,providers){var factory=providerToFactory(provider,ngModuleType,providers);if(isValueProvider(provider)){return makeRecord(undefined,provider.useValue);}else{return makeRecord(factory,NOT_YET);}}/**
	 * Converts a `SingleProvider` into a factory function.
	 *
	 * @param provider provider to convert to factory
	 */function providerToFactory(provider,ngModuleType,providers){var factory=undefined;if(isTypeProvider(provider)){return injectableDefOrInjectorDefFactory(resolveForwardRef(provider));}else{if(isValueProvider(provider)){factory=function factory(){return resolveForwardRef(provider.useValue);};}else if(isExistingProvider(provider)){factory=function factory(){return ÉµÉµinject(resolveForwardRef(provider.useExisting));};}else if(isFactoryProvider(provider)){factory=function factory(){return provider.useFactory.apply(provider,__spread(injectArgs(provider.deps||[])));};}else{var classRef_1=resolveForwardRef(provider&&(provider.useClass||provider.provide));if(!classRef_1){throwInvalidProviderError(ngModuleType,providers,provider);}if(hasDeps(provider)){factory=function factory(){return new(classRef_1.bind.apply(classRef_1,__spread([void 0],injectArgs(provider.deps))))();};}else{return injectableDefOrInjectorDefFactory(classRef_1);}}}return factory;}function makeRecord(factory,value,multi){if(multi===void 0){multi=false;}return {factory:factory,value:value,multi:multi?[]:undefined};}function isValueProvider(value){return value!==null&&_typeof(value)=='object'&&USE_VALUE in value;}function isExistingProvider(value){return !!(value&&value.useExisting);}function isFactoryProvider(value){return !!(value&&value.useFactory);}function isTypeProvider(value){return typeof value==='function';}function hasDeps(value){return !!value.deps;}function hasOnDestroy(value){return value!==null&&_typeof(value)==='object'&&typeof value.ngOnDestroy==='function';}function couldBeInjectableType(value){return typeof value==='function'||_typeof(value)==='object'&&value instanceof InjectionToken;}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function INJECTOR_IMPL__PRE_R3__(providers,parent,name){return new StaticInjector(providers,parent,name);}var INJECTOR_IMPL=INJECTOR_IMPL__PRE_R3__;/**
	 * Concrete injectors implement this interface.
	 *
	 * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * {@example core/di/ts/injector_spec.ts region='Injector'}
	 *
	 * `Injector` returns itself when given `Injector` as a token:
	 *
	 * {@example core/di/ts/injector_spec.ts region='injectInjector'}
	 *
	 * @publicApi
	 */var Injector=/** @class */function(){function Injector(){}/**
	     * Create a new Injector which is configure using `StaticProvider`s.
	     *
	     * @usageNotes
	     * ### Example
	     *
	     * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
	     */Injector.create=function(options,parent){if(Array.isArray(options)){return INJECTOR_IMPL(options,parent,'');}else{return INJECTOR_IMPL(options.providers,options.parent,options.name||'');}};Injector.THROW_IF_NOT_FOUND=THROW_IF_NOT_FOUND;Injector.NULL=new NullInjector();/** @nocollapse */Injector.ngInjectableDef=ÉµÉµdefineInjectable({token:Injector,providedIn:'any',factory:function factory(){return ÉµÉµinject(INJECTOR);}});/**
	     * @internal
	     * @nocollapse
	     */Injector.__NG_ELEMENT_ID__=-1;return Injector;}();var IDENT=function IDENT(value){return value;};var EMPTY$1=[];var CIRCULAR$1=IDENT;var MULTI_PROVIDER_FN=function MULTI_PROVIDER_FN(){return Array.prototype.slice.call(arguments);};var NO_NEW_LINE$1='Éµ';var StaticInjector=/** @class */function(){function StaticInjector(providers,parent,source){if(parent===void 0){parent=Injector.NULL;}if(source===void 0){source=null;}this.parent=parent;this.source=source;var records=this._records=new Map();records.set(Injector,{token:Injector,fn:IDENT,deps:EMPTY$1,value:this,useNew:false});records.set(INJECTOR,{token:INJECTOR,fn:IDENT,deps:EMPTY$1,value:this,useNew:false});recursivelyProcessProviders(records,providers);}StaticInjector.prototype.get=function(token,notFoundValue,flags){if(flags===void 0){flags=InjectFlags.Default;}var record=this._records.get(token);try{return tryResolveToken(token,record,this._records,this.parent,notFoundValue,flags);}catch(e){return catchInjectorError(e,token,'StaticInjectorError',this.source);}};StaticInjector.prototype.toString=function(){var tokens=[],records=this._records;records.forEach(function(v,token){return tokens.push(stringify(token));});return "StaticInjector["+tokens.join(', ')+"]";};return StaticInjector;}();function resolveProvider(provider){var deps=computeDeps(provider);var fn=IDENT;var value=EMPTY$1;var useNew=false;var provide=resolveForwardRef(provider.provide);if(USE_VALUE in provider){// We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.
	value=provider.useValue;}else if(provider.useFactory){fn=provider.useFactory;}else if(provider.useExisting);else if(provider.useClass){useNew=true;fn=resolveForwardRef(provider.useClass);}else if(typeof provide=='function'){useNew=true;fn=provide;}else{throw staticError('StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable',provider);}return {deps:deps,fn:fn,useNew:useNew,value:value};}function multiProviderMixError(token){return staticError('Cannot mix multi providers and regular providers',token);}function recursivelyProcessProviders(records,provider){if(provider){provider=resolveForwardRef(provider);if(provider instanceof Array){// if we have an array recurse into the array
	for(var i=0;i<provider.length;i++){recursivelyProcessProviders(records,provider[i]);}}else if(typeof provider==='function'){// Functions were supported in ReflectiveInjector, but are not here. For safety give useful
	// error messages
	throw staticError('Function/Class not supported',provider);}else if(provider&&_typeof(provider)==='object'&&provider.provide){// At this point we have what looks like a provider: {provide: ?, ....}
	var token=resolveForwardRef(provider.provide);var resolvedProvider=resolveProvider(provider);if(provider.multi===true){// This is a multi provider.
	var multiProvider=records.get(token);if(multiProvider){if(multiProvider.fn!==MULTI_PROVIDER_FN){throw multiProviderMixError(token);}}else{// Create a placeholder factory which will look up the constituents of the multi provider.
	records.set(token,multiProvider={token:provider.provide,deps:[],useNew:false,fn:MULTI_PROVIDER_FN,value:EMPTY$1});}// Treat the provider as the token.
	token=provider;multiProvider.deps.push({token:token,options:6/* Default */});}var record=records.get(token);if(record&&record.fn==MULTI_PROVIDER_FN){throw multiProviderMixError(token);}records.set(token,resolvedProvider);}else{throw staticError('Unexpected provider',provider);}}}function tryResolveToken(token,record,records,parent,notFoundValue,flags){try{return resolveToken(token,record,records,parent,notFoundValue,flags);}catch(e){// ensure that 'e' is of type Error.
	if(!(e instanceof Error)){e=new Error(e);}var path=e[NG_TEMP_TOKEN_PATH]=e[NG_TEMP_TOKEN_PATH]||[];path.unshift(token);if(record&&record.value==CIRCULAR$1){// Reset the Circular flag.
	record.value=EMPTY$1;}throw e;}}function resolveToken(token,record,records,parent,notFoundValue,flags){var _a;var value;if(record&&!(flags&InjectFlags.SkipSelf)){// If we don't have a record, this implies that we don't own the provider hence don't know how
	// to resolve it.
	value=record.value;if(value==CIRCULAR$1){throw Error(NO_NEW_LINE$1+'Circular dependency');}else if(value===EMPTY$1){record.value=CIRCULAR$1;var obj=undefined;var useNew=record.useNew;var fn=record.fn;var depRecords=record.deps;var deps=EMPTY$1;if(depRecords.length){deps=[];for(var i=0;i<depRecords.length;i++){var depRecord=depRecords[i];var options=depRecord.options;var childRecord=options&2/* CheckSelf */?records.get(depRecord.token):undefined;deps.push(tryResolveToken(// Current Token to resolve
	depRecord.token,// A record which describes how to resolve the token.
	// If undefined, this means we don't have such a record
	childRecord,// Other records we know about.
	records,// If we don't know how to resolve dependency and we should not check parent for it,
	// than pass in Null injector.
	!childRecord&&!(options&4/* CheckParent */)?Injector.NULL:parent,options&1/* Optional */?null:Injector.THROW_IF_NOT_FOUND,InjectFlags.Default));}}record.value=value=useNew?new((_a=fn).bind.apply(_a,__spread([void 0],deps)))():fn.apply(obj,deps);}}else if(!(flags&InjectFlags.Self)){value=parent.get(token,notFoundValue,InjectFlags.Default);}return value;}function computeDeps(provider){var deps=EMPTY$1;var providerDeps=provider.deps;if(providerDeps&&providerDeps.length){deps=[];for(var i=0;i<providerDeps.length;i++){var options=6/* Default */;var token=resolveForwardRef(providerDeps[i]);if(token instanceof Array){for(var j=0,annotations=token;j<annotations.length;j++){var annotation=annotations[j];if(annotation instanceof Optional||annotation==Optional){options=options|1/* Optional */;}else if(annotation instanceof SkipSelf||annotation==SkipSelf){options=options&~2/* CheckSelf */;}else if(annotation instanceof Self||annotation==Self){options=options&~4/* CheckParent */;}else if(annotation instanceof Inject){token=annotation.token;}else{token=resolveForwardRef(annotation);}}}deps.push({token:token,options:options});}}else if(provider.useExisting){var token=resolveForwardRef(provider.useExisting);deps=[{token:token,options:6/* Default */}];}else if(!providerDeps&&!(USE_VALUE in provider)){// useValue & useExisting are the only ones which are exempt from deps all others need it.
	throw staticError('\'deps\' required',provider);}return deps;}function staticError(text,obj){return new Error(formatError(text,obj,'StaticInjectorError'));}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function findFirstClosedCycle(keys){var res=[];for(var i=0;i<keys.length;++i){if(res.indexOf(keys[i])>-1){res.push(keys[i]);return res;}res.push(keys[i]);}return res;}function constructResolvingPath(keys){if(keys.length>1){var reversed=findFirstClosedCycle(keys.slice().reverse());var tokenStrs=reversed.map(function(k){return stringify(k.token);});return ' ('+tokenStrs.join(' -> ')+')';}return '';}function injectionError(injector,key,constructResolvingMessage,originalError){var keys=[key];var errMsg=constructResolvingMessage(keys);var error=originalError?wrappedError(errMsg,originalError):Error(errMsg);error.addKey=addKey;error.keys=keys;error.injectors=[injector];error.constructResolvingMessage=constructResolvingMessage;error[ERROR_ORIGINAL_ERROR]=originalError;return error;}function addKey(injector,key){this.injectors.push(injector);this.keys.push(key);// Note: This updated message won't be reflected in the `.stack` property
	this.message=this.constructResolvingMessage(this.keys);}/**
	 * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the
	 * {@link Injector} does not have a {@link Provider} for the given key.
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * ```typescript
	 * class A {
	 *   constructor(b:B) {}
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	 * ```
	 */function noProviderError(injector,key){return injectionError(injector,key,function(keys){var first$$1=stringify(keys[0].token);return "No provider for "+first$$1+"!"+constructResolvingPath(keys);});}/**
	 * Thrown when dependencies form a cycle.
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * ```typescript
	 * var injector = Injector.resolveAndCreate([
	 *   {provide: "one", useFactory: (two) => "two", deps: [[new Inject("two")]]},
	 *   {provide: "two", useFactory: (one) => "one", deps: [[new Inject("one")]]}
	 * ]);
	 *
	 * expect(() => injector.get("one")).toThrowError();
	 * ```
	 *
	 * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
	 */function cyclicDependencyError(injector,key){return injectionError(injector,key,function(keys){return "Cannot instantiate cyclic dependency!"+constructResolvingPath(keys);});}/**
	 * Thrown when a constructing type returns with an Error.
	 *
	 * The `InstantiationError` class contains the original error plus the dependency graph which caused
	 * this object to be instantiated.
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * ```typescript
	 * class A {
	 *   constructor() {
	 *     throw new Error('message');
	 *   }
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([A]);

	 * try {
	 *   injector.get(A);
	 * } catch (e) {
	 *   expect(e instanceof InstantiationError).toBe(true);
	 *   expect(e.originalException.message).toEqual("message");
	 *   expect(e.originalStack).toBeDefined();
	 * }
	 * ```
	 */function instantiationError(injector,originalException,originalStack,key){return injectionError(injector,key,function(keys){var first$$1=stringify(keys[0].token);return originalException.message+": Error during instantiation of "+first$$1+"!"+constructResolvingPath(keys)+".";},originalException);}/**
	 * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}
	 * creation.
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * ```typescript
	 * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
	 * ```
	 */function invalidProviderError(provider){return Error("Invalid provider - only instances of Provider and Type are allowed, got: "+provider);}/**
	 * Thrown when the class has no annotation information.
	 *
	 * Lack of annotation information prevents the {@link Injector} from determining which dependencies
	 * need to be injected into the constructor.
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * ```typescript
	 * class A {
	 *   constructor(b) {}
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	 * ```
	 *
	 * This error is also thrown when the class not marked with {@link Injectable} has parameter types.
	 *
	 * ```typescript
	 * class B {}
	 *
	 * class A {
	 *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
	 * ```
	 *
	 */function noAnnotationError(typeOrFunc,params){var signature=[];for(var i=0,ii=params.length;i<ii;i++){var parameter=params[i];if(!parameter||parameter.length==0){signature.push('?');}else{signature.push(parameter.map(stringify).join(' '));}}return Error('Cannot resolve all parameters for \''+stringify(typeOrFunc)+'\'('+signature.join(', ')+'). '+'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \''+stringify(typeOrFunc)+'\' is decorated with Injectable.');}/**
	 * Thrown when getting an object by index.
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * ```typescript
	 * class A {}
	 *
	 * var injector = Injector.resolveAndCreate([A]);
	 *
	 * expect(() => injector.getAt(100)).toThrowError();
	 * ```
	 *
	 */function outOfBoundsError(index){return Error("Index "+index+" is out-of-bounds.");}// TODO: add a working example after alpha38 is released
	/**
	 * Thrown when a multi provider and a regular provider are bound to the same token.
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * ```typescript
	 * expect(() => Injector.resolveAndCreate([
	 *   { provide: "Strings", useValue: "string1", multi: true},
	 *   { provide: "Strings", useValue: "string2", multi: false}
	 * ])).toThrowError();
	 * ```
	 */function mixingMultiProvidersWithRegularProvidersError(provider1,provider2){return Error("Cannot mix multi providers and regular providers, got: "+provider1+" "+provider2);}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * A unique object used for retrieving items from the {@link ReflectiveInjector}.
	 *
	 * Keys have:
	 * - a system-wide unique `id`.
	 * - a `token`.
	 *
	 * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows
	 * the
	 * injector to store created objects in a more efficient way.
	 *
	 * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when
	 * resolving
	 * providers.
	 *
	 * @deprecated No replacement
	 * @publicApi
	 */var ReflectiveKey=/** @class */function(){/**
	     * Private
	     */function ReflectiveKey(token,id){this.token=token;this.id=id;if(!token){throw new Error('Token must be defined!');}this.displayName=stringify(this.token);}/**
	     * Retrieves a `Key` for a token.
	     */ReflectiveKey.get=function(token){return _globalKeyRegistry.get(resolveForwardRef(token));};Object.defineProperty(ReflectiveKey,"numberOfKeys",{/**
	         * @returns the number of keys registered in the system.
	         */get:function get(){return _globalKeyRegistry.numberOfKeys;},enumerable:true,configurable:true});return ReflectiveKey;}();var KeyRegistry=/** @class */function(){function KeyRegistry(){this._allKeys=new Map();}KeyRegistry.prototype.get=function(token){if(token instanceof ReflectiveKey)return token;if(this._allKeys.has(token)){return this._allKeys.get(token);}var newKey=new ReflectiveKey(token,ReflectiveKey.numberOfKeys);this._allKeys.set(token,newKey);return newKey;};Object.defineProperty(KeyRegistry.prototype,"numberOfKeys",{get:function get(){return this._allKeys.size;},enumerable:true,configurable:true});return KeyRegistry;}();var _globalKeyRegistry=new KeyRegistry();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Provides access to reflection data about symbols. Used internally by Angular
	 * to power dependency injection and compilation.
	 */var Reflector=/** @class */function(){function Reflector(reflectionCapabilities){this.reflectionCapabilities=reflectionCapabilities;}Reflector.prototype.updateCapabilities=function(caps){this.reflectionCapabilities=caps;};Reflector.prototype.factory=function(type){return this.reflectionCapabilities.factory(type);};Reflector.prototype.parameters=function(typeOrFunc){return this.reflectionCapabilities.parameters(typeOrFunc);};Reflector.prototype.annotations=function(typeOrFunc){return this.reflectionCapabilities.annotations(typeOrFunc);};Reflector.prototype.propMetadata=function(typeOrFunc){return this.reflectionCapabilities.propMetadata(typeOrFunc);};Reflector.prototype.hasLifecycleHook=function(type,lcProperty){return this.reflectionCapabilities.hasLifecycleHook(type,lcProperty);};Reflector.prototype.getter=function(name){return this.reflectionCapabilities.getter(name);};Reflector.prototype.setter=function(name){return this.reflectionCapabilities.setter(name);};Reflector.prototype.method=function(name){return this.reflectionCapabilities.method(name);};Reflector.prototype.importUri=function(type){return this.reflectionCapabilities.importUri(type);};Reflector.prototype.resourceUri=function(type){return this.reflectionCapabilities.resourceUri(type);};Reflector.prototype.resolveIdentifier=function(name,moduleUrl,members,runtime){return this.reflectionCapabilities.resolveIdentifier(name,moduleUrl,members,runtime);};Reflector.prototype.resolveEnum=function(identifier,name){return this.reflectionCapabilities.resolveEnum(identifier,name);};return Reflector;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * The {@link Reflector} used internally in Angular to access metadata
	 * about symbols.
	 */var reflector=new Reflector(new ReflectionCapabilities());/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * `Dependency` is used by the framework to extend DI.
	 * This is internal to Angular and should not be used directly.
	 */var ReflectiveDependency=/** @class */function(){function ReflectiveDependency(key,optional,visibility){this.key=key;this.optional=optional;this.visibility=visibility;}ReflectiveDependency.fromKey=function(key){return new ReflectiveDependency(key,false,null);};return ReflectiveDependency;}();var _EMPTY_LIST=[];var ResolvedReflectiveProvider_=/** @class */function(){function ResolvedReflectiveProvider_(key,resolvedFactories,multiProvider){this.key=key;this.resolvedFactories=resolvedFactories;this.multiProvider=multiProvider;this.resolvedFactory=this.resolvedFactories[0];}return ResolvedReflectiveProvider_;}();/**
	 * An internal resolved representation of a factory function created by resolving `Provider`.
	 * @publicApi
	 */var ResolvedReflectiveFactory=/** @class */function(){function ResolvedReflectiveFactory(/**
	     * Factory function which can return an instance of an object represented by a key.
	     */factory,/**
	     * Arguments (dependencies) to the `factory` function.
	     */dependencies){this.factory=factory;this.dependencies=dependencies;}return ResolvedReflectiveFactory;}();/**
	 * Resolve a single provider.
	 */function resolveReflectiveFactory(provider){var factoryFn;var resolvedDeps;if(provider.useClass){var useClass=resolveForwardRef(provider.useClass);factoryFn=reflector.factory(useClass);resolvedDeps=_dependenciesFor(useClass);}else if(provider.useExisting){factoryFn=function factoryFn(aliasInstance){return aliasInstance;};resolvedDeps=[ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];}else if(provider.useFactory){factoryFn=provider.useFactory;resolvedDeps=constructDependencies(provider.useFactory,provider.deps);}else{factoryFn=function factoryFn(){return provider.useValue;};resolvedDeps=_EMPTY_LIST;}return new ResolvedReflectiveFactory(factoryFn,resolvedDeps);}/**
	 * Converts the `Provider` into `ResolvedProvider`.
	 *
	 * `Injector` internally only uses `ResolvedProvider`, `Provider` contains convenience provider
	 * syntax.
	 */function resolveReflectiveProvider(provider){return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide),[resolveReflectiveFactory(provider)],provider.multi||false);}/**
	 * Resolve a list of Providers.
	 */function resolveReflectiveProviders(providers){var normalized=_normalizeProviders(providers,[]);var resolved=normalized.map(resolveReflectiveProvider);var resolvedProviderMap=mergeResolvedReflectiveProviders(resolved,new Map());return Array.from(resolvedProviderMap.values());}/**
	 * Merges a list of ResolvedProviders into a list where each key is contained exactly once and
	 * multi providers have been merged.
	 */function mergeResolvedReflectiveProviders(providers,normalizedProvidersMap){for(var i=0;i<providers.length;i++){var provider=providers[i];var existing=normalizedProvidersMap.get(provider.key.id);if(existing){if(provider.multiProvider!==existing.multiProvider){throw mixingMultiProvidersWithRegularProvidersError(existing,provider);}if(provider.multiProvider){for(var j=0;j<provider.resolvedFactories.length;j++){existing.resolvedFactories.push(provider.resolvedFactories[j]);}}else{normalizedProvidersMap.set(provider.key.id,provider);}}else{var resolvedProvider=void 0;if(provider.multiProvider){resolvedProvider=new ResolvedReflectiveProvider_(provider.key,provider.resolvedFactories.slice(),provider.multiProvider);}else{resolvedProvider=provider;}normalizedProvidersMap.set(provider.key.id,resolvedProvider);}}return normalizedProvidersMap;}function _normalizeProviders(providers,res){providers.forEach(function(b){if(b instanceof Type){res.push({provide:b,useClass:b});}else if(b&&_typeof(b)=='object'&&b.provide!==undefined){res.push(b);}else if(b instanceof Array){_normalizeProviders(b,res);}else{throw invalidProviderError(b);}});return res;}function constructDependencies(typeOrFunc,dependencies){if(!dependencies){return _dependenciesFor(typeOrFunc);}else{var params_1=dependencies.map(function(t){return [t];});return dependencies.map(function(t){return _extractToken(typeOrFunc,t,params_1);});}}function _dependenciesFor(typeOrFunc){var params=reflector.parameters(typeOrFunc);if(!params)return [];if(params.some(function(p){return p==null;})){throw noAnnotationError(typeOrFunc,params);}return params.map(function(p){return _extractToken(typeOrFunc,p,params);});}function _extractToken(typeOrFunc,metadata,params){var token=null;var optional=false;if(!Array.isArray(metadata)){if(metadata instanceof Inject){return _createDependency(metadata.token,optional,null);}else{return _createDependency(metadata,optional,null);}}var visibility=null;for(var i=0;i<metadata.length;++i){var paramMetadata=metadata[i];if(paramMetadata instanceof Type){token=paramMetadata;}else if(paramMetadata instanceof Inject){token=paramMetadata.token;}else if(paramMetadata instanceof Optional){optional=true;}else if(paramMetadata instanceof Self||paramMetadata instanceof SkipSelf){visibility=paramMetadata;}else if(paramMetadata instanceof InjectionToken){token=paramMetadata;}}token=resolveForwardRef(token);if(token!=null){return _createDependency(token,optional,visibility);}else{throw noAnnotationError(typeOrFunc,params);}}function _createDependency(token,optional,visibility){return new ReflectiveDependency(ReflectiveKey.get(token),optional,visibility);}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ // Threshold for the dynamic version
	var UNDEFINED=new Object();/**
	 * A ReflectiveDependency injection container used for instantiating objects and resolving
	 * dependencies.
	 *
	 * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
	 * constructor dependencies.
	 *
	 * In typical use, application code asks for the dependencies in the constructor and they are
	 * resolved by the `Injector`.
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * The following example creates an `Injector` configured to create `Engine` and `Car`.
	 *
	 * ```typescript
	 * @Injectable()
	 * class Engine {
	 * }
	 *
	 * @Injectable()
	 * class Car {
	 *   constructor(public engine:Engine) {}
	 * }
	 *
	 * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	 * var car = injector.get(Car);
	 * expect(car instanceof Car).toBe(true);
	 * expect(car.engine instanceof Engine).toBe(true);
	 * ```
	 *
	 * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
	 * resolve all of the object's dependencies automatically.
	 *
	 * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.
	 * @publicApi
	 */var ReflectiveInjector=/** @class */function(){function ReflectiveInjector(){}/**
	     * Turns an array of provider definitions into an array of resolved providers.
	     *
	     * A resolution is a process of flattening multiple nested arrays and converting individual
	     * providers into an array of `ResolvedReflectiveProvider`s.
	     *
	     * @usageNotes
	     * ### Example
	     *
	     * ```typescript
	     * @Injectable()
	     * class Engine {
	     * }
	     *
	     * @Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
	     *
	     * expect(providers.length).toEqual(2);
	     *
	     * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
	     * expect(providers[0].key.displayName).toBe("Car");
	     * expect(providers[0].dependencies.length).toEqual(1);
	     * expect(providers[0].factory).toBeDefined();
	     *
	     * expect(providers[1].key.displayName).toBe("Engine");
	     * });
	     * ```
	     *
	     */ReflectiveInjector.resolve=function(providers){return resolveReflectiveProviders(providers);};/**
	     * Resolves an array of providers and creates an injector from those providers.
	     *
	     * The passed-in providers can be an array of `Type`, `Provider`,
	     * or a recursive array of more providers.
	     *
	     * @usageNotes
	     * ### Example
	     *
	     * ```typescript
	     * @Injectable()
	     * class Engine {
	     * }
	     *
	     * @Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	     * expect(injector.get(Car) instanceof Car).toBe(true);
	     * ```
	     */ReflectiveInjector.resolveAndCreate=function(providers,parent){var ResolvedReflectiveProviders=ReflectiveInjector.resolve(providers);return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders,parent);};/**
	     * Creates an injector from previously resolved providers.
	     *
	     * This API is the recommended way to construct injectors in performance-sensitive parts.
	     *
	     * @usageNotes
	     * ### Example
	     *
	     * ```typescript
	     * @Injectable()
	     * class Engine {
	     * }
	     *
	     * @Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var providers = ReflectiveInjector.resolve([Car, Engine]);
	     * var injector = ReflectiveInjector.fromResolvedProviders(providers);
	     * expect(injector.get(Car) instanceof Car).toBe(true);
	     * ```
	     */ReflectiveInjector.fromResolvedProviders=function(providers,parent){return new ReflectiveInjector_(providers,parent);};return ReflectiveInjector;}();var ReflectiveInjector_=/** @class */function(){/**
	     * Private
	     */function ReflectiveInjector_(_providers,_parent){/** @internal */this._constructionCounter=0;this._providers=_providers;this.parent=_parent||null;var len=_providers.length;this.keyIds=new Array(len);this.objs=new Array(len);for(var i=0;i<len;i++){this.keyIds[i]=_providers[i].key.id;this.objs[i]=UNDEFINED;}}ReflectiveInjector_.prototype.get=function(token,notFoundValue){if(notFoundValue===void 0){notFoundValue=THROW_IF_NOT_FOUND;}return this._getByKey(ReflectiveKey.get(token),null,notFoundValue);};ReflectiveInjector_.prototype.resolveAndCreateChild=function(providers){var ResolvedReflectiveProviders=ReflectiveInjector.resolve(providers);return this.createChildFromResolved(ResolvedReflectiveProviders);};ReflectiveInjector_.prototype.createChildFromResolved=function(providers){var inj=new ReflectiveInjector_(providers);inj.parent=this;return inj;};ReflectiveInjector_.prototype.resolveAndInstantiate=function(provider){return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);};ReflectiveInjector_.prototype.instantiateResolved=function(provider){return this._instantiateProvider(provider);};ReflectiveInjector_.prototype.getProviderAtIndex=function(index){if(index<0||index>=this._providers.length){throw outOfBoundsError(index);}return this._providers[index];};/** @internal */ReflectiveInjector_.prototype._new=function(provider){if(this._constructionCounter++>this._getMaxNumberOfObjects()){throw cyclicDependencyError(this,provider.key);}return this._instantiateProvider(provider);};ReflectiveInjector_.prototype._getMaxNumberOfObjects=function(){return this.objs.length;};ReflectiveInjector_.prototype._instantiateProvider=function(provider){if(provider.multiProvider){var res=new Array(provider.resolvedFactories.length);for(var i=0;i<provider.resolvedFactories.length;++i){res[i]=this._instantiate(provider,provider.resolvedFactories[i]);}return res;}else{return this._instantiate(provider,provider.resolvedFactories[0]);}};ReflectiveInjector_.prototype._instantiate=function(provider,ResolvedReflectiveFactory){var _this=this;var factory=ResolvedReflectiveFactory.factory;var deps;try{deps=ResolvedReflectiveFactory.dependencies.map(function(dep){return _this._getByReflectiveDependency(dep);});}catch(e){if(e.addKey){e.addKey(this,provider.key);}throw e;}var obj;try{obj=factory.apply(void 0,__spread(deps));}catch(e){throw instantiationError(this,e,e.stack,provider.key);}return obj;};ReflectiveInjector_.prototype._getByReflectiveDependency=function(dep){return this._getByKey(dep.key,dep.visibility,dep.optional?null:THROW_IF_NOT_FOUND);};ReflectiveInjector_.prototype._getByKey=function(key,visibility,notFoundValue){if(key===ReflectiveInjector_.INJECTOR_KEY){return this;}if(visibility instanceof Self){return this._getByKeySelf(key,notFoundValue);}else{return this._getByKeyDefault(key,notFoundValue,visibility);}};ReflectiveInjector_.prototype._getObjByKeyId=function(keyId){for(var i=0;i<this.keyIds.length;i++){if(this.keyIds[i]===keyId){if(this.objs[i]===UNDEFINED){this.objs[i]=this._new(this._providers[i]);}return this.objs[i];}}return UNDEFINED;};/** @internal */ReflectiveInjector_.prototype._throwOrNull=function(key,notFoundValue){if(notFoundValue!==THROW_IF_NOT_FOUND){return notFoundValue;}else{throw noProviderError(this,key);}};/** @internal */ReflectiveInjector_.prototype._getByKeySelf=function(key,notFoundValue){var obj=this._getObjByKeyId(key.id);return obj!==UNDEFINED?obj:this._throwOrNull(key,notFoundValue);};/** @internal */ReflectiveInjector_.prototype._getByKeyDefault=function(key,notFoundValue,visibility){var inj;if(visibility instanceof SkipSelf){inj=this.parent;}else{inj=this;}while(inj instanceof ReflectiveInjector_){var inj_=inj;var obj=inj_._getObjByKeyId(key.id);if(obj!==UNDEFINED)return obj;inj=inj_.parent;}if(inj!==null){return inj.get(key.token,notFoundValue);}else{return this._throwOrNull(key,notFoundValue);}};Object.defineProperty(ReflectiveInjector_.prototype,"displayName",{get:function get(){var providers=_mapProviders(this,function(b){return ' "'+b.key.displayName+'" ';}).join(', ');return "ReflectiveInjector(providers: ["+providers+"])";},enumerable:true,configurable:true});ReflectiveInjector_.prototype.toString=function(){return this.displayName;};ReflectiveInjector_.INJECTOR_KEY=ReflectiveKey.get(Injector);return ReflectiveInjector_;}();function _mapProviders(injector,fn){var res=new Array(injector._providers.length);for(var i=0;i<injector._providers.length;++i){res[i]=fn(injector.getProviderAtIndex(i));}return res;}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * A DI token that you can use to create a virtual [provider](guide/glossary#provider)
	 * that will populate the `entryComponents` field of components and NgModules
	 * based on its `useValue` property value.
	 * All components that are referenced in the `useValue` value (either directly
	 * or in a nested array or map) are added to the `entryComponents` property.
	 *
	 * @usageNotes
	 *
	 * The following example shows how the router can populate the `entryComponents`
	 * field of an NgModule based on a router configuration that refers
	 * to components.
	 *
	 * ```typescript
	 * // helper function inside the router
	 * function provideRoutes(routes) {
	 *   return [
	 *     {provide: ROUTES, useValue: routes},
	 *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
	 *   ];
	 * }
	 *
	 * // user code
	 * let routes = [
	 *   {path: '/root', component: RootComp},
	 *   {path: '/teams', component: TeamsComp}
	 * ];
	 *
	 * @NgModule({
	 *   providers: [provideRoutes(routes)]
	 * })
	 * class ModuleWithRoutes {}
	 * ```
	 *
	 * @publicApi
	 */var ANALYZE_FOR_ENTRY_COMPONENTS=new InjectionToken('AnalyzeForEntryComponents');/**
	 * Base class for query metadata.
	 *
	 * @see `ContentChildren`.
	 * @see `ContentChild`.
	 * @see `ViewChildren`.
	 * @see `ViewChild`.
	 *
	 * @publicApi
	 */var Query=/** @class */function(){function Query(){}return Query;}();var Éµ0$b=function Éµ0$b(selector,data){if(data===void 0){data={};}return _assign({selector:selector,first:false,isViewQuery:false,descendants:false},data);};/**
	 * ContentChildren decorator and metadata.
	 *
	 *
	 * @Annotation
	 * @publicApi
	 */var ContentChildren=makePropDecorator('ContentChildren',Éµ0$b,Query);var Éµ1$3=function Éµ1$3(selector,data){if(data===void 0){data={};}return _assign({selector:selector,first:true,isViewQuery:false,descendants:true},data);};/**
	 * ContentChild decorator and metadata.
	 *
	 *
	 * @Annotation
	 *
	 * @publicApi
	 */var ContentChild=makePropDecorator('ContentChild',Éµ1$3,Query);var Éµ2=function Éµ2(selector,data){if(data===void 0){data={};}return _assign({selector:selector,first:false,isViewQuery:true,descendants:true},data);};/**
	 * ViewChildren decorator and metadata.
	 *
	 * @Annotation
	 * @publicApi
	 */var ViewChildren=makePropDecorator('ViewChildren',Éµ2,Query);var Éµ3=function Éµ3(selector,data){return _assign({selector:selector,first:true,isViewQuery:true,descendants:true},data);};/**
	 * ViewChild decorator and metadata.
	 *
	 * @Annotation
	 * @publicApi
	 */var ViewChild=makePropDecorator('ViewChild',Éµ3,Query);/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var _symbolIterator=null;function getSymbolIterator$1(){if(!_symbolIterator){var Symbol_1=_global$1['Symbol'];if(Symbol_1&&Symbol_1.iterator){_symbolIterator=Symbol_1.iterator;}else{// es6-shim specific logic
	var keys=Object.getOwnPropertyNames(Map.prototype);for(var i=0;i<keys.length;++i){var key=keys[i];if(key!=='entries'&&key!=='size'&&Map.prototype[key]===Map.prototype['entries']){_symbolIterator=key;}}}}return _symbolIterator;}function looseIdentical(a,b){return a===b||typeof a==='number'&&typeof b==='number'&&isNaN(a)&&isNaN(b);}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function devModeEqual$1(a,b){var isListLikeIterableA=isListLikeIterable$1(a);var isListLikeIterableB=isListLikeIterable$1(b);if(isListLikeIterableA&&isListLikeIterableB){return areIterablesEqual$1(a,b,devModeEqual$1);}else{var isAObject=a&&(_typeof(a)==='object'||typeof a==='function');var isBObject=b&&(_typeof(b)==='object'||typeof b==='function');if(!isListLikeIterableA&&isAObject&&!isListLikeIterableB&&isBObject){return true;}else{return looseIdentical(a,b);}}}/**
	 * Indicates that the result of a {@link Pipe} transformation has changed even though the
	 * reference has not changed.
	 *
	 * Wrapped values are unwrapped automatically during the change detection, and the unwrapped value
	 * is stored.
	 *
	 * Example:
	 *
	 * ```
	 * if (this._latestValue === this._latestReturnedValue) {
	 *    return this._latestReturnedValue;
	 *  } else {
	 *    this._latestReturnedValue = this._latestValue;
	 *    return WrappedValue.wrap(this._latestValue); // this will force update
	 *  }
	 * ```
	 *
	 * @publicApi
	 */var WrappedValue=/** @class */function(){function WrappedValue(value){this.wrapped=value;}/** Creates a wrapped value. */WrappedValue.wrap=function(value){return new WrappedValue(value);};/**
	     * Returns the underlying value of a wrapped value.
	     * Returns the given `value` when it is not wrapped.
	     **/WrappedValue.unwrap=function(value){return WrappedValue.isWrapped(value)?value.wrapped:value;};/** Returns true if `value` is a wrapped value. */WrappedValue.isWrapped=function(value){return value instanceof WrappedValue;};return WrappedValue;}();function isListLikeIterable$1(obj){if(!isJsObject$1(obj))return false;return Array.isArray(obj)||!(obj instanceof Map)&&// JS Map are iterables but return entries as [k, v]
	getSymbolIterator$1()in obj;// JS Iterable have a Symbol.iterator prop
	}function areIterablesEqual$1(a,b,comparator){var iterator1=a[getSymbolIterator$1()]();var iterator2=b[getSymbolIterator$1()]();while(true){var item1=iterator1.next();var item2=iterator2.next();if(item1.done&&item2.done)return true;if(item1.done||item2.done)return false;if(!comparator(item1.value,item2.value))return false;}}function iterateListLike$1(obj,fn){if(Array.isArray(obj)){for(var i=0;i<obj.length;i++){fn(obj[i]);}}else{var iterator=obj[getSymbolIterator$1()]();var item=void 0;while(!(item=iterator.next()).done){fn(item.value);}}}function isJsObject$1(o){return o!==null&&(typeof o==='function'||_typeof(o)==='object');}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ // TODO(misko): consider inlining
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Determine if the argument is shaped like a Promise
	 */function isPromise$1(obj){// allow any Promise/A+ compliant thenable.
	// It's up to the caller to ensure that obj.then conforms to the spec
	return !!obj&&typeof obj.then==='function';}/**
	 * Determine if the argument is an Observable
	 */function isObservable$1(obj){// TODO: use isObservable once we update pass rxjs 6.1
	// https://github.com/ReactiveX/rxjs/blob/master/CHANGELOG.md#610-2018-05-03
	return !!obj&&typeof obj.subscribe==='function';}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Returns the component instance associated with a given DOM host element.
	 * Elements which don't represent components return `null`.
	 *
	 * @param element Host DOM element from which the component should be retrieved.
	 *
	 * ```
	 * <my-app>
	 *   #VIEW
	 *     <div>
	 *       <child-comp></child-comp>
	 *     </div>
	 * </mp-app>
	 *
	 * expect(getComponent(<child-comp>) instanceof ChildComponent).toBeTruthy();
	 * expect(getComponent(<my-app>) instanceof MyApp).toBeTruthy();
	 * ```
	 *
	 * @publicApi
	 */function getComponent(element){var context=loadLContextFromNode(element);if(context.component===undefined){context.component=getComponentAtNodeIndex(context.nodeIndex,context.lView);}return context.component;}/**
	 * Returns the component instance associated with a given DOM host element.
	 * Elements which don't represent components return `null`.
	 *
	 * @param element Host DOM element from which the component should be retrieved.
	 *
	 * ```
	 * <my-app>
	 *   #VIEW
	 *     <div>
	 *       <child-comp></child-comp>
	 *     </div>
	 * </mp-app>
	 *
	 * expect(getComponent(<child-comp>) instanceof ChildComponent).toBeTruthy();
	 * expect(getComponent(<my-app>) instanceof MyApp).toBeTruthy();
	 * ```
	 *
	 * @publicApi
	 */function getContext$1(element){var context=loadLContextFromNode(element);return context.lView[CONTEXT];}/**
	 * Returns the component instance associated with view which owns the DOM element (`null`
	 * otherwise).
	 *
	 * @param element DOM element which is owned by an existing component's view.
	 *
	 * ```
	 * <my-app>
	 *   #VIEW
	 *     <div>
	 *       <child-comp></child-comp>
	 *     </div>
	 * </mp-app>
	 *
	 * expect(getViewComponent(<child-comp>) instanceof MyApp).toBeTruthy();
	 * expect(getViewComponent(<my-app>)).toEqual(null);
	 * ```
	 *
	 * @publicApi
	 */function getViewComponent(element){var context=loadLContext(element);var lView=context.lView;var parent;ngDevMode&&assertLView(lView);while(lView[HOST]===null&&(parent=getLViewParent(lView))){// As long as lView[HOST] is null we know we are part of sub-template such as `*ngIf`
	lView=parent;}return lView[FLAGS]&512/* IsRoot */?null:lView[CONTEXT];}/**
	 * Retrieves an `Injector` associated with the element, component or directive.
	 *
	 * @param target A DOM element, component or directive instance.
	 *
	 * @publicApi
	 */function getInjector(target){var context=loadLContext(target);var tNode=context.lView[TVIEW].data[context.nodeIndex];return new NodeInjector(tNode,context.lView);}/**
	 * Retrieve a set of injection tokens at a given DOM node.
	 *
	 * @param element Element for which the injection tokens should be retrieved.
	 * @publicApi
	 */function getInjectionTokens(element){var context=loadLContext(element,false);if(!context)return [];var lView=context.lView;var tView=lView[TVIEW];var tNode=tView.data[context.nodeIndex];var providerTokens=[];var startIndex=tNode.providerIndexes&65535/* ProvidersStartIndexMask */;var endIndex=tNode.directiveEnd;for(var i=startIndex;i<endIndex;i++){var value=tView.data[i];if(isDirectiveDefHack(value)){// The fact that we sometimes store Type and sometimes DirectiveDef in this location is a
	// design flaw.  We should always store same type so that we can be monomorphic. The issue
	// is that for Components/Directives we store the def instead the type. The correct behavior
	// is that we should always be storing injectable type in this location.
	value=value.type;}providerTokens.push(value);}return providerTokens;}function loadLContext(target,throwOnNotFound){if(throwOnNotFound===void 0){throwOnNotFound=true;}var context=getLContext(target);if(!context&&throwOnNotFound){throw new Error(ngDevMode?"Unable to find context associated with "+stringifyForError(target):'Invalid ng target');}return context;}/**
	 * Retrieve map of local references.
	 *
	 * The references are retrieved as a map of local reference name to element or directive instance.
	 *
	 * @param target A DOM element, component or directive instance.
	 *
	 * @publicApi
	 */function getLocalRefs(target){var context=loadLContext(target);if(context.localRefs===undefined){context.localRefs=discoverLocalRefs(context.lView,context.nodeIndex);}return context.localRefs||{};}function loadLContextFromNode(node){if(!(node instanceof Node))throw new Error('Expecting instance of DOM Node');return loadLContext(node);}function isBrowserEvents(listener){// Browser events are those which don't have `useCapture` as boolean.
	return typeof listener.useCapture==='boolean';}/**
	 * Retrieves a list of DOM listeners.
	 *
	 * ```
	 * <my-app>
	 *   #VIEW
	 *     <div (click)="doSomething()">
	 *     </div>
	 * </mp-app>
	 *
	 * expect(getListeners(<div>)).toEqual({
	 *   name: 'click',
	 *   element: <div>,
	 *   callback: () => doSomething(),
	 *   useCapture: false
	 * });
	 * ```
	 *
	 * @param element Element for which the DOM listeners should be retrieved.
	 * @publicApi
	 */function getListeners(element){var lContext=loadLContextFromNode(element);var lView=lContext.lView;var tView=lView[TVIEW];var lCleanup=lView[CLEANUP];var tCleanup=tView.cleanup;var listeners=[];if(tCleanup&&lCleanup){for(var i=0;i<tCleanup.length;){var firstParam=tCleanup[i++];var secondParam=tCleanup[i++];if(typeof firstParam==='string'){var name_1=firstParam;var listenerElement=unwrapRNode(lView[secondParam]);var callback=lCleanup[tCleanup[i++]];var useCaptureOrIndx=tCleanup[i++];// if useCaptureOrIndx is boolean then report it as is.
	// if useCaptureOrIndx is positive number then it in unsubscribe method
	// if useCaptureOrIndx is negative number then it is a Subscription
	var useCapture=typeof useCaptureOrIndx==='boolean'?useCaptureOrIndx:useCaptureOrIndx>=0?false:null;if(element==listenerElement){listeners.push({element:element,name:name_1,callback:callback,useCapture:useCapture});}}}}listeners.sort(sortListeners);return listeners;}function sortListeners(a,b){if(a.name==b.name)return 0;return a.name<b.name?-1:1;}/**
	 * This function should not exist because it is megamorphic and only mostly correct.
	 *
	 * See call site for more info.
	 */function isDirectiveDefHack(obj){return obj.type!==undefined&&obj.template!==undefined&&obj.declaredInputs!==undefined;}/**
	 * Creates the root component view and the root component node.
	 *
	 * @param rNode Render host element.
	 * @param def ComponentDef
	 * @param rootView The parent view where the host node is stored
	 * @param renderer The current renderer
	 * @param sanitizer The sanitizer, if provided
	 *
	 * @returns Component view created
	 */function createRootComponentView(rNode,def,rootView,rendererFactory,renderer,sanitizer){resetComponentState();var tView=rootView[TVIEW];ngDevMode&&assertDataInRange(rootView,0+HEADER_OFFSET);rootView[0+HEADER_OFFSET]=rNode;var tNode=getOrCreateTNode(tView,null,0,3/* Element */,null,null);var componentView=createLView(rootView,getOrCreateTView(def),null,def.onPush?64/* Dirty */:16/* CheckAlways */,rootView[HEADER_OFFSET],tNode,rendererFactory,renderer,sanitizer);if(tView.firstTemplatePass){diPublicInInjector(getOrCreateNodeInjectorForNode(tNode,rootView),tView,def.type);tNode.flags=1/* isComponent */;initNodeFlags(tNode,rootView.length,1);queueComponentIndexForCheck(tNode);}// Store component view at node index, with node as the HOST
	return rootView[HEADER_OFFSET]=componentView;}/**
	 * Creates a root component and sets it up with features and host bindings. Shared by
	 * renderComponent() and ViewContainerRef.createComponent().
	 */function createRootComponent(componentView,componentDef,rootView,rootContext,hostFeatures){var tView=rootView[TVIEW];// Create directive instance with factory() and store at next index in viewData
	var component=instantiateRootComponent(tView,rootView,componentDef);rootContext.components.push(component);componentView[CONTEXT]=component;hostFeatures&&hostFeatures.forEach(function(feature){return feature(component,componentDef);});// We want to generate an empty QueryList for root content queries for backwards
	// compatibility with ViewEngine.
	if(componentDef.contentQueries){componentDef.contentQueries(1/* Create */,component,rootView.length-1);}var rootTNode=getPreviousOrParentTNode();if(tView.firstTemplatePass&&componentDef.hostBindings){var elementIndex=rootTNode.index-HEADER_OFFSET;var expando=tView.expandoInstructions;invokeHostBindingsInCreationMode(componentDef,expando,component,rootTNode,tView.firstTemplatePass);}return component;}function createRootContext(scheduler,playerHandler){return {components:[],scheduler:scheduler||defaultScheduler,clean:CLEAN_PROMISE,playerHandler:playerHandler||null,flags:0/* Empty */};}/**
	 * Used to enable lifecycle hooks on the root component.
	 *
	 * Include this feature when calling `renderComponent` if the root component
	 * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't
	 * be called properly.
	 *
	 * Example:
	 *
	 * ```
	 * renderComponent(AppComponent, {features: [RootLifecycleHooks]});
	 * ```
	 */function LifecycleHooksFeature(component,def){var rootTView=readPatchedLView(component)[TVIEW];var dirIndex=rootTView.data.length-1;registerPreOrderHooks(dirIndex,def,rootTView,-1,-1,-1);// TODO(misko): replace `as TNode` with createTNode call. (needs refactoring to lose dep on
	// LNode).
	registerPostOrderHooks(rootTView,{directiveStart:dirIndex,directiveEnd:dirIndex+1});}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Represents a basic change from a previous to a new value for a single
	 * property on a directive instance. Passed as a value in a
	 * {@link SimpleChanges} object to the `ngOnChanges` hook.
	 *
	 * @see `OnChanges`
	 *
	 * @publicApi
	 */var SimpleChange=/** @class */function(){function SimpleChange(previousValue,currentValue,firstChange){this.previousValue=previousValue;this.currentValue=currentValue;this.firstChange=firstChange;}/**
	     * Check whether the new value is the first value assigned.
	     */SimpleChange.prototype.isFirstChange=function(){return this.firstChange;};return SimpleChange;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Represents a component created by a `ComponentFactory`.
	 * Provides access to the component instance and related objects,
	 * and provides the means of destroying the instance.
	 *
	 * @publicApi
	 */var ComponentRef=/** @class */function(){function ComponentRef(){}return ComponentRef;}();/**
	 * Base class for a factory that can create a component dynamically.
	 * Instantiate a factory for a given type of component with `resolveComponentFactory()`.
	 * Use the resulting `ComponentFactory.create()` method to create a component of that type.
	 *
	 * @see [Dynamic Components](guide/dynamic-component-loader)
	 *
	 * @publicApi
	 */var ComponentFactory=/** @class */function(){function ComponentFactory(){}return ComponentFactory;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function noComponentFactoryError(component){var error=Error("No component factory found for "+stringify(component)+". Did you add it to @NgModule.entryComponents?");error[ERROR_COMPONENT]=component;return error;}var ERROR_COMPONENT='ngComponent';var _NullComponentFactoryResolver=/** @class */function(){function _NullComponentFactoryResolver(){}_NullComponentFactoryResolver.prototype.resolveComponentFactory=function(component){throw noComponentFactoryError(component);};return _NullComponentFactoryResolver;}();/**
	 * A simple registry that maps `Components` to generated `ComponentFactory` classes
	 * that can be used to create instances of components.
	 * Use to obtain the factory for a given component type,
	 * then use the factory's `create()` method to create a component of that type.
	 *
	 * @see [Dynamic Components](guide/dynamic-component-loader)
	 * @publicApi
	 */var ComponentFactoryResolver=/** @class */function(){function ComponentFactoryResolver(){}ComponentFactoryResolver.NULL=new _NullComponentFactoryResolver();return ComponentFactoryResolver;}();var ComponentFactoryBoundToModule=/** @class */function(_super){__extends(ComponentFactoryBoundToModule,_super);function ComponentFactoryBoundToModule(factory,ngModule){var _this=_super.call(this)||this;_this.factory=factory;_this.ngModule=ngModule;_this.selector=factory.selector;_this.componentType=factory.componentType;_this.ngContentSelectors=factory.ngContentSelectors;_this.inputs=factory.inputs;_this.outputs=factory.outputs;return _this;}ComponentFactoryBoundToModule.prototype.create=function(injector,projectableNodes,rootSelectorOrNode,ngModule){return this.factory.create(injector,projectableNodes,rootSelectorOrNode,ngModule||this.ngModule);};return ComponentFactoryBoundToModule;}(ComponentFactory);/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function noop$1(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}// Do nothing.
	}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * A wrapper around a native element inside of a View.
	 *
	 * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
	 * element.
	 *
	 * @security Permitting direct access to the DOM can make your application more vulnerable to
	 * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the
	 * [Security Guide](http://g.co/ng/security).
	 *
	 * @publicApi
	 */ // Note: We don't expose things like `Injector`, `ViewContainer`, ... here,
	// i.e. users have to ask for what they need. With that, we can build better analysis tools
	// and could do better codegen in the future.
	var ElementRef=/** @class */function(){function ElementRef(nativeElement){this.nativeElement=nativeElement;}/**
	     * @internal
	     * @nocollapse
	     */ElementRef.__NG_ELEMENT_ID__=function(){return SWITCH_ELEMENT_REF_FACTORY(ElementRef);};return ElementRef;}();var SWITCH_ELEMENT_REF_FACTORY__PRE_R3__=noop$1;var SWITCH_ELEMENT_REF_FACTORY=SWITCH_ELEMENT_REF_FACTORY__PRE_R3__;/**
	 * @deprecated Use the `Renderer2` instead.
	 * @publicApi
	 */var Renderer=/** @class */function(){function Renderer(){}return Renderer;}();var Renderer2Interceptor=new InjectionToken('Renderer2Interceptor');/**
	 * Creates and initializes a custom renderer that implements the `Renderer2` base class.
	 *
	 * @publicApi
	 */var RendererFactory2=/** @class */function(){function RendererFactory2(){}return RendererFactory2;}();/**
	 * Flags for renderer-specific style modifiers.
	 * @publicApi
	 */var RendererStyleFlags2;(function(RendererStyleFlags2){/**
	     * Marks a style as important.
	     */RendererStyleFlags2[RendererStyleFlags2["Important"]=1]="Important";/**
	     * Marks a style as using dash case naming (this-is-dash-case).
	     */RendererStyleFlags2[RendererStyleFlags2["DashCase"]=2]="DashCase";})(RendererStyleFlags2||(RendererStyleFlags2={}));/**
	 * Extend this base class to implement custom rendering. By default, Angular
	 * renders a template into DOM. You can use custom rendering to intercept
	 * rendering calls, or to render to something other than DOM.
	 *
	 * Create your custom renderer using `RendererFactory2`.
	 *
	 * Use a custom renderer to bypass Angular's templating and
	 * make custom UI changes that can't be expressed declaratively.
	 * For example if you need to set a property or an attribute whose name is
	 * not statically known, use the `setProperty()` or
	 * `setAttribute()` method.
	 *
	 * @publicApi
	 */var Renderer2=/** @class */function(){function Renderer2(){}/**
	     * @internal
	     * @nocollapse
	     */Renderer2.__NG_ELEMENT_ID__=function(){return SWITCH_RENDERER2_FACTORY();};return Renderer2;}();var SWITCH_RENDERER2_FACTORY__PRE_R3__=noop$1;var SWITCH_RENDERER2_FACTORY=SWITCH_RENDERER2_FACTORY__PRE_R3__;/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * @description Represents the version of Angular
	 *
	 * @publicApi
	 */var Version=/** @class */function(){function Version(full){this.full=full;this.major=full.split('.')[0];this.minor=full.split('.')[1];this.patch=full.split('.').slice(2).join('.');}return Version;}();/**
	 * @publicApi
	 */var VERSION=new Version('8.2.6');/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var DefaultIterableDifferFactory=/** @class */function(){function DefaultIterableDifferFactory(){}DefaultIterableDifferFactory.prototype.supports=function(obj){return isListLikeIterable$1(obj);};DefaultIterableDifferFactory.prototype.create=function(trackByFn){return new DefaultIterableDiffer(trackByFn);};return DefaultIterableDifferFactory;}();var trackByIdentity=function trackByIdentity(index,item){return item;};/**
	 * @deprecated v4.0.0 - Should not be part of public API.
	 * @publicApi
	 */var DefaultIterableDiffer=/** @class */function(){function DefaultIterableDiffer(trackByFn){this.length=0;// Keeps track of the used records at any point in time (during & across `_check()` calls)
	this._linkedRecords=null;// Keeps track of the removed records at any point in time during `_check()` calls.
	this._unlinkedRecords=null;this._previousItHead=null;this._itHead=null;this._itTail=null;this._additionsHead=null;this._additionsTail=null;this._movesHead=null;this._movesTail=null;this._removalsHead=null;this._removalsTail=null;// Keeps track of records where custom track by is the same, but item identity has changed
	this._identityChangesHead=null;this._identityChangesTail=null;this._trackByFn=trackByFn||trackByIdentity;}DefaultIterableDiffer.prototype.forEachItem=function(fn){var record;for(record=this._itHead;record!==null;record=record._next){fn(record);}};DefaultIterableDiffer.prototype.forEachOperation=function(fn){var nextIt=this._itHead;var nextRemove=this._removalsHead;var addRemoveOffset=0;var moveOffsets=null;while(nextIt||nextRemove){// Figure out which is the next record to process
	// Order: remove, add, move
	var record=!nextRemove||nextIt&&nextIt.currentIndex<getPreviousIndex(nextRemove,addRemoveOffset,moveOffsets)?nextIt:nextRemove;var adjPreviousIndex=getPreviousIndex(record,addRemoveOffset,moveOffsets);var currentIndex=record.currentIndex;// consume the item, and adjust the addRemoveOffset and update moveDistance if necessary
	if(record===nextRemove){addRemoveOffset--;nextRemove=nextRemove._nextRemoved;}else{nextIt=nextIt._next;if(record.previousIndex==null){addRemoveOffset++;}else{// INVARIANT:  currentIndex < previousIndex
	if(!moveOffsets)moveOffsets=[];var localMovePreviousIndex=adjPreviousIndex-addRemoveOffset;var localCurrentIndex=currentIndex-addRemoveOffset;if(localMovePreviousIndex!=localCurrentIndex){for(var i=0;i<localMovePreviousIndex;i++){var offset=i<moveOffsets.length?moveOffsets[i]:moveOffsets[i]=0;var index=offset+i;if(localCurrentIndex<=index&&index<localMovePreviousIndex){moveOffsets[i]=offset+1;}}var previousIndex=record.previousIndex;moveOffsets[previousIndex]=localCurrentIndex-localMovePreviousIndex;}}}if(adjPreviousIndex!==currentIndex){fn(record,adjPreviousIndex,currentIndex);}}};DefaultIterableDiffer.prototype.forEachPreviousItem=function(fn){var record;for(record=this._previousItHead;record!==null;record=record._nextPrevious){fn(record);}};DefaultIterableDiffer.prototype.forEachAddedItem=function(fn){var record;for(record=this._additionsHead;record!==null;record=record._nextAdded){fn(record);}};DefaultIterableDiffer.prototype.forEachMovedItem=function(fn){var record;for(record=this._movesHead;record!==null;record=record._nextMoved){fn(record);}};DefaultIterableDiffer.prototype.forEachRemovedItem=function(fn){var record;for(record=this._removalsHead;record!==null;record=record._nextRemoved){fn(record);}};DefaultIterableDiffer.prototype.forEachIdentityChange=function(fn){var record;for(record=this._identityChangesHead;record!==null;record=record._nextIdentityChange){fn(record);}};DefaultIterableDiffer.prototype.diff=function(collection){if(collection==null)collection=[];if(!isListLikeIterable$1(collection)){throw new Error("Error trying to diff '"+stringify(collection)+"'. Only arrays and iterables are allowed");}if(this.check(collection)){return this;}else{return null;}};DefaultIterableDiffer.prototype.onDestroy=function(){};DefaultIterableDiffer.prototype.check=function(collection){var _this=this;this._reset();var record=this._itHead;var mayBeDirty=false;var index;var item;var itemTrackBy;if(Array.isArray(collection)){this.length=collection.length;for(var index_1=0;index_1<this.length;index_1++){item=collection[index_1];itemTrackBy=this._trackByFn(index_1,item);if(record===null||!looseIdentical(record.trackById,itemTrackBy)){record=this._mismatch(record,item,itemTrackBy,index_1);mayBeDirty=true;}else{if(mayBeDirty){// TODO(misko): can we limit this to duplicates only?
	record=this._verifyReinsertion(record,item,itemTrackBy,index_1);}if(!looseIdentical(record.item,item))this._addIdentityChange(record,item);}record=record._next;}}else{index=0;iterateListLike$1(collection,function(item){itemTrackBy=_this._trackByFn(index,item);if(record===null||!looseIdentical(record.trackById,itemTrackBy)){record=_this._mismatch(record,item,itemTrackBy,index);mayBeDirty=true;}else{if(mayBeDirty){// TODO(misko): can we limit this to duplicates only?
	record=_this._verifyReinsertion(record,item,itemTrackBy,index);}if(!looseIdentical(record.item,item))_this._addIdentityChange(record,item);}record=record._next;index++;});this.length=index;}this._truncate(record);this.collection=collection;return this.isDirty;};Object.defineProperty(DefaultIterableDiffer.prototype,"isDirty",{/* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
	         * changes.
	         */get:function get(){return this._additionsHead!==null||this._movesHead!==null||this._removalsHead!==null||this._identityChangesHead!==null;},enumerable:true,configurable:true});/**
	     * Reset the state of the change objects to show no changes. This means set previousKey to
	     * currentKey, and clear all of the queues (additions, moves, removals).
	     * Set the previousIndexes of moved and added items to their currentIndexes
	     * Reset the list of additions, moves and removals
	     *
	     * @internal
	     */DefaultIterableDiffer.prototype._reset=function(){if(this.isDirty){var record=void 0;var nextRecord=void 0;for(record=this._previousItHead=this._itHead;record!==null;record=record._next){record._nextPrevious=record._next;}for(record=this._additionsHead;record!==null;record=record._nextAdded){record.previousIndex=record.currentIndex;}this._additionsHead=this._additionsTail=null;for(record=this._movesHead;record!==null;record=nextRecord){record.previousIndex=record.currentIndex;nextRecord=record._nextMoved;}this._movesHead=this._movesTail=null;this._removalsHead=this._removalsTail=null;this._identityChangesHead=this._identityChangesTail=null;// TODO(vicb): when assert gets supported
	// assert(!this.isDirty);
	}};/**
	     * This is the core function which handles differences between collections.
	     *
	     * - `record` is the record which we saw at this position last time. If null then it is a new
	     *   item.
	     * - `item` is the current item in the collection
	     * - `index` is the position of the item in the collection
	     *
	     * @internal
	     */DefaultIterableDiffer.prototype._mismatch=function(record,item,itemTrackBy,index){// The previous record after which we will append the current one.
	var previousRecord;if(record===null){previousRecord=this._itTail;}else{previousRecord=record._prev;// Remove the record from the collection since we know it does not match the item.
	this._remove(record);}// Attempt to see if we have seen the item before.
	record=this._linkedRecords===null?null:this._linkedRecords.get(itemTrackBy,index);if(record!==null){// We have seen this before, we need to move it forward in the collection.
	// But first we need to check if identity changed, so we can update in view if necessary
	if(!looseIdentical(record.item,item))this._addIdentityChange(record,item);this._moveAfter(record,previousRecord,index);}else{// Never seen it, check evicted list.
	record=this._unlinkedRecords===null?null:this._unlinkedRecords.get(itemTrackBy,null);if(record!==null){// It is an item which we have evicted earlier: reinsert it back into the list.
	// But first we need to check if identity changed, so we can update in view if necessary
	if(!looseIdentical(record.item,item))this._addIdentityChange(record,item);this._reinsertAfter(record,previousRecord,index);}else{// It is a new item: add it.
	record=this._addAfter(new IterableChangeRecord_(item,itemTrackBy),previousRecord,index);}}return record;};/**
	     * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
	     *
	     * Use case: `[a, a]` => `[b, a, a]`
	     *
	     * If we did not have this check then the insertion of `b` would:
	     *   1) evict first `a`
	     *   2) insert `b` at `0` index.
	     *   3) leave `a` at index `1` as is. <-- this is wrong!
	     *   3) reinsert `a` at index 2. <-- this is wrong!
	     *
	     * The correct behavior is:
	     *   1) evict first `a`
	     *   2) insert `b` at `0` index.
	     *   3) reinsert `a` at index 1.
	     *   3) move `a` at from `1` to `2`.
	     *
	     *
	     * Double check that we have not evicted a duplicate item. We need to check if the item type may
	     * have already been removed:
	     * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
	     * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
	     * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
	     * at the end.
	     *
	     * @internal
	     */DefaultIterableDiffer.prototype._verifyReinsertion=function(record,item,itemTrackBy,index){var reinsertRecord=this._unlinkedRecords===null?null:this._unlinkedRecords.get(itemTrackBy,null);if(reinsertRecord!==null){record=this._reinsertAfter(reinsertRecord,record._prev,index);}else if(record.currentIndex!=index){record.currentIndex=index;this._addToMoves(record,index);}return record;};/**
	     * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection
	     *
	     * - `record` The first excess {@link IterableChangeRecord_}.
	     *
	     * @internal
	     */DefaultIterableDiffer.prototype._truncate=function(record){// Anything after that needs to be removed;
	while(record!==null){var nextRecord=record._next;this._addToRemovals(this._unlink(record));record=nextRecord;}if(this._unlinkedRecords!==null){this._unlinkedRecords.clear();}if(this._additionsTail!==null){this._additionsTail._nextAdded=null;}if(this._movesTail!==null){this._movesTail._nextMoved=null;}if(this._itTail!==null){this._itTail._next=null;}if(this._removalsTail!==null){this._removalsTail._nextRemoved=null;}if(this._identityChangesTail!==null){this._identityChangesTail._nextIdentityChange=null;}};/** @internal */DefaultIterableDiffer.prototype._reinsertAfter=function(record,prevRecord,index){if(this._unlinkedRecords!==null){this._unlinkedRecords.remove(record);}var prev=record._prevRemoved;var next=record._nextRemoved;if(prev===null){this._removalsHead=next;}else{prev._nextRemoved=next;}if(next===null){this._removalsTail=prev;}else{next._prevRemoved=prev;}this._insertAfter(record,prevRecord,index);this._addToMoves(record,index);return record;};/** @internal */DefaultIterableDiffer.prototype._moveAfter=function(record,prevRecord,index){this._unlink(record);this._insertAfter(record,prevRecord,index);this._addToMoves(record,index);return record;};/** @internal */DefaultIterableDiffer.prototype._addAfter=function(record,prevRecord,index){this._insertAfter(record,prevRecord,index);if(this._additionsTail===null){// TODO(vicb):
	// assert(this._additionsHead === null);
	this._additionsTail=this._additionsHead=record;}else{// TODO(vicb):
	// assert(_additionsTail._nextAdded === null);
	// assert(record._nextAdded === null);
	this._additionsTail=this._additionsTail._nextAdded=record;}return record;};/** @internal */DefaultIterableDiffer.prototype._insertAfter=function(record,prevRecord,index){// TODO(vicb):
	// assert(record != prevRecord);
	// assert(record._next === null);
	// assert(record._prev === null);
	var next=prevRecord===null?this._itHead:prevRecord._next;// TODO(vicb):
	// assert(next != record);
	// assert(prevRecord != record);
	record._next=next;record._prev=prevRecord;if(next===null){this._itTail=record;}else{next._prev=record;}if(prevRecord===null){this._itHead=record;}else{prevRecord._next=record;}if(this._linkedRecords===null){this._linkedRecords=new _DuplicateMap();}this._linkedRecords.put(record);record.currentIndex=index;return record;};/** @internal */DefaultIterableDiffer.prototype._remove=function(record){return this._addToRemovals(this._unlink(record));};/** @internal */DefaultIterableDiffer.prototype._unlink=function(record){if(this._linkedRecords!==null){this._linkedRecords.remove(record);}var prev=record._prev;var next=record._next;// TODO(vicb):
	// assert((record._prev = null) === null);
	// assert((record._next = null) === null);
	if(prev===null){this._itHead=next;}else{prev._next=next;}if(next===null){this._itTail=prev;}else{next._prev=prev;}return record;};/** @internal */DefaultIterableDiffer.prototype._addToMoves=function(record,toIndex){// TODO(vicb):
	// assert(record._nextMoved === null);
	if(record.previousIndex===toIndex){return record;}if(this._movesTail===null){// TODO(vicb):
	// assert(_movesHead === null);
	this._movesTail=this._movesHead=record;}else{// TODO(vicb):
	// assert(_movesTail._nextMoved === null);
	this._movesTail=this._movesTail._nextMoved=record;}return record;};DefaultIterableDiffer.prototype._addToRemovals=function(record){if(this._unlinkedRecords===null){this._unlinkedRecords=new _DuplicateMap();}this._unlinkedRecords.put(record);record.currentIndex=null;record._nextRemoved=null;if(this._removalsTail===null){// TODO(vicb):
	// assert(_removalsHead === null);
	this._removalsTail=this._removalsHead=record;record._prevRemoved=null;}else{// TODO(vicb):
	// assert(_removalsTail._nextRemoved === null);
	// assert(record._nextRemoved === null);
	record._prevRemoved=this._removalsTail;this._removalsTail=this._removalsTail._nextRemoved=record;}return record;};/** @internal */DefaultIterableDiffer.prototype._addIdentityChange=function(record,item){record.item=item;if(this._identityChangesTail===null){this._identityChangesTail=this._identityChangesHead=record;}else{this._identityChangesTail=this._identityChangesTail._nextIdentityChange=record;}return record;};return DefaultIterableDiffer;}();var IterableChangeRecord_=/** @class */function(){function IterableChangeRecord_(item,trackById){this.item=item;this.trackById=trackById;this.currentIndex=null;this.previousIndex=null;/** @internal */this._nextPrevious=null;/** @internal */this._prev=null;/** @internal */this._next=null;/** @internal */this._prevDup=null;/** @internal */this._nextDup=null;/** @internal */this._prevRemoved=null;/** @internal */this._nextRemoved=null;/** @internal */this._nextAdded=null;/** @internal */this._nextMoved=null;/** @internal */this._nextIdentityChange=null;}return IterableChangeRecord_;}();// A linked list of CollectionChangeRecords with the same IterableChangeRecord_.item
	var _DuplicateItemRecordList=/** @class */function(){function _DuplicateItemRecordList(){/** @internal */this._head=null;/** @internal */this._tail=null;}/**
	     * Append the record to the list of duplicates.
	     *
	     * Note: by design all records in the list of duplicates hold the same value in record.item.
	     */_DuplicateItemRecordList.prototype.add=function(record){if(this._head===null){this._head=this._tail=record;record._nextDup=null;record._prevDup=null;}else{// TODO(vicb):
	// assert(record.item ==  _head.item ||
	//       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
	this._tail._nextDup=record;record._prevDup=this._tail;record._nextDup=null;this._tail=record;}};// Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and
	// IterableChangeRecord_.currentIndex >= atOrAfterIndex
	_DuplicateItemRecordList.prototype.get=function(trackById,atOrAfterIndex){var record;for(record=this._head;record!==null;record=record._nextDup){if((atOrAfterIndex===null||atOrAfterIndex<=record.currentIndex)&&looseIdentical(record.trackById,trackById)){return record;}}return null;};/**
	     * Remove one {@link IterableChangeRecord_} from the list of duplicates.
	     *
	     * Returns whether the list of duplicates is empty.
	     */_DuplicateItemRecordList.prototype.remove=function(record){// TODO(vicb):
	// assert(() {
	//  // verify that the record being removed is in the list.
	//  for (IterableChangeRecord_ cursor = _head; cursor != null; cursor = cursor._nextDup) {
	//    if (identical(cursor, record)) return true;
	//  }
	//  return false;
	//});
	var prev=record._prevDup;var next=record._nextDup;if(prev===null){this._head=next;}else{prev._nextDup=next;}if(next===null){this._tail=prev;}else{next._prevDup=prev;}return this._head===null;};return _DuplicateItemRecordList;}();var _DuplicateMap=/** @class */function(){function _DuplicateMap(){this.map=new Map();}_DuplicateMap.prototype.put=function(record){var key=record.trackById;var duplicates=this.map.get(key);if(!duplicates){duplicates=new _DuplicateItemRecordList();this.map.set(key,duplicates);}duplicates.add(record);};/**
	     * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we
	     * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.
	     *
	     * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
	     * have any more `a`s needs to return the second `a`.
	     */_DuplicateMap.prototype.get=function(trackById,atOrAfterIndex){var key=trackById;var recordList=this.map.get(key);return recordList?recordList.get(trackById,atOrAfterIndex):null;};/**
	     * Removes a {@link IterableChangeRecord_} from the list of duplicates.
	     *
	     * The list of duplicates also is removed from the map if it gets empty.
	     */_DuplicateMap.prototype.remove=function(record){var key=record.trackById;var recordList=this.map.get(key);// Remove the list of duplicates when it gets empty
	if(recordList.remove(record)){this.map.delete(key);}return record;};Object.defineProperty(_DuplicateMap.prototype,"isEmpty",{get:function get(){return this.map.size===0;},enumerable:true,configurable:true});_DuplicateMap.prototype.clear=function(){this.map.clear();};return _DuplicateMap;}();function getPreviousIndex(item,addRemoveOffset,moveOffsets){var previousIndex=item.previousIndex;if(previousIndex===null)return previousIndex;var moveOffset=0;if(moveOffsets&&previousIndex<moveOffsets.length){moveOffset=moveOffsets[previousIndex];}return previousIndex+addRemoveOffset+moveOffset;}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var DefaultKeyValueDifferFactory=/** @class */function(){function DefaultKeyValueDifferFactory(){}DefaultKeyValueDifferFactory.prototype.supports=function(obj){return obj instanceof Map||isJsObject$1(obj);};DefaultKeyValueDifferFactory.prototype.create=function(){return new DefaultKeyValueDiffer();};return DefaultKeyValueDifferFactory;}();var DefaultKeyValueDiffer=/** @class */function(){function DefaultKeyValueDiffer(){this._records=new Map();this._mapHead=null;// _appendAfter is used in the check loop
	this._appendAfter=null;this._previousMapHead=null;this._changesHead=null;this._changesTail=null;this._additionsHead=null;this._additionsTail=null;this._removalsHead=null;this._removalsTail=null;}Object.defineProperty(DefaultKeyValueDiffer.prototype,"isDirty",{get:function get(){return this._additionsHead!==null||this._changesHead!==null||this._removalsHead!==null;},enumerable:true,configurable:true});DefaultKeyValueDiffer.prototype.forEachItem=function(fn){var record;for(record=this._mapHead;record!==null;record=record._next){fn(record);}};DefaultKeyValueDiffer.prototype.forEachPreviousItem=function(fn){var record;for(record=this._previousMapHead;record!==null;record=record._nextPrevious){fn(record);}};DefaultKeyValueDiffer.prototype.forEachChangedItem=function(fn){var record;for(record=this._changesHead;record!==null;record=record._nextChanged){fn(record);}};DefaultKeyValueDiffer.prototype.forEachAddedItem=function(fn){var record;for(record=this._additionsHead;record!==null;record=record._nextAdded){fn(record);}};DefaultKeyValueDiffer.prototype.forEachRemovedItem=function(fn){var record;for(record=this._removalsHead;record!==null;record=record._nextRemoved){fn(record);}};DefaultKeyValueDiffer.prototype.diff=function(map$$1){if(!map$$1){map$$1=new Map();}else if(!(map$$1 instanceof Map||isJsObject$1(map$$1))){throw new Error("Error trying to diff '"+stringify(map$$1)+"'. Only maps and objects are allowed");}return this.check(map$$1)?this:null;};DefaultKeyValueDiffer.prototype.onDestroy=function(){};/**
	     * Check the current state of the map vs the previous.
	     * The algorithm is optimised for when the keys do no change.
	     */DefaultKeyValueDiffer.prototype.check=function(map$$1){var _this=this;this._reset();var insertBefore=this._mapHead;this._appendAfter=null;this._forEach(map$$1,function(value,key){if(insertBefore&&insertBefore.key===key){_this._maybeAddToChanges(insertBefore,value);_this._appendAfter=insertBefore;insertBefore=insertBefore._next;}else{var record=_this._getOrCreateRecordForKey(key,value);insertBefore=_this._insertBeforeOrAppend(insertBefore,record);}});// Items remaining at the end of the list have been deleted
	if(insertBefore){if(insertBefore._prev){insertBefore._prev._next=null;}this._removalsHead=insertBefore;for(var record=insertBefore;record!==null;record=record._nextRemoved){if(record===this._mapHead){this._mapHead=null;}this._records.delete(record.key);record._nextRemoved=record._next;record.previousValue=record.currentValue;record.currentValue=null;record._prev=null;record._next=null;}}// Make sure tails have no next records from previous runs
	if(this._changesTail)this._changesTail._nextChanged=null;if(this._additionsTail)this._additionsTail._nextAdded=null;return this.isDirty;};/**
	     * Inserts a record before `before` or append at the end of the list when `before` is null.
	     *
	     * Notes:
	     * - This method appends at `this._appendAfter`,
	     * - This method updates `this._appendAfter`,
	     * - The return value is the new value for the insertion pointer.
	     */DefaultKeyValueDiffer.prototype._insertBeforeOrAppend=function(before,record){if(before){var prev=before._prev;record._next=before;record._prev=prev;before._prev=record;if(prev){prev._next=record;}if(before===this._mapHead){this._mapHead=record;}this._appendAfter=before;return before;}if(this._appendAfter){this._appendAfter._next=record;record._prev=this._appendAfter;}else{this._mapHead=record;}this._appendAfter=record;return null;};DefaultKeyValueDiffer.prototype._getOrCreateRecordForKey=function(key,value){if(this._records.has(key)){var record_1=this._records.get(key);this._maybeAddToChanges(record_1,value);var prev=record_1._prev;var next=record_1._next;if(prev){prev._next=next;}if(next){next._prev=prev;}record_1._next=null;record_1._prev=null;return record_1;}var record=new KeyValueChangeRecord_(key);this._records.set(key,record);record.currentValue=value;this._addToAdditions(record);return record;};/** @internal */DefaultKeyValueDiffer.prototype._reset=function(){if(this.isDirty){var record=void 0;// let `_previousMapHead` contain the state of the map before the changes
	this._previousMapHead=this._mapHead;for(record=this._previousMapHead;record!==null;record=record._next){record._nextPrevious=record._next;}// Update `record.previousValue` with the value of the item before the changes
	// We need to update all changed items (that's those which have been added and changed)
	for(record=this._changesHead;record!==null;record=record._nextChanged){record.previousValue=record.currentValue;}for(record=this._additionsHead;record!=null;record=record._nextAdded){record.previousValue=record.currentValue;}this._changesHead=this._changesTail=null;this._additionsHead=this._additionsTail=null;this._removalsHead=null;}};// Add the record or a given key to the list of changes only when the value has actually changed
	DefaultKeyValueDiffer.prototype._maybeAddToChanges=function(record,newValue){if(!looseIdentical(newValue,record.currentValue)){record.previousValue=record.currentValue;record.currentValue=newValue;this._addToChanges(record);}};DefaultKeyValueDiffer.prototype._addToAdditions=function(record){if(this._additionsHead===null){this._additionsHead=this._additionsTail=record;}else{this._additionsTail._nextAdded=record;this._additionsTail=record;}};DefaultKeyValueDiffer.prototype._addToChanges=function(record){if(this._changesHead===null){this._changesHead=this._changesTail=record;}else{this._changesTail._nextChanged=record;this._changesTail=record;}};/** @internal */DefaultKeyValueDiffer.prototype._forEach=function(obj,fn){if(obj instanceof Map){obj.forEach(fn);}else{Object.keys(obj).forEach(function(k){return fn(obj[k],k);});}};return DefaultKeyValueDiffer;}();var KeyValueChangeRecord_=/** @class */function(){function KeyValueChangeRecord_(key){this.key=key;this.previousValue=null;this.currentValue=null;/** @internal */this._nextPrevious=null;/** @internal */this._next=null;/** @internal */this._prev=null;/** @internal */this._nextAdded=null;/** @internal */this._nextRemoved=null;/** @internal */this._nextChanged=null;}return KeyValueChangeRecord_;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
	 *
	 * @publicApi
	 */var IterableDiffers=/** @class */function(){function IterableDiffers(factories){this.factories=factories;}IterableDiffers.create=function(factories,parent){if(parent!=null){var copied=parent.factories.slice();factories=factories.concat(copied);}return new IterableDiffers(factories);};/**
	     * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
	     * inherited {@link IterableDiffers} instance with the provided factories and return a new
	     * {@link IterableDiffers} instance.
	     *
	     * @usageNotes
	     * ### Example
	     *
	     * The following example shows how to extend an existing list of factories,
	     * which will only be applied to the injector for this component and its children.
	     * This step is all that's required to make a new {@link IterableDiffer} available.
	     *
	     * ```
	     * @Component({
	     *   viewProviders: [
	     *     IterableDiffers.extend([new ImmutableListDiffer()])
	     *   ]
	     * })
	     * ```
	     */IterableDiffers.extend=function(factories){return {provide:IterableDiffers,useFactory:function useFactory(parent){if(!parent){// Typically would occur when calling IterableDiffers.extend inside of dependencies passed
	// to
	// bootstrap(), which would override default pipes instead of extending them.
	throw new Error('Cannot extend IterableDiffers without a parent injector');}return IterableDiffers.create(factories,parent);},// Dependency technically isn't optional, but we can provide a better error message this way.
	deps:[[IterableDiffers,new SkipSelf(),new Optional()]]};};IterableDiffers.prototype.find=function(iterable){var factory=this.factories.find(function(f){return f.supports(iterable);});if(factory!=null){return factory;}else{throw new Error("Cannot find a differ supporting object '"+iterable+"' of type '"+getTypeNameForDebugging(iterable)+"'");}};/** @nocollapse */IterableDiffers.ngInjectableDef=ÉµÉµdefineInjectable({token:IterableDiffers,providedIn:'root',factory:function factory(){return new IterableDiffers([new DefaultIterableDifferFactory()]);}});return IterableDiffers;}();function getTypeNameForDebugging(type){return type['name']||_typeof(type);}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
	 *
	 * @publicApi
	 */var KeyValueDiffers=/** @class */function(){function KeyValueDiffers(factories){this.factories=factories;}KeyValueDiffers.create=function(factories,parent){if(parent){var copied=parent.factories.slice();factories=factories.concat(copied);}return new KeyValueDiffers(factories);};/**
	     * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
	     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
	     * {@link KeyValueDiffers} instance.
	     *
	     * @usageNotes
	     * ### Example
	     *
	     * The following example shows how to extend an existing list of factories,
	     * which will only be applied to the injector for this component and its children.
	     * This step is all that's required to make a new {@link KeyValueDiffer} available.
	     *
	     * ```
	     * @Component({
	     *   viewProviders: [
	     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
	     *   ]
	     * })
	     * ```
	     */KeyValueDiffers.extend=function(factories){return {provide:KeyValueDiffers,useFactory:function useFactory(parent){if(!parent){// Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
	// to bootstrap(), which would override default pipes instead of extending them.
	throw new Error('Cannot extend KeyValueDiffers without a parent injector');}return KeyValueDiffers.create(factories,parent);},// Dependency technically isn't optional, but we can provide a better error message this way.
	deps:[[KeyValueDiffers,new SkipSelf(),new Optional()]]};};KeyValueDiffers.prototype.find=function(kv){var factory=this.factories.find(function(f){return f.supports(kv);});if(factory){return factory;}throw new Error("Cannot find a differ supporting object '"+kv+"'");};/** @nocollapse */KeyValueDiffers.ngInjectableDef=ÉµÉµdefineInjectable({token:KeyValueDiffers,providedIn:'root',factory:function factory(){return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);}});return KeyValueDiffers;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Structural diffing for `Object`s and `Map`s.
	 */var keyValDiff=[new DefaultKeyValueDifferFactory()];/**
	 * Structural diffing for `Iterable` types such as `Array`s.
	 */var iterableDiff=[new DefaultIterableDifferFactory()];var defaultIterableDiffers=new IterableDiffers(iterableDiff);var defaultKeyValueDiffers=new KeyValueDiffers(keyValDiff);/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Represents an embedded template that can be used to instantiate embedded views.
	 * To instantiate embedded views based on a template, use the `ViewContainerRef`
	 * method `createEmbeddedView()`.
	 *
	 * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`
	 * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view
	 * is injected into the constructor of the directive,
	 * using the `TemplateRef` token.
	 *
	 * You can also use a `Query` to find a `TemplateRef` associated with
	 * a component or a directive.
	 *
	 * @see `ViewContainerRef`
	 * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)
	 *
	 * @publicApi
	 */var TemplateRef=/** @class */function(){function TemplateRef(){}/**
	     * @internal
	     * @nocollapse
	     */TemplateRef.__NG_ELEMENT_ID__=function(){return SWITCH_TEMPLATE_REF_FACTORY(TemplateRef,ElementRef);};return TemplateRef;}();var SWITCH_TEMPLATE_REF_FACTORY__PRE_R3__=noop$1;var SWITCH_TEMPLATE_REF_FACTORY=SWITCH_TEMPLATE_REF_FACTORY__PRE_R3__;/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Represents a container where one or more views can be attached to a component.
	 *
	 * Can contain *host views* (created by instantiating a
	 * component with the `createComponent()` method), and *embedded views*
	 * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).
	 *
	 * A view container instance can contain other view containers,
	 * creating a [view hierarchy](guide/glossary#view-tree).
	 *
	 * @see `ComponentRef`
	 * @see `EmbeddedViewRef`
	 *
	 * @publicApi
	 */var ViewContainerRef=/** @class */function(){function ViewContainerRef(){}/**
	     * @internal
	     * @nocollapse
	     */ViewContainerRef.__NG_ELEMENT_ID__=function(){return SWITCH_VIEW_CONTAINER_REF_FACTORY(ViewContainerRef,ElementRef);};return ViewContainerRef;}();var SWITCH_VIEW_CONTAINER_REF_FACTORY__PRE_R3__=noop$1;var SWITCH_VIEW_CONTAINER_REF_FACTORY=SWITCH_VIEW_CONTAINER_REF_FACTORY__PRE_R3__;/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function expressionChangedAfterItHasBeenCheckedError(context,oldValue,currValue,isFirstCheck){var msg="ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '"+oldValue+"'. Current value: '"+currValue+"'.";if(isFirstCheck){msg+=" It seems like the view has been created after its parent and its children have been dirty checked."+" Has it been created in a change detection hook ?";}return viewDebugError(msg,context);}function viewWrappedDebugError(err,context){if(!(err instanceof Error)){// errors that are not Error instances don't have a stack,
	// so it is ok to wrap them into a new Error object...
	err=new Error(err.toString());}_addDebugContext(err,context);return err;}function viewDebugError(msg,context){var err=new Error(msg);_addDebugContext(err,context);return err;}function _addDebugContext(err,context){err[ERROR_DEBUG_CONTEXT]=context;err[ERROR_LOGGER]=context.logError.bind(context);}function isViewDebugError(err){return !!getDebugContext(err);}function viewDestroyedError(action){return new Error("ViewDestroyedError: Attempt to use a destroyed view: "+action);}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ // Called before each cycle of a view's check to detect whether this is in the
	// initState for which we need to call ngOnInit, ngAfterContentInit or ngAfterViewInit
	// lifecycle methods. Returns true if this check cycle should call lifecycle
	// methods.
	function shiftInitState(view,priorInitState,newInitState){// Only update the InitState if we are currently in the prior state.
	// For example, only move into CallingInit if we are in BeforeInit. Only
	// move into CallingContentInit if we are in CallingInit. Normally this will
	// always be true because of how checkCycle is called in checkAndUpdateView.
	// However, if checkAndUpdateView is called recursively or if an exception is
	// thrown while checkAndUpdateView is running, checkAndUpdateView starts over
	// from the beginning. This ensures the state is monotonically increasing,
	// terminating in the AfterInit state, which ensures the Init methods are called
	// at least once and only once.
	var state=view.state;var initState=state&1792/* InitState_Mask */;if(initState===priorInitState){view.state=state&~1792/* InitState_Mask */|newInitState;view.initIndex=-1;return true;}return initState===newInitState;}// Returns true if the lifecycle init method should be called for the node with
	// the given init index.
	function shouldCallLifecycleInitHook(view,initState,index){if((view.state&1792/* InitState_Mask */)===initState&&view.initIndex<=index){view.initIndex=index+1;return true;}return false;}/**
	 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
	 */function asTextData(view,index){return view.nodes[index];}/**
	 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
	 */function asElementData(view,index){return view.nodes[index];}/**
	 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
	 */function asProviderData(view,index){return view.nodes[index];}/**
	 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
	 */function asPureExpressionData(view,index){return view.nodes[index];}/**
	 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
	 */function asQueryList(view,index){return view.nodes[index];}/**
	 * This object is used to prevent cycles in the source files and to have a place where
	 * debug mode can hook it. It is lazily filled when `isDevMode` is known.
	 */var Services={setCurrentNode:undefined,createRootView:undefined,createEmbeddedView:undefined,createComponentView:undefined,createNgModuleRef:undefined,overrideProvider:undefined,overrideComponentView:undefined,clearOverrides:undefined,checkAndUpdateView:undefined,checkNoChangesView:undefined,destroyView:undefined,resolveDep:undefined,createDebugContext:undefined,handleEvent:undefined,updateDirectives:undefined,updateRenderer:undefined,dirtyParentQueries:undefined};/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var NOOP=function NOOP(){};var _tokenKeyCache=new Map();function tokenKey(token){var key=_tokenKeyCache.get(token);if(!key){key=stringify(token)+'_'+_tokenKeyCache.size;_tokenKeyCache.set(token,key);}return key;}function checkBinding(view,def,bindingIdx,value){var oldValues=view.oldValues;if(view.state&2/* FirstCheck */||!looseIdentical(oldValues[def.bindingIndex+bindingIdx],value)){return true;}return false;}function checkAndUpdateBinding(view,def,bindingIdx,value){if(checkBinding(view,def,bindingIdx,value)){view.oldValues[def.bindingIndex+bindingIdx]=value;return true;}return false;}function checkBindingNoChanges(view,def,bindingIdx,value){var oldValue=view.oldValues[def.bindingIndex+bindingIdx];if(view.state&1/* BeforeFirstCheck */||!devModeEqual$1(oldValue,value)){var bindingName=def.bindings[bindingIdx].name;throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view,def.nodeIndex),bindingName+": "+oldValue,bindingName+": "+value,(view.state&1/* BeforeFirstCheck */)!==0);}}function markParentViewsForCheck(view){var currView=view;while(currView){if(currView.def.flags&2/* OnPush */){currView.state|=8/* ChecksEnabled */;}currView=currView.viewContainerParent||currView.parent;}}function markParentViewsForCheckProjectedViews(view,endView){var currView=view;while(currView&&currView!==endView){currView.state|=64/* CheckProjectedViews */;currView=currView.viewContainerParent||currView.parent;}}function dispatchEvent(view,nodeIndex,eventName,event){try{var nodeDef=view.def.nodes[nodeIndex];var startView=nodeDef.flags&33554432/* ComponentView */?asElementData(view,nodeIndex).componentView:view;markParentViewsForCheck(startView);return Services.handleEvent(view,nodeIndex,eventName,event);}catch(e){// Attention: Don't rethrow, as it would cancel Observable subscriptions!
	view.root.errorHandler.handleError(e);}}function declaredViewContainer(view){if(view.parent){var parentView=view.parent;return asElementData(parentView,view.parentNodeDef.nodeIndex);}return null;}/**
	 * for component views, this is the host element.
	 * for embedded views, this is the index of the parent node
	 * that contains the view container.
	 */function viewParentEl(view){var parentView=view.parent;if(parentView){return view.parentNodeDef.parent;}else{return null;}}function renderNode(view,def){switch(def.flags&201347067/* Types */){case 1/* TypeElement */:return asElementData(view,def.nodeIndex).renderElement;case 2/* TypeText */:return asTextData(view,def.nodeIndex).renderText;}}function elementEventFullName(target,name){return target?target+":"+name:name;}function isComponentView(view){return !!view.parent&&!!(view.parentNodeDef.flags&32768/* Component */);}function isEmbeddedView(view){return !!view.parent&&!(view.parentNodeDef.flags&32768/* Component */);}function splitDepsDsl(deps,sourceName){return deps.map(function(value){var _a;var token;var flags;if(Array.isArray(value)){_a=__read(value,2),flags=_a[0],token=_a[1];}else{flags=0/* None */;token=value;}if(token&&(typeof token==='function'||_typeof(token)==='object')&&sourceName){Object.defineProperty(token,SOURCE,{value:sourceName,configurable:true});}return {flags:flags,token:token,tokenKey:tokenKey(token)};});}function getParentRenderElement(view,renderHost,def){var renderParent=def.renderParent;if(renderParent){if((renderParent.flags&1/* TypeElement */)===0||(renderParent.flags&33554432/* ComponentView */)===0||renderParent.element.componentRendererType&&renderParent.element.componentRendererType.encapsulation===ViewEncapsulation.Native){// only children of non components, or children of components with native encapsulation should
	// be attached.
	return asElementData(view,def.renderParent.nodeIndex).renderElement;}}else{return renderHost;}}var DEFINITION_CACHE=new WeakMap();function resolveDefinition(factory){var value=DEFINITION_CACHE.get(factory);if(!value){value=factory(function(){return NOOP;});value.factory=factory;DEFINITION_CACHE.set(factory,value);}return value;}function rootRenderNodes(view){var renderNodes=[];visitRootRenderNodes(view,0/* Collect */,undefined,undefined,renderNodes);return renderNodes;}function visitRootRenderNodes(view,action,parentNode,nextSibling,target){// We need to re-compute the parent node in case the nodes have been moved around manually
	if(action===3/* RemoveChild */){parentNode=view.renderer.parentNode(renderNode(view,view.def.lastRenderRootNode));}visitSiblingRenderNodes(view,action,0,view.def.nodes.length-1,parentNode,nextSibling,target);}function visitSiblingRenderNodes(view,action,startIndex,endIndex,parentNode,nextSibling,target){for(var i=startIndex;i<=endIndex;i++){var nodeDef=view.def.nodes[i];if(nodeDef.flags&(1/* TypeElement */|2/* TypeText */|8/* TypeNgContent */)){visitRenderNode(view,nodeDef,action,parentNode,nextSibling,target);}// jump to next sibling
	i+=nodeDef.childCount;}}function visitProjectedRenderNodes(view,ngContentIndex,action,parentNode,nextSibling,target){var compView=view;while(compView&&!isComponentView(compView)){compView=compView.parent;}var hostView=compView.parent;var hostElDef=viewParentEl(compView);var startIndex=hostElDef.nodeIndex+1;var endIndex=hostElDef.nodeIndex+hostElDef.childCount;for(var i=startIndex;i<=endIndex;i++){var nodeDef=hostView.def.nodes[i];if(nodeDef.ngContentIndex===ngContentIndex){visitRenderNode(hostView,nodeDef,action,parentNode,nextSibling,target);}// jump to next sibling
	i+=nodeDef.childCount;}if(!hostView.parent){// a root view
	var projectedNodes=view.root.projectableNodes[ngContentIndex];if(projectedNodes){for(var i=0;i<projectedNodes.length;i++){execRenderNodeAction(view,projectedNodes[i],action,parentNode,nextSibling,target);}}}}function visitRenderNode(view,nodeDef,action,parentNode,nextSibling,target){if(nodeDef.flags&8/* TypeNgContent */){visitProjectedRenderNodes(view,nodeDef.ngContent.index,action,parentNode,nextSibling,target);}else{var rn=renderNode(view,nodeDef);if(action===3/* RemoveChild */&&nodeDef.flags&33554432/* ComponentView */&&nodeDef.bindingFlags&48/* CatSyntheticProperty */){// Note: we might need to do both actions.
	if(nodeDef.bindingFlags&16/* SyntheticProperty */){execRenderNodeAction(view,rn,action,parentNode,nextSibling,target);}if(nodeDef.bindingFlags&32/* SyntheticHostProperty */){var compView=asElementData(view,nodeDef.nodeIndex).componentView;execRenderNodeAction(compView,rn,action,parentNode,nextSibling,target);}}else{execRenderNodeAction(view,rn,action,parentNode,nextSibling,target);}if(nodeDef.flags&16777216/* EmbeddedViews */){var embeddedViews=asElementData(view,nodeDef.nodeIndex).viewContainer._embeddedViews;for(var k=0;k<embeddedViews.length;k++){visitRootRenderNodes(embeddedViews[k],action,parentNode,nextSibling,target);}}if(nodeDef.flags&1/* TypeElement */&&!nodeDef.element.name){visitSiblingRenderNodes(view,action,nodeDef.nodeIndex+1,nodeDef.nodeIndex+nodeDef.childCount,parentNode,nextSibling,target);}}}function execRenderNodeAction(view,renderNode,action,parentNode,nextSibling,target){var renderer=view.renderer;switch(action){case 1/* AppendChild */:renderer.appendChild(parentNode,renderNode);break;case 2/* InsertBefore */:renderer.insertBefore(parentNode,renderNode,nextSibling);break;case 3/* RemoveChild */:renderer.removeChild(parentNode,renderNode);break;case 0/* Collect */:target.push(renderNode);break;}}var NS_PREFIX_RE=/^:([^:]+):(.+)$/;function splitNamespace(name){if(name[0]===':'){var match=name.match(NS_PREFIX_RE);return [match[1],match[2]];}return ['',name];}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var UNDEFINED_VALUE=new Object();var InjectorRefTokenKey=tokenKey(Injector);var INJECTORRefTokenKey=tokenKey(INJECTOR);var NgModuleRefTokenKey=tokenKey(NgModuleRef);function initNgModule(data){var def=data._def;var providers=data._providers=new Array(def.providers.length);for(var i=0;i<def.providers.length;i++){var provDef=def.providers[i];if(!(provDef.flags&4096/* LazyProvider */)){// Make sure the provider has not been already initialized outside this loop.
	if(providers[i]===undefined){providers[i]=_createProviderInstance(data,provDef);}}}}function resolveNgModuleDep(data,depDef,notFoundValue){if(notFoundValue===void 0){notFoundValue=Injector.THROW_IF_NOT_FOUND;}var former=setCurrentInjector(data);try{if(depDef.flags&8/* Value */){return depDef.token;}if(depDef.flags&2/* Optional */){notFoundValue=null;}if(depDef.flags&1/* SkipSelf */){return data._parent.get(depDef.token,notFoundValue);}var tokenKey_1=depDef.tokenKey;switch(tokenKey_1){case InjectorRefTokenKey:case INJECTORRefTokenKey:case NgModuleRefTokenKey:return data;}var providerDef=data._def.providersByKey[tokenKey_1];var injectableDef=void 0;if(providerDef){var providerInstance=data._providers[providerDef.index];if(providerInstance===undefined){providerInstance=data._providers[providerDef.index]=_createProviderInstance(data,providerDef);}return providerInstance===UNDEFINED_VALUE?undefined:providerInstance;}else if((injectableDef=getInjectableDef(depDef.token))&&targetsModule(data,injectableDef)){var index=data._providers.length;data._def.providers[index]=data._def.providersByKey[depDef.tokenKey]={flags:1024/* TypeFactoryProvider */|4096/* LazyProvider */,value:injectableDef.factory,deps:[],index:index,token:depDef.token};data._providers[index]=UNDEFINED_VALUE;return data._providers[index]=_createProviderInstance(data,data._def.providersByKey[depDef.tokenKey]);}else if(depDef.flags&4/* Self */){return notFoundValue;}return data._parent.get(depDef.token,notFoundValue);}finally{setCurrentInjector(former);}}function moduleTransitivelyPresent(ngModule,scope){return ngModule._def.modules.indexOf(scope)>-1;}function targetsModule(ngModule,def){return def.providedIn!=null&&(moduleTransitivelyPresent(ngModule,def.providedIn)||def.providedIn==='root'&&ngModule._def.isRoot);}function _createProviderInstance(ngModule,providerDef){var injectable;switch(providerDef.flags&201347067/* Types */){case 512/* TypeClassProvider */:injectable=_createClass$1(ngModule,providerDef.value,providerDef.deps);break;case 1024/* TypeFactoryProvider */:injectable=_callFactory(ngModule,providerDef.value,providerDef.deps);break;case 2048/* TypeUseExistingProvider */:injectable=resolveNgModuleDep(ngModule,providerDef.deps[0]);break;case 256/* TypeValueProvider */:injectable=providerDef.value;break;}// The read of `ngOnDestroy` here is slightly expensive as it's megamorphic, so it should be
	// avoided if possible. The sequence of checks here determines whether ngOnDestroy needs to be
	// checked. It might not if the `injectable` isn't an object or if NodeFlags.OnDestroy is already
	// set (ngOnDestroy was detected statically).
	if(injectable!==UNDEFINED_VALUE&&injectable!==null&&_typeof(injectable)==='object'&&!(providerDef.flags&131072/* OnDestroy */)&&typeof injectable.ngOnDestroy==='function'){providerDef.flags|=131072/* OnDestroy */;}return injectable===undefined?UNDEFINED_VALUE:injectable;}function _createClass$1(ngModule,ctor,deps){var len=deps.length;switch(len){case 0:return new ctor();case 1:return new ctor(resolveNgModuleDep(ngModule,deps[0]));case 2:return new ctor(resolveNgModuleDep(ngModule,deps[0]),resolveNgModuleDep(ngModule,deps[1]));case 3:return new ctor(resolveNgModuleDep(ngModule,deps[0]),resolveNgModuleDep(ngModule,deps[1]),resolveNgModuleDep(ngModule,deps[2]));default:var depValues=new Array(len);for(var i=0;i<len;i++){depValues[i]=resolveNgModuleDep(ngModule,deps[i]);}return new(ctor.bind.apply(ctor,__spread([void 0],depValues)))();}}function _callFactory(ngModule,factory,deps){var len=deps.length;switch(len){case 0:return factory();case 1:return factory(resolveNgModuleDep(ngModule,deps[0]));case 2:return factory(resolveNgModuleDep(ngModule,deps[0]),resolveNgModuleDep(ngModule,deps[1]));case 3:return factory(resolveNgModuleDep(ngModule,deps[0]),resolveNgModuleDep(ngModule,deps[1]),resolveNgModuleDep(ngModule,deps[2]));default:var depValues=Array(len);for(var i=0;i<len;i++){depValues[i]=resolveNgModuleDep(ngModule,deps[i]);}return factory.apply(void 0,__spread(depValues));}}function callNgModuleLifecycle(ngModule,lifecycles){var def=ngModule._def;var destroyed=new Set();for(var i=0;i<def.providers.length;i++){var provDef=def.providers[i];if(provDef.flags&131072/* OnDestroy */){var instance=ngModule._providers[i];if(instance&&instance!==UNDEFINED_VALUE){var onDestroy=instance.ngOnDestroy;if(typeof onDestroy==='function'&&!destroyed.has(instance)){onDestroy.apply(instance);destroyed.add(instance);}}}}}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function attachEmbeddedView(parentView,elementData,viewIndex,view){var embeddedViews=elementData.viewContainer._embeddedViews;if(viewIndex===null||viewIndex===undefined){viewIndex=embeddedViews.length;}view.viewContainerParent=parentView;addToArray(embeddedViews,viewIndex,view);attachProjectedView(elementData,view);Services.dirtyParentQueries(view);var prevView=viewIndex>0?embeddedViews[viewIndex-1]:null;renderAttachEmbeddedView(elementData,prevView,view);}function attachProjectedView(vcElementData,view){var dvcElementData=declaredViewContainer(view);if(!dvcElementData||dvcElementData===vcElementData||view.state&16/* IsProjectedView */){return;}// Note: For performance reasons, we
	// - add a view to template._projectedViews only 1x throughout its lifetime,
	//   and remove it not until the view is destroyed.
	//   (hard, as when a parent view is attached/detached we would need to attach/detach all
	//    nested projected views as well, even across component boundaries).
	// - don't track the insertion order of views in the projected views array
	//   (hard, as when the views of the same template are inserted different view containers)
	view.state|=16/* IsProjectedView */;var projectedViews=dvcElementData.template._projectedViews;if(!projectedViews){projectedViews=dvcElementData.template._projectedViews=[];}projectedViews.push(view);// Note: we are changing the NodeDef here as we cannot calculate
	// the fact whether a template is used for projection during compilation.
	markNodeAsProjectedTemplate(view.parent.def,view.parentNodeDef);}function markNodeAsProjectedTemplate(viewDef,nodeDef){if(nodeDef.flags&4/* ProjectedTemplate */){return;}viewDef.nodeFlags|=4/* ProjectedTemplate */;nodeDef.flags|=4/* ProjectedTemplate */;var parentNodeDef=nodeDef.parent;while(parentNodeDef){parentNodeDef.childFlags|=4/* ProjectedTemplate */;parentNodeDef=parentNodeDef.parent;}}function detachEmbeddedView(elementData,viewIndex){var embeddedViews=elementData.viewContainer._embeddedViews;if(viewIndex==null||viewIndex>=embeddedViews.length){viewIndex=embeddedViews.length-1;}if(viewIndex<0){return null;}var view=embeddedViews[viewIndex];view.viewContainerParent=null;removeFromArray(embeddedViews,viewIndex);// See attachProjectedView for why we don't update projectedViews here.
	Services.dirtyParentQueries(view);renderDetachView$1(view);return view;}function detachProjectedView(view){if(!(view.state&16/* IsProjectedView */)){return;}var dvcElementData=declaredViewContainer(view);if(dvcElementData){var projectedViews=dvcElementData.template._projectedViews;if(projectedViews){removeFromArray(projectedViews,projectedViews.indexOf(view));Services.dirtyParentQueries(view);}}}function moveEmbeddedView(elementData,oldViewIndex,newViewIndex){var embeddedViews=elementData.viewContainer._embeddedViews;var view=embeddedViews[oldViewIndex];removeFromArray(embeddedViews,oldViewIndex);if(newViewIndex==null){newViewIndex=embeddedViews.length;}addToArray(embeddedViews,newViewIndex,view);// Note: Don't need to change projectedViews as the order in there
	// as always invalid...
	Services.dirtyParentQueries(view);renderDetachView$1(view);var prevView=newViewIndex>0?embeddedViews[newViewIndex-1]:null;renderAttachEmbeddedView(elementData,prevView,view);return view;}function renderAttachEmbeddedView(elementData,prevView,view){var prevRenderNode=prevView?renderNode(prevView,prevView.def.lastRenderRootNode):elementData.renderElement;var parentNode=view.renderer.parentNode(prevRenderNode);var nextSibling=view.renderer.nextSibling(prevRenderNode);// Note: We can't check if `nextSibling` is present, as on WebWorkers it will always be!
	// However, browsers automatically do `appendChild` when there is no `nextSibling`.
	visitRootRenderNodes(view,2/* InsertBefore */,parentNode,nextSibling,undefined);}function renderDetachView$1(view){visitRootRenderNodes(view,3/* RemoveChild */,null,null,undefined);}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var EMPTY_CONTEXT=new Object();// Attention: this function is called as top level function.
	function getComponentViewDefinitionFactory(componentFactory){return componentFactory.viewDefFactory;}var ComponentFactory_=/** @class */function(_super){__extends(ComponentFactory_,_super);function ComponentFactory_(selector,componentType,viewDefFactory,_inputs,_outputs,ngContentSelectors){var _this=// Attention: this ctor is called as top level function.
	// Putting any logic in here will destroy closure tree shaking!
	_super.call(this)||this;_this.selector=selector;_this.componentType=componentType;_this._inputs=_inputs;_this._outputs=_outputs;_this.ngContentSelectors=ngContentSelectors;_this.viewDefFactory=viewDefFactory;return _this;}Object.defineProperty(ComponentFactory_.prototype,"inputs",{get:function get(){var inputsArr=[];var inputs=this._inputs;for(var propName in inputs){var templateName=inputs[propName];inputsArr.push({propName:propName,templateName:templateName});}return inputsArr;},enumerable:true,configurable:true});Object.defineProperty(ComponentFactory_.prototype,"outputs",{get:function get(){var outputsArr=[];for(var propName in this._outputs){var templateName=this._outputs[propName];outputsArr.push({propName:propName,templateName:templateName});}return outputsArr;},enumerable:true,configurable:true});/**
	     * Creates a new component.
	     */ComponentFactory_.prototype.create=function(injector,projectableNodes,rootSelectorOrNode,ngModule){if(!ngModule){throw new Error('ngModule should be provided');}var viewDef=resolveDefinition(this.viewDefFactory);var componentNodeIndex=viewDef.nodes[0].element.componentProvider.nodeIndex;var view=Services.createRootView(injector,projectableNodes||[],rootSelectorOrNode,viewDef,ngModule,EMPTY_CONTEXT);var component=asProviderData(view,componentNodeIndex).instance;if(rootSelectorOrNode){view.renderer.setAttribute(asElementData(view,0).renderElement,'ng-version',VERSION.full);}return new ComponentRef_(view,new ViewRef_(view),component);};return ComponentFactory_;}(ComponentFactory);var ComponentRef_=/** @class */function(_super){__extends(ComponentRef_,_super);function ComponentRef_(_view,_viewRef,_component){var _this=_super.call(this)||this;_this._view=_view;_this._viewRef=_viewRef;_this._component=_component;_this._elDef=_this._view.def.nodes[0];_this.hostView=_viewRef;_this.changeDetectorRef=_viewRef;_this.instance=_component;return _this;}Object.defineProperty(ComponentRef_.prototype,"location",{get:function get(){return new ElementRef(asElementData(this._view,this._elDef.nodeIndex).renderElement);},enumerable:true,configurable:true});Object.defineProperty(ComponentRef_.prototype,"injector",{get:function get(){return new Injector_(this._view,this._elDef);},enumerable:true,configurable:true});Object.defineProperty(ComponentRef_.prototype,"componentType",{get:function get(){return this._component.constructor;},enumerable:true,configurable:true});ComponentRef_.prototype.destroy=function(){this._viewRef.destroy();};ComponentRef_.prototype.onDestroy=function(callback){this._viewRef.onDestroy(callback);};return ComponentRef_;}(ComponentRef);function createViewContainerData(view,elDef,elData){return new ViewContainerRef_(view,elDef,elData);}var ViewContainerRef_=/** @class */function(){function ViewContainerRef_(_view,_elDef,_data){this._view=_view;this._elDef=_elDef;this._data=_data;/**
	         * @internal
	         */this._embeddedViews=[];}Object.defineProperty(ViewContainerRef_.prototype,"element",{get:function get(){return new ElementRef(this._data.renderElement);},enumerable:true,configurable:true});Object.defineProperty(ViewContainerRef_.prototype,"injector",{get:function get(){return new Injector_(this._view,this._elDef);},enumerable:true,configurable:true});Object.defineProperty(ViewContainerRef_.prototype,"parentInjector",{/** @deprecated No replacement */get:function get(){var view=this._view;var elDef=this._elDef.parent;while(!elDef&&view){elDef=viewParentEl(view);view=view.parent;}return view?new Injector_(view,elDef):new Injector_(this._view,null);},enumerable:true,configurable:true});ViewContainerRef_.prototype.clear=function(){var len=this._embeddedViews.length;for(var i=len-1;i>=0;i--){var view=detachEmbeddedView(this._data,i);Services.destroyView(view);}};ViewContainerRef_.prototype.get=function(index){var view=this._embeddedViews[index];if(view){var ref=new ViewRef_(view);ref.attachToViewContainerRef(this);return ref;}return null;};Object.defineProperty(ViewContainerRef_.prototype,"length",{get:function get(){return this._embeddedViews.length;},enumerable:true,configurable:true});ViewContainerRef_.prototype.createEmbeddedView=function(templateRef,context,index){var viewRef=templateRef.createEmbeddedView(context||{});this.insert(viewRef,index);return viewRef;};ViewContainerRef_.prototype.createComponent=function(componentFactory,index,injector,projectableNodes,ngModuleRef){var contextInjector=injector||this.parentInjector;if(!ngModuleRef&&!(componentFactory instanceof ComponentFactoryBoundToModule)){ngModuleRef=contextInjector.get(NgModuleRef);}var componentRef=componentFactory.create(contextInjector,projectableNodes,undefined,ngModuleRef);this.insert(componentRef.hostView,index);return componentRef;};ViewContainerRef_.prototype.insert=function(viewRef,index){if(viewRef.destroyed){throw new Error('Cannot insert a destroyed View in a ViewContainer!');}var viewRef_=viewRef;var viewData=viewRef_._view;attachEmbeddedView(this._view,this._data,index,viewData);viewRef_.attachToViewContainerRef(this);return viewRef;};ViewContainerRef_.prototype.move=function(viewRef,currentIndex){if(viewRef.destroyed){throw new Error('Cannot move a destroyed View in a ViewContainer!');}var previousIndex=this._embeddedViews.indexOf(viewRef._view);moveEmbeddedView(this._data,previousIndex,currentIndex);return viewRef;};ViewContainerRef_.prototype.indexOf=function(viewRef){return this._embeddedViews.indexOf(viewRef._view);};ViewContainerRef_.prototype.remove=function(index){var viewData=detachEmbeddedView(this._data,index);if(viewData){Services.destroyView(viewData);}};ViewContainerRef_.prototype.detach=function(index){var view=detachEmbeddedView(this._data,index);return view?new ViewRef_(view):null;};return ViewContainerRef_;}();function createChangeDetectorRef(view){return new ViewRef_(view);}var ViewRef_=/** @class */function(){function ViewRef_(_view){this._view=_view;this._viewContainerRef=null;this._appRef=null;}Object.defineProperty(ViewRef_.prototype,"rootNodes",{get:function get(){return rootRenderNodes(this._view);},enumerable:true,configurable:true});Object.defineProperty(ViewRef_.prototype,"context",{get:function get(){return this._view.context;},enumerable:true,configurable:true});Object.defineProperty(ViewRef_.prototype,"destroyed",{get:function get(){return (this._view.state&128/* Destroyed */)!==0;},enumerable:true,configurable:true});ViewRef_.prototype.markForCheck=function(){markParentViewsForCheck(this._view);};ViewRef_.prototype.detach=function(){this._view.state&=~4/* Attached */;};ViewRef_.prototype.detectChanges=function(){var fs=this._view.root.rendererFactory;if(fs.begin){fs.begin();}try{Services.checkAndUpdateView(this._view);}finally{if(fs.end){fs.end();}}};ViewRef_.prototype.checkNoChanges=function(){Services.checkNoChangesView(this._view);};ViewRef_.prototype.reattach=function(){this._view.state|=4/* Attached */;};ViewRef_.prototype.onDestroy=function(callback){if(!this._view.disposables){this._view.disposables=[];}this._view.disposables.push(callback);};ViewRef_.prototype.destroy=function(){if(this._appRef){this._appRef.detachView(this);}else if(this._viewContainerRef){this._viewContainerRef.detach(this._viewContainerRef.indexOf(this));}Services.destroyView(this._view);};ViewRef_.prototype.detachFromAppRef=function(){this._appRef=null;renderDetachView$1(this._view);Services.dirtyParentQueries(this._view);};ViewRef_.prototype.attachToAppRef=function(appRef){if(this._viewContainerRef){throw new Error('This view is already attached to a ViewContainer!');}this._appRef=appRef;};ViewRef_.prototype.attachToViewContainerRef=function(vcRef){if(this._appRef){throw new Error('This view is already attached directly to the ApplicationRef!');}this._viewContainerRef=vcRef;};return ViewRef_;}();function createTemplateData(view,def){return new TemplateRef_(view,def);}var TemplateRef_=/** @class */function(_super){__extends(TemplateRef_,_super);function TemplateRef_(_parentView,_def){var _this=_super.call(this)||this;_this._parentView=_parentView;_this._def=_def;return _this;}TemplateRef_.prototype.createEmbeddedView=function(context){return new ViewRef_(Services.createEmbeddedView(this._parentView,this._def,this._def.element.template,context));};Object.defineProperty(TemplateRef_.prototype,"elementRef",{get:function get(){return new ElementRef(asElementData(this._parentView,this._def.nodeIndex).renderElement);},enumerable:true,configurable:true});return TemplateRef_;}(TemplateRef);function createInjector$1(view,elDef){return new Injector_(view,elDef);}var Injector_=/** @class */function(){function Injector_(view,elDef){this.view=view;this.elDef=elDef;}Injector_.prototype.get=function(token,notFoundValue){if(notFoundValue===void 0){notFoundValue=Injector.THROW_IF_NOT_FOUND;}var allowPrivateServices=this.elDef?(this.elDef.flags&33554432/* ComponentView */)!==0:false;return Services.resolveDep(this.view,this.elDef,allowPrivateServices,{flags:0/* None */,token:token,tokenKey:tokenKey(token)},notFoundValue);};return Injector_;}();function createRendererV1(view){return new RendererAdapter(view.renderer);}var RendererAdapter=/** @class */function(){function RendererAdapter(delegate){this.delegate=delegate;}RendererAdapter.prototype.selectRootElement=function(selectorOrNode){return this.delegate.selectRootElement(selectorOrNode);};RendererAdapter.prototype.createElement=function(parent,namespaceAndName){var _a=__read(splitNamespace(namespaceAndName),2),ns=_a[0],name=_a[1];var el=this.delegate.createElement(name,ns);if(parent){this.delegate.appendChild(parent,el);}return el;};RendererAdapter.prototype.createViewRoot=function(hostElement){return hostElement;};RendererAdapter.prototype.createTemplateAnchor=function(parentElement){var comment=this.delegate.createComment('');if(parentElement){this.delegate.appendChild(parentElement,comment);}return comment;};RendererAdapter.prototype.createText=function(parentElement,value){var node=this.delegate.createText(value);if(parentElement){this.delegate.appendChild(parentElement,node);}return node;};RendererAdapter.prototype.projectNodes=function(parentElement,nodes){for(var i=0;i<nodes.length;i++){this.delegate.appendChild(parentElement,nodes[i]);}};RendererAdapter.prototype.attachViewAfter=function(node,viewRootNodes){var parentElement=this.delegate.parentNode(node);var nextSibling=this.delegate.nextSibling(node);for(var i=0;i<viewRootNodes.length;i++){this.delegate.insertBefore(parentElement,viewRootNodes[i],nextSibling);}};RendererAdapter.prototype.detachView=function(viewRootNodes){for(var i=0;i<viewRootNodes.length;i++){var node=viewRootNodes[i];var parentElement=this.delegate.parentNode(node);this.delegate.removeChild(parentElement,node);}};RendererAdapter.prototype.destroyView=function(hostElement,viewAllNodes){for(var i=0;i<viewAllNodes.length;i++){this.delegate.destroyNode(viewAllNodes[i]);}};RendererAdapter.prototype.listen=function(renderElement,name,callback){return this.delegate.listen(renderElement,name,callback);};RendererAdapter.prototype.listenGlobal=function(target,name,callback){return this.delegate.listen(target,name,callback);};RendererAdapter.prototype.setElementProperty=function(renderElement,propertyName,propertyValue){this.delegate.setProperty(renderElement,propertyName,propertyValue);};RendererAdapter.prototype.setElementAttribute=function(renderElement,namespaceAndName,attributeValue){var _a=__read(splitNamespace(namespaceAndName),2),ns=_a[0],name=_a[1];if(attributeValue!=null){this.delegate.setAttribute(renderElement,name,attributeValue,ns);}else{this.delegate.removeAttribute(renderElement,name,ns);}};RendererAdapter.prototype.setBindingDebugInfo=function(renderElement,propertyName,propertyValue){};RendererAdapter.prototype.setElementClass=function(renderElement,className,isAdd){if(isAdd){this.delegate.addClass(renderElement,className);}else{this.delegate.removeClass(renderElement,className);}};RendererAdapter.prototype.setElementStyle=function(renderElement,styleName,styleValue){if(styleValue!=null){this.delegate.setStyle(renderElement,styleName,styleValue);}else{this.delegate.removeStyle(renderElement,styleName);}};RendererAdapter.prototype.invokeElementMethod=function(renderElement,methodName,args){renderElement[methodName].apply(renderElement,args);};RendererAdapter.prototype.setText=function(renderNode,text){this.delegate.setValue(renderNode,text);};RendererAdapter.prototype.animate=function(){throw new Error('Renderer.animate is no longer supported!');};return RendererAdapter;}();function createNgModuleRef(moduleType,parent,bootstrapComponents,def){return new NgModuleRef_(moduleType,parent,bootstrapComponents,def);}var NgModuleRef_=/** @class */function(){function NgModuleRef_(_moduleType,_parent,_bootstrapComponents,_def){this._moduleType=_moduleType;this._parent=_parent;this._bootstrapComponents=_bootstrapComponents;this._def=_def;this._destroyListeners=[];this._destroyed=false;this.injector=this;initNgModule(this);}NgModuleRef_.prototype.get=function(token,notFoundValue,injectFlags){if(notFoundValue===void 0){notFoundValue=Injector.THROW_IF_NOT_FOUND;}if(injectFlags===void 0){injectFlags=InjectFlags.Default;}var flags=0/* None */;if(injectFlags&InjectFlags.SkipSelf){flags|=1/* SkipSelf */;}else if(injectFlags&InjectFlags.Self){flags|=4/* Self */;}return resolveNgModuleDep(this,{token:token,tokenKey:tokenKey(token),flags:flags},notFoundValue);};Object.defineProperty(NgModuleRef_.prototype,"instance",{get:function get(){return this.get(this._moduleType);},enumerable:true,configurable:true});Object.defineProperty(NgModuleRef_.prototype,"componentFactoryResolver",{get:function get(){return this.get(ComponentFactoryResolver);},enumerable:true,configurable:true});NgModuleRef_.prototype.destroy=function(){if(this._destroyed){throw new Error("The ng module "+stringify(this.instance.constructor)+" has already been destroyed.");}this._destroyed=true;callNgModuleLifecycle(this,131072/* OnDestroy */);this._destroyListeners.forEach(function(listener){return listener();});};NgModuleRef_.prototype.onDestroy=function(callback){this._destroyListeners.push(callback);};return NgModuleRef_;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var RendererV1TokenKey=tokenKey(Renderer);var Renderer2TokenKey=tokenKey(Renderer2);var ElementRefTokenKey=tokenKey(ElementRef);var ViewContainerRefTokenKey=tokenKey(ViewContainerRef);var TemplateRefTokenKey=tokenKey(TemplateRef);var ChangeDetectorRefTokenKey=tokenKey(ChangeDetectorRef);var InjectorRefTokenKey$1=tokenKey(Injector);var INJECTORRefTokenKey$1=tokenKey(INJECTOR);function createProviderInstance(view,def){return _createProviderInstance$1(view,def);}function createPipeInstance(view,def){// deps are looked up from component.
	var compView=view;while(compView.parent&&!isComponentView(compView)){compView=compView.parent;}// pipes can see the private services of the component
	var allowPrivateServices=true;// pipes are always eager and classes!
	return createClass(compView.parent,viewParentEl(compView),allowPrivateServices,def.provider.value,def.provider.deps);}function createDirectiveInstance(view,def){// components can see other private services, other directives can't.
	var allowPrivateServices=(def.flags&32768/* Component */)>0;// directives are always eager and classes!
	var instance=createClass(view,def.parent,allowPrivateServices,def.provider.value,def.provider.deps);if(def.outputs.length){for(var i=0;i<def.outputs.length;i++){var output=def.outputs[i];var outputObservable=instance[output.propName];if(isObservable$1(outputObservable)){var subscription=outputObservable.subscribe(eventHandlerClosure(view,def.parent.nodeIndex,output.eventName));view.disposables[def.outputIndex+i]=subscription.unsubscribe.bind(subscription);}else{throw new Error("@Output "+output.propName+" not initialized in '"+instance.constructor.name+"'.");}}}return instance;}function eventHandlerClosure(view,index,eventName){return function(event){return dispatchEvent(view,index,eventName,event);};}function checkAndUpdateDirectiveInline(view,def,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9){var providerData=asProviderData(view,def.nodeIndex);var directive=providerData.instance;var changed=false;var changes=undefined;var bindLen=def.bindings.length;if(bindLen>0&&checkBinding(view,def,0,v0)){changed=true;changes=updateProp(view,providerData,def,0,v0,changes);}if(bindLen>1&&checkBinding(view,def,1,v1)){changed=true;changes=updateProp(view,providerData,def,1,v1,changes);}if(bindLen>2&&checkBinding(view,def,2,v2)){changed=true;changes=updateProp(view,providerData,def,2,v2,changes);}if(bindLen>3&&checkBinding(view,def,3,v3)){changed=true;changes=updateProp(view,providerData,def,3,v3,changes);}if(bindLen>4&&checkBinding(view,def,4,v4)){changed=true;changes=updateProp(view,providerData,def,4,v4,changes);}if(bindLen>5&&checkBinding(view,def,5,v5)){changed=true;changes=updateProp(view,providerData,def,5,v5,changes);}if(bindLen>6&&checkBinding(view,def,6,v6)){changed=true;changes=updateProp(view,providerData,def,6,v6,changes);}if(bindLen>7&&checkBinding(view,def,7,v7)){changed=true;changes=updateProp(view,providerData,def,7,v7,changes);}if(bindLen>8&&checkBinding(view,def,8,v8)){changed=true;changes=updateProp(view,providerData,def,8,v8,changes);}if(bindLen>9&&checkBinding(view,def,9,v9)){changed=true;changes=updateProp(view,providerData,def,9,v9,changes);}if(changes){directive.ngOnChanges(changes);}if(def.flags&65536/* OnInit */&&shouldCallLifecycleInitHook(view,256/* InitState_CallingOnInit */,def.nodeIndex)){directive.ngOnInit();}if(def.flags&262144/* DoCheck */){directive.ngDoCheck();}return changed;}function checkAndUpdateDirectiveDynamic(view,def,values){var providerData=asProviderData(view,def.nodeIndex);var directive=providerData.instance;var changed=false;var changes=undefined;for(var i=0;i<values.length;i++){if(checkBinding(view,def,i,values[i])){changed=true;changes=updateProp(view,providerData,def,i,values[i],changes);}}if(changes){directive.ngOnChanges(changes);}if(def.flags&65536/* OnInit */&&shouldCallLifecycleInitHook(view,256/* InitState_CallingOnInit */,def.nodeIndex)){directive.ngOnInit();}if(def.flags&262144/* DoCheck */){directive.ngDoCheck();}return changed;}function _createProviderInstance$1(view,def){// private services can see other private services
	var allowPrivateServices=(def.flags&8192/* PrivateProvider */)>0;var providerDef=def.provider;switch(def.flags&201347067/* Types */){case 512/* TypeClassProvider */:return createClass(view,def.parent,allowPrivateServices,providerDef.value,providerDef.deps);case 1024/* TypeFactoryProvider */:return callFactory(view,def.parent,allowPrivateServices,providerDef.value,providerDef.deps);case 2048/* TypeUseExistingProvider */:return resolveDep(view,def.parent,allowPrivateServices,providerDef.deps[0]);case 256/* TypeValueProvider */:return providerDef.value;}}function createClass(view,elDef,allowPrivateServices,ctor,deps){var len=deps.length;switch(len){case 0:return new ctor();case 1:return new ctor(resolveDep(view,elDef,allowPrivateServices,deps[0]));case 2:return new ctor(resolveDep(view,elDef,allowPrivateServices,deps[0]),resolveDep(view,elDef,allowPrivateServices,deps[1]));case 3:return new ctor(resolveDep(view,elDef,allowPrivateServices,deps[0]),resolveDep(view,elDef,allowPrivateServices,deps[1]),resolveDep(view,elDef,allowPrivateServices,deps[2]));default:var depValues=new Array(len);for(var i=0;i<len;i++){depValues[i]=resolveDep(view,elDef,allowPrivateServices,deps[i]);}return new(ctor.bind.apply(ctor,__spread([void 0],depValues)))();}}function callFactory(view,elDef,allowPrivateServices,factory,deps){var len=deps.length;switch(len){case 0:return factory();case 1:return factory(resolveDep(view,elDef,allowPrivateServices,deps[0]));case 2:return factory(resolveDep(view,elDef,allowPrivateServices,deps[0]),resolveDep(view,elDef,allowPrivateServices,deps[1]));case 3:return factory(resolveDep(view,elDef,allowPrivateServices,deps[0]),resolveDep(view,elDef,allowPrivateServices,deps[1]),resolveDep(view,elDef,allowPrivateServices,deps[2]));default:var depValues=Array(len);for(var i=0;i<len;i++){depValues[i]=resolveDep(view,elDef,allowPrivateServices,deps[i]);}return factory.apply(void 0,__spread(depValues));}}// This default value is when checking the hierarchy for a token.
	//
	// It means both:
	// - the token is not provided by the current injector,
	// - only the element injectors should be checked (ie do not check module injectors
	//
	//          mod1
	//         /
	//       el1   mod2
	//         \  /
	//         el2
	//
	// When requesting el2.injector.get(token), we should check in the following order and return the
	// first found value:
	// - el2.injector.get(token, default)
	// - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module
	// - mod2.injector.get(token, default)
	var NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR={};function resolveDep(view,elDef,allowPrivateServices,depDef,notFoundValue){if(notFoundValue===void 0){notFoundValue=Injector.THROW_IF_NOT_FOUND;}if(depDef.flags&8/* Value */){return depDef.token;}var startView=view;if(depDef.flags&2/* Optional */){notFoundValue=null;}var tokenKey=depDef.tokenKey;if(tokenKey===ChangeDetectorRefTokenKey){// directives on the same element as a component should be able to control the change detector
	// of that component as well.
	allowPrivateServices=!!(elDef&&elDef.element.componentView);}if(elDef&&depDef.flags&1/* SkipSelf */){allowPrivateServices=false;elDef=elDef.parent;}var searchView=view;while(searchView){if(elDef){switch(tokenKey){case RendererV1TokenKey:{var compView=findCompView(searchView,elDef,allowPrivateServices);return createRendererV1(compView);}case Renderer2TokenKey:{var compView=findCompView(searchView,elDef,allowPrivateServices);return compView.renderer;}case ElementRefTokenKey:return new ElementRef(asElementData(searchView,elDef.nodeIndex).renderElement);case ViewContainerRefTokenKey:return asElementData(searchView,elDef.nodeIndex).viewContainer;case TemplateRefTokenKey:{if(elDef.element.template){return asElementData(searchView,elDef.nodeIndex).template;}break;}case ChangeDetectorRefTokenKey:{var cdView=findCompView(searchView,elDef,allowPrivateServices);return createChangeDetectorRef(cdView);}case InjectorRefTokenKey$1:case INJECTORRefTokenKey$1:return createInjector$1(searchView,elDef);default:var providerDef_1=(allowPrivateServices?elDef.element.allProviders:elDef.element.publicProviders)[tokenKey];if(providerDef_1){var providerData=asProviderData(searchView,providerDef_1.nodeIndex);if(!providerData){providerData={instance:_createProviderInstance$1(searchView,providerDef_1)};searchView.nodes[providerDef_1.nodeIndex]=providerData;}return providerData.instance;}}}allowPrivateServices=isComponentView(searchView);elDef=viewParentEl(searchView);searchView=searchView.parent;if(depDef.flags&4/* Self */){searchView=null;}}var value=startView.root.injector.get(depDef.token,NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);if(value!==NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR||notFoundValue===NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR){// Return the value from the root element injector when
	// - it provides it
	//   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
	// - the module injector should not be checked
	//   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
	return value;}return startView.root.ngModule.injector.get(depDef.token,notFoundValue);}function findCompView(view,elDef,allowPrivateServices){var compView;if(allowPrivateServices){compView=asElementData(view,elDef.nodeIndex).componentView;}else{compView=view;while(compView.parent&&!isComponentView(compView)){compView=compView.parent;}}return compView;}function updateProp(view,providerData,def,bindingIdx,value,changes){if(def.flags&32768/* Component */){var compView=asElementData(view,def.parent.nodeIndex).componentView;if(compView.def.flags&2/* OnPush */){compView.state|=8/* ChecksEnabled */;}}var binding=def.bindings[bindingIdx];var propName=binding.name;// Note: This is still safe with Closure Compiler as
	// the user passed in the property name as an object has to `providerDef`,
	// so Closure Compiler will have renamed the property correctly already.
	providerData.instance[propName]=value;if(def.flags&524288/* OnChanges */){changes=changes||{};var oldValue=WrappedValue.unwrap(view.oldValues[def.bindingIndex+bindingIdx]);var binding_1=def.bindings[bindingIdx];changes[binding_1.nonMinifiedName]=new SimpleChange(oldValue,value,(view.state&2/* FirstCheck */)!==0);}view.oldValues[def.bindingIndex+bindingIdx]=value;return changes;}// This function calls the ngAfterContentCheck, ngAfterContentInit,
	// ngAfterViewCheck, and ngAfterViewInit lifecycle hooks (depending on the node
	// flags in lifecycle). Unlike ngDoCheck, ngOnChanges and ngOnInit, which are
	// called during a pre-order traversal of the view tree (that is calling the
	// parent hooks before the child hooks) these events are sent in using a
	// post-order traversal of the tree (children before parents). This changes the
	// meaning of initIndex in the view state. For ngOnInit, initIndex tracks the
	// expected nodeIndex which a ngOnInit should be called. When sending
	// ngAfterContentInit and ngAfterViewInit it is the expected count of
	// ngAfterContentInit or ngAfterViewInit methods that have been called. This
	// ensure that despite being called recursively or after picking up after an
	// exception, the ngAfterContentInit or ngAfterViewInit will be called on the
	// correct nodes. Consider for example, the following (where E is an element
	// and D is a directive)
	//  Tree:       pre-order index  post-order index
	//    E1        0                6
	//      E2      1                1
	//       D3     2                0
	//      E4      3                5
	//       E5     4                4
	//        E6    5                2
	//        E7    6                3
	// As can be seen, the post-order index has an unclear relationship to the
	// pre-order index (postOrderIndex === preOrderIndex - parentCount +
	// childCount). Since number of calls to ngAfterContentInit and ngAfterViewInit
	// are stable (will be the same for the same view regardless of exceptions or
	// recursion) we just need to count them which will roughly correspond to the
	// post-order index (it skips elements and directives that do not have
	// lifecycle hooks).
	//
	// For example, if an exception is raised in the E6.onAfterViewInit() the
	// initIndex is left at 3 (by shouldCallLifecycleInitHook() which set it to
	// initIndex + 1). When checkAndUpdateView() is called again D3, E2 and E6 will
	// not have their ngAfterViewInit() called but, starting with E7, the rest of
	// the view will begin getting ngAfterViewInit() called until a check and
	// pass is complete.
	//
	// This algorthim also handles recursion. Consider if E4's ngAfterViewInit()
	// indirectly calls E1's ChangeDetectorRef.detectChanges(). The expected
	// initIndex is set to 6, the recusive checkAndUpdateView() starts walk again.
	// D3, E2, E6, E7, E5 and E4 are skipped, ngAfterViewInit() is called on E1.
	// When the recursion returns the initIndex will be 7 so E1 is skipped as it
	// has already been called in the recursively called checkAnUpdateView().
	function callLifecycleHooksChildrenFirst(view,lifecycles){if(!(view.def.nodeFlags&lifecycles)){return;}var nodes=view.def.nodes;var initIndex=0;for(var i=0;i<nodes.length;i++){var nodeDef=nodes[i];var parent_1=nodeDef.parent;if(!parent_1&&nodeDef.flags&lifecycles){// matching root node (e.g. a pipe)
	callProviderLifecycles(view,i,nodeDef.flags&lifecycles,initIndex++);}if((nodeDef.childFlags&lifecycles)===0){// no child matches one of the lifecycles
	i+=nodeDef.childCount;}while(parent_1&&parent_1.flags&1/* TypeElement */&&i===parent_1.nodeIndex+parent_1.childCount){// last child of an element
	if(parent_1.directChildFlags&lifecycles){initIndex=callElementProvidersLifecycles(view,parent_1,lifecycles,initIndex);}parent_1=parent_1.parent;}}}function callElementProvidersLifecycles(view,elDef,lifecycles,initIndex){for(var i=elDef.nodeIndex+1;i<=elDef.nodeIndex+elDef.childCount;i++){var nodeDef=view.def.nodes[i];if(nodeDef.flags&lifecycles){callProviderLifecycles(view,i,nodeDef.flags&lifecycles,initIndex++);}// only visit direct children
	i+=nodeDef.childCount;}return initIndex;}function callProviderLifecycles(view,index,lifecycles,initIndex){var providerData=asProviderData(view,index);if(!providerData){return;}var provider=providerData.instance;if(!provider){return;}Services.setCurrentNode(view,index);if(lifecycles&1048576/* AfterContentInit */&&shouldCallLifecycleInitHook(view,512/* InitState_CallingAfterContentInit */,initIndex)){provider.ngAfterContentInit();}if(lifecycles&2097152/* AfterContentChecked */){provider.ngAfterContentChecked();}if(lifecycles&4194304/* AfterViewInit */&&shouldCallLifecycleInitHook(view,768/* InitState_CallingAfterViewInit */,initIndex)){provider.ngAfterViewInit();}if(lifecycles&8388608/* AfterViewChecked */){provider.ngAfterViewChecked();}if(lifecycles&131072/* OnDestroy */){provider.ngOnDestroy();}}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var ComponentFactoryResolver$1=/** @class */function(_super){__extends(ComponentFactoryResolver,_super);/**
	     * @param ngModule The NgModuleRef to which all resolved factories are bound.
	     */function ComponentFactoryResolver(ngModule){var _this=_super.call(this)||this;_this.ngModule=ngModule;return _this;}ComponentFactoryResolver.prototype.resolveComponentFactory=function(component){ngDevMode&&assertComponentType(component);var componentDef=getComponentDef(component);return new ComponentFactory$1(componentDef,this.ngModule);};return ComponentFactoryResolver;}(ComponentFactoryResolver);function toRefArray(map$$1){var array=[];for(var nonMinified in map$$1){if(map$$1.hasOwnProperty(nonMinified)){var minified=map$$1[nonMinified];array.push({propName:minified,templateName:nonMinified});}}return array;}/**
	 * A change detection scheduler token for {@link RootContext}. This token is the default value used
	 * for the default `RootContext` found in the {@link ROOT_CONTEXT} token.
	 */var SCHEDULER=new InjectionToken('SCHEDULER_TOKEN',{providedIn:'root',factory:function factory(){return defaultScheduler;}});function createChainedInjector(rootViewInjector,moduleInjector){return {get:function get(token,notFoundValue,flags){var value=rootViewInjector.get(token,NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR,flags);if(value!==NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR||notFoundValue===NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR){// Return the value from the root element injector when
	// - it provides it
	//   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
	// - the module injector should not be checked
	//   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
	return value;}return moduleInjector.get(token,notFoundValue,flags);}};}/**
	 * Render3 implementation of {@link viewEngine_ComponentFactory}.
	 */var ComponentFactory$1=/** @class */function(_super){__extends(ComponentFactory,_super);/**
	     * @param componentDef The component definition.
	     * @param ngModule The NgModuleRef to which the factory is bound.
	     */function ComponentFactory(componentDef,ngModule){var _this=_super.call(this)||this;_this.componentDef=componentDef;_this.ngModule=ngModule;_this.componentType=componentDef.type;// default to 'div' in case this component has an attribute selector
	_this.selector=componentDef.selectors[0][0]||'div';_this.ngContentSelectors=componentDef.ngContentSelectors?componentDef.ngContentSelectors:[];_this.isBoundToModule=!!ngModule;return _this;}Object.defineProperty(ComponentFactory.prototype,"inputs",{get:function get(){return toRefArray(this.componentDef.inputs);},enumerable:true,configurable:true});Object.defineProperty(ComponentFactory.prototype,"outputs",{get:function get(){return toRefArray(this.componentDef.outputs);},enumerable:true,configurable:true});ComponentFactory.prototype.create=function(injector,projectableNodes,rootSelectorOrNode,ngModule){ngModule=ngModule||this.ngModule;var rootViewInjector=ngModule?createChainedInjector(injector,ngModule.injector):injector;var rendererFactory=rootViewInjector.get(RendererFactory2,domRendererFactory3);var sanitizer=rootViewInjector.get(Sanitizer,null);// Ensure that the namespace for the root node is correct,
	// otherwise the browser might not render out the element properly.
	namespaceHTMLInternal();var hostRNode=rootSelectorOrNode?locateHostElement(rendererFactory,rootSelectorOrNode):elementCreate(this.selector,rendererFactory.createRenderer(null,this.componentDef));var rootFlags=this.componentDef.onPush?64/* Dirty */|512/* IsRoot */:16/* CheckAlways */|512/* IsRoot */;// Check whether this Component needs to be isolated from other components, i.e. whether it
	// should be placed into its own (empty) root context or existing root context should be used.
	// Note: this is internal-only convention and might change in the future, so it should not be
	// relied upon externally.
	var isIsolated=typeof rootSelectorOrNode==='string'&&/^#root-ng-internal-isolated-\d+/.test(rootSelectorOrNode);var rootContext=createRootContext();var renderer=rendererFactory.createRenderer(hostRNode,this.componentDef);if(rootSelectorOrNode&&hostRNode){ngDevMode&&ngDevMode.rendererSetAttribute++;isProceduralRenderer(renderer)?renderer.setAttribute(hostRNode,'ng-version',VERSION.full):hostRNode.setAttribute('ng-version',VERSION.full);}// Create the root view. Uses empty TView and ContentTemplate.
	var rootLView=createLView(null,createTView(-1,null,1,0,null,null,null,null),rootContext,rootFlags,null,null,rendererFactory,renderer,sanitizer,rootViewInjector);// rootView is the parent when bootstrapping
	var oldLView=enterView(rootLView,null);var component;var tElementNode;// Will become true if the `try` block executes with no errors.
	var safeToRunHooks=false;try{var componentView=createRootComponentView(hostRNode,this.componentDef,rootLView,rendererFactory,renderer);tElementNode=getTNode(0,rootLView);if(projectableNodes){// projectable nodes can be passed as array of arrays or an array of iterables (ngUpgrade
	// case). Here we do normalize passed data structure to be an array of arrays to avoid
	// complex checks down the line.
	tElementNode.projection=projectableNodes.map(function(nodesforSlot){return Array.from(nodesforSlot);});}// TODO: should LifecycleHooksFeature and other host features be generated by the compiler and
	// executed here?
	// Angular 5 reference: https://stackblitz.com/edit/lifecycle-hooks-vcref
	component=createRootComponent(componentView,this.componentDef,rootLView,rootContext,[LifecycleHooksFeature]);addToViewTree(rootLView,componentView);refreshDescendantViews(rootLView);safeToRunHooks=true;}finally{leaveView(oldLView,safeToRunHooks);}var componentRef=new ComponentRef$1(this.componentType,component,createElementRef(ElementRef,tElementNode,rootLView),rootLView,tElementNode);if(!rootSelectorOrNode||isIsolated){// The host element of the internal or isolated root view is attached to the component's host
	// view node.
	componentRef.hostView._tViewNode.child=tElementNode;}return componentRef;};return ComponentFactory;}(ComponentFactory);var componentFactoryResolver=new ComponentFactoryResolver$1();/**
	 * Represents an instance of a Component created via a {@link ComponentFactory}.
	 *
	 * `ComponentRef` provides access to the Component Instance as well other objects related to this
	 * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}
	 * method.
	 *
	 */var ComponentRef$1=/** @class */function(_super){__extends(ComponentRef,_super);function ComponentRef(componentType,instance,location,_rootLView,_tNode){var _this=_super.call(this)||this;_this.location=location;_this._rootLView=_rootLView;_this._tNode=_tNode;_this.destroyCbs=[];_this.instance=instance;_this.hostView=_this.changeDetectorRef=new RootViewRef(_rootLView);_this.hostView._tViewNode=assignTViewNodeToLView(_rootLView[TVIEW],null,-1,_rootLView);_this.componentType=componentType;return _this;}Object.defineProperty(ComponentRef.prototype,"injector",{get:function get(){return new NodeInjector(this._tNode,this._rootLView);},enumerable:true,configurable:true});ComponentRef.prototype.destroy=function(){if(this.destroyCbs){this.destroyCbs.forEach(function(fn){return fn();});this.destroyCbs=null;!this.hostView.destroyed&&this.hostView.destroy();}};ComponentRef.prototype.onDestroy=function(callback){if(this.destroyCbs){this.destroyCbs.push(callback);}};return ComponentRef;}(ComponentRef);/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * NOTE: changes to the `ngI18nClosureMode` name must be synced with `compiler-cli/src/tooling.ts`.
	 */if(typeof ngI18nClosureMode==='undefined'){// These property accesses can be ignored because ngI18nClosureMode will be set to false
	// when optimizing code and the whole if statement will be dropped.
	// Make sure to refer to ngI18nClosureMode as ['ngI18nClosureMode'] for closure.
	// NOTE: we need to have it in IIFE so that the tree-shaker is happy.
	(function(){// tslint:disable-next-line:no-toplevel-property-access
	_global$1['ngI18nClosureMode']=// TODO(FW-1250): validate that this actually, you know, works.
	// tslint:disable-next-line:no-toplevel-property-access
	typeof goog!=='undefined'&&typeof goog.getMsg==='function';})();}/**
	 * Index of each type of locale data from the locale data array
	 */var LocaleDataIndex;(function(LocaleDataIndex){LocaleDataIndex[LocaleDataIndex["LocaleId"]=0]="LocaleId";LocaleDataIndex[LocaleDataIndex["DayPeriodsFormat"]=1]="DayPeriodsFormat";LocaleDataIndex[LocaleDataIndex["DayPeriodsStandalone"]=2]="DayPeriodsStandalone";LocaleDataIndex[LocaleDataIndex["DaysFormat"]=3]="DaysFormat";LocaleDataIndex[LocaleDataIndex["DaysStandalone"]=4]="DaysStandalone";LocaleDataIndex[LocaleDataIndex["MonthsFormat"]=5]="MonthsFormat";LocaleDataIndex[LocaleDataIndex["MonthsStandalone"]=6]="MonthsStandalone";LocaleDataIndex[LocaleDataIndex["Eras"]=7]="Eras";LocaleDataIndex[LocaleDataIndex["FirstDayOfWeek"]=8]="FirstDayOfWeek";LocaleDataIndex[LocaleDataIndex["WeekendRange"]=9]="WeekendRange";LocaleDataIndex[LocaleDataIndex["DateFormat"]=10]="DateFormat";LocaleDataIndex[LocaleDataIndex["TimeFormat"]=11]="TimeFormat";LocaleDataIndex[LocaleDataIndex["DateTimeFormat"]=12]="DateTimeFormat";LocaleDataIndex[LocaleDataIndex["NumberSymbols"]=13]="NumberSymbols";LocaleDataIndex[LocaleDataIndex["NumberFormats"]=14]="NumberFormats";LocaleDataIndex[LocaleDataIndex["CurrencySymbol"]=15]="CurrencySymbol";LocaleDataIndex[LocaleDataIndex["CurrencyName"]=16]="CurrencyName";LocaleDataIndex[LocaleDataIndex["Currencies"]=17]="Currencies";LocaleDataIndex[LocaleDataIndex["PluralCase"]=18]="PluralCase";LocaleDataIndex[LocaleDataIndex["ExtraData"]=19]="ExtraData";})(LocaleDataIndex||(LocaleDataIndex={}));/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ // THIS CODE IS GENERATED - DO NOT MODIFY
	/**
	 * The locale id that the application is using by default (for translations and ICU expressions).
	 */var DEFAULT_LOCALE_ID='en-US';/**
	 * The locale id that the application is currently using (for translations and ICU expressions).
	 * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine
	 * but is now defined as a global value.
	 */var LOCALE_ID=DEFAULT_LOCALE_ID;/**
	 * Sets the locale id that will be used for translations and ICU expressions.
	 * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine
	 * but is now defined as a global value.
	 *
	 * @param localeId
	 */function setLocaleId(localeId){assertDefined(localeId,"Expected localeId to be defined");if(typeof localeId==='string'){LOCALE_ID=localeId.toLowerCase().replace(/_/g,'-');}}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Map of module-id to the corresponding NgModule.
	 * - In pre Ivy we track NgModuleFactory,
	 * - In post Ivy we track the NgModuleType
	 */var modules=new Map();function assertSameOrNotExisting(id,type,incoming){if(type&&type!==incoming){throw new Error("Duplicate module registered for "+id+" - "+stringify(type)+" vs "+stringify(type.name));}}function registerNgModuleType(ngModuleType){if(ngModuleType.ngModuleDef.id!==null){var id=ngModuleType.ngModuleDef.id;var existing=modules.get(id);assertSameOrNotExisting(id,existing,ngModuleType);modules.set(id,ngModuleType);}var imports=ngModuleType.ngModuleDef.imports;if(imports instanceof Function){imports=imports();}if(imports){imports.forEach(function(i){return registerNgModuleType(i);});}}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var COMPONENT_FACTORY_RESOLVER={provide:ComponentFactoryResolver,useClass:ComponentFactoryResolver$1,deps:[NgModuleRef]};var NgModuleRef$1=/** @class */function(_super){__extends(NgModuleRef$1,_super);function NgModuleRef$1(ngModuleType,_parent){var _this=_super.call(this)||this;_this._parent=_parent;// tslint:disable-next-line:require-internal-with-underscore
	_this._bootstrapComponents=[];_this.injector=_this;_this.destroyCbs=[];var ngModuleDef=getNgModuleDef(ngModuleType);ngDevMode&&assertDefined(ngModuleDef,"NgModule '"+stringify(ngModuleType)+"' is not a subtype of 'NgModuleType'.");var ngLocaleIdDef=getNgLocaleIdDef(ngModuleType);if(ngLocaleIdDef){setLocaleId(ngLocaleIdDef);}_this._bootstrapComponents=maybeUnwrapFn(ngModuleDef.bootstrap);var additionalProviders=[{provide:NgModuleRef,useValue:_this},COMPONENT_FACTORY_RESOLVER];_this._r3Injector=createInjector(ngModuleType,_parent,additionalProviders,stringify(ngModuleType));_this.instance=_this.get(ngModuleType);return _this;}NgModuleRef$1.prototype.get=function(token,notFoundValue,injectFlags){if(notFoundValue===void 0){notFoundValue=Injector.THROW_IF_NOT_FOUND;}if(injectFlags===void 0){injectFlags=InjectFlags.Default;}if(token===Injector||token===NgModuleRef||token===INJECTOR){return this;}return this._r3Injector.get(token,notFoundValue,injectFlags);};Object.defineProperty(NgModuleRef$1.prototype,"componentFactoryResolver",{get:function get(){return this.get(ComponentFactoryResolver);},enumerable:true,configurable:true});NgModuleRef$1.prototype.destroy=function(){ngDevMode&&assertDefined(this.destroyCbs,'NgModule already destroyed');var injector=this._r3Injector;!injector.destroyed&&injector.destroy();this.destroyCbs.forEach(function(fn){return fn();});this.destroyCbs=null;};NgModuleRef$1.prototype.onDestroy=function(callback){ngDevMode&&assertDefined(this.destroyCbs,'NgModule already destroyed');this.destroyCbs.push(callback);};return NgModuleRef$1;}(NgModuleRef);var NgModuleFactory$1=/** @class */function(_super){__extends(NgModuleFactory,_super);function NgModuleFactory(moduleType){var _this=_super.call(this)||this;_this.moduleType=moduleType;var ngModuleDef=getNgModuleDef(moduleType);if(ngModuleDef!==null){// Register the NgModule with Angular's module registry. The location (and hence timing) of
	// this call is critical to ensure this works correctly (modules get registered when expected)
	// without bloating bundles (modules are registered when otherwise not referenced).
	//
	// In View Engine, registration occurs in the .ngfactory.js file as a side effect. This has
	// several practical consequences:
	//
	// - If an .ngfactory file is not imported from, the module won't be registered (and can be
	//   tree shaken).
	// - If an .ngfactory file is imported from, the module will be registered even if an instance
	//   is not actually created (via `create` below).
	// - Since an .ngfactory file in View Engine references the .ngfactory files of the NgModule's
	//   imports,
	//
	// In Ivy, things are a bit different. .ngfactory files still exist for compatibility, but are
	// not a required API to use - there are other ways to obtain an NgModuleFactory for a given
	// NgModule. Thus, relying on a side effect in the .ngfactory file is not sufficient. Instead,
	// the side effect of registration is added here, in the constructor of NgModuleFactory,
	// ensuring no matter how a factory is created, the module is registered correctly.
	//
	// An alternative would be to include the registration side effect inline following the actual
	// NgModule definition. This also has the correct timing, but breaks tree-shaking - modules
	// will be registered and retained even if they're otherwise never referenced.
	registerNgModuleType(moduleType);}return _this;}NgModuleFactory.prototype.create=function(parentInjector){return new NgModuleRef$1(this.moduleType,parentInjector);};return NgModuleFactory;}(NgModuleFactory);/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Use in components with the `@Output` directive to emit custom events
	 * synchronously or asynchronously, and register handlers for those events
	 * by subscribing to an instance.
	 *
	 * @usageNotes
	 *
	 * Extends
	 * [RxJS `Subject`](https://rxjs.dev/api/index/class/Subject)
	 * for Angular by adding the `emit()` method.
	 *
	 * In the following example, a component defines two output properties
	 * that create event emitters. When the title is clicked, the emitter
	 * emits an open or close event to toggle the current visibility state.
	 *
	 * ```html
	 * @Component({
	 *   selector: 'zippy',
	 *   template: `
	 *   <div class="zippy">
	 *     <div (click)="toggle()">Toggle</div>
	 *     <div [hidden]="!visible">
	 *       <ng-content></ng-content>
	 *     </div>
	 *  </div>`})
	 * export class Zippy {
	 *   visible: boolean = true;
	 *   @Output() open: EventEmitter<any> = new EventEmitter();
	 *   @Output() close: EventEmitter<any> = new EventEmitter();
	 *
	 *   toggle() {
	 *     this.visible = !this.visible;
	 *     if (this.visible) {
	 *       this.open.emit(null);
	 *     } else {
	 *       this.close.emit(null);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * Access the event object with the `$event` argument passed to the output event
	 * handler:
	 *
	 * ```html
	 * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	 * ```
	 *
	 * @see [Observables in Angular](guide/observables-in-angular)
	 * @publicApi
	 */var EventEmitter=/** @class */function(_super){__extends(EventEmitter,_super);/**
	     * Creates an instance of this class that can
	     * deliver events synchronously or asynchronously.
	     *
	     * @param isAsync When true, deliver events asynchronously.
	     *
	     */function EventEmitter(isAsync){if(isAsync===void 0){isAsync=false;}var _this=_super.call(this)||this;_this.__isAsync=isAsync;return _this;}/**
	     * Emits an event containing a given value.
	     * @param value The value to emit.
	     */EventEmitter.prototype.emit=function(value){_super.prototype.next.call(this,value);};/**
	     * Registers handlers for events emitted by this instance.
	     * @param generatorOrNext When supplied, a custom handler for emitted events.
	     * @param error When supplied, a custom handler for an error notification
	     * from this emitter.
	     * @param complete When supplied, a custom handler for a completion
	     * notification from this emitter.
	     */EventEmitter.prototype.subscribe=function(generatorOrNext,error,complete){var schedulerFn;var errorFn=function errorFn(err){return null;};var completeFn=function completeFn(){return null;};if(generatorOrNext&&_typeof(generatorOrNext)==='object'){schedulerFn=this.__isAsync?function(value){setTimeout(function(){return generatorOrNext.next(value);});}:function(value){generatorOrNext.next(value);};if(generatorOrNext.error){errorFn=this.__isAsync?function(err){setTimeout(function(){return generatorOrNext.error(err);});}:function(err){generatorOrNext.error(err);};}if(generatorOrNext.complete){completeFn=this.__isAsync?function(){setTimeout(function(){return generatorOrNext.complete();});}:function(){generatorOrNext.complete();};}}else{schedulerFn=this.__isAsync?function(value){setTimeout(function(){return generatorOrNext(value);});}:function(value){generatorOrNext(value);};if(error){errorFn=this.__isAsync?function(err){setTimeout(function(){return error(err);});}:function(err){error(err);};}if(complete){completeFn=this.__isAsync?function(){setTimeout(function(){return complete();});}:function(){complete();};}}var sink=_super.prototype.subscribe.call(this,schedulerFn,errorFn,completeFn);if(generatorOrNext instanceof Subscription){generatorOrNext.add(sink);}return sink;};return EventEmitter;}(Subject);/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function symbolIterator(){return this._results[getSymbolIterator$1()]();}/**
	 * An unmodifiable list of items that Angular keeps up to date when the state
	 * of the application changes.
	 *
	 * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}
	 * provide.
	 *
	 * Implements an iterable interface, therefore it can be used in both ES6
	 * javascript `for (var i of items)` loops as well as in Angular templates with
	 * `*ngFor="let i of myList"`.
	 *
	 * Changes can be observed by subscribing to the changes `Observable`.
	 *
	 * NOTE: In the future this class will implement an `Observable` interface.
	 *
	 * @usageNotes
	 * ### Example
	 * ```typescript
	 * @Component({...})
	 * class Container {
	 *   @ViewChildren(Item) items:QueryList<Item>;
	 * }
	 * ```
	 *
	 * @publicApi
	 */var QueryList=/** @class */function(){function QueryList(){this.dirty=true;this._results=[];this.changes=new EventEmitter();this.length=0;// This function should be declared on the prototype, but doing so there will cause the class
	// declaration to have side-effects and become not tree-shakable. For this reason we do it in
	// the constructor.
	// [getSymbolIterator()](): Iterator<T> { ... }
	var symbol=getSymbolIterator$1();var proto=QueryList.prototype;if(!proto[symbol])proto[symbol]=symbolIterator;}/**
	     * See
	     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
	     */QueryList.prototype.map=function(fn){return this._results.map(fn);};/**
	     * See
	     * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
	     */QueryList.prototype.filter=function(fn){return this._results.filter(fn);};/**
	     * See
	     * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
	     */QueryList.prototype.find=function(fn){return this._results.find(fn);};/**
	     * See
	     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
	     */QueryList.prototype.reduce=function(fn,init){return this._results.reduce(fn,init);};/**
	     * See
	     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
	     */QueryList.prototype.forEach=function(fn){this._results.forEach(fn);};/**
	     * See
	     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
	     */QueryList.prototype.some=function(fn){return this._results.some(fn);};/**
	     * Returns a copy of the internal results list as an Array.
	     */QueryList.prototype.toArray=function(){return this._results.slice();};QueryList.prototype.toString=function(){return this._results.toString();};/**
	     * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that
	     * on change detection, it will not notify of changes to the queries, unless a new change
	     * occurs.
	     *
	     * @param resultsTree The query results to store
	     */QueryList.prototype.reset=function(resultsTree){this._results=flatten(resultsTree);this.dirty=false;this.length=this._results.length;this.last=this._results[this.length-1];this.first=this._results[0];};/**
	     * Triggers a change event by emitting on the `changes` {@link EventEmitter}.
	     */QueryList.prototype.notifyOnChanges=function(){this.changes.emit(this);};/** internal */QueryList.prototype.setDirty=function(){this.dirty=true;};/** internal */QueryList.prototype.destroy=function(){this.changes.complete();this.changes.unsubscribe();};return QueryList;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ // Note: This hack is necessary so we don't erroneously get a circular dependency
	var TQueries_=/** @class */function(){function TQueries_(queries){if(queries===void 0){queries=[];}this.queries=queries;}TQueries_.prototype.elementStart=function(tView,tNode){var e_1,_a;ngDevMode&&assertFirstTemplatePass(tView,'Queries should collect results on the first template pass only');try{for(var _b=__values(this.queries),_c=_b.next();!_c.done;_c=_b.next()){var query=_c.value;query.elementStart(tView,tNode);}}catch(e_1_1){e_1={error:e_1_1};}finally{try{if(_c&&!_c.done&&(_a=_b.return))_a.call(_b);}finally{if(e_1)throw e_1.error;}}};TQueries_.prototype.elementEnd=function(tNode){var e_2,_a;try{for(var _b=__values(this.queries),_c=_b.next();!_c.done;_c=_b.next()){var query=_c.value;query.elementEnd(tNode);}}catch(e_2_1){e_2={error:e_2_1};}finally{try{if(_c&&!_c.done&&(_a=_b.return))_a.call(_b);}finally{if(e_2)throw e_2.error;}}};TQueries_.prototype.embeddedTView=function(tNode){var queriesForTemplateRef=null;for(var i=0;i<this.length;i++){var childQueryIndex=queriesForTemplateRef!==null?queriesForTemplateRef.length:0;var tqueryClone=this.getByIndex(i).embeddedTView(tNode,childQueryIndex);if(tqueryClone){tqueryClone.indexInDeclarationView=i;if(queriesForTemplateRef!==null){queriesForTemplateRef.push(tqueryClone);}else{queriesForTemplateRef=[tqueryClone];}}}return queriesForTemplateRef!==null?new TQueries_(queriesForTemplateRef):null;};TQueries_.prototype.template=function(tView,tNode){var e_3,_a;ngDevMode&&assertFirstTemplatePass(tView,'Queries should collect results on the first template pass only');try{for(var _b=__values(this.queries),_c=_b.next();!_c.done;_c=_b.next()){var query=_c.value;query.template(tView,tNode);}}catch(e_3_1){e_3={error:e_3_1};}finally{try{if(_c&&!_c.done&&(_a=_b.return))_a.call(_b);}finally{if(e_3)throw e_3.error;}}};TQueries_.prototype.getByIndex=function(index){ngDevMode&&assertDataInRange(this.queries,index);return this.queries[index];};Object.defineProperty(TQueries_.prototype,"length",{get:function get(){return this.queries.length;},enumerable:true,configurable:true});TQueries_.prototype.track=function(tquery){this.queries.push(tquery);};return TQueries_;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var Éµ0$f=function Éµ0$f(dir){if(dir===void 0){dir={};}return dir;},Éµ1$4=function Éµ1$4(type,meta){return SWITCH_COMPILE_DIRECTIVE(type,meta);};/**
	 * Type of the Directive metadata.
	 *
	 * @publicApi
	 */var Directive=makeDecorator('Directive',Éµ0$f,undefined,undefined,Éµ1$4);var Éµ2$1=function Éµ2$1(c){if(c===void 0){c={};}return _assign({changeDetection:ChangeDetectionStrategy.Default},c);},Éµ3$1=function Éµ3$1(type,meta){return SWITCH_COMPILE_COMPONENT(type,meta);};/**
	 * Component decorator and metadata.
	 *
	 * @Annotation
	 * @publicApi
	 */var Component=makeDecorator('Component',Éµ2$1,Directive,undefined,Éµ3$1);var Éµ4=function Éµ4(p){return _assign({pure:true},p);},Éµ5=function Éµ5(type,meta){return SWITCH_COMPILE_PIPE(type,meta);};/**
	 * @Annotation
	 * @publicApi
	 */var Pipe=makeDecorator('Pipe',Éµ4,undefined,undefined,Éµ5);var Éµ6=function Éµ6(bindingPropertyName){return {bindingPropertyName:bindingPropertyName};};/**
	 * @Annotation
	 * @publicApi
	 */var Input=makePropDecorator('Input',Éµ6);var Éµ7=function Éµ7(bindingPropertyName){return {bindingPropertyName:bindingPropertyName};};/**
	 * @Annotation
	 * @publicApi
	 */var Output=makePropDecorator('Output',Éµ7);var Éµ8=function Éµ8(hostPropertyName){return {hostPropertyName:hostPropertyName};};/**
	 * @Annotation
	 * @publicApi
	 */var HostBinding=makePropDecorator('HostBinding',Éµ8);var Éµ9=function Éµ9(eventName,args){return {eventName:eventName,args:args};};/**
	 * Decorator that binds a DOM event to a host listener and supplies configuration metadata.
	 * Angular invokes the supplied handler method when the host element emits the specified event,
	 * and updates the bound element with the result.
	 *
	 * If the handler method returns false, applies `preventDefault` on the bound element.
	 *
	 * @usageNotes
	 *
	 * The following example declares a directive
	 * that attaches a click listener to a button and counts clicks.
	 *
	 * ```ts
	 * @Directive({selector: 'button[counting]'})
	 * class CountClicks {
	 *   numberOfClicks = 0;
	 *
	 *   @HostListener('click', ['$event.target'])
	 *   onClick(btn) {
	 *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);
	 *  }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: '<button counting>Increment</button>',
	 * })
	 * class App {}
	 * ```
	 *
	 * @Annotation
	 * @publicApi
	 */var HostListener=makePropDecorator('HostListener',Éµ9);var SWITCH_COMPILE_COMPONENT__PRE_R3__=noop$1;var SWITCH_COMPILE_DIRECTIVE__PRE_R3__=noop$1;var SWITCH_COMPILE_PIPE__PRE_R3__=noop$1;var SWITCH_COMPILE_COMPONENT=SWITCH_COMPILE_COMPONENT__PRE_R3__;var SWITCH_COMPILE_DIRECTIVE=SWITCH_COMPILE_DIRECTIVE__PRE_R3__;var SWITCH_COMPILE_PIPE=SWITCH_COMPILE_PIPE__PRE_R3__;/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var Éµ0$g=function Éµ0$g(ngModule){return ngModule;},Éµ1$5=/**
	 * Decorator that marks the following class as an NgModule, and supplies
	 * configuration metadata for it.
	 *
	 * * The `declarations` and `entryComponents` options configure the compiler
	 * with information about what belongs to the NgModule.
	 * * The `providers` options configures the NgModule's injector to provide
	 * dependencies the NgModule members.
	 * * The `imports` and `exports` options bring in members from other modules, and make
	 * this module's members available to others.
	 */function Éµ1$5(type,meta){return SWITCH_COMPILE_NGMODULE(type,meta);};/**
	 * @Annotation
	 * @publicApi
	 */var NgModule=makeDecorator('NgModule',Éµ0$g,undefined,undefined,Éµ1$5);function preR3NgModuleCompile(moduleType,metadata){var imports=metadata&&metadata.imports||[];if(metadata&&metadata.exports){imports=__spread(imports,[metadata.exports]);}moduleType.ngInjectorDef=ÉµÉµdefineInjector({factory:convertInjectableProviderToFactory(moduleType,{useClass:moduleType}),providers:metadata&&metadata.providers,imports:imports});}var SWITCH_COMPILE_NGMODULE__PRE_R3__=preR3NgModuleCompile;var SWITCH_COMPILE_NGMODULE=SWITCH_COMPILE_NGMODULE__PRE_R3__;/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * A function that will be executed when an application is initialized.
	 *
	 * @publicApi
	 */var APP_INITIALIZER=new InjectionToken('Application Initializer');/**
	 * A class that reflects the state of running {@link APP_INITIALIZER}s.
	 *
	 * @publicApi
	 */var ApplicationInitStatus=/** @class */function(){function ApplicationInitStatus(appInits){var _this=this;this.appInits=appInits;this.initialized=false;this.done=false;this.donePromise=new Promise(function(res,rej){_this.resolve=res;_this.reject=rej;});}/** @internal */ApplicationInitStatus.prototype.runInitializers=function(){var _this=this;if(this.initialized){return;}var asyncInitPromises=[];var complete=function complete(){_this.done=true;_this.resolve();};if(this.appInits){for(var i=0;i<this.appInits.length;i++){var initResult=this.appInits[i]();if(isPromise$1(initResult)){asyncInitPromises.push(initResult);}}}Promise.all(asyncInitPromises).then(function(){complete();}).catch(function(e){_this.reject(e);});if(asyncInitPromises.length===0){complete();}this.initialized=true;};ApplicationInitStatus=__decorate([Injectable(),__param(0,Inject(APP_INITIALIZER)),__param(0,Optional()),__metadata("design:paramtypes",[Array])],ApplicationInitStatus);return ApplicationInitStatus;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * A DI Token representing a unique string id assigned to the application by Angular and used
	 * primarily for prefixing application attributes and CSS styles when
	 * {@link ViewEncapsulation#Emulated ViewEncapsulation.Emulated} is being used.
	 *
	 * If you need to avoid randomly generated value to be used as an application id, you can provide
	 * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
	 * using this token.
	 * @publicApi
	 */var APP_ID=new InjectionToken('AppId');function _appIdRandomProviderFactory(){return ""+_randomChar()+_randomChar()+_randomChar();}/**
	 * Providers that will generate a random APP_ID_TOKEN.
	 * @publicApi
	 */var APP_ID_RANDOM_PROVIDER={provide:APP_ID,useFactory:_appIdRandomProviderFactory,deps:[]};function _randomChar(){return String.fromCharCode(97+Math.floor(Math.random()*25));}/**
	 * A function that will be executed when a platform is initialized.
	 * @publicApi
	 */var PLATFORM_INITIALIZER=new InjectionToken('Platform Initializer');/**
	 * A token that indicates an opaque platform id.
	 * @publicApi
	 */var PLATFORM_ID=new InjectionToken('Platform ID');/**
	 * All callbacks provided via this token will be called for every component that is bootstrapped.
	 * Signature of the callback:
	 *
	 * `(componentRef: ComponentRef) => void`.
	 *
	 * @publicApi
	 */var APP_BOOTSTRAP_LISTENER=new InjectionToken('appBootstrapListener');/**
	 * A token which indicates the root directory of the application
	 * @publicApi
	 */var PACKAGE_ROOT_URL=new InjectionToken('Application Packages Root URL');/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var Console=/** @class */function(){function Console(){}Console.prototype.log=function(message){// tslint:disable-next-line:no-console
	console.log(message);};// Note: for reporting errors use `DOM.logError()` as it is platform specific
	Console.prototype.warn=function(message){// tslint:disable-next-line:no-console
	console.warn(message);};Console=__decorate([Injectable()],Console);return Console;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Provide this token to set the locale of your application.
	 * It is used for i18n extraction, by i18n pipes (DatePipe, I18nPluralPipe, CurrencyPipe,
	 * DecimalPipe and PercentPipe) and by ICU expressions.
	 *
	 * See the [i18n guide](guide/i18n#setting-up-locale) for more information.
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * ```typescript
	 * import { LOCALE_ID } from '@angular/core';
	 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
	 * import { AppModule } from './app/app.module';
	 *
	 * platformBrowserDynamic().bootstrapModule(AppModule, {
	 *   providers: [{provide: LOCALE_ID, useValue: 'en-US' }]
	 * });
	 * ```
	 *
	 * @publicApi
	 */var LOCALE_ID$1=new InjectionToken('LocaleId');/**
	 * Use this token at bootstrap to provide the content of your translation file (`xtb`,
	 * `xlf` or `xlf2`) when you want to translate your application in another language.
	 *
	 * See the [i18n guide](guide/i18n#merge) for more information.
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * ```typescript
	 * import { TRANSLATIONS } from '@angular/core';
	 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
	 * import { AppModule } from './app/app.module';
	 *
	 * // content of your translation file
	 * const translations = '....';
	 *
	 * platformBrowserDynamic().bootstrapModule(AppModule, {
	 *   providers: [{provide: TRANSLATIONS, useValue: translations }]
	 * });
	 * ```
	 *
	 * @publicApi
	 */var TRANSLATIONS$1=new InjectionToken('Translations');/**
	 * Provide this token at bootstrap to set the format of your {@link TRANSLATIONS}: `xtb`,
	 * `xlf` or `xlf2`.
	 *
	 * See the [i18n guide](guide/i18n#merge) for more information.
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * ```typescript
	 * import { TRANSLATIONS_FORMAT } from '@angular/core';
	 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
	 * import { AppModule } from './app/app.module';
	 *
	 * platformBrowserDynamic().bootstrapModule(AppModule, {
	 *   providers: [{provide: TRANSLATIONS_FORMAT, useValue: 'xlf' }]
	 * });
	 * ```
	 *
	 * @publicApi
	 */var TRANSLATIONS_FORMAT=new InjectionToken('TranslationsFormat');/**
	 * Use this enum at bootstrap as an option of `bootstrapModule` to define the strategy
	 * that the compiler should use in case of missing translations:
	 * - Error: throw if you have missing translations.
	 * - Warning (default): show a warning in the console and/or shell.
	 * - Ignore: do nothing.
	 *
	 * See the [i18n guide](guide/i18n#missing-translation) for more information.
	 *
	 * @usageNotes
	 * ### Example
	 * ```typescript
	 * import { MissingTranslationStrategy } from '@angular/core';
	 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
	 * import { AppModule } from './app/app.module';
	 *
	 * platformBrowserDynamic().bootstrapModule(AppModule, {
	 *   missingTranslation: MissingTranslationStrategy.Error
	 * });
	 * ```
	 *
	 * @publicApi
	 */var MissingTranslationStrategy;(function(MissingTranslationStrategy){MissingTranslationStrategy[MissingTranslationStrategy["Error"]=0]="Error";MissingTranslationStrategy[MissingTranslationStrategy["Warning"]=1]="Warning";MissingTranslationStrategy[MissingTranslationStrategy["Ignore"]=2]="Ignore";})(MissingTranslationStrategy||(MissingTranslationStrategy={}));function _throwError(){throw new Error("Runtime compiler is not loaded");}var Compiler_compileModuleSync__PRE_R3__=_throwError;var Compiler_compileModuleSync=Compiler_compileModuleSync__PRE_R3__;var Compiler_compileModuleAsync__PRE_R3__=_throwError;var Compiler_compileModuleAsync=Compiler_compileModuleAsync__PRE_R3__;var Compiler_compileModuleAndAllComponentsSync__PRE_R3__=_throwError;var Compiler_compileModuleAndAllComponentsSync=Compiler_compileModuleAndAllComponentsSync__PRE_R3__;var Compiler_compileModuleAndAllComponentsAsync__PRE_R3__=_throwError;var Compiler_compileModuleAndAllComponentsAsync=Compiler_compileModuleAndAllComponentsAsync__PRE_R3__;/**
	 * Low-level service for running the angular compiler during runtime
	 * to create {@link ComponentFactory}s, which
	 * can later be used to create and render a Component instance.
	 *
	 * Each `@NgModule` provides an own `Compiler` to its injector,
	 * that will use the directives/pipes of the ng module for compilation
	 * of components.
	 *
	 * @publicApi
	 */var Compiler=/** @class */function(){function Compiler(){/**
	         * Compiles the given NgModule and all of its components. All templates of the components listed
	         * in `entryComponents` have to be inlined.
	         */this.compileModuleSync=Compiler_compileModuleSync;/**
	         * Compiles the given NgModule and all of its components
	         */this.compileModuleAsync=Compiler_compileModuleAsync;/**
	         * Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.
	         */this.compileModuleAndAllComponentsSync=Compiler_compileModuleAndAllComponentsSync;/**
	         * Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.
	         */this.compileModuleAndAllComponentsAsync=Compiler_compileModuleAndAllComponentsAsync;}/**
	     * Clears all caches.
	     */Compiler.prototype.clearCache=function(){};/**
	     * Clears the cache for the given component/ngModule.
	     */Compiler.prototype.clearCacheFor=function(type){};/**
	     * Returns the id for a given NgModule, if one is defined and known to the compiler.
	     */Compiler.prototype.getModuleId=function(moduleType){return undefined;};Compiler=__decorate([Injectable()],Compiler);return Compiler;}();/**
	 * Token to provide CompilerOptions in the platform injector.
	 *
	 * @publicApi
	 */var COMPILER_OPTIONS=new InjectionToken('compilerOptions');/**
	 * A factory for creating a Compiler
	 *
	 * @publicApi
	 */var CompilerFactory=/** @class */function(){function CompilerFactory(){}return CompilerFactory;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var trace;var events;function detectWTF(){var wtf=_global$1/** TODO #9100 */['wtf'];if(wtf){trace=wtf['trace'];if(trace){events=trace['events'];return true;}}return false;}function createScope(signature,flags){if(flags===void 0){flags=null;}return events.createScope(signature,flags);}function leave(scope,returnValue){trace.leaveScope(scope,returnValue);return returnValue;}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * True if WTF is enabled.
	 */var wtfEnabled=detectWTF();function noopScope(arg0,arg1){return null;}/**
	 * Create trace scope.
	 *
	 * Scopes must be strictly nested and are analogous to stack frames, but
	 * do not have to follow the stack frames. Instead it is recommended that they follow logical
	 * nesting. You may want to use
	 * [Event
	 * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
	 * as they are defined in WTF.
	 *
	 * Used to mark scope entry. The return value is used to leave the scope.
	 *
	 *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
	 *
	 *     someMethod() {
	 *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
	 *        // DO SOME WORK HERE
	 *        return wtfLeave(s, 123); // Return value 123
	 *     }
	 *
	 * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
	 * negatively impact the performance of your application. For this reason we recommend that
	 * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
	 * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
	 * exception, will produce incorrect trace, but presence of exception signifies logic error which
	 * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
	 * an exception is expected during normal execution while profiling.
	 *
	 * @publicApi
	 * @deprecated the Web Tracing Framework is no longer supported in Angular
	 */var wtfCreateScope=wtfEnabled?createScope:function(signature,flags){return noopScope;};/**
	 * Used to mark end of Scope.
	 *
	 * - `scope` to end.
	 * - `returnValue` (optional) to be passed to the WTF.
	 *
	 * Returns the `returnValue for easy chaining.
	 * @publicApi
	 * @deprecated the Web Tracing Framework is no longer supported in Angular
	 */var wtfLeave=wtfEnabled?leave:function(s,r){return r;};/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var promise=function(){return Promise.resolve(0);}();function scheduleMicroTask(fn){if(typeof Zone==='undefined'){// use promise to schedule microTask instead of use Zone
	promise.then(function(){fn&&fn.apply(null,null);});}else{Zone.current.scheduleMicroTask('scheduleMicrotask',fn);}}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * An injectable service for executing work inside or outside of the Angular zone.
	 *
	 * The most common use of this service is to optimize performance when starting a work consisting of
	 * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
	 * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks
	 * can reenter the Angular zone via {@link #run}.
	 *
	 * <!-- TODO: add/fix links to:
	 *   - docs explaining zones and the use of zones in Angular and change-detection
	 *   - link to runOutsideAngular/run (throughout this file!)
	 *   -->
	 *
	 * @usageNotes
	 * ### Example
	 *
	 * ```
	 * import {Component, NgZone} from '@angular/core';
	 * import {NgIf} from '@angular/common';
	 *
	 * @Component({
	 *   selector: 'ng-zone-demo',
	 *   template: `
	 *     <h2>Demo: NgZone</h2>
	 *
	 *     <p>Progress: {{progress}}%</p>
	 *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
	 *
	 *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
	 *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
	 *   `,
	 * })
	 * export class NgZoneDemo {
	 *   progress: number = 0;
	 *   label: string;
	 *
	 *   constructor(private _ngZone: NgZone) {}
	 *
	 *   // Loop inside the Angular zone
	 *   // so the UI DOES refresh after each setTimeout cycle
	 *   processWithinAngularZone() {
	 *     this.label = 'inside';
	 *     this.progress = 0;
	 *     this._increaseProgress(() => console.log('Inside Done!'));
	 *   }
	 *
	 *   // Loop outside of the Angular zone
	 *   // so the UI DOES NOT refresh after each setTimeout cycle
	 *   processOutsideOfAngularZone() {
	 *     this.label = 'outside';
	 *     this.progress = 0;
	 *     this._ngZone.runOutsideAngular(() => {
	 *       this._increaseProgress(() => {
	 *         // reenter the Angular zone and display done
	 *         this._ngZone.run(() => { console.log('Outside Done!'); });
	 *       });
	 *     });
	 *   }
	 *
	 *   _increaseProgress(doneCallback: () => void) {
	 *     this.progress += 1;
	 *     console.log(`Current progress: ${this.progress}%`);
	 *
	 *     if (this.progress < 100) {
	 *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);
	 *     } else {
	 *       doneCallback();
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * @publicApi
	 */var NgZone=/** @class */function(){function NgZone(_a){var _b=_a.enableLongStackTrace,enableLongStackTrace=_b===void 0?false:_b;this.hasPendingMicrotasks=false;this.hasPendingMacrotasks=false;/**
	         * Whether there are no outstanding microtasks or macrotasks.
	         */this.isStable=true;/**
	         * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
	         */this.onUnstable=new EventEmitter(false);/**
	         * Notifies when there is no more microtasks enqueued in the current VM Turn.
	         * This is a hint for Angular to do change detection, which may enqueue more microtasks.
	         * For this reason this event can fire multiple times per VM Turn.
	         */this.onMicrotaskEmpty=new EventEmitter(false);/**
	         * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
	         * implies we are about to relinquish VM turn.
	         * This event gets called just once.
	         */this.onStable=new EventEmitter(false);/**
	         * Notifies that an error has been delivered.
	         */this.onError=new EventEmitter(false);if(typeof Zone=='undefined'){throw new Error("In this configuration Angular requires Zone.js");}Zone.assertZonePatched();var self=this;self._nesting=0;self._outer=self._inner=Zone.current;if(Zone['wtfZoneSpec']){self._inner=self._inner.fork(Zone['wtfZoneSpec']);}if(Zone['TaskTrackingZoneSpec']){self._inner=self._inner.fork(new Zone['TaskTrackingZoneSpec']());}if(enableLongStackTrace&&Zone['longStackTraceZoneSpec']){self._inner=self._inner.fork(Zone['longStackTraceZoneSpec']);}forkInnerZoneWithAngularBehavior(self);}NgZone.isInAngularZone=function(){return Zone.current.get('isAngularZone')===true;};NgZone.assertInAngularZone=function(){if(!NgZone.isInAngularZone()){throw new Error('Expected to be in Angular Zone, but it is not!');}};NgZone.assertNotInAngularZone=function(){if(NgZone.isInAngularZone()){throw new Error('Expected to not be in Angular Zone, but it is!');}};/**
	     * Executes the `fn` function synchronously within the Angular zone and returns value returned by
	     * the function.
	     *
	     * Running functions via `run` allows you to reenter Angular zone from a task that was executed
	     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
	     *
	     * Any future tasks or microtasks scheduled from within this function will continue executing from
	     * within the Angular zone.
	     *
	     * If a synchronous error happens it will be rethrown and not reported via `onError`.
	     */NgZone.prototype.run=function(fn,applyThis,applyArgs){return this._inner.run(fn,applyThis,applyArgs);};/**
	     * Executes the `fn` function synchronously within the Angular zone as a task and returns value
	     * returned by the function.
	     *
	     * Running functions via `run` allows you to reenter Angular zone from a task that was executed
	     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
	     *
	     * Any future tasks or microtasks scheduled from within this function will continue executing from
	     * within the Angular zone.
	     *
	     * If a synchronous error happens it will be rethrown and not reported via `onError`.
	     */NgZone.prototype.runTask=function(fn,applyThis,applyArgs,name){var zone=this._inner;var task=zone.scheduleEventTask('NgZoneEvent: '+name,fn,EMPTY_PAYLOAD,noop$1$1,noop$1$1);try{return zone.runTask(task,applyThis,applyArgs);}finally{zone.cancelTask(task);}};/**
	     * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
	     * rethrown.
	     */NgZone.prototype.runGuarded=function(fn,applyThis,applyArgs){return this._inner.runGuarded(fn,applyThis,applyArgs);};/**
	     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
	     * the function.
	     *
	     * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do
	     * work that
	     * doesn't trigger Angular change-detection or is subject to Angular's error handling.
	     *
	     * Any future tasks or microtasks scheduled from within this function will continue executing from
	     * outside of the Angular zone.
	     *
	     * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
	     */NgZone.prototype.runOutsideAngular=function(fn){return this._outer.run(fn);};return NgZone;}();function noop$1$1(){}var EMPTY_PAYLOAD={};function checkStable(zone){if(zone._nesting==0&&!zone.hasPendingMicrotasks&&!zone.isStable){try{zone._nesting++;zone.onMicrotaskEmpty.emit(null);}finally{zone._nesting--;if(!zone.hasPendingMicrotasks){try{zone.runOutsideAngular(function(){return zone.onStable.emit(null);});}finally{zone.isStable=true;}}}}}function forkInnerZoneWithAngularBehavior(zone){zone._inner=zone._inner.fork({name:'angular',properties:{'isAngularZone':true},onInvokeTask:function onInvokeTask(delegate,current,target,task,applyThis,applyArgs){try{onEnter(zone);return delegate.invokeTask(target,task,applyThis,applyArgs);}finally{onLeave(zone);}},onInvoke:function onInvoke(delegate,current,target,callback,applyThis,applyArgs,source){try{onEnter(zone);return delegate.invoke(target,callback,applyThis,applyArgs,source);}finally{onLeave(zone);}},onHasTask:function onHasTask(delegate,current,target,hasTaskState){delegate.hasTask(target,hasTaskState);if(current===target){// We are only interested in hasTask events which originate from our zone
	// (A child hasTask event is not interesting to us)
	if(hasTaskState.change=='microTask'){zone.hasPendingMicrotasks=hasTaskState.microTask;checkStable(zone);}else if(hasTaskState.change=='macroTask'){zone.hasPendingMacrotasks=hasTaskState.macroTask;}}},onHandleError:function onHandleError(delegate,current,target,error){delegate.handleError(target,error);zone.runOutsideAngular(function(){return zone.onError.emit(error);});return false;}});}function onEnter(zone){zone._nesting++;if(zone.isStable){zone.isStable=false;zone.onUnstable.emit(null);}}function onLeave(zone){zone._nesting--;checkStable(zone);}/**
	 * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls
	 * to framework to perform rendering.
	 */var NoopNgZone=/** @class */function(){function NoopNgZone(){this.hasPendingMicrotasks=false;this.hasPendingMacrotasks=false;this.isStable=true;this.onUnstable=new EventEmitter();this.onMicrotaskEmpty=new EventEmitter();this.onStable=new EventEmitter();this.onError=new EventEmitter();}NoopNgZone.prototype.run=function(fn){return fn();};NoopNgZone.prototype.runGuarded=function(fn){return fn();};NoopNgZone.prototype.runOutsideAngular=function(fn){return fn();};NoopNgZone.prototype.runTask=function(fn){return fn();};return NoopNgZone;}();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * The Testability service provides testing hooks that can be accessed from
	 * the browser and by services such as Protractor. Each bootstrapped Angular
	 * application on the page will have an instance of Testability.
	 * @publicApi
	 */var Testability=/** @class */function(){function Testability(_ngZone){var _this=this;this._ngZone=_ngZone;this._pendingCount=0;this._isZoneStable=true;/**
	         * Whether any work was done since the last 'whenStable' callback. This is
	         * useful to detect if this could have potentially destabilized another
	         * component while it is stabilizing.
	         * @internal
	         */this._didWork=false;this._callbacks=[];this.taskTrackingZone=null;this._watchAngularEvents();_ngZone.run(function(){_this.taskTrackingZone=typeof Zone=='undefined'?null:Zone.current.get('TaskTrackingZone');});}Testability.prototype._watchAngularEvents=function(){var _this=this;this._ngZone.onUnstable.subscribe({next:function next(){_this._didWork=true;_this._isZoneStable=false;}});this._ngZone.runOutsideAngular(function(){_this._ngZone.onStable.subscribe({next:function next(){NgZone.assertNotInAngularZone();scheduleMicroTask(function(){_this._isZoneStable=true;_this._runCallbacksIfReady();});}});});};/**
	     * Increases the number of pending request
	     * @deprecated pending requests are now tracked with zones.
	     */Testability.prototype.increasePendingRequestCount=function(){this._pendingCount+=1;this._didWork=true;return this._pendingCount;};/**
	     * Decreases the number of pending request
	     * @deprecated pending requests are now tracked with zones
	     */Testability.prototype.decreasePendingRequestCount=function(){this._pendingCount-=1;if(this._pendingCount<0){throw new Error('pending async requests below zero');}this._runCallbacksIfReady();return this._pendingCount;};/**
	     * Whether an associated application is stable
	     */Testability.prototype.isStable=function(){return this._isZoneStable&&this._pendingCount===0&&!this._ngZone.hasPendingMacrotasks;};Testability.prototype._runCallbacksIfReady=function(){var _this=this;if(this.isStable()){// Schedules the call backs in a new frame so that it is always async.
	scheduleMicroTask(function(){while(_this._callbacks.length!==0){var cb=_this._callbacks.pop();clearTimeout(cb.timeoutId);cb.doneCb(_this._didWork);}_this._didWork=false;});}else{// Still not stable, send updates.
	var pending_1=this.getPendingTasks();this._callbacks=this._callbacks.filter(function(cb){if(cb.updateCb&&cb.updateCb(pending_1)){clearTimeout(cb.timeoutId);return false;}return true;});this._didWork=true;}};Testability.prototype.getPendingTasks=function(){if(!this.taskTrackingZone){return [];}// Copy the tasks data so that we don't leak tasks.
	return this.taskTrackingZone.macroTasks.map(function(t){return {source:t.source,// From TaskTrackingZone:
	// https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40
	creationLocation:t.creationLocation,data:t.data};});};Testability.prototype.addCallback=function(cb,timeout$$1,updateCb){var _this=this;var timeoutId=-1;if(timeout$$1&&timeout$$1>0){timeoutId=setTimeout(function(){_this._callbacks=_this._callbacks.filter(function(cb){return cb.timeoutId!==timeoutId;});cb(_this._didWork,_this.getPendingTasks());},timeout$$1);}this._callbacks.push({doneCb:cb,timeoutId:timeoutId,updateCb:updateCb});};/**
	     * Wait for the application to be stable with a timeout. If the timeout is reached before that
	     * happens, the callback receives a list of the macro tasks that were pending, otherwise null.
	     *
	     * @param doneCb The callback to invoke when Angular is stable or the timeout expires
	     *    whichever comes first.
	     * @param timeout Optional. The maximum time to wait for Angular to become stable. If not
	     *    specified, whenStable() will wait forever.
	     * @param updateCb Optional. If specified, this callback will be invoked whenever the set of
	     *    pending macrotasks changes. If this callback returns true doneCb will not be invoked
	     *    and no further updates will be issued.
	     */Testability.prototype.whenStable=function(doneCb,timeout$$1,updateCb){if(updateCb&&!this.taskTrackingZone){throw new Error('Task tracking zone is required when passing an update callback to '+'whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');}// These arguments are 'Function' above to keep the public API simple.
	this.addCallback(doneCb,timeout$$1,updateCb);this._runCallbacksIfReady();};/**
	     * Get the number of pending requests
	     * @deprecated pending requests are now tracked with zones
	     */Testability.prototype.getPendingRequestCount=function(){return this._pendingCount;};/**
	     * Find providers by name
	     * @param using The root element to search from
	     * @param provider The name of binding variable
	     * @param exactMatch Whether using exactMatch
	     */Testability.prototype.findProviders=function(using$$1,provider,exactMatch){// TODO(juliemr): implement.
	return [];};Testability=__decorate([Injectable(),__metadata("design:paramtypes",[NgZone])],Testability);return Testability;}();/**
	 * A global registry of {@link Testability} instances for specific elements.
	 * @publicApi
	 */var TestabilityRegistry=/** @class */function(){function TestabilityRegistry(){/** @internal */this._applications=new Map();_testabilityGetter.addToWindow(this);}/**
	     * Registers an application with a testability hook so that it can be tracked
	     * @param token token of application, root element
	     * @param testability Testability hook
	     */TestabilityRegistry.prototype.registerApplication=function(token,testability){this._applications.set(token,testability);};/**
	     * Unregisters an application.
	     * @param token token of application, root element
	     */TestabilityRegistry.prototype.unregisterApplication=function(token){this._applications.delete(token);};/**
	     * Unregisters all applications
	     */TestabilityRegistry.prototype.unregisterAllApplications=function(){this._applications.clear();};/**
	     * Get a testability hook associated with the application
	     * @param elem root element
	     */TestabilityRegistry.prototype.getTestability=function(elem){return this._applications.get(elem)||null;};/**
	     * Get all registered testabilities
	     */TestabilityRegistry.prototype.getAllTestabilities=function(){return Array.from(this._applications.values());};/**
	     * Get all registered applications(root elements)
	     */TestabilityRegistry.prototype.getAllRootElements=function(){return Array.from(this._applications.keys());};/**
	     * Find testability of a node in the Tree
	     * @param elem node
	     * @param findInAncestors whether finding testability in ancestors if testability was not found in
	     * current node
	     */TestabilityRegistry.prototype.findTestabilityInTree=function(elem,findInAncestors){if(findInAncestors===void 0){findInAncestors=true;}return _testabilityGetter.findTestabilityInTree(this,elem,findInAncestors);};TestabilityRegistry=__decorate([Injectable(),__metadata("design:paramtypes",[])],TestabilityRegistry);return TestabilityRegistry;}();var _NoopGetTestability=/** @class */function(){function _NoopGetTestability(){}_NoopGetTestability.prototype.addToWindow=function(registry){};_NoopGetTestability.prototype.findTestabilityInTree=function(registry,elem,findInAncestors){return null;};return _NoopGetTestability;}();var _testabilityGetter=new _NoopGetTestability();/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var _platform;var compileNgModuleFactory=compileNgModuleFactory__PRE_R3__;function compileNgModuleFactory__PRE_R3__(injector,options,moduleType){var compilerFactory=injector.get(CompilerFactory);var compiler=compilerFactory.createCompiler([options]);return compiler.compileModuleAsync(moduleType);}var isBoundToModule=isBoundToModule__PRE_R3__;function isBoundToModule__PRE_R3__(cf){return cf instanceof ComponentFactoryBoundToModule;}var ALLOW_MULTIPLE_PLATFORMS=new InjectionToken('AllowMultipleToken');/**
	 * Creates a platform.
	 * Platforms have to be eagerly created via this function.
	 *
	 * @publicApi
	 */function createPlatform(injector){if(_platform&&!_platform.destroyed&&!_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS,false)){throw new Error('There can be only one platform. Destroy the previous one to create a new one.');}_platform=injector.get(PlatformRef);var inits=injector.get(PLATFORM_INITIALIZER,null);if(inits)inits.forEach(function(init){return init();});return _platform;}/**
	 * Creates a factory for a platform
	 *
	 * @publicApi
	 */function createPlatformFactory(parentPlatformFactory,name,providers){if(providers===void 0){providers=[];}var desc="Platform: "+name;var marker=new InjectionToken(desc);return function(extraProviders){if(extraProviders===void 0){extraProviders=[];}var platform=getPlatform();if(!platform||platform.injector.get(ALLOW_MULTIPLE_PLATFORMS,false)){if(parentPlatformFactory){parentPlatformFactory(providers.concat(extraProviders).concat({provide:marker,useValue:true}));}else{var injectedProviders=providers.concat(extraProviders).concat({provide:marker,useValue:true});createPlatform(Injector.create({providers:injectedProviders,name:desc}));}}return assertPlatform(marker);};}/**
	 * Checks that there currently is a platform which contains the given token as a provider.
	 *
	 * @publicApi
	 */function assertPlatform(requiredToken){var platform=getPlatform();if(!platform){throw new Error('No platform exists!');}if(!platform.injector.get(requiredToken,null)){throw new Error('A platform with a different configuration has been created. Please destroy it first.');}return platform;}/**
	 * Returns the current platform.
	 *
	 * @publicApi
	 */function getPlatform(){return _platform&&!_platform.destroyed?_platform:null;}/**
	 * The Angular platform is the entry point for Angular on a web page. Each page
	 * has exactly one platform, and services (such as reflection) which are common
	 * to every Angular application running on the page are bound in its scope.
	 *
	 * A page's platform is initialized implicitly when a platform is created via a platform factory
	 * (e.g. {@link platformBrowser}), or explicitly by calling the {@link createPlatform} function.
	 *
	 * @publicApi
	 */var PlatformRef=/** @class */function(){/** @internal */function PlatformRef(_injector){this._injector=_injector;this._modules=[];this._destroyListeners=[];this._destroyed=false;}/**
	     * Creates an instance of an `@NgModule` for the given platform
	     * for offline compilation.
	     *
	     * @usageNotes
	     * ### Simple Example
	     *
	     * ```typescript
	     * my_module.ts:
	     *
	     * @NgModule({
	     *   imports: [BrowserModule]
	     * })
	     * class MyModule {}
	     *
	     * main.ts:
	     * import {MyModuleNgFactory} from './my_module.ngfactory';
	     * import {platformBrowser} from '@angular/platform-browser';
	     *
	     * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
	     * ```
	     */PlatformRef.prototype.bootstrapModuleFactory=function(moduleFactory,options){var _this=this;// Note: We need to create the NgZone _before_ we instantiate the module,
	// as instantiating the module creates some providers eagerly.
	// So we create a mini parent injector that just contains the new NgZone and
	// pass that as parent to the NgModuleFactory.
	var ngZoneOption=options?options.ngZone:undefined;var ngZone=getNgZone(ngZoneOption);var providers=[{provide:NgZone,useValue:ngZone}];// Attention: Don't use ApplicationRef.run here,
	// as we want to be sure that all possible constructor calls are inside `ngZone.run`!
	return ngZone.run(function(){var ngZoneInjector=Injector.create({providers:providers,parent:_this.injector,name:moduleFactory.moduleType.name});var moduleRef=moduleFactory.create(ngZoneInjector);var exceptionHandler=moduleRef.injector.get(ErrorHandler,null);if(!exceptionHandler){throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');}// If the `LOCALE_ID` provider is defined at bootstrap we set the value for runtime i18n (ivy)
	moduleRef.onDestroy(function(){return remove(_this._modules,moduleRef);});ngZone.runOutsideAngular(function(){return ngZone.onError.subscribe({next:function next(error){exceptionHandler.handleError(error);}});});return _callAndReportToErrorHandler(exceptionHandler,ngZone,function(){var initStatus=moduleRef.injector.get(ApplicationInitStatus);initStatus.runInitializers();return initStatus.donePromise.then(function(){_this._moduleDoBootstrap(moduleRef);return moduleRef;});});});};/**
	     * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.
	     *
	     * @usageNotes
	     * ### Simple Example
	     *
	     * ```typescript
	     * @NgModule({
	     *   imports: [BrowserModule]
	     * })
	     * class MyModule {}
	     *
	     * let moduleRef = platformBrowser().bootstrapModule(MyModule);
	     * ```
	     *
	     */PlatformRef.prototype.bootstrapModule=function(moduleType,compilerOptions){var _this=this;if(compilerOptions===void 0){compilerOptions=[];}var options=optionsReducer({},compilerOptions);return compileNgModuleFactory(this.injector,options,moduleType).then(function(moduleFactory){return _this.bootstrapModuleFactory(moduleFactory,options);});};PlatformRef.prototype._moduleDoBootstrap=function(moduleRef){var appRef=moduleRef.injector.get(ApplicationRef);if(moduleRef._bootstrapComponents.length>0){moduleRef._bootstrapComponents.forEach(function(f){return appRef.bootstrap(f);});}else if(moduleRef.instance.ngDoBootstrap){moduleRef.instance.ngDoBootstrap(appRef);}else{throw new Error("The module "+stringify(moduleRef.instance.constructor)+" was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. "+"Please define one of these.");}this._modules.push(moduleRef);};/**
	     * Register a listener to be called when the platform is disposed.
	     */PlatformRef.prototype.onDestroy=function(callback){this._destroyListeners.push(callback);};Object.defineProperty(PlatformRef.prototype,"injector",{/**
	         * Retrieve the platform {@link Injector}, which is the parent injector for
	         * every Angular application on the page and provides singleton providers.
	         */get:function get(){return this._injector;},enumerable:true,configurable:true});/**
	     * Destroy the Angular platform and all Angular applications on the page.
	     */PlatformRef.prototype.destroy=function(){if(this._destroyed){throw new Error('The platform has already been destroyed!');}this._modules.slice().forEach(function(module){return module.destroy();});this._destroyListeners.forEach(function(listener){return listener();});this._destroyed=true;};Object.defineProperty(PlatformRef.prototype,"destroyed",{get:function get(){return this._destroyed;},enumerable:true,configurable:true});PlatformRef=__decorate([Injectable(),__metadata("design:paramtypes",[Injector])],PlatformRef);return PlatformRef;}();function getNgZone(ngZoneOption){var ngZone;if(ngZoneOption==='noop'){ngZone=new NoopNgZone();}else{ngZone=(ngZoneOption==='zone.js'?undefined:ngZoneOption)||new NgZone({enableLongStackTrace:isDevMode()});}return ngZone;}function _callAndReportToErrorHandler(errorHandler,ngZone,callback){try{var result=callback();if(isPromise$1(result)){return result.catch(function(e){ngZone.runOutsideAngular(function(){return errorHandler.handleError(e);});// rethrow as the exception handler might not do it
	throw e;});}return result;}catch(e){ngZone.runOutsideAngular(function(){return errorHandler.handleError(e);});// rethrow as the exception handler might not do it
	throw e;}}function optionsReducer(dst,objs){if(Array.isArray(objs)){dst=objs.reduce(optionsReducer,dst);}else{dst=_assign({},dst,objs);}return dst;}/**
	 * A reference to an Angular application running on a page.
	 *
	 * @usageNotes
	 *
	 * {@a is-stable-examples}
	 * ### isStable examples and caveats
	 *
	 * Note two important points about `isStable`, demonstrated in the examples below:
	 * - the application will never be stable if you start any kind
	 * of recurrent asynchronous task when the application starts
	 * (for example for a polling process, started with a `setInterval`, a `setTimeout`
	 * or using RxJS operators like `interval`);
	 * - the `isStable` Observable runs outside of the Angular zone.
	 *
	 * Let's imagine that you start a recurrent task
	 * (here incrementing a counter, using RxJS `interval`),
	 * and at the same time subscribe to `isStable`.
	 *
	 * ```
	 * constructor(appRef: ApplicationRef) {
	 *   appRef.isStable.pipe(
	 *      filter(stable => stable)
	 *   ).subscribe(() => console.log('App is stable now');
	 *   interval(1000).subscribe(counter => console.log(counter));
	 * }
	 * ```
	 * In this example, `isStable` will never emit `true`,
	 * and the trace "App is stable now" will never get logged.
	 *
	 * If you want to execute something when the app is stable,
	 * you have to wait for the application to be stable
	 * before starting your polling process.
	 *
	 * ```
	 * constructor(appRef: ApplicationRef) {
	 *   appRef.isStable.pipe(
	 *     first(stable => stable),
	 *     tap(stable => console.log('App is stable now')),
	 *     switchMap(() => interval(1000))
	 *   ).subscribe(counter => console.log(counter));
	 * }
	 * ```
	 * In this example, the trace "App is stable now" will be logged
	 * and then the counter starts incrementing every second.
	 *
	 * Note also that this Observable runs outside of the Angular zone,
	 * which means that the code in the subscription
	 * to this Observable will not trigger the change detection.
	 *
	 * Let's imagine that instead of logging the counter value,
	 * you update a field of your component
	 * and display it in its template.
	 *
	 * ```
	 * constructor(appRef: ApplicationRef) {
	 *   appRef.isStable.pipe(
	 *     first(stable => stable),
	 *     switchMap(() => interval(1000))
	 *   ).subscribe(counter => this.value = counter);
	 * }
	 * ```
	 * As the `isStable` Observable runs outside the zone,
	 * the `value` field will be updated properly,
	 * but the template will not be refreshed!
	 *
	 * You'll have to manually trigger the change detection to update the template.
	 *
	 * ```
	 * constructor(appRef: ApplicationRef, cd: ChangeDetectorRef) {
	 *   appRef.isStable.pipe(
	 *     first(stable => stable),
	 *     switchMap(() => interval(1000))
	 *   ).subscribe(counter => {
	 *     this.value = counter;
	 *     cd.detectChanges();
	 *   });
	 * }
	 * ```
	 *
	 * Or make the subscription callback run inside the zone.
	 *
	 * ```
	 * constructor(appRef: ApplicationRef, zone: NgZone) {
	 *   appRef.isStable.pipe(
	 *     first(stable => stable),
	 *     switchMap(() => interval(1000))
	 *   ).subscribe(counter => zone.run(() => this.value = counter));
	 * }
	 * ```
	 *
	 * @publicApi
	 */var ApplicationRef=/** @class */function(){/** @internal */function ApplicationRef(_zone,_console,_injector,_exceptionHandler,_componentFactoryResolver,_initStatus){var _this=this;this._zone=_zone;this._console=_console;this._injector=_injector;this._exceptionHandler=_exceptionHandler;this._componentFactoryResolver=_componentFactoryResolver;this._initStatus=_initStatus;this._bootstrapListeners=[];this._views=[];this._runningTick=false;this._enforceNoNewChanges=false;this._stable=true;/**
	         * Get a list of component types registered to this application.
	         * This list is populated even before the component is created.
	         */this.componentTypes=[];/**
	         * Get a list of components registered to this application.
	         */this.components=[];this._enforceNoNewChanges=isDevMode();this._zone.onMicrotaskEmpty.subscribe({next:function next(){_this._zone.run(function(){_this.tick();});}});var isCurrentlyStable=new Observable(function(observer){_this._stable=_this._zone.isStable&&!_this._zone.hasPendingMacrotasks&&!_this._zone.hasPendingMicrotasks;_this._zone.runOutsideAngular(function(){observer.next(_this._stable);observer.complete();});});var isStable=new Observable(function(observer){// Create the subscription to onStable outside the Angular Zone so that
	// the callback is run outside the Angular Zone.
	var stableSub;_this._zone.runOutsideAngular(function(){stableSub=_this._zone.onStable.subscribe(function(){NgZone.assertNotInAngularZone();// Check whether there are no pending macro/micro tasks in the next tick
	// to allow for NgZone to update the state.
	scheduleMicroTask(function(){if(!_this._stable&&!_this._zone.hasPendingMacrotasks&&!_this._zone.hasPendingMicrotasks){_this._stable=true;observer.next(true);}});});});var unstableSub=_this._zone.onUnstable.subscribe(function(){NgZone.assertInAngularZone();if(_this._stable){_this._stable=false;_this._zone.runOutsideAngular(function(){observer.next(false);});}});return function(){stableSub.unsubscribe();unstableSub.unsubscribe();};});this.isStable=merge(isCurrentlyStable,isStable.pipe(share()));}ApplicationRef_1=ApplicationRef;/**
	     * Bootstrap a new component at the root level of the application.
	     *
	     * @usageNotes
	     * ### Bootstrap process
	     *
	     * When bootstrapping a new root component into an application, Angular mounts the
	     * specified application component onto DOM elements identified by the componentType's
	     * selector and kicks off automatic change detection to finish initializing the component.
	     *
	     * Optionally, a component can be mounted onto a DOM element that does not match the
	     * componentType's selector.
	     *
	     * ### Example
	     * {@example core/ts/platform/platform.ts region='longform'}
	     */ApplicationRef.prototype.bootstrap=function(componentOrFactory,rootSelectorOrNode){var _this=this;if(!this._initStatus.done){throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');}var componentFactory;if(componentOrFactory instanceof ComponentFactory){componentFactory=componentOrFactory;}else{componentFactory=this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);}this.componentTypes.push(componentFactory.componentType);// Create a factory associated with the current module if it's not bound to some other
	var ngModule=isBoundToModule(componentFactory)?null:this._injector.get(NgModuleRef);var selectorOrNode=rootSelectorOrNode||componentFactory.selector;var compRef=componentFactory.create(Injector.NULL,[],selectorOrNode,ngModule);compRef.onDestroy(function(){_this._unloadComponent(compRef);});var testability=compRef.injector.get(Testability,null);if(testability){compRef.injector.get(TestabilityRegistry).registerApplication(compRef.location.nativeElement,testability);}this._loadComponent(compRef);if(isDevMode()){this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode.");}return compRef;};/**
	     * Invoke this method to explicitly process change detection and its side-effects.
	     *
	     * In development mode, `tick()` also performs a second change detection cycle to ensure that no
	     * further changes are detected. If additional changes are picked up during this second cycle,
	     * bindings in the app have side-effects that cannot be resolved in a single change detection
	     * pass.
	     * In this case, Angular throws an error, since an Angular application can only have one change
	     * detection pass during which all change detection must complete.
	     */ApplicationRef.prototype.tick=function(){var e_1,_a,e_2,_b;var _this=this;if(this._runningTick){throw new Error('ApplicationRef.tick is called recursively');}var scope=ApplicationRef_1._tickScope();try{this._runningTick=true;try{for(var _c=__values(this._views),_d=_c.next();!_d.done;_d=_c.next()){var view=_d.value;view.detectChanges();}}catch(e_1_1){e_1={error:e_1_1};}finally{try{if(_d&&!_d.done&&(_a=_c.return))_a.call(_c);}finally{if(e_1)throw e_1.error;}}if(this._enforceNoNewChanges){try{for(var _e=__values(this._views),_f=_e.next();!_f.done;_f=_e.next()){var view=_f.value;view.checkNoChanges();}}catch(e_2_1){e_2={error:e_2_1};}finally{try{if(_f&&!_f.done&&(_b=_e.return))_b.call(_e);}finally{if(e_2)throw e_2.error;}}}}catch(e){// Attention: Don't rethrow as it could cancel subscriptions to Observables!
	this._zone.runOutsideAngular(function(){return _this._exceptionHandler.handleError(e);});}finally{this._runningTick=false;wtfLeave(scope);}};/**
	     * Attaches a view so that it will be dirty checked.
	     * The view will be automatically detached when it is destroyed.
	     * This will throw if the view is already attached to a ViewContainer.
	     */ApplicationRef.prototype.attachView=function(viewRef){var view=viewRef;this._views.push(view);view.attachToAppRef(this);};/**
	     * Detaches a view from dirty checking again.
	     */ApplicationRef.prototype.detachView=function(viewRef){var view=viewRef;remove(this._views,view);view.detachFromAppRef();};ApplicationRef.prototype._loadComponent=function(componentRef){this.attachView(componentRef.hostView);this.tick();this.components.push(componentRef);// Get the listeners lazily to prevent DI cycles.
	var listeners=this._injector.get(APP_BOOTSTRAP_LISTENER,[]).concat(this._bootstrapListeners);listeners.forEach(function(listener){return listener(componentRef);});};ApplicationRef.prototype._unloadComponent=function(componentRef){this.detachView(componentRef.hostView);remove(this.components,componentRef);};/** @internal */ApplicationRef.prototype.ngOnDestroy=function(){// TODO(alxhub): Dispose of the NgZone.
	this._views.slice().forEach(function(view){return view.destroy();});};Object.defineProperty(ApplicationRef.prototype,"viewCount",{/**
	         * Returns the number of attached views.
	         */get:function get(){return this._views.length;},enumerable:true,configurable:true});var ApplicationRef_1;/** @internal */ApplicationRef._tickScope=wtfCreateScope('ApplicationRef#tick()');ApplicationRef=ApplicationRef_1=__decorate([Injectable(),__metadata("design:paramtypes",[NgZone,Console,Injector,ErrorHandler,ComponentFactoryResolver,ApplicationInitStatus])],ApplicationRef);return ApplicationRef;}();function remove(list,el){var index=list.indexOf(el);if(index>-1){list.splice(index,1);}}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var _SEPARATOR='#';var FACTORY_CLASS_SUFFIX='NgFactory';/**
	 * Configuration for SystemJsNgModuleLoader.
	 * token.
	 *
	 * @publicApi
	 * @deprecated the `string` form of `loadChildren` is deprecated, and `SystemJsNgModuleLoaderConfig`
	 * is part of its implementation. See `LoadChildren` for more details.
	 */var SystemJsNgModuleLoaderConfig=/** @class */function(){function SystemJsNgModuleLoaderConfig(){}return SystemJsNgModuleLoaderConfig;}();var DEFAULT_CONFIG={factoryPathPrefix:'',factoryPathSuffix:'.ngfactory'};/**
	 * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory
	 * @publicApi
	 * @deprecated the `string` form of `loadChildren` is deprecated, and `SystemJsNgModuleLoader` is
	 * part of its implementation. See `LoadChildren` for more details.
	 */var SystemJsNgModuleLoader=/** @class */function(){function SystemJsNgModuleLoader(_compiler,config$$1){this._compiler=_compiler;this._config=config$$1||DEFAULT_CONFIG;}SystemJsNgModuleLoader.prototype.load=function(path){var legacyOfflineMode=this._compiler instanceof Compiler;return legacyOfflineMode?this.loadFactory(path):this.loadAndCompile(path);};SystemJsNgModuleLoader.prototype.loadAndCompile=function(path){var _this=this;var _a=__read(path.split(_SEPARATOR),2),module=_a[0],exportName=_a[1];if(exportName===undefined){exportName='default';}return System.import(module).then(function(module){return module[exportName];}).then(function(type){return checkNotEmpty(type,module,exportName);}).then(function(type){return _this._compiler.compileModuleAsync(type);});};SystemJsNgModuleLoader.prototype.loadFactory=function(path){var _a=__read(path.split(_SEPARATOR),2),module=_a[0],exportName=_a[1];var factoryClassSuffix=FACTORY_CLASS_SUFFIX;if(exportName===undefined){exportName='default';factoryClassSuffix='';}return System.import(this._config.factoryPathPrefix+module+this._config.factoryPathSuffix).then(function(module){return module[exportName+factoryClassSuffix];}).then(function(factory){return checkNotEmpty(factory,module,exportName);});};SystemJsNgModuleLoader=__decorate([Injectable(),__param(1,Optional()),__metadata("design:paramtypes",[Compiler,SystemJsNgModuleLoaderConfig])],SystemJsNgModuleLoader);return SystemJsNgModuleLoader;}();function checkNotEmpty(value,modulePath,exportName){if(!value){throw new Error("Cannot find '"+exportName+"' in '"+modulePath+"'");}return value;}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * Represents an Angular [view](guide/glossary#view),
	 * specifically the [host view](guide/glossary#view-tree) that is defined by a component.
	 * Also serves as the base class
	 * that adds destroy methods for [embedded views](guide/glossary#view-tree).
	 *
	 * @see `EmbeddedViewRef`
	 *
	 * @publicApi
	 */var ViewRef$1=/** @class */function(_super){__extends(ViewRef,_super);function ViewRef(){return _super!==null&&_super.apply(this,arguments)||this;}return ViewRef;}(ChangeDetectorRef);/**
	 * Represents an Angular [view](guide/glossary#view) in a view container.
	 * An [embedded view](guide/glossary#view-tree) can be referenced from a component
	 * other than the hosting component whose template defines it, or it can be defined
	 * independently by a `TemplateRef`.
	 *
	 * Properties of elements in a view can change, but the structure (number and order) of elements in
	 * a view cannot. Change the structure of elements by inserting, moving, or
	 * removing nested views in a view container.
	 *
	 * @see `ViewContainerRef`
	 *
	 * @usageNotes
	 *
	 * The following template breaks down into two separate `TemplateRef` instances,
	 * an outer one and an inner one.
	 *
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <li *ngFor="let  item of items">{{item}}</li>
	 * </ul>
	 * ```
	 *
	 * This is the outer `TemplateRef`:
	 *
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <ng-template ngFor let-item [ngForOf]="items"></ng-template>
	 * </ul>
	 * ```
	 *
	 * This is the inner `TemplateRef`:
	 *
	 * ```
	 *   <li>{{item}}</li>
	 * ```
	 *
	 * The outer and inner `TemplateRef` instances are assembled into views as follows:
	 *
	 * ```
	 * <!-- ViewRef: outer-0 -->
	 * Count: 2
	 * <ul>
	 *   <ng-template view-container-ref></ng-template>
	 *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
	 *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
	 * </ul>
	 * <!-- /ViewRef: outer-0 -->
	 * ```
	 * @publicApi
	 */var EmbeddedViewRef=/** @class */function(_super){__extends(EmbeddedViewRef,_super);function EmbeddedViewRef(){return _super!==null&&_super.apply(this,arguments)||this;}return EmbeddedViewRef;}(ViewRef$1);/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * @publicApi
	 */var DebugEventListener=/** @class */function(){function DebugEventListener(name,callback){this.name=name;this.callback=callback;}return DebugEventListener;}();var DebugNode__PRE_R3__=/** @class */function(){function DebugNode__PRE_R3__(nativeNode,parent,_debugContext){this.listeners=[];this.parent=null;this._debugContext=_debugContext;this.nativeNode=nativeNode;if(parent&&parent instanceof DebugElement__PRE_R3__){parent.addChild(this);}}Object.defineProperty(DebugNode__PRE_R3__.prototype,"injector",{get:function get(){return this._debugContext.injector;},enumerable:true,configurable:true});Object.defineProperty(DebugNode__PRE_R3__.prototype,"componentInstance",{get:function get(){return this._debugContext.component;},enumerable:true,configurable:true});Object.defineProperty(DebugNode__PRE_R3__.prototype,"context",{get:function get(){return this._debugContext.context;},enumerable:true,configurable:true});Object.defineProperty(DebugNode__PRE_R3__.prototype,"references",{get:function get(){return this._debugContext.references;},enumerable:true,configurable:true});Object.defineProperty(DebugNode__PRE_R3__.prototype,"providerTokens",{get:function get(){return this._debugContext.providerTokens;},enumerable:true,configurable:true});return DebugNode__PRE_R3__;}();var DebugElement__PRE_R3__=/** @class */function(_super){__extends(DebugElement__PRE_R3__,_super);function DebugElement__PRE_R3__(nativeNode,parent,_debugContext){var _this=_super.call(this,nativeNode,parent,_debugContext)||this;_this.properties={};_this.attributes={};_this.classes={};_this.styles={};_this.childNodes=[];_this.nativeElement=nativeNode;return _this;}DebugElement__PRE_R3__.prototype.addChild=function(child){if(child){this.childNodes.push(child);child.parent=this;}};DebugElement__PRE_R3__.prototype.removeChild=function(child){var childIndex=this.childNodes.indexOf(child);if(childIndex!==-1){child.parent=null;this.childNodes.splice(childIndex,1);}};DebugElement__PRE_R3__.prototype.insertChildrenAfter=function(child,newChildren){var _a;var _this=this;var siblingIndex=this.childNodes.indexOf(child);if(siblingIndex!==-1){(_a=this.childNodes).splice.apply(_a,__spread([siblingIndex+1,0],newChildren));newChildren.forEach(function(c){if(c.parent){c.parent.removeChild(c);}child.parent=_this;});}};DebugElement__PRE_R3__.prototype.insertBefore=function(refChild,newChild){var refIndex=this.childNodes.indexOf(refChild);if(refIndex===-1){this.addChild(newChild);}else{if(newChild.parent){newChild.parent.removeChild(newChild);}newChild.parent=this;this.childNodes.splice(refIndex,0,newChild);}};DebugElement__PRE_R3__.prototype.query=function(predicate){var results=this.queryAll(predicate);return results[0]||null;};DebugElement__PRE_R3__.prototype.queryAll=function(predicate){var matches=[];_queryElementChildren(this,predicate,matches);return matches;};DebugElement__PRE_R3__.prototype.queryAllNodes=function(predicate){var matches=[];_queryNodeChildren(this,predicate,matches);return matches;};Object.defineProperty(DebugElement__PRE_R3__.prototype,"children",{get:function get(){return this.childNodes//
	.filter(function(node){return node instanceof DebugElement__PRE_R3__;});},enumerable:true,configurable:true});DebugElement__PRE_R3__.prototype.triggerEventHandler=function(eventName,eventObj){this.listeners.forEach(function(listener){if(listener.name==eventName){listener.callback(eventObj);}});};return DebugElement__PRE_R3__;}(DebugNode__PRE_R3__);function _queryElementChildren(element,predicate,matches){element.childNodes.forEach(function(node){if(node instanceof DebugElement__PRE_R3__){if(predicate(node)){matches.push(node);}_queryElementChildren(node,predicate,matches);}});}function _queryNodeChildren(parentNode,predicate,matches){if(parentNode instanceof DebugElement__PRE_R3__){parentNode.childNodes.forEach(function(node){if(predicate(node)){matches.push(node);}if(node instanceof DebugElement__PRE_R3__){_queryNodeChildren(node,predicate,matches);}});}}var DebugNode__POST_R3__=/** @class */function(){function DebugNode__POST_R3__(nativeNode){this.nativeNode=nativeNode;}Object.defineProperty(DebugNode__POST_R3__.prototype,"parent",{get:function get(){var parent=this.nativeNode.parentNode;return parent?new DebugElement__POST_R3__(parent):null;},enumerable:true,configurable:true});Object.defineProperty(DebugNode__POST_R3__.prototype,"injector",{get:function get(){return getInjector(this.nativeNode);},enumerable:true,configurable:true});Object.defineProperty(DebugNode__POST_R3__.prototype,"componentInstance",{get:function get(){var nativeElement=this.nativeNode;return nativeElement&&(getComponent(nativeElement)||getViewComponent(nativeElement));},enumerable:true,configurable:true});Object.defineProperty(DebugNode__POST_R3__.prototype,"context",{get:function get(){return getComponent(this.nativeNode)||getContext$1(this.nativeNode);},enumerable:true,configurable:true});Object.defineProperty(DebugNode__POST_R3__.prototype,"listeners",{get:function get(){return getListeners(this.nativeNode).filter(isBrowserEvents);},enumerable:true,configurable:true});Object.defineProperty(DebugNode__POST_R3__.prototype,"references",{get:function get(){return getLocalRefs(this.nativeNode);},enumerable:true,configurable:true});Object.defineProperty(DebugNode__POST_R3__.prototype,"providerTokens",{get:function get(){return getInjectionTokens(this.nativeNode);},enumerable:true,configurable:true});return DebugNode__POST_R3__;}();var DebugElement__POST_R3__=/** @class */function(_super){__extends(DebugElement__POST_R3__,_super);function DebugElement__POST_R3__(nativeNode){var _this=this;ngDevMode&&assertDomNode(nativeNode);_this=_super.call(this,nativeNode)||this;return _this;}Object.defineProperty(DebugElement__POST_R3__.prototype,"nativeElement",{get:function get(){return this.nativeNode.nodeType==Node.ELEMENT_NODE?this.nativeNode:null;},enumerable:true,configurable:true});Object.defineProperty(DebugElement__POST_R3__.prototype,"name",{get:function get(){return this.nativeElement.nodeName;},enumerable:true,configurable:true});Object.defineProperty(DebugElement__POST_R3__.prototype,"properties",{/**
	         *  Gets a map of property names to property values for an element.
	         *
	         *  This map includes:
	         *  - Regular property bindings (e.g. `[id]="id"`)
	         *  - Host property bindings (e.g. `host: { '[id]': "id" }`)
	         *  - Interpolated property bindings (e.g. `id="{{ value }}")
	         *
	         *  It does not include:
	         *  - input property bindings (e.g. `[myCustomInput]="value"`)
	         *  - attribute bindings (e.g. `[attr.role]="menu"`)
	         */get:function get(){var context=loadLContext(this.nativeNode);var lView=context.lView;var tData=lView[TVIEW].data;var tNode=tData[context.nodeIndex];var properties=collectPropertyBindings(tNode,lView,tData);var hostProperties=collectHostPropertyBindings(tNode,lView,tData);var className=collectClassNames(this);var output=_assign({},properties,hostProperties);if(className){output['className']=output['className']?output['className']+(" "+className):className;}return output;},enumerable:true,configurable:true});Object.defineProperty(DebugElement__POST_R3__.prototype,"attributes",{get:function get(){var attributes={};var element=this.nativeElement;if(!element){return attributes;}var context=loadLContext(element);var lView=context.lView;var tNodeAttrs=lView[TVIEW].data[context.nodeIndex].attrs;var lowercaseTNodeAttrs=[];// For debug nodes we take the element's attribute directly from the DOM since it allows us
	// to account for ones that weren't set via bindings (e.g. ViewEngine keeps track of the ones
	// that are set through `Renderer2`). The problem is that the browser will lowercase all names,
	// however since we have the attributes already on the TNode, we can preserve the case by going
	// through them once, adding them to the `attributes` map and putting their lower-cased name
	// into an array. Afterwards when we're going through the native DOM attributes, we can check
	// whether we haven't run into an attribute already through the TNode.
	if(tNodeAttrs){var i=0;while(i<tNodeAttrs.length){var attrName=tNodeAttrs[i];// Stop as soon as we hit a marker. We only care about the regular attributes. Everything
	// else will be handled below when we read the final attributes off the DOM.
	if(typeof attrName!=='string')break;var attrValue=tNodeAttrs[i+1];attributes[attrName]=attrValue;lowercaseTNodeAttrs.push(attrName.toLowerCase());i+=2;}}var eAttrs=element.attributes;for(var i=0;i<eAttrs.length;i++){var attr=eAttrs[i];// Make sure that we don't assign the same attribute both in its
	// case-sensitive form and the lower-cased one from the browser.
	if(lowercaseTNodeAttrs.indexOf(attr.name)===-1){attributes[attr.name]=attr.value;}}return attributes;},enumerable:true,configurable:true});Object.defineProperty(DebugElement__POST_R3__.prototype,"styles",{get:function get(){return _getStylingDebugInfo(this.nativeElement,false);},enumerable:true,configurable:true});Object.defineProperty(DebugElement__POST_R3__.prototype,"classes",{get:function get(){return _getStylingDebugInfo(this.nativeElement,true);},enumerable:true,configurable:true});Object.defineProperty(DebugElement__POST_R3__.prototype,"childNodes",{get:function get(){var childNodes=this.nativeNode.childNodes;var children=[];for(var i=0;i<childNodes.length;i++){var element=childNodes[i];children.push(getDebugNode__POST_R3__(element));}return children;},enumerable:true,configurable:true});Object.defineProperty(DebugElement__POST_R3__.prototype,"children",{get:function get(){var nativeElement=this.nativeElement;if(!nativeElement)return [];var childNodes=nativeElement.children;var children=[];for(var i=0;i<childNodes.length;i++){var element=childNodes[i];children.push(getDebugNode__POST_R3__(element));}return children;},enumerable:true,configurable:true});DebugElement__POST_R3__.prototype.query=function(predicate){var results=this.queryAll(predicate);return results[0]||null;};DebugElement__POST_R3__.prototype.queryAll=function(predicate){var matches=[];_queryAllR3(this,predicate,matches,true);return matches;};DebugElement__POST_R3__.prototype.queryAllNodes=function(predicate){var matches=[];_queryAllR3(this,predicate,matches,false);return matches;};DebugElement__POST_R3__.prototype.triggerEventHandler=function(eventName,eventObj){this.listeners.forEach(function(listener){if(listener.name===eventName){listener.callback(eventObj);}});};return DebugElement__POST_R3__;}(DebugNode__POST_R3__);function _getStylingDebugInfo(element,isClassBased){if(element){var context=loadLContextFromNode(element);var lView=context.lView;var tData=lView[TVIEW].data;var tNode=tData[context.nodeIndex];if(isClassBased){return isStylingContext(tNode.classes)?new NodeStylingDebug(tNode.classes,lView,true).values:stylingMapToStringMap(tNode.classes);}else{return isStylingContext(tNode.styles)?new NodeStylingDebug(tNode.styles,lView,false).values:stylingMapToStringMap(tNode.styles);}}return {};}function _queryAllR3(parentElement,predicate,matches,elementsOnly){var context=loadLContext(parentElement.nativeNode);var parentTNode=context.lView[TVIEW].data[context.nodeIndex];_queryNodeChildrenR3(parentTNode,context.lView,predicate,matches,elementsOnly,parentElement.nativeNode);}/**
	 * Recursively match the current TNode against the predicate, and goes on with the next ones.
	 *
	 * @param tNode the current TNode
	 * @param lView the LView of this TNode
	 * @param predicate the predicate to match
	 * @param matches the list of positive matches
	 * @param elementsOnly whether only elements should be searched
	 * @param rootNativeNode the root native node on which predicate should not be matched
	 */function _queryNodeChildrenR3(tNode,lView,predicate,matches,elementsOnly,rootNativeNode){var e_1,_a;var nativeNode=getNativeByTNodeOrNull(tNode,lView);// For each type of TNode, specific logic is executed.
	if(tNode.type===3/* Element */||tNode.type===4/* ElementContainer */){// Case 1: the TNode is an element
	// The native node has to be checked.
	_addQueryMatchR3(nativeNode,predicate,matches,elementsOnly,rootNativeNode);if(isComponent(tNode)){// If the element is the host of a component, then all nodes in its view have to be processed.
	// Note: the component's content (tNode.child) will be processed from the insertion points.
	var componentView=getComponentViewByIndex(tNode.index,lView);if(componentView&&componentView[TVIEW].firstChild){_queryNodeChildrenR3(componentView[TVIEW].firstChild,componentView,predicate,matches,elementsOnly,rootNativeNode);}}else{if(tNode.child){// Otherwise, its children have to be processed.
	_queryNodeChildrenR3(tNode.child,lView,predicate,matches,elementsOnly,rootNativeNode);}// We also have to query the DOM directly in order to catch elements inserted through
	// Renderer2. Note that this is __not__ optimal, because we're walking similar trees multiple
	// times. ViewEngine could do it more efficiently, because all the insertions go through
	// Renderer2, however that's not the case in Ivy. This approach is being used because:
	// 1. Matching the ViewEngine behavior would mean potentially introducing a depedency
	//    from `Renderer2` to Ivy which could bring Ivy code into ViewEngine.
	// 2. We would have to make `Renderer3` "know" about debug nodes.
	// 3. It allows us to capture nodes that were inserted directly via the DOM.
	nativeNode&&_queryNativeNodeDescendants(nativeNode,predicate,matches,elementsOnly);}// In all cases, if a dynamic container exists for this node, each view inside it has to be
	// processed.
	var nodeOrContainer=lView[tNode.index];if(isLContainer(nodeOrContainer)){_queryNodeChildrenInContainerR3(nodeOrContainer,predicate,matches,elementsOnly,rootNativeNode);}}else if(tNode.type===0/* Container */){// Case 2: the TNode is a container
	// The native node has to be checked.
	var lContainer=lView[tNode.index];_addQueryMatchR3(lContainer[NATIVE],predicate,matches,elementsOnly,rootNativeNode);// Each view inside the container has to be processed.
	_queryNodeChildrenInContainerR3(lContainer,predicate,matches,elementsOnly,rootNativeNode);}else if(tNode.type===1/* Projection */){// Case 3: the TNode is a projection insertion point (i.e. a <ng-content>).
	// The nodes projected at this location all need to be processed.
	var componentView=findComponentView(lView);var componentHost=componentView[T_HOST];var head=componentHost.projection[tNode.projection];if(Array.isArray(head)){try{for(var head_1=__values(head),head_1_1=head_1.next();!head_1_1.done;head_1_1=head_1.next()){var nativeNode_1=head_1_1.value;_addQueryMatchR3(nativeNode_1,predicate,matches,elementsOnly,rootNativeNode);}}catch(e_1_1){e_1={error:e_1_1};}finally{try{if(head_1_1&&!head_1_1.done&&(_a=head_1.return))_a.call(head_1);}finally{if(e_1)throw e_1.error;}}}else if(head){var nextLView=componentView[PARENT];var nextTNode=nextLView[TVIEW].data[head.index];_queryNodeChildrenR3(nextTNode,nextLView,predicate,matches,elementsOnly,rootNativeNode);}}else if(tNode.child){// Case 4: the TNode is a view.
	_queryNodeChildrenR3(tNode.child,lView,predicate,matches,elementsOnly,rootNativeNode);}// We don't want to go to the next sibling of the root node.
	if(rootNativeNode!==nativeNode){// To determine the next node to be processed, we need to use the next or the projectionNext
	// link, depending on whether the current node has been projected.
	var nextTNode=tNode.flags&2/* isProjected */?tNode.projectionNext:tNode.next;if(nextTNode){_queryNodeChildrenR3(nextTNode,lView,predicate,matches,elementsOnly,rootNativeNode);}}}/**
	 * Process all TNodes in a given container.
	 *
	 * @param lContainer the container to be processed
	 * @param predicate the predicate to match
	 * @param matches the list of positive matches
	 * @param elementsOnly whether only elements should be searched
	 * @param rootNativeNode the root native node on which predicate should not be matched
	 */function _queryNodeChildrenInContainerR3(lContainer,predicate,matches,elementsOnly,rootNativeNode){for(var i=CONTAINER_HEADER_OFFSET;i<lContainer.length;i++){var childView=lContainer[i];_queryNodeChildrenR3(childView[TVIEW].node,childView,predicate,matches,elementsOnly,rootNativeNode);}}/**
	 * Match the current native node against the predicate.
	 *
	 * @param nativeNode the current native node
	 * @param predicate the predicate to match
	 * @param matches the list of positive matches
	 * @param elementsOnly whether only elements should be searched
	 * @param rootNativeNode the root native node on which predicate should not be matched
	 */function _addQueryMatchR3(nativeNode,predicate,matches,elementsOnly,rootNativeNode){if(rootNativeNode!==nativeNode){var debugNode=getDebugNode(nativeNode);if(!debugNode){return;}// Type of the "predicate and "matches" array are set based on the value of
	// the "elementsOnly" parameter. TypeScript is not able to properly infer these
	// types with generics, so we manually cast the parameters accordingly.
	if(elementsOnly&&debugNode instanceof DebugElement__POST_R3__&&predicate(debugNode)&&matches.indexOf(debugNode)===-1){matches.push(debugNode);}else if(!elementsOnly&&predicate(debugNode)&&matches.indexOf(debugNode)===-1){matches.push(debugNode);}}}/**
	 * Match all the descendants of a DOM node against a predicate.
	 *
	 * @param nativeNode the current native node
	 * @param predicate the predicate to match
	 * @param matches the list of positive matches
	 * @param elementsOnly whether only elements should be searched
	 */function _queryNativeNodeDescendants(parentNode,predicate,matches,elementsOnly){var nodes=parentNode.childNodes;var length=nodes.length;for(var i=0;i<length;i++){var node=nodes[i];var debugNode=getDebugNode(node);if(debugNode){if(elementsOnly&&debugNode instanceof DebugElement__POST_R3__&&predicate(debugNode)&&matches.indexOf(debugNode)===-1){matches.push(debugNode);}else if(!elementsOnly&&predicate(debugNode)&&matches.indexOf(debugNode)===-1){matches.push(debugNode);}_queryNativeNodeDescendants(node,predicate,matches,elementsOnly);}}}/**
	 * Iterates through the property bindings for a given node and generates
	 * a map of property names to values. This map only contains property bindings
	 * defined in templates, not in host bindings.
	 */function collectPropertyBindings(tNode,lView,tData){var properties={};var bindingIndex=getFirstBindingIndex(tNode.propertyMetadataStartIndex,tData);while(bindingIndex<tNode.propertyMetadataEndIndex){var value=void 0;var propMetadata=tData[bindingIndex];while(!isPropMetadataString(propMetadata)){// This is the first value for an interpolation. We need to build up
	// the full interpolation by combining runtime values in LView with
	// the static interstitial values stored in TData.
	value=(value||'')+renderStringify(lView[bindingIndex])+tData[bindingIndex];propMetadata=tData[++bindingIndex];}value=value===undefined?lView[bindingIndex]:value+=lView[bindingIndex];// Property metadata string has 3 parts: property name, prefix, and suffix
	var metadataParts=propMetadata.split(INTERPOLATION_DELIMITER);var propertyName=metadataParts[0];// Attr bindings don't have property names and should be skipped
	if(propertyName){// Wrap value with prefix and suffix (will be '' for normal bindings), if they're defined.
	// Avoid wrapping for normal bindings so that the value doesn't get cast to a string.
	properties[propertyName]=metadataParts[1]&&metadataParts[2]?metadataParts[1]+value+metadataParts[2]:value;}bindingIndex++;}return properties;}/**
	 * Retrieves the first binding index that holds values for this property
	 * binding.
	 *
	 * For normal bindings (e.g. `[id]="id"`), the binding index is the
	 * same as the metadata index. For interpolations (e.g. `id="{{id}}-{{name}}"`),
	 * there can be multiple binding values, so we might have to loop backwards
	 * from the metadata index until we find the first one.
	 *
	 * @param metadataIndex The index of the first property metadata string for
	 * this node.
	 * @param tData The data array for the current TView
	 * @returns The first binding index for this binding
	 */function getFirstBindingIndex(metadataIndex,tData){var currentBindingIndex=metadataIndex-1;// If the slot before the metadata holds a string, we know that this
	// metadata applies to an interpolation with at least 2 bindings, and
	// we need to search further to access the first binding value.
	var currentValue=tData[currentBindingIndex];// We need to iterate until we hit either a:
	// - TNode (it is an element slot marking the end of `consts` section), OR a
	// - metadata string (slot is attribute metadata or a previous node's property metadata)
	while(typeof currentValue==='string'&&!isPropMetadataString(currentValue)){currentValue=tData[--currentBindingIndex];}return currentBindingIndex+1;}function collectHostPropertyBindings(tNode,lView,tData){var properties={};// Host binding values for a node are stored after directives on that node
	var hostPropIndex=tNode.directiveEnd;var propMetadata=tData[hostPropIndex];// When we reach a value in TView.data that is not a string, we know we've
	// hit the next node's providers and directives and should stop copying data.
	while(typeof propMetadata==='string'){var propertyName=propMetadata.split(INTERPOLATION_DELIMITER)[0];properties[propertyName]=lView[hostPropIndex];propMetadata=tData[++hostPropIndex];}return properties;}function collectClassNames(debugElement){var e_2,_a;var classes=debugElement.classes;var output='';try{for(var _b=__values(Object.keys(classes)),_c=_b.next();!_c.done;_c=_b.next()){var className=_c.value;if(classes[className]){output=output?output+(" "+className):className;}}}catch(e_2_1){e_2={error:e_2_1};}finally{try{if(_c&&!_c.done&&(_a=_b.return))_a.call(_b);}finally{if(e_2)throw e_2.error;}}return output;}// Need to keep the nodes in a global Map so that multiple angular apps are supported.
	var _nativeNodeToDebugNode=new Map();function getDebugNode__PRE_R3__(nativeNode){return _nativeNodeToDebugNode.get(nativeNode)||null;}var NG_DEBUG_PROPERTY='__ng_debug__';function getDebugNode__POST_R3__(nativeNode){if(nativeNode instanceof Node){if(!nativeNode.hasOwnProperty(NG_DEBUG_PROPERTY)){nativeNode[NG_DEBUG_PROPERTY]=nativeNode.nodeType==Node.ELEMENT_NODE?new DebugElement__POST_R3__(nativeNode):new DebugNode__POST_R3__(nativeNode);}return nativeNode[NG_DEBUG_PROPERTY];}return null;}/**
	 * @publicApi
	 */var getDebugNode=getDebugNode__PRE_R3__;function indexDebugNode(node){_nativeNodeToDebugNode.set(node.nativeNode,node);}function removeDebugNodeFromIndex(node){_nativeNodeToDebugNode.delete(node.nativeNode);}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var _CORE_PLATFORM_PROVIDERS=[// Set a default platform name for platforms that don't set it explicitly.
	{provide:PLATFORM_ID,useValue:'unknown'},{provide:PlatformRef,deps:[Injector]},{provide:TestabilityRegistry,deps:[]},{provide:Console,deps:[]}];/**
	 * This platform has to be included in any other platform
	 *
	 * @publicApi
	 */var platformCore=createPlatformFactory(null,'core',_CORE_PLATFORM_PROVIDERS);/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */function _iterableDiffersFactory(){return defaultIterableDiffers;}function _keyValueDiffersFactory(){return defaultKeyValueDiffers;}function _localeFactory(locale){if(locale){return locale;}// Use `goog.LOCALE` as default value for `LOCALE_ID` token for Closure Compiler.
	// Note: default `goog.LOCALE` value is `en`, when Angular used `en-US`. In order to preserve
	// backwards compatibility, we use Angular default value over Closure Compiler's one.
	if(ngI18nClosureMode&&typeof goog!=='undefined'&&goog.LOCALE!=='en'){return goog.LOCALE;}return DEFAULT_LOCALE_ID;}/**
	 * A built-in [dependency injection token](guide/glossary#di-token)
	 * that is used to configure the root injector for bootstrapping.
	 */var APPLICATION_MODULE_PROVIDERS=[{provide:ApplicationRef,useClass:ApplicationRef,deps:[NgZone,Console,Injector,ErrorHandler,ComponentFactoryResolver,ApplicationInitStatus]},{provide:SCHEDULER,deps:[NgZone],useFactory:zoneSchedulerFactory},{provide:ApplicationInitStatus,useClass:ApplicationInitStatus,deps:[[new Optional(),APP_INITIALIZER]]},{provide:Compiler,useClass:Compiler,deps:[]},APP_ID_RANDOM_PROVIDER,{provide:IterableDiffers,useFactory:_iterableDiffersFactory,deps:[]},{provide:KeyValueDiffers,useFactory:_keyValueDiffersFactory,deps:[]},{provide:LOCALE_ID$1,useFactory:_localeFactory,deps:[[new Inject(LOCALE_ID$1),new Optional(),new SkipSelf()]]}];/**
	 * Schedule work at next available slot.
	 *
	 * In Ivy this is just `requestAnimationFrame`. For compatibility reasons when bootstrapped
	 * using `platformRef.bootstrap` we need to use `NgZone.onStable` as the scheduling mechanism.
	 * This overrides the scheduling mechanism in Ivy to `NgZone.onStable`.
	 *
	 * @param ngZone NgZone to use for scheduling.
	 */function zoneSchedulerFactory(ngZone){var queue=[];ngZone.onStable.subscribe(function(){while(queue.length){queue.pop()();}});return function(fn){queue.push(fn);};}/**
	 * Configures the root injector for an app with
	 * providers of `@angular/core` dependencies that `ApplicationRef` needs
	 * to bootstrap components.
	 *
	 * Re-exported by `BrowserModule`, which is included automatically in the root
	 * `AppModule` when you create a new app with the CLI `new` command.
	 *
	 * @publicApi
	 */var ApplicationModule=/** @class */function(){// Inject ApplicationRef to make it eager...
	function ApplicationModule(appRef){}ApplicationModule=__decorate([NgModule({providers:APPLICATION_MODULE_PROVIDERS}),__metadata("design:paramtypes",[ApplicationRef])],ApplicationModule);return ApplicationModule;}();function createElement(view,renderHost,def){var elDef=def.element;var rootSelectorOrNode=view.root.selectorOrNode;var renderer=view.renderer;var el;if(view.parent||!rootSelectorOrNode){if(elDef.name){el=renderer.createElement(elDef.name,elDef.ns);}else{el=renderer.createComment('');}var parentEl=getParentRenderElement(view,renderHost,def);if(parentEl){renderer.appendChild(parentEl,el);}}else{// when using native Shadow DOM, do not clear the root element contents to allow slot projection
	var preserveContent=!!elDef.componentRendererType&&elDef.componentRendererType.encapsulation===ViewEncapsulation.ShadowDom;el=renderer.selectRootElement(rootSelectorOrNode,preserveContent);}if(elDef.attrs){for(var i=0;i<elDef.attrs.length;i++){var _a=__read(elDef.attrs[i],3),ns=_a[0],name_2=_a[1],value=_a[2];renderer.setAttribute(el,name_2,value,ns);}}return el;}function listenToElementOutputs(view,compView,def,el){for(var i=0;i<def.outputs.length;i++){var output=def.outputs[i];var handleEventClosure=renderEventHandlerClosure(view,def.nodeIndex,elementEventFullName(output.target,output.eventName));var listenTarget=output.target;var listenerView=view;if(output.target==='component'){listenTarget=null;listenerView=compView;}var disposable=listenerView.renderer.listen(listenTarget||el,output.eventName,handleEventClosure);view.disposables[def.outputIndex+i]=disposable;}}function renderEventHandlerClosure(view,index,eventName){return function(event){return dispatchEvent(view,index,eventName,event);};}function checkAndUpdateElementInline(view,def,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9){var bindLen=def.bindings.length;var changed=false;if(bindLen>0&&checkAndUpdateElementValue(view,def,0,v0))changed=true;if(bindLen>1&&checkAndUpdateElementValue(view,def,1,v1))changed=true;if(bindLen>2&&checkAndUpdateElementValue(view,def,2,v2))changed=true;if(bindLen>3&&checkAndUpdateElementValue(view,def,3,v3))changed=true;if(bindLen>4&&checkAndUpdateElementValue(view,def,4,v4))changed=true;if(bindLen>5&&checkAndUpdateElementValue(view,def,5,v5))changed=true;if(bindLen>6&&checkAndUpdateElementValue(view,def,6,v6))changed=true;if(bindLen>7&&checkAndUpdateElementValue(view,def,7,v7))changed=true;if(bindLen>8&&checkAndUpdateElementValue(view,def,8,v8))changed=true;if(bindLen>9&&checkAndUpdateElementValue(view,def,9,v9))changed=true;return changed;}function checkAndUpdateElementDynamic(view,def,values){var changed=false;for(var i=0;i<values.length;i++){if(checkAndUpdateElementValue(view,def,i,values[i]))changed=true;}return changed;}function checkAndUpdateElementValue(view,def,bindingIdx,value){if(!checkAndUpdateBinding(view,def,bindingIdx,value)){return false;}var binding=def.bindings[bindingIdx];var elData=asElementData(view,def.nodeIndex);var renderNode=elData.renderElement;var name=binding.name;switch(binding.flags&15/* Types */){case 1/* TypeElementAttribute */:setElementAttribute(view,binding,renderNode,binding.ns,name,value);break;case 2/* TypeElementClass */:setElementClass(view,renderNode,name,value);break;case 4/* TypeElementStyle */:setElementStyle(view,binding,renderNode,name,value);break;case 8/* TypeProperty */:var bindView=def.flags&33554432/* ComponentView */&&binding.flags&32/* SyntheticHostProperty */?elData.componentView:view;setElementProperty(bindView,binding,renderNode,name,value);break;}return true;}function setElementAttribute(view,binding,renderNode,ns,name,value){var securityContext=binding.securityContext;var renderValue=securityContext?view.root.sanitizer.sanitize(securityContext,value):value;renderValue=renderValue!=null?renderValue.toString():null;var renderer=view.renderer;if(value!=null){renderer.setAttribute(renderNode,name,renderValue,ns);}else{renderer.removeAttribute(renderNode,name,ns);}}function setElementClass(view,renderNode,name,value){var renderer=view.renderer;if(value){renderer.addClass(renderNode,name);}else{renderer.removeClass(renderNode,name);}}function setElementStyle(view,binding,renderNode,name,value){var renderValue=view.root.sanitizer.sanitize(SecurityContext.STYLE,value);if(renderValue!=null){renderValue=renderValue.toString();var unit=binding.suffix;if(unit!=null){renderValue=renderValue+unit;}}else{renderValue=null;}var renderer=view.renderer;if(renderValue!=null){renderer.setStyle(renderNode,name,renderValue);}else{renderer.removeStyle(renderNode,name);}}function setElementProperty(view,binding,renderNode,name,value){var securityContext=binding.securityContext;var renderValue=securityContext?view.root.sanitizer.sanitize(securityContext,value):value;view.renderer.setProperty(renderNode,name,renderValue);}function createQuery(){return new QueryList();}function dirtyParentQueries(view){var queryIds=view.def.nodeMatchedQueries;while(view.parent&&isEmbeddedView(view)){var tplDef=view.parentNodeDef;view=view.parent;// content queries
	var end=tplDef.nodeIndex+tplDef.childCount;for(var i=0;i<=end;i++){var nodeDef=view.def.nodes[i];if(nodeDef.flags&67108864/* TypeContentQuery */&&nodeDef.flags&536870912/* DynamicQuery */&&(nodeDef.query.filterId&queryIds)===nodeDef.query.filterId){asQueryList(view,i).setDirty();}if(nodeDef.flags&1/* TypeElement */&&i+nodeDef.childCount<tplDef.nodeIndex||!(nodeDef.childFlags&67108864/* TypeContentQuery */)||!(nodeDef.childFlags&536870912/* DynamicQuery */)){// skip elements that don't contain the template element or no query.
	i+=nodeDef.childCount;}}}// view queries
	if(view.def.nodeFlags&134217728/* TypeViewQuery */){for(var i=0;i<view.def.nodes.length;i++){var nodeDef=view.def.nodes[i];if(nodeDef.flags&134217728/* TypeViewQuery */&&nodeDef.flags&536870912/* DynamicQuery */){asQueryList(view,i).setDirty();}// only visit the root nodes
	i+=nodeDef.childCount;}}}function checkAndUpdateQuery(view,nodeDef){var queryList=asQueryList(view,nodeDef.nodeIndex);if(!queryList.dirty){return;}var directiveInstance;var newValues=undefined;if(nodeDef.flags&67108864/* TypeContentQuery */){var elementDef=nodeDef.parent.parent;newValues=calcQueryValues(view,elementDef.nodeIndex,elementDef.nodeIndex+elementDef.childCount,nodeDef.query,[]);directiveInstance=asProviderData(view,nodeDef.parent.nodeIndex).instance;}else if(nodeDef.flags&134217728/* TypeViewQuery */){newValues=calcQueryValues(view,0,view.def.nodes.length-1,nodeDef.query,[]);directiveInstance=view.component;}queryList.reset(newValues);var bindings=nodeDef.query.bindings;var notify=false;for(var i=0;i<bindings.length;i++){var binding=bindings[i];var boundValue=void 0;switch(binding.bindingType){case 0/* First */:boundValue=queryList.first;break;case 1/* All */:boundValue=queryList;notify=true;break;}directiveInstance[binding.propName]=boundValue;}if(notify){queryList.notifyOnChanges();}}function calcQueryValues(view,startIndex,endIndex,queryDef,values){for(var i=startIndex;i<=endIndex;i++){var nodeDef=view.def.nodes[i];var valueType=nodeDef.matchedQueries[queryDef.id];if(valueType!=null){values.push(getQueryValue(view,nodeDef,valueType));}if(nodeDef.flags&1/* TypeElement */&&nodeDef.element.template&&(nodeDef.element.template.nodeMatchedQueries&queryDef.filterId)===queryDef.filterId){var elementData=asElementData(view,i);// check embedded views that were attached at the place of their template,
	// but process child nodes first if some match the query (see issue #16568)
	if((nodeDef.childMatchedQueries&queryDef.filterId)===queryDef.filterId){calcQueryValues(view,i+1,i+nodeDef.childCount,queryDef,values);i+=nodeDef.childCount;}if(nodeDef.flags&16777216/* EmbeddedViews */){var embeddedViews=elementData.viewContainer._embeddedViews;for(var k=0;k<embeddedViews.length;k++){var embeddedView=embeddedViews[k];var dvc=declaredViewContainer(embeddedView);if(dvc&&dvc===elementData){calcQueryValues(embeddedView,0,embeddedView.def.nodes.length-1,queryDef,values);}}}var projectedViews=elementData.template._projectedViews;if(projectedViews){for(var k=0;k<projectedViews.length;k++){var projectedView=projectedViews[k];calcQueryValues(projectedView,0,projectedView.def.nodes.length-1,queryDef,values);}}}if((nodeDef.childMatchedQueries&queryDef.filterId)!==queryDef.filterId){// if no child matches the query, skip the children.
	i+=nodeDef.childCount;}}return values;}function getQueryValue(view,nodeDef,queryValueType){if(queryValueType!=null){// a match
	switch(queryValueType){case 1/* RenderElement */:return asElementData(view,nodeDef.nodeIndex).renderElement;case 0/* ElementRef */:return new ElementRef(asElementData(view,nodeDef.nodeIndex).renderElement);case 2/* TemplateRef */:return asElementData(view,nodeDef.nodeIndex).template;case 3/* ViewContainerRef */:return asElementData(view,nodeDef.nodeIndex).viewContainer;case 4/* Provider */:return asProviderData(view,nodeDef.nodeIndex).instance;}}}function appendNgContent(view,renderHost,def){var parentEl=getParentRenderElement(view,renderHost,def);if(!parentEl){// Nothing to do if there is no parent element.
	return;}var ngContentIndex=def.ngContent.index;visitProjectedRenderNodes(view,ngContentIndex,1/* AppendChild */,parentEl,null,undefined);}function createPureExpression(view,def){return {value:undefined};}function checkAndUpdatePureExpressionInline(view,def,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9){var bindings=def.bindings;var changed=false;var bindLen=bindings.length;if(bindLen>0&&checkAndUpdateBinding(view,def,0,v0))changed=true;if(bindLen>1&&checkAndUpdateBinding(view,def,1,v1))changed=true;if(bindLen>2&&checkAndUpdateBinding(view,def,2,v2))changed=true;if(bindLen>3&&checkAndUpdateBinding(view,def,3,v3))changed=true;if(bindLen>4&&checkAndUpdateBinding(view,def,4,v4))changed=true;if(bindLen>5&&checkAndUpdateBinding(view,def,5,v5))changed=true;if(bindLen>6&&checkAndUpdateBinding(view,def,6,v6))changed=true;if(bindLen>7&&checkAndUpdateBinding(view,def,7,v7))changed=true;if(bindLen>8&&checkAndUpdateBinding(view,def,8,v8))changed=true;if(bindLen>9&&checkAndUpdateBinding(view,def,9,v9))changed=true;if(changed){var data=asPureExpressionData(view,def.nodeIndex);var value=void 0;switch(def.flags&201347067/* Types */){case 32/* TypePureArray */:value=new Array(bindings.length);if(bindLen>0)value[0]=v0;if(bindLen>1)value[1]=v1;if(bindLen>2)value[2]=v2;if(bindLen>3)value[3]=v3;if(bindLen>4)value[4]=v4;if(bindLen>5)value[5]=v5;if(bindLen>6)value[6]=v6;if(bindLen>7)value[7]=v7;if(bindLen>8)value[8]=v8;if(bindLen>9)value[9]=v9;break;case 64/* TypePureObject */:value={};if(bindLen>0)value[bindings[0].name]=v0;if(bindLen>1)value[bindings[1].name]=v1;if(bindLen>2)value[bindings[2].name]=v2;if(bindLen>3)value[bindings[3].name]=v3;if(bindLen>4)value[bindings[4].name]=v4;if(bindLen>5)value[bindings[5].name]=v5;if(bindLen>6)value[bindings[6].name]=v6;if(bindLen>7)value[bindings[7].name]=v7;if(bindLen>8)value[bindings[8].name]=v8;if(bindLen>9)value[bindings[9].name]=v9;break;case 128/* TypePurePipe */:var pipe$$1=v0;switch(bindLen){case 1:value=pipe$$1.transform(v0);break;case 2:value=pipe$$1.transform(v1);break;case 3:value=pipe$$1.transform(v1,v2);break;case 4:value=pipe$$1.transform(v1,v2,v3);break;case 5:value=pipe$$1.transform(v1,v2,v3,v4);break;case 6:value=pipe$$1.transform(v1,v2,v3,v4,v5);break;case 7:value=pipe$$1.transform(v1,v2,v3,v4,v5,v6);break;case 8:value=pipe$$1.transform(v1,v2,v3,v4,v5,v6,v7);break;case 9:value=pipe$$1.transform(v1,v2,v3,v4,v5,v6,v7,v8);break;case 10:value=pipe$$1.transform(v1,v2,v3,v4,v5,v6,v7,v8,v9);break;}break;}data.value=value;}return changed;}function checkAndUpdatePureExpressionDynamic(view,def,values){var bindings=def.bindings;var changed=false;for(var i=0;i<values.length;i++){// Note: We need to loop over all values, so that
	// the old values are updates as well!
	if(checkAndUpdateBinding(view,def,i,values[i])){changed=true;}}if(changed){var data=asPureExpressionData(view,def.nodeIndex);var value=void 0;switch(def.flags&201347067/* Types */){case 32/* TypePureArray */:value=values;break;case 64/* TypePureObject */:value={};for(var i=0;i<values.length;i++){value[bindings[i].name]=values[i];}break;case 128/* TypePurePipe */:var pipe$$1=values[0];var params=values.slice(1);value=pipe$$1.transform.apply(pipe$$1,__spread(params));break;}data.value=value;}return changed;}function createText(view,renderHost,def){var renderNode;var renderer=view.renderer;renderNode=renderer.createText(def.text.prefix);var parentEl=getParentRenderElement(view,renderHost,def);if(parentEl){renderer.appendChild(parentEl,renderNode);}return {renderText:renderNode};}function checkAndUpdateTextInline(view,def,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9){var changed=false;var bindings=def.bindings;var bindLen=bindings.length;if(bindLen>0&&checkAndUpdateBinding(view,def,0,v0))changed=true;if(bindLen>1&&checkAndUpdateBinding(view,def,1,v1))changed=true;if(bindLen>2&&checkAndUpdateBinding(view,def,2,v2))changed=true;if(bindLen>3&&checkAndUpdateBinding(view,def,3,v3))changed=true;if(bindLen>4&&checkAndUpdateBinding(view,def,4,v4))changed=true;if(bindLen>5&&checkAndUpdateBinding(view,def,5,v5))changed=true;if(bindLen>6&&checkAndUpdateBinding(view,def,6,v6))changed=true;if(bindLen>7&&checkAndUpdateBinding(view,def,7,v7))changed=true;if(bindLen>8&&checkAndUpdateBinding(view,def,8,v8))changed=true;if(bindLen>9&&checkAndUpdateBinding(view,def,9,v9))changed=true;if(changed){var value=def.text.prefix;if(bindLen>0)value+=_addInterpolationPart(v0,bindings[0]);if(bindLen>1)value+=_addInterpolationPart(v1,bindings[1]);if(bindLen>2)value+=_addInterpolationPart(v2,bindings[2]);if(bindLen>3)value+=_addInterpolationPart(v3,bindings[3]);if(bindLen>4)value+=_addInterpolationPart(v4,bindings[4]);if(bindLen>5)value+=_addInterpolationPart(v5,bindings[5]);if(bindLen>6)value+=_addInterpolationPart(v6,bindings[6]);if(bindLen>7)value+=_addInterpolationPart(v7,bindings[7]);if(bindLen>8)value+=_addInterpolationPart(v8,bindings[8]);if(bindLen>9)value+=_addInterpolationPart(v9,bindings[9]);var renderNode=asTextData(view,def.nodeIndex).renderText;view.renderer.setValue(renderNode,value);}return changed;}function checkAndUpdateTextDynamic(view,def,values){var bindings=def.bindings;var changed=false;for(var i=0;i<values.length;i++){// Note: We need to loop over all values, so that
	// the old values are updates as well!
	if(checkAndUpdateBinding(view,def,i,values[i])){changed=true;}}if(changed){var value='';for(var i=0;i<values.length;i++){value=value+_addInterpolationPart(values[i],bindings[i]);}value=def.text.prefix+value;var renderNode=asTextData(view,def.nodeIndex).renderText;view.renderer.setValue(renderNode,value);}return changed;}function _addInterpolationPart(value,binding){var valueStr=value!=null?value.toString():'';return valueStr+binding.suffix;}function createEmbeddedView(parent,anchorDef,viewDef,context){// embedded views are seen as siblings to the anchor, so we need
	// to get the parent of the anchor and use it as parentIndex.
	var view=createView(parent.root,parent.renderer,parent,anchorDef,viewDef);initView(view,parent.component,context);createViewNodes(view);return view;}function createRootView(root,def,context){var view=createView(root,root.renderer,null,null,def);initView(view,context,context);createViewNodes(view);return view;}function createComponentView(parentView,nodeDef,viewDef,hostElement){var rendererType=nodeDef.element.componentRendererType;var compRenderer;if(!rendererType){compRenderer=parentView.root.renderer;}else{compRenderer=parentView.root.rendererFactory.createRenderer(hostElement,rendererType);}return createView(parentView.root,compRenderer,parentView,nodeDef.element.componentProvider,viewDef);}function createView(root,renderer,parent,parentNodeDef,def){var nodes=new Array(def.nodes.length);var disposables=def.outputCount?new Array(def.outputCount):null;var view={def:def,parent:parent,viewContainerParent:null,parentNodeDef:parentNodeDef,context:null,component:null,nodes:nodes,state:13/* CatInit */,root:root,renderer:renderer,oldValues:new Array(def.bindingCount),disposables:disposables,initIndex:-1};return view;}function initView(view,component,context){view.component=component;view.context=context;}function createViewNodes(view){var renderHost;if(isComponentView(view)){var hostDef=view.parentNodeDef;renderHost=asElementData(view.parent,hostDef.parent.nodeIndex).renderElement;}var def=view.def;var nodes=view.nodes;for(var i=0;i<def.nodes.length;i++){var nodeDef=def.nodes[i];Services.setCurrentNode(view,i);var nodeData=void 0;switch(nodeDef.flags&201347067/* Types */){case 1/* TypeElement */:var el=createElement(view,renderHost,nodeDef);var componentView=undefined;if(nodeDef.flags&33554432/* ComponentView */){var compViewDef=resolveDefinition(nodeDef.element.componentView);componentView=Services.createComponentView(view,nodeDef,compViewDef,el);}listenToElementOutputs(view,componentView,nodeDef,el);nodeData={renderElement:el,componentView:componentView,viewContainer:null,template:nodeDef.element.template?createTemplateData(view,nodeDef):undefined};if(nodeDef.flags&16777216/* EmbeddedViews */){nodeData.viewContainer=createViewContainerData(view,nodeDef,nodeData);}break;case 2/* TypeText */:nodeData=createText(view,renderHost,nodeDef);break;case 512/* TypeClassProvider */:case 1024/* TypeFactoryProvider */:case 2048/* TypeUseExistingProvider */:case 256/* TypeValueProvider */:{nodeData=nodes[i];if(!nodeData&&!(nodeDef.flags&4096/* LazyProvider */)){var instance=createProviderInstance(view,nodeDef);nodeData={instance:instance};}break;}case 16/* TypePipe */:{var instance=createPipeInstance(view,nodeDef);nodeData={instance:instance};break;}case 16384/* TypeDirective */:{nodeData=nodes[i];if(!nodeData){var instance=createDirectiveInstance(view,nodeDef);nodeData={instance:instance};}if(nodeDef.flags&32768/* Component */){var compView=asElementData(view,nodeDef.parent.nodeIndex).componentView;initView(compView,nodeData.instance,nodeData.instance);}break;}case 32/* TypePureArray */:case 64/* TypePureObject */:case 128/* TypePurePipe */:nodeData=createPureExpression(view,nodeDef);break;case 67108864/* TypeContentQuery */:case 134217728/* TypeViewQuery */:nodeData=createQuery();break;case 8/* TypeNgContent */:appendNgContent(view,renderHost,nodeDef);// no runtime data needed for NgContent...
	nodeData=undefined;break;}nodes[i]=nodeData;}// Create the ViewData.nodes of component views after we created everything else,
	// so that e.g. ng-content works
	execComponentViewsAction(view,ViewAction.CreateViewNodes);// fill static content and view queries
	execQueriesAction(view,67108864/* TypeContentQuery */|134217728/* TypeViewQuery */,268435456/* StaticQuery */,0/* CheckAndUpdate */);}function checkNoChangesView(view){markProjectedViewsForCheck(view);Services.updateDirectives(view,1/* CheckNoChanges */);execEmbeddedViewsAction(view,ViewAction.CheckNoChanges);Services.updateRenderer(view,1/* CheckNoChanges */);execComponentViewsAction(view,ViewAction.CheckNoChanges);// Note: We don't check queries for changes as we didn't do this in v2.x.
	// TODO(tbosch): investigate if we can enable the check again in v5.x with a nicer error message.
	view.state&=~(64/* CheckProjectedViews */|32/* CheckProjectedView */);}function checkAndUpdateView(view){if(view.state&1/* BeforeFirstCheck */){view.state&=~1/* BeforeFirstCheck */;view.state|=2/* FirstCheck */;}else{view.state&=~2/* FirstCheck */;}shiftInitState(view,0/* InitState_BeforeInit */,256/* InitState_CallingOnInit */);markProjectedViewsForCheck(view);Services.updateDirectives(view,0/* CheckAndUpdate */);execEmbeddedViewsAction(view,ViewAction.CheckAndUpdate);execQueriesAction(view,67108864/* TypeContentQuery */,536870912/* DynamicQuery */,0/* CheckAndUpdate */);var callInit=shiftInitState(view,256/* InitState_CallingOnInit */,512/* InitState_CallingAfterContentInit */);callLifecycleHooksChildrenFirst(view,2097152/* AfterContentChecked */|(callInit?1048576/* AfterContentInit */:0));Services.updateRenderer(view,0/* CheckAndUpdate */);execComponentViewsAction(view,ViewAction.CheckAndUpdate);execQueriesAction(view,134217728/* TypeViewQuery */,536870912/* DynamicQuery */,0/* CheckAndUpdate */);callInit=shiftInitState(view,512/* InitState_CallingAfterContentInit */,768/* InitState_CallingAfterViewInit */);callLifecycleHooksChildrenFirst(view,8388608/* AfterViewChecked */|(callInit?4194304/* AfterViewInit */:0));if(view.def.flags&2/* OnPush */){view.state&=~8/* ChecksEnabled */;}view.state&=~(64/* CheckProjectedViews */|32/* CheckProjectedView */);shiftInitState(view,768/* InitState_CallingAfterViewInit */,1024/* InitState_AfterInit */);}function checkAndUpdateNode(view,nodeDef,argStyle,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9){if(argStyle===0/* Inline */){return checkAndUpdateNodeInline(view,nodeDef,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9);}else{return checkAndUpdateNodeDynamic(view,nodeDef,v0);}}function markProjectedViewsForCheck(view){var def=view.def;if(!(def.nodeFlags&4/* ProjectedTemplate */)){return;}for(var i=0;i<def.nodes.length;i++){var nodeDef=def.nodes[i];if(nodeDef.flags&4/* ProjectedTemplate */){var projectedViews=asElementData(view,i).template._projectedViews;if(projectedViews){for(var i_1=0;i_1<projectedViews.length;i_1++){var projectedView=projectedViews[i_1];projectedView.state|=32/* CheckProjectedView */;markParentViewsForCheckProjectedViews(projectedView,view);}}}else if((nodeDef.childFlags&4/* ProjectedTemplate */)===0){// a parent with leafs
	// no child is a component,
	// then skip the children
	i+=nodeDef.childCount;}}}function checkAndUpdateNodeInline(view,nodeDef,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9){switch(nodeDef.flags&201347067/* Types */){case 1/* TypeElement */:return checkAndUpdateElementInline(view,nodeDef,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9);case 2/* TypeText */:return checkAndUpdateTextInline(view,nodeDef,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9);case 16384/* TypeDirective */:return checkAndUpdateDirectiveInline(view,nodeDef,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9);case 32/* TypePureArray */:case 64/* TypePureObject */:case 128/* TypePurePipe */:return checkAndUpdatePureExpressionInline(view,nodeDef,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9);default:throw'unreachable';}}function checkAndUpdateNodeDynamic(view,nodeDef,values){switch(nodeDef.flags&201347067/* Types */){case 1/* TypeElement */:return checkAndUpdateElementDynamic(view,nodeDef,values);case 2/* TypeText */:return checkAndUpdateTextDynamic(view,nodeDef,values);case 16384/* TypeDirective */:return checkAndUpdateDirectiveDynamic(view,nodeDef,values);case 32/* TypePureArray */:case 64/* TypePureObject */:case 128/* TypePurePipe */:return checkAndUpdatePureExpressionDynamic(view,nodeDef,values);default:throw'unreachable';}}function checkNoChangesNode(view,nodeDef,argStyle,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9){if(argStyle===0/* Inline */){checkNoChangesNodeInline(view,nodeDef,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9);}else{checkNoChangesNodeDynamic(view,nodeDef,v0);}// Returning false is ok here as we would have thrown in case of a change.
	return false;}function checkNoChangesNodeInline(view,nodeDef,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9){var bindLen=nodeDef.bindings.length;if(bindLen>0)checkBindingNoChanges(view,nodeDef,0,v0);if(bindLen>1)checkBindingNoChanges(view,nodeDef,1,v1);if(bindLen>2)checkBindingNoChanges(view,nodeDef,2,v2);if(bindLen>3)checkBindingNoChanges(view,nodeDef,3,v3);if(bindLen>4)checkBindingNoChanges(view,nodeDef,4,v4);if(bindLen>5)checkBindingNoChanges(view,nodeDef,5,v5);if(bindLen>6)checkBindingNoChanges(view,nodeDef,6,v6);if(bindLen>7)checkBindingNoChanges(view,nodeDef,7,v7);if(bindLen>8)checkBindingNoChanges(view,nodeDef,8,v8);if(bindLen>9)checkBindingNoChanges(view,nodeDef,9,v9);}function checkNoChangesNodeDynamic(view,nodeDef,values){for(var i=0;i<values.length;i++){checkBindingNoChanges(view,nodeDef,i,values[i]);}}/**
	 * Workaround https://github.com/angular/tsickle/issues/497
	 * @suppress {misplacedTypeAnnotation}
	 */function checkNoChangesQuery(view,nodeDef){var queryList=asQueryList(view,nodeDef.nodeIndex);if(queryList.dirty){throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view,nodeDef.nodeIndex),"Query "+nodeDef.query.id+" not dirty","Query "+nodeDef.query.id+" dirty",(view.state&1/* BeforeFirstCheck */)!==0);}}function destroyView(view){if(view.state&128/* Destroyed */){return;}execEmbeddedViewsAction(view,ViewAction.Destroy);execComponentViewsAction(view,ViewAction.Destroy);callLifecycleHooksChildrenFirst(view,131072/* OnDestroy */);if(view.disposables){for(var i=0;i<view.disposables.length;i++){view.disposables[i]();}}detachProjectedView(view);if(view.renderer.destroyNode){destroyViewNodes(view);}if(isComponentView(view)){view.renderer.destroy();}view.state|=128/* Destroyed */;}function destroyViewNodes(view){var len=view.def.nodes.length;for(var i=0;i<len;i++){var def=view.def.nodes[i];if(def.flags&1/* TypeElement */){view.renderer.destroyNode(asElementData(view,i).renderElement);}else if(def.flags&2/* TypeText */){view.renderer.destroyNode(asTextData(view,i).renderText);}else if(def.flags&67108864/* TypeContentQuery */||def.flags&134217728/* TypeViewQuery */){asQueryList(view,i).destroy();}}}var ViewAction;(function(ViewAction){ViewAction[ViewAction["CreateViewNodes"]=0]="CreateViewNodes";ViewAction[ViewAction["CheckNoChanges"]=1]="CheckNoChanges";ViewAction[ViewAction["CheckNoChangesProjectedViews"]=2]="CheckNoChangesProjectedViews";ViewAction[ViewAction["CheckAndUpdate"]=3]="CheckAndUpdate";ViewAction[ViewAction["CheckAndUpdateProjectedViews"]=4]="CheckAndUpdateProjectedViews";ViewAction[ViewAction["Destroy"]=5]="Destroy";})(ViewAction||(ViewAction={}));function execComponentViewsAction(view,action){var def=view.def;if(!(def.nodeFlags&33554432/* ComponentView */)){return;}for(var i=0;i<def.nodes.length;i++){var nodeDef=def.nodes[i];if(nodeDef.flags&33554432/* ComponentView */){// a leaf
	callViewAction(asElementData(view,i).componentView,action);}else if((nodeDef.childFlags&33554432/* ComponentView */)===0){// a parent with leafs
	// no child is a component,
	// then skip the children
	i+=nodeDef.childCount;}}}function execEmbeddedViewsAction(view,action){var def=view.def;if(!(def.nodeFlags&16777216/* EmbeddedViews */)){return;}for(var i=0;i<def.nodes.length;i++){var nodeDef=def.nodes[i];if(nodeDef.flags&16777216/* EmbeddedViews */){// a leaf
	var embeddedViews=asElementData(view,i).viewContainer._embeddedViews;for(var k=0;k<embeddedViews.length;k++){callViewAction(embeddedViews[k],action);}}else if((nodeDef.childFlags&16777216/* EmbeddedViews */)===0){// a parent with leafs
	// no child is a component,
	// then skip the children
	i+=nodeDef.childCount;}}}function callViewAction(view,action){var viewState=view.state;switch(action){case ViewAction.CheckNoChanges:if((viewState&128/* Destroyed */)===0){if((viewState&12/* CatDetectChanges */)===12/* CatDetectChanges */){checkNoChangesView(view);}else if(viewState&64/* CheckProjectedViews */){execProjectedViewsAction(view,ViewAction.CheckNoChangesProjectedViews);}}break;case ViewAction.CheckNoChangesProjectedViews:if((viewState&128/* Destroyed */)===0){if(viewState&32/* CheckProjectedView */){checkNoChangesView(view);}else if(viewState&64/* CheckProjectedViews */){execProjectedViewsAction(view,action);}}break;case ViewAction.CheckAndUpdate:if((viewState&128/* Destroyed */)===0){if((viewState&12/* CatDetectChanges */)===12/* CatDetectChanges */){checkAndUpdateView(view);}else if(viewState&64/* CheckProjectedViews */){execProjectedViewsAction(view,ViewAction.CheckAndUpdateProjectedViews);}}break;case ViewAction.CheckAndUpdateProjectedViews:if((viewState&128/* Destroyed */)===0){if(viewState&32/* CheckProjectedView */){checkAndUpdateView(view);}else if(viewState&64/* CheckProjectedViews */){execProjectedViewsAction(view,action);}}break;case ViewAction.Destroy:// Note: destroyView recurses over all views,
	// so we don't need to special case projected views here.
	destroyView(view);break;case ViewAction.CreateViewNodes:createViewNodes(view);break;}}function execProjectedViewsAction(view,action){execEmbeddedViewsAction(view,action);execComponentViewsAction(view,action);}function execQueriesAction(view,queryFlags,staticDynamicQueryFlag,checkType){if(!(view.def.nodeFlags&queryFlags)||!(view.def.nodeFlags&staticDynamicQueryFlag)){return;}var nodeCount=view.def.nodes.length;for(var i=0;i<nodeCount;i++){var nodeDef=view.def.nodes[i];if(nodeDef.flags&queryFlags&&nodeDef.flags&staticDynamicQueryFlag){Services.setCurrentNode(view,nodeDef.nodeIndex);switch(checkType){case 0/* CheckAndUpdate */:checkAndUpdateQuery(view,nodeDef);break;case 1/* CheckNoChanges */:checkNoChangesQuery(view,nodeDef);break;}}if(!(nodeDef.childFlags&queryFlags)||!(nodeDef.childFlags&staticDynamicQueryFlag)){// no child has a matching query
	// then skip the children
	i+=nodeDef.childCount;}}}/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */var initialized=false;function initServicesIfNeeded(){if(initialized){return;}initialized=true;var services=isDevMode()?createDebugServices():createProdServices();Services.setCurrentNode=services.setCurrentNode;Services.createRootView=services.createRootView;Services.createEmbeddedView=services.createEmbeddedView;Services.createComponentView=services.createComponentView;Services.createNgModuleRef=services.createNgModuleRef;Services.overrideProvider=services.overrideProvider;Services.overrideComponentView=services.overrideComponentView;Services.clearOverrides=services.clearOverrides;Services.checkAndUpdateView=services.checkAndUpdateView;Services.checkNoChangesView=services.checkNoChangesView;Services.destroyView=services.destroyView;Services.resolveDep=resolveDep;Services.createDebugContext=services.createDebugContext;Services.handleEvent=services.handleEvent;Services.updateDirectives=services.updateDirectives;Services.updateRenderer=services.updateRenderer;Services.dirtyParentQueries=dirtyParentQueries;}function createProdServices(){return {setCurrentNode:function setCurrentNode(){},createRootView:createProdRootView,createEmbeddedView:createEmbeddedView,createComponentView:createComponentView,createNgModuleRef:createNgModuleRef,overrideProvider:NOOP,overrideComponentView:NOOP,clearOverrides:NOOP,checkAndUpdateView:checkAndUpdateView,checkNoChangesView:checkNoChangesView,destroyView:destroyView,createDebugContext:function createDebugContext(view,nodeIndex){return new DebugContext_(view,nodeIndex);},handleEvent:function handleEvent(view,nodeIndex,eventName,event){return view.def.handleEvent(view,nodeIndex,eventName,event);},updateDirectives:function updateDirectives(view,checkType){return view.def.updateDirectives(checkType===0/* CheckAndUpdate */?prodCheckAndUpdateNode:prodCheckNoChangesNode,view);},updateRenderer:function updateRenderer(view,checkType){return view.def.updateRenderer(checkType===0/* CheckAndUpdate */?prodCheckAndUpdateNode:prodCheckNoChangesNode,view);}};}function createDebugServices(){return {setCurrentNode:debugSetCurrentNode,createRootView:debugCreateRootView,createEmbeddedView:debugCreateEmbeddedView,createComponentView:debugCreateComponentView,createNgModuleRef:debugCreateNgModuleRef,overrideProvider:debugOverrideProvider,overrideComponentView:debugOverrideComponentView,clearOverrides:debugClearOverrides,checkAndUpdateView:debugCheckAndUpdateView,checkNoChangesView:debugCheckNoChangesView,destroyView:debugDestroyView,createDebugContext:function createDebugContext(view,nodeIndex){return new DebugContext_(view,nodeIndex);},handleEvent:debugHandleEvent,updateDirectives:debugUpdateDirectives,updateRenderer:debugUpdateRenderer};}function createProdRootView(elInjector,projectableNodes,rootSelectorOrNode,def,ngModule,context){var rendererFactory=ngModule.injector.get(RendererFactory2);return createRootView(createRootData(elInjector,ngModule,rendererFactory,projectableNodes,rootSelectorOrNode),def,context);}function debugCreateRootView(elInjector,projectableNodes,rootSelectorOrNode,def,ngModule,context){var rendererFactory=ngModule.injector.get(RendererFactory2);var root=createRootData(elInjector,ngModule,new DebugRendererFactory2(rendererFactory),projectableNodes,rootSelectorOrNode);var defWithOverride=applyProviderOverridesToView(def);return callWithDebugContext(DebugAction.create,createRootView,null,[root,defWithOverride,context]);}function createRootData(elInjector,ngModule,rendererFactory,projectableNodes,rootSelectorOrNode){var sanitizer=ngModule.injector.get(Sanitizer);var errorHandler=ngModule.injector.get(ErrorHandler);var renderer=rendererFactory.createRenderer(null,null);return {ngModule:ngModule,injector:elInjector,projectableNodes:projectableNodes,selectorOrNode:rootSelectorOrNode,sanitizer:sanitizer,rendererFactory:rendererFactory,renderer:renderer,errorHandler:errorHandler};}function debugCreateEmbeddedView(parentView,anchorDef,viewDef,context){var defWithOverride=applyProviderOverridesToView(viewDef);return callWithDebugContext(DebugAction.create,createEmbeddedView,null,[parentView,anchorDef,defWithOverride,context]);}function debugCreateComponentView(parentView,nodeDef,viewDef,hostElement){var overrideComponentView=viewDefOverrides.get(nodeDef.element.componentProvider.provider.token);if(overrideComponentView){viewDef=overrideComponentView;}else{viewDef=applyProviderOverridesToView(viewDef);}return callWithDebugContext(DebugAction.create,createComponentView,null,[parentView,nodeDef,viewDef,hostElement]);}function debugCreateNgModuleRef(moduleType,parentInjector,bootstrapComponents,def){var defWithOverride=applyProviderOverridesToNgModule(def);return createNgModuleRef(moduleType,parentInjector,bootstrapComponents,defWithOverride);}var providerOverrides=new Map();var providerOverridesWithScope=new Map();var viewDefOverrides=new Map();function debugOverrideProvider(override){providerOverrides.set(override.token,override);var injectableDef;if(typeof override.token==='function'&&(injectableDef=getInjectableDef(override.token))&&typeof injectableDef.providedIn==='function'){providerOverridesWithScope.set(override.token,override);}}function debugOverrideComponentView(comp,compFactory){var hostViewDef=resolveDefinition(getComponentViewDefinitionFactory(compFactory));var compViewDef=resolveDefinition(hostViewDef.nodes[0].element.componentView);viewDefOverrides.set(comp,compViewDef);}function debugClearOverrides(){providerOverrides.clear();providerOverridesWithScope.clear();viewDefOverrides.clear();}// Notes about the algorithm:
	// 1) Locate the providers of an element and check if one of them was overwritten
	// 2) Change the providers of that element
	//
	// We only create new datastructures if we need to, to keep perf impact
	// reasonable.
	function applyProviderOverridesToView(def){if(providerOverrides.size===0){return def;}var elementIndicesWithOverwrittenProviders=findElementIndicesWithOverwrittenProviders(def);if(elementIndicesWithOverwrittenProviders.length===0){return def;}// clone the whole view definition,
	// as it maintains references between the nodes that are hard to update.
	def=def.factory(function(){return NOOP;});for(var i=0;i<elementIndicesWithOverwrittenProviders.length;i++){applyProviderOverridesToElement(def,elementIndicesWithOverwrittenProviders[i]);}return def;function findElementIndicesWithOverwrittenProviders(def){var elIndicesWithOverwrittenProviders=[];var lastElementDef=null;for(var i=0;i<def.nodes.length;i++){var nodeDef=def.nodes[i];if(nodeDef.flags&1/* TypeElement */){lastElementDef=nodeDef;}if(lastElementDef&&nodeDef.flags&3840/* CatProviderNoDirective */&&providerOverrides.has(nodeDef.provider.token)){elIndicesWithOverwrittenProviders.push(lastElementDef.nodeIndex);lastElementDef=null;}}return elIndicesWithOverwrittenProviders;}function applyProviderOverridesToElement(viewDef,elIndex){for(var i=elIndex+1;i<viewDef.nodes.length;i++){var nodeDef=viewDef.nodes[i];if(nodeDef.flags&1/* TypeElement */){// stop at the next element
	return;}if(nodeDef.flags&3840/* CatProviderNoDirective */){var provider=nodeDef.provider;var override=providerOverrides.get(provider.token);if(override){nodeDef.flags=nodeDef.flags&~3840/* CatProviderNoDirective */|override.flags;provider.deps=splitDepsDsl(override.deps);provider.value=override.value;}}}}}// Notes about the algorithm:
	// We only create new datastructures if we need to, to keep perf impact
	// reasonable.
	function applyProviderOverridesToNgModule(def){var _a=calcHasOverrides(def),hasOverrides=_a.hasOverrides,hasDeprecatedOverrides=_a.hasDeprecatedOverrides;if(!hasOverrides){return def;}// clone the whole view definition,
	// as it maintains references between the nodes that are hard to update.
	def=def.factory(function(){return NOOP;});applyProviderOverrides(def);return def;function calcHasOverrides(def){var hasOverrides=false;var hasDeprecatedOverrides=false;if(providerOverrides.size===0){return {hasOverrides:hasOverrides,hasDeprecatedOverrides:hasDeprecatedOverrides};}def.providers.forEach(function(node){var override=providerOverrides.get(node.token);if(node.flags&3840/* CatProviderNoDirective */&&override){hasOverrides=true;hasDeprecatedOverrides=hasDeprecatedOverrides||override.deprecatedBehavior;}});def.modules.forEach(function(module){providerOverridesWithScope.forEach(function(override,token){if(getInjectableDef(token).providedIn===module){hasOverrides=true;hasDeprecatedOverrides=hasDeprecatedOverrides||override.deprecatedBehavior;}});});return {hasOverrides:hasOverrides,hasDeprecatedOverrides:hasDeprecatedOverrides};}function applyProviderOverrides(def){for(var i=0;i<def.providers.length;i++){var provider=def.providers[i];if(hasDeprecatedOverrides){// We had a bug where me made
	// all providers lazy. Keep this logic behind a flag
	// for migrating existing users.
	provider.flags|=4096/* LazyProvider */;}var override=providerOverrides.get(provider.token);if(override){provider.flags=provider.flags&~3840/* CatProviderNoDirective */|override.flags;provider.deps=splitDepsDsl(override.deps);provider.value=override.value;}}if(providerOverridesWithScope.size>0){var moduleSet_1=new Set(def.modules);providerOverridesWithScope.forEach(function(override,token){if(moduleSet_1.has(getInjectableDef(token).providedIn)){var provider={token:token,flags:override.flags|(hasDeprecatedOverrides?4096/* LazyProvider */:0/* None */),deps:splitDepsDsl(override.deps),value:override.value,index:def.providers.length};def.providers.push(provider);def.providersByKey[tokenKey(token)]=provider;}});}}}function prodCheckAndUpdateNode(view,checkIndex,argStyle,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9){var nodeDef=view.def.nodes[checkIndex];checkAndUpdateNode(view,nodeDef,argStyle,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9);return nodeDef.flags&224/* CatPureExpression */?asPureExpressionData(view,checkIndex).value:undefined;}function prodCheckNoChangesNode(view,checkIndex,argStyle,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9){var nodeDef=view.def.nodes[checkIndex];checkNoChangesNode(view,nodeDef,argStyle,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9);return nodeDef.flags&224/* CatPureExpression */?asPureExpressionData(view,checkIndex).value:undefined;}function debugCheckAndUpdateView(view){return callWithDebugContext(DebugAction.detectChanges,checkAndUpdateView,null,[view]);}function debugCheckNoChangesView(view){return callWithDebugContext(DebugAction.checkNoChanges,checkNoChangesView,null,[view]);}function debugDestroyView(view){return callWithDebugContext(DebugAction.destroy,destroyView,null,[view]);}var DebugAction;(function(DebugAction){DebugAction[DebugAction["create"]=0]="create";DebugAction[DebugAction["detectChanges"]=1]="detectChanges";DebugAction[DebugAction["checkNoChanges"]=2]="checkNoChanges";DebugAction[DebugAction["destroy"]=3]="destroy";DebugAction[DebugAction["handleEvent"]=4]="handleEvent";})(DebugAction||(DebugAction={}));var _currentAction;var _currentView;var _currentNodeIndex;function debugSetCurrentNode(view,nodeIndex){_currentView=view;_currentNodeIndex=nodeIndex;}function debugHandleEvent(view,nodeIndex,eventName,event){debugSetCurrentNode(view,nodeIndex);return callWithDebugContext(DebugAction.handleEvent,view.def.handleEvent,null,[view,nodeIndex,eventName,event]);}function debugUpdateDirectives(view,checkType){if(view.state&128/* Destroyed */){throw viewDestroyedError(DebugAction[_currentAction]);}debugSetCurrentNode(view,nextDirectiveWithBinding(view,0));return view.def.updateDirectives(debugCheckDirectivesFn,view);function debugCheckDirectivesFn(view,nodeIndex,argStyle){var values=[];for(var _i=3;_i<arguments.length;_i++){values[_i-3]=arguments[_i];}var nodeDef=view.def.nodes[nodeIndex];if(checkType===0/* CheckAndUpdate */){debugCheckAndUpdateNode(view,nodeDef,argStyle,values);}else{debugCheckNoChangesNode(view,nodeDef,argStyle,values);}if(nodeDef.flags&16384/* TypeDirective */){debugSetCurrentNode(view,nextDirectiveWithBinding(view,nodeIndex));}return nodeDef.flags&224/* CatPureExpression */?asPureExpressionData(view,nodeDef.nodeIndex).value:undefined;}}function debugUpdateRenderer(view,checkType){if(view.state&128/* Destroyed */){throw viewDestroyedError(DebugAction[_currentAction]);}debugSetCurrentNode(view,nextRenderNodeWithBinding(view,0));return view.def.updateRenderer(debugCheckRenderNodeFn,view);function debugCheckRenderNodeFn(view,nodeIndex,argStyle){var values=[];for(var _i=3;_i<arguments.length;_i++){values[_i-3]=arguments[_i];}var nodeDef=view.def.nodes[nodeIndex];if(checkType===0/* CheckAndUpdate */){debugCheckAndUpdateNode(view,nodeDef,argStyle,values);}else{debugCheckNoChangesNode(view,nodeDef,argStyle,values);}if(nodeDef.flags&3/* CatRenderNode */){debugSetCurrentNode(view,nextRenderNodeWithBinding(view,nodeIndex));}return nodeDef.flags&224/* CatPureExpression */?asPureExpressionData(view,nodeDef.nodeIndex).value:undefined;}}function debugCheckAndUpdateNode(view,nodeDef,argStyle,givenValues){var changed=checkAndUpdateNode.apply(void 0,__spread([view,nodeDef,argStyle],givenValues));if(changed){var values=argStyle===1/* Dynamic */?givenValues[0]:givenValues;if(nodeDef.flags&16384/* TypeDirective */){var bindingValues={};for(var i=0;i<nodeDef.bindings.length;i++){var binding=nodeDef.bindings[i];var value=values[i];if(binding.flags&8/* TypeProperty */){bindingValues[normalizeDebugBindingName(binding.nonMinifiedName)]=normalizeDebugBindingValue(value);}}var elDef=nodeDef.parent;var el=asElementData(view,elDef.nodeIndex).renderElement;if(!elDef.element.name){// a comment.
	view.renderer.setValue(el,"bindings="+JSON.stringify(bindingValues,null,2));}else{// a regular element.
	for(var attr in bindingValues){var value=bindingValues[attr];if(value!=null){view.renderer.setAttribute(el,attr,value);}else{view.renderer.removeAttribute(el,attr);}}}}}}function debugCheckNoChangesNode(view,nodeDef,argStyle,values){checkNoChangesNode.apply(void 0,__spread([view,nodeDef,argStyle],values));}function nextDirectiveWithBinding(view,nodeIndex){for(var i=nodeIndex;i<view.def.nodes.length;i++){var nodeDef=view.def.nodes[i];if(nodeDef.flags&16384/* TypeDirective */&&nodeDef.bindings&&nodeDef.bindings.length){return i;}}return null;}function nextRenderNodeWithBinding(view,nodeIndex){for(var i=nodeIndex;i<view.def.nodes.length;i++){var nodeDef=view.def.nodes[i];if(nodeDef.flags&3/* CatRenderNode */&&nodeDef.bindings&&nodeDef.bindings.length){return i;}}return null;}var DebugContext_=/** @class */function(){function DebugContext_(view,nodeIndex){this.view=view;this.nodeIndex=nodeIndex;if(nodeIndex==null){this.nodeIndex=nodeIndex=0;}this.nodeDef=view.def.nodes[nodeIndex];var elDef=this.nodeDef;var elView=view;while(elDef&&(elDef.flags&1/* TypeElement */)===0){elDef=elDef.parent;}if(!elDef){while(!elDef&&elView){elDef=viewParentEl(elView);elView=elView.parent;}}this.elDef=elDef;this.elView=elView;}Object.defineProperty(DebugContext_.prototype,"elOrCompView",{get:function get(){// Has to be done lazily as we use the DebugContext also during creation of elements...
	return asElementData(this.elView,this.elDef.nodeIndex).componentView||this.view;},enumerable:true,configurable:true});Object.defineProperty(DebugContext_.prototype,"injector",{get:function get(){return createInjector$1(this.elView,this.elDef);},enumerable:true,configurable:true});Object.defineProperty(DebugContext_.prototype,"component",{get:function get(){return this.elOrCompView.component;},enumerable:true,configurable:true});Object.defineProperty(DebugContext_.prototype,"context",{get:function get(){return this.elOrCompView.context;},enumerable:true,configurable:true});Object.defineProperty(DebugContext_.prototype,"providerTokens",{get:function get(){var tokens=[];if(this.elDef){for(var i=this.elDef.nodeIndex+1;i<=this.elDef.nodeIndex+this.elDef.childCount;i++){var childDef=this.elView.def.nodes[i];if(childDef.flags&20224/* CatProvider */){tokens.push(childDef.provider.token);}i+=childDef.childCount;}}return tokens;},enumerable:true,configurable:true});Object.defineProperty(DebugContext_.prototype,"references",{get:function get(){var references={};if(this.elDef){collectReferences(this.elView,this.elDef,references);for(var i=this.elDef.nodeIndex+1;i<=this.elDef.nodeIndex+this.elDef.childCount;i++){var childDef=this.elView.def.nodes[i];if(childDef.flags&20224/* CatProvider */){collectReferences(this.elView,childDef,references);}i+=childDef.childCount;}}return references;},enumerable:true,configurable:true});Object.defineProperty(DebugContext_.prototype,"componentRenderElement",{get:function get(){var elData=findHostElement(this.elOrCompView);return elData?elData.renderElement:undefined;},enumerable:true,configurable:true});Object.defineProperty(DebugContext_.prototype,"renderNode",{get:function get(){return this.nodeDef.flags&2/* TypeText */?renderNode(this.view,this.nodeDef):renderNode(this.elView,this.elDef);},enumerable:true,configurable:true});DebugContext_.prototype.logError=function(console){var values=[];for(var _i=1;_i<arguments.length;_i++){values[_i-1]=arguments[_i];}var logViewDef;var logNodeIndex;if(this.nodeDef.flags&2/* TypeText */){logViewDef=this.view.def;logNodeIndex=this.nodeDef.nodeIndex;}else{logViewDef=this.elView.def;logNodeIndex=this.elDef.nodeIndex;}// Note: we only generate a log function for text and element nodes
	// to make the generated code as small as possible.
	var renderNodeIndex=getRenderNodeIndex(logViewDef,logNodeIndex);var currRenderNodeIndex=-1;var nodeLogger=function nodeLogger(){var _a;currRenderNodeIndex++;if(currRenderNodeIndex===renderNodeIndex){return (_a=console.error).bind.apply(_a,__spread([console],values));}else{return NOOP;}};logViewDef.factory(nodeLogger);if(currRenderNodeIndex<renderNodeIndex){console.error('Illegal state: the ViewDefinitionFactory did not call the logger!');console.error.apply(console,__spread(values));}};return DebugContext_;}();function getRenderNodeIndex(viewDef,nodeIndex){var renderNodeIndex=-1;for(var i=0;i<=nodeIndex;i++){var nodeDef=viewDef.nodes[i];if(nodeDef.flags&3/* CatRenderNode */){renderNodeIndex++;}}return renderNodeIndex;}function findHostElement(view){while(view&&!isComponentView(view)){view=view.parent;}if(view.parent){return asElementData(view.parent,viewParentEl(view).nodeIndex);}return null;}function collectReferences(view,nodeDef,references){for(var refName in nodeDef.references){references[refName]=getQueryValue(view,nodeDef,nodeDef.references[refName]);}}function callWithDebugContext(action,fn,self,args){var oldAction=_currentAction;var oldView=_currentView;var oldNodeIndex=_currentNodeIndex;try{_currentAction=action;var result=fn.apply(self,args);_currentView=oldView;_currentNodeIndex=oldNodeIndex;_currentAction=oldAction;return result;}catch(e){if(isViewDebugError(e)||!_currentView){throw e;}throw viewWrappedDebugError(e,getCurrentDebugContext());}}function getCurrentDebugContext(){return _currentView?new DebugContext_(_currentView,_currentNodeIndex):null;}var DebugRendererFactory2=/** @class */function(){function DebugRendererFactory2(delegate){this.delegate=delegate;}DebugRendererFactory2.prototype.createRenderer=function(element,renderData){return new DebugRenderer2(this.delegate.createRenderer(element,renderData));};DebugRendererFactory2.prototype.begin=function(){if(this.delegate.begin){this.delegate.begin();}};DebugRendererFactory2.prototype.end=function(){if(this.delegate.end){this.delegate.end();}};DebugRendererFactory2.prototype.whenRenderingDone=function(){if(this.delegate.whenRenderingDone){return this.delegate.whenRenderingDone();}return Promise.resolve(null);};return DebugRendererFactory2;}();var DebugRenderer2=/** @class */function(){function DebugRenderer2(delegate){this.delegate=delegate;/**
	         * Factory function used to create a `DebugContext` when a node is created.
	         *
	         * The `DebugContext` allows to retrieve information about the nodes that are useful in tests.
	         *
	         * The factory is configurable so that the `DebugRenderer2` could instantiate either a View Engine
	         * or a Render context.
	         */this.debugContextFactory=getCurrentDebugContext;this.data=this.delegate.data;}DebugRenderer2.prototype.createDebugContext=function(nativeElement){return this.debugContextFactory(nativeElement);};DebugRenderer2.prototype.destroyNode=function(node){var debugNode=getDebugNode(node);removeDebugNodeFromIndex(debugNode);if(debugNode instanceof DebugNode__PRE_R3__){debugNode.listeners.length=0;}if(this.delegate.destroyNode){this.delegate.destroyNode(node);}};DebugRenderer2.prototype.destroy=function(){this.delegate.destroy();};DebugRenderer2.prototype.createElement=function(name,namespace){var el=this.delegate.createElement(name,namespace);var debugCtx=this.createDebugContext(el);if(debugCtx){var debugEl=new DebugElement__PRE_R3__(el,null,debugCtx);debugEl.name=name;indexDebugNode(debugEl);}return el;};DebugRenderer2.prototype.createComment=function(value){var comment=this.delegate.createComment(value);var debugCtx=this.createDebugContext(comment);if(debugCtx){indexDebugNode(new DebugNode__PRE_R3__(comment,null,debugCtx));}return comment;};DebugRenderer2.prototype.createText=function(value){var text=this.delegate.createText(value);var debugCtx=this.createDebugContext(text);if(debugCtx){indexDebugNode(new DebugNode__PRE_R3__(text,null,debugCtx));}return text;};DebugRenderer2.prototype.appendChild=function(parent,newChild){var debugEl=getDebugNode(parent);var debugChildEl=getDebugNode(newChild);if(debugEl&&debugChildEl&&debugEl instanceof DebugElement__PRE_R3__){debugEl.addChild(debugChildEl);}this.delegate.appendChild(parent,newChild);};DebugRenderer2.prototype.insertBefore=function(parent,newChild,refChild){var debugEl=getDebugNode(parent);var debugChildEl=getDebugNode(newChild);var debugRefEl=getDebugNode(refChild);if(debugEl&&debugChildEl&&debugEl instanceof DebugElement__PRE_R3__){debugEl.insertBefore(debugRefEl,debugChildEl);}this.delegate.insertBefore(parent,newChild,refChild);};DebugRenderer2.prototype.removeChild=function(parent,oldChild){var debugEl=getDebugNode(parent);var debugChildEl=getDebugNode(oldChild);if(debugEl&&debugChildEl&&debugEl instanceof DebugElement__PRE_R3__){debugEl.removeChild(debugChildEl);}this.delegate.removeChild(parent,oldChild);};DebugRenderer2.prototype.selectRootElement=function(selectorOrNode,preserveContent){var el=this.delegate.selectRootElement(selectorOrNode,preserveContent);var debugCtx=getCurrentDebugContext();if(debugCtx){indexDebugNode(new DebugElement__PRE_R3__(el,null,debugCtx));}return el;};DebugRenderer2.prototype.setAttribute=function(el,name,value,namespace){var debugEl=getDebugNode(el);if(debugEl&&debugEl instanceof DebugElement__PRE_R3__){var fullName=namespace?namespace+':'+name:name;debugEl.attributes[fullName]=value;}this.delegate.setAttribute(el,name,value,namespace);};DebugRenderer2.prototype.removeAttribute=function(el,name,namespace){var debugEl=getDebugNode(el);if(debugEl&&debugEl instanceof DebugElement__PRE_R3__){var fullName=namespace?namespace+':'+name:name;debugEl.attributes[fullName]=null;}this.delegate.removeAttribute(el,name,namespace);};DebugRenderer2.prototype.addClass=function(el,name){var debugEl=getDebugNode(el);if(debugEl&&debugEl instanceof DebugElement__PRE_R3__){debugEl.classes[name]=true;}this.delegate.addClass(el,name);};DebugRenderer2.prototype.removeClass=function(el,name){var debugEl=getDebugNode(el);if(debugEl&&debugEl instanceof DebugElement__PRE_R3__){debugEl.classes[name]=false;}this.delegate.removeClass(el,name);};DebugRenderer2.prototype.setStyle=function(el,style,value,flags){var debugEl=getDebugNode(el);if(debugEl&&debugEl instanceof DebugElement__PRE_R3__){debugEl.styles[style]=value;}this.delegate.setStyle(el,style,value,flags);};DebugRenderer2.prototype.removeStyle=function(el,style,flags){var debugEl=getDebugNode(el);if(debugEl&&debugEl instanceof DebugElement__PRE_R3__){debugEl.styles[style]=null;}this.delegate.removeStyle(el,style,flags);};DebugRenderer2.prototype.setProperty=function(el,name,value){var debugEl=getDebugNode(el);if(debugEl&&debugEl instanceof DebugElement__PRE_R3__){debugEl.properties[name]=value;}this.delegate.setProperty(el,name,value);};DebugRenderer2.prototype.listen=function(target,eventName,callback){if(typeof target!=='string'){var debugEl=getDebugNode(target);if(debugEl){debugEl.listeners.push(new DebugEventListener(eventName,callback));}}return this.delegate.listen(target,eventName,callback);};DebugRenderer2.prototype.parentNode=function(node){return this.delegate.parentNode(node);};DebugRenderer2.prototype.nextSibling=function(node){return this.delegate.nextSibling(node);};DebugRenderer2.prototype.setValue=function(node,value){return this.delegate.setValue(node,value);};return DebugRenderer2;}();function cloneNgModuleDefinition(def){var providers=Array.from(def.providers);var modules=Array.from(def.modules);var providersByKey={};for(var key in def.providersByKey){providersByKey[key]=def.providersByKey[key];}return {factory:def.factory,isRoot:def.isRoot,providers:providers,modules:modules,providersByKey:providersByKey};}var NgModuleFactory_=/** @class */function(_super){__extends(NgModuleFactory_,_super);function NgModuleFactory_(moduleType,_bootstrapComponents,_ngModuleDefFactory){var _this=// Attention: this ctor is called as top level function.
	// Putting any logic in here will destroy closure tree shaking!
	_super.call(this)||this;_this.moduleType=moduleType;_this._bootstrapComponents=_bootstrapComponents;_this._ngModuleDefFactory=_ngModuleDefFactory;return _this;}NgModuleFactory_.prototype.create=function(parentInjector){initServicesIfNeeded();// Clone the NgModuleDefinition so that any tree shakeable provider definition
	// added to this instance of the NgModuleRef doesn't affect the cached copy.
	// See https://github.com/angular/angular/issues/25018.
	var def=cloneNgModuleDefinition(resolveDefinition(this._ngModuleDefFactory));return Services.createNgModuleRef(this.moduleType,parentInjector||Injector.NULL,this._bootstrapComponents,def);};return NgModuleFactory_;}(NgModuleFactory);/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ /**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ // clang-format on

	var $parseFloat = _global.parseFloat;
	var $trim$1 = _stringTrim.trim;

	var _parseFloat = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str) {
	  var string = $trim$1(String(str), 3);
	  var result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

	// 20.1.2.12 Number.parseFloat(string)
	_export(_export.S + _export.F * (Number.parseFloat != _parseFloat), 'Number', { parseFloat: _parseFloat });

	var runtime_1 = createCommonjsModule(function (module) {
	  /**
	   * Copyright (c) 2014-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   */
	  var runtime = function (exports) {

	    var Op = Object.prototype;
	    var hasOwn = Op.hasOwnProperty;
	    var undefined; // More compressible than void 0.

	    var $Symbol = typeof Symbol === "function" ? Symbol : {};
	    var iteratorSymbol = $Symbol.iterator || "@@iterator";
	    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	    function wrap(innerFn, outerFn, self, tryLocsList) {
	      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	      var generator = Object.create(protoGenerator.prototype);
	      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
	      // .throw, and .return methods.

	      generator._invoke = makeInvokeMethod(innerFn, self, context);
	      return generator;
	    }

	    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
	    // record like context.tryEntries[i].completion. This interface could
	    // have been (and was previously) designed to take a closure to be
	    // invoked without arguments, but in all the cases we care about we
	    // already have an existing method we want to call, so there's no need
	    // to create a new function object. We can even get away with assuming
	    // the method takes exactly one argument, since that happens to be true
	    // in every case, so we don't have to touch the arguments object. The
	    // only additional allocation required is the completion record, which
	    // has a stable shape and so hopefully should be cheap to allocate.

	    function tryCatch(fn, obj, arg) {
	      try {
	        return {
	          type: "normal",
	          arg: fn.call(obj, arg)
	        };
	      } catch (err) {
	        return {
	          type: "throw",
	          arg: err
	        };
	      }
	    }

	    var GenStateSuspendedStart = "suspendedStart";
	    var GenStateSuspendedYield = "suspendedYield";
	    var GenStateExecuting = "executing";
	    var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
	    // breaking out of the dispatch switch statement.

	    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
	    // .constructor.prototype properties for functions that return Generator
	    // objects. For full spec compliance, you may wish to configure your
	    // minifier not to mangle the names of these two functions.

	    function Generator() {}

	    function GeneratorFunction() {}

	    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
	    // don't natively support it.


	    var IteratorPrototype = {};

	    IteratorPrototype[iteratorSymbol] = function () {
	      return this;
	    };

	    var getProto = Object.getPrototypeOf;
	    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

	    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	      // This environment has a native %IteratorPrototype%; use it instead
	      // of the polyfill.
	      IteratorPrototype = NativeIteratorPrototype;
	    }

	    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
	    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	    GeneratorFunctionPrototype.constructor = GeneratorFunction;
	    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
	    // Iterator interface in terms of a single ._invoke method.

	    function defineIteratorMethods(prototype) {
	      ["next", "throw", "return"].forEach(function (method) {
	        prototype[method] = function (arg) {
	          return this._invoke(method, arg);
	        };
	      });
	    }

	    exports.isGeneratorFunction = function (genFun) {
	      var ctor = typeof genFun === "function" && genFun.constructor;
	      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
	      // do is to check its .name property.
	      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
	    };

	    exports.mark = function (genFun) {
	      if (Object.setPrototypeOf) {
	        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	      } else {
	        genFun.__proto__ = GeneratorFunctionPrototype;

	        if (!(toStringTagSymbol in genFun)) {
	          genFun[toStringTagSymbol] = "GeneratorFunction";
	        }
	      }

	      genFun.prototype = Object.create(Gp);
	      return genFun;
	    }; // Within the body of any async function, `await x` is transformed to
	    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	    // `hasOwn.call(value, "__await")` to determine if the yielded value is
	    // meant to be awaited.


	    exports.awrap = function (arg) {
	      return {
	        __await: arg
	      };
	    };

	    function AsyncIterator(generator) {
	      function invoke(method, arg, resolve, reject) {
	        var record = tryCatch(generator[method], generator, arg);

	        if (record.type === "throw") {
	          reject(record.arg);
	        } else {
	          var result = record.arg;
	          var value = result.value;

	          if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
	            return Promise.resolve(value.__await).then(function (value) {
	              invoke("next", value, resolve, reject);
	            }, function (err) {
	              invoke("throw", err, resolve, reject);
	            });
	          }

	          return Promise.resolve(value).then(function (unwrapped) {
	            // When a yielded Promise is resolved, its final value becomes
	            // the .value of the Promise<{value,done}> result for the
	            // current iteration.
	            result.value = unwrapped;
	            resolve(result);
	          }, function (error) {
	            // If a rejected Promise was yielded, throw the rejection back
	            // into the async generator function so it can be handled there.
	            return invoke("throw", error, resolve, reject);
	          });
	        }
	      }

	      var previousPromise;

	      function enqueue(method, arg) {
	        function callInvokeWithMethodAndArg() {
	          return new Promise(function (resolve, reject) {
	            invoke(method, arg, resolve, reject);
	          });
	        }

	        return previousPromise = // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
	        // invocations of the iterator.
	        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	      } // Define the unified helper method that is used to implement .next,
	      // .throw, and .return (see defineIteratorMethods).


	      this._invoke = enqueue;
	    }

	    defineIteratorMethods(AsyncIterator.prototype);

	    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	      return this;
	    };

	    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
	    // AsyncIterator objects; they just return a Promise for the value of
	    // the final result produced by the iterator.

	    exports.async = function (innerFn, outerFn, self, tryLocsList) {
	      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
	      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function (result) {
	        return result.done ? result.value : iter.next();
	      });
	    };

	    function makeInvokeMethod(innerFn, self, context) {
	      var state = GenStateSuspendedStart;
	      return function invoke(method, arg) {
	        if (state === GenStateExecuting) {
	          throw new Error("Generator is already running");
	        }

	        if (state === GenStateCompleted) {
	          if (method === "throw") {
	            throw arg;
	          } // Be forgiving, per 25.3.3.3.3 of the spec:
	          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


	          return doneResult();
	        }

	        context.method = method;
	        context.arg = arg;

	        while (true) {
	          var delegate = context.delegate;

	          if (delegate) {
	            var delegateResult = maybeInvokeDelegate(delegate, context);

	            if (delegateResult) {
	              if (delegateResult === ContinueSentinel) continue;
	              return delegateResult;
	            }
	          }

	          if (context.method === "next") {
	            // Setting context._sent for legacy support of Babel's
	            // function.sent implementation.
	            context.sent = context._sent = context.arg;
	          } else if (context.method === "throw") {
	            if (state === GenStateSuspendedStart) {
	              state = GenStateCompleted;
	              throw context.arg;
	            }

	            context.dispatchException(context.arg);
	          } else if (context.method === "return") {
	            context.abrupt("return", context.arg);
	          }

	          state = GenStateExecuting;
	          var record = tryCatch(innerFn, self, context);

	          if (record.type === "normal") {
	            // If an exception is thrown from innerFn, we leave state ===
	            // GenStateExecuting and loop back for another invocation.
	            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

	            if (record.arg === ContinueSentinel) {
	              continue;
	            }

	            return {
	              value: record.arg,
	              done: context.done
	            };
	          } else if (record.type === "throw") {
	            state = GenStateCompleted; // Dispatch the exception by looping back around to the
	            // context.dispatchException(context.arg) call above.

	            context.method = "throw";
	            context.arg = record.arg;
	          }
	        }
	      };
	    } // Call delegate.iterator[context.method](context.arg) and handle the
	    // result, either by returning a { value, done } result from the
	    // delegate iterator, or by modifying context.method and context.arg,
	    // setting context.delegate to null, and returning the ContinueSentinel.


	    function maybeInvokeDelegate(delegate, context) {
	      var method = delegate.iterator[context.method];

	      if (method === undefined) {
	        // A .throw or .return when the delegate iterator has no .throw
	        // method always terminates the yield* loop.
	        context.delegate = null;

	        if (context.method === "throw") {
	          // Note: ["return"] must be used for ES3 parsing compatibility.
	          if (delegate.iterator["return"]) {
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            context.method = "return";
	            context.arg = undefined;
	            maybeInvokeDelegate(delegate, context);

	            if (context.method === "throw") {
	              // If maybeInvokeDelegate(context) changed context.method from
	              // "return" to "throw", let that override the TypeError below.
	              return ContinueSentinel;
	            }
	          }

	          context.method = "throw";
	          context.arg = new TypeError("The iterator does not provide a 'throw' method");
	        }

	        return ContinueSentinel;
	      }

	      var record = tryCatch(method, delegate.iterator, context.arg);

	      if (record.type === "throw") {
	        context.method = "throw";
	        context.arg = record.arg;
	        context.delegate = null;
	        return ContinueSentinel;
	      }

	      var info = record.arg;

	      if (!info) {
	        context.method = "throw";
	        context.arg = new TypeError("iterator result is not an object");
	        context.delegate = null;
	        return ContinueSentinel;
	      }

	      if (info.done) {
	        // Assign the result of the finished delegate to the temporary
	        // variable specified by delegate.resultName (see delegateYield).
	        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

	        context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
	        // exception, let the outer generator proceed normally. If
	        // context.method was "next", forget context.arg since it has been
	        // "consumed" by the delegate iterator. If context.method was
	        // "return", allow the original .return call to continue in the
	        // outer generator.

	        if (context.method !== "return") {
	          context.method = "next";
	          context.arg = undefined;
	        }
	      } else {
	        // Re-yield the result returned by the delegate method.
	        return info;
	      } // The delegate iterator is finished, so forget it and continue with
	      // the outer generator.


	      context.delegate = null;
	      return ContinueSentinel;
	    } // Define Generator.prototype.{next,throw,return} in terms of the
	    // unified ._invoke helper method.


	    defineIteratorMethods(Gp);
	    Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
	    // @@iterator function is called on it. Some browsers' implementations of the
	    // iterator prototype chain incorrectly implement this, causing the Generator
	    // object to not be returned from this call. This ensures that doesn't happen.
	    // See https://github.com/facebook/regenerator/issues/274 for more details.

	    Gp[iteratorSymbol] = function () {
	      return this;
	    };

	    Gp.toString = function () {
	      return "[object Generator]";
	    };

	    function pushTryEntry(locs) {
	      var entry = {
	        tryLoc: locs[0]
	      };

	      if (1 in locs) {
	        entry.catchLoc = locs[1];
	      }

	      if (2 in locs) {
	        entry.finallyLoc = locs[2];
	        entry.afterLoc = locs[3];
	      }

	      this.tryEntries.push(entry);
	    }

	    function resetTryEntry(entry) {
	      var record = entry.completion || {};
	      record.type = "normal";
	      delete record.arg;
	      entry.completion = record;
	    }

	    function Context(tryLocsList) {
	      // The root entry object (effectively a try statement without a catch
	      // or a finally block) gives us a place to store values thrown from
	      // locations where there is no enclosing try statement.
	      this.tryEntries = [{
	        tryLoc: "root"
	      }];
	      tryLocsList.forEach(pushTryEntry, this);
	      this.reset(true);
	    }

	    exports.keys = function (object) {
	      var keys = [];

	      for (var key in object) {
	        keys.push(key);
	      }

	      keys.reverse(); // Rather than returning an object with a next method, we keep
	      // things simple and return the next function itself.

	      return function next() {
	        while (keys.length) {
	          var key = keys.pop();

	          if (key in object) {
	            next.value = key;
	            next.done = false;
	            return next;
	          }
	        } // To avoid creating an additional object, we just hang the .value
	        // and .done properties off the next function object itself. This
	        // also ensures that the minifier will not anonymize the function.


	        next.done = true;
	        return next;
	      };
	    };

	    function values(iterable) {
	      if (iterable) {
	        var iteratorMethod = iterable[iteratorSymbol];

	        if (iteratorMethod) {
	          return iteratorMethod.call(iterable);
	        }

	        if (typeof iterable.next === "function") {
	          return iterable;
	        }

	        if (!isNaN(iterable.length)) {
	          var i = -1,
	              next = function next() {
	            while (++i < iterable.length) {
	              if (hasOwn.call(iterable, i)) {
	                next.value = iterable[i];
	                next.done = false;
	                return next;
	              }
	            }

	            next.value = undefined;
	            next.done = true;
	            return next;
	          };

	          return next.next = next;
	        }
	      } // Return an iterator with no values.


	      return {
	        next: doneResult
	      };
	    }

	    exports.values = values;

	    function doneResult() {
	      return {
	        value: undefined,
	        done: true
	      };
	    }

	    Context.prototype = {
	      constructor: Context,
	      reset: function reset(skipTempReset) {
	        this.prev = 0;
	        this.next = 0; // Resetting context._sent for legacy support of Babel's
	        // function.sent implementation.

	        this.sent = this._sent = undefined;
	        this.done = false;
	        this.delegate = null;
	        this.method = "next";
	        this.arg = undefined;
	        this.tryEntries.forEach(resetTryEntry);

	        if (!skipTempReset) {
	          for (var name in this) {
	            // Not sure about the optimal order of these conditions:
	            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
	              this[name] = undefined;
	            }
	          }
	        }
	      },
	      stop: function stop() {
	        this.done = true;
	        var rootEntry = this.tryEntries[0];
	        var rootRecord = rootEntry.completion;

	        if (rootRecord.type === "throw") {
	          throw rootRecord.arg;
	        }

	        return this.rval;
	      },
	      dispatchException: function dispatchException(exception) {
	        if (this.done) {
	          throw exception;
	        }

	        var context = this;

	        function handle(loc, caught) {
	          record.type = "throw";
	          record.arg = exception;
	          context.next = loc;

	          if (caught) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            context.method = "next";
	            context.arg = undefined;
	          }

	          return !!caught;
	        }

	        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	          var entry = this.tryEntries[i];
	          var record = entry.completion;

	          if (entry.tryLoc === "root") {
	            // Exception thrown outside of any try block that could handle
	            // it, so set the completion value of the entire function to
	            // throw the exception.
	            return handle("end");
	          }

	          if (entry.tryLoc <= this.prev) {
	            var hasCatch = hasOwn.call(entry, "catchLoc");
	            var hasFinally = hasOwn.call(entry, "finallyLoc");

	            if (hasCatch && hasFinally) {
	              if (this.prev < entry.catchLoc) {
	                return handle(entry.catchLoc, true);
	              } else if (this.prev < entry.finallyLoc) {
	                return handle(entry.finallyLoc);
	              }
	            } else if (hasCatch) {
	              if (this.prev < entry.catchLoc) {
	                return handle(entry.catchLoc, true);
	              }
	            } else if (hasFinally) {
	              if (this.prev < entry.finallyLoc) {
	                return handle(entry.finallyLoc);
	              }
	            } else {
	              throw new Error("try statement without catch or finally");
	            }
	          }
	        }
	      },
	      abrupt: function abrupt(type, arg) {
	        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	          var entry = this.tryEntries[i];

	          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
	            var finallyEntry = entry;
	            break;
	          }
	        }

	        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
	          // Ignore the finally entry if control is not jumping to a
	          // location outside the try/catch block.
	          finallyEntry = null;
	        }

	        var record = finallyEntry ? finallyEntry.completion : {};
	        record.type = type;
	        record.arg = arg;

	        if (finallyEntry) {
	          this.method = "next";
	          this.next = finallyEntry.finallyLoc;
	          return ContinueSentinel;
	        }

	        return this.complete(record);
	      },
	      complete: function complete(record, afterLoc) {
	        if (record.type === "throw") {
	          throw record.arg;
	        }

	        if (record.type === "break" || record.type === "continue") {
	          this.next = record.arg;
	        } else if (record.type === "return") {
	          this.rval = this.arg = record.arg;
	          this.method = "return";
	          this.next = "end";
	        } else if (record.type === "normal" && afterLoc) {
	          this.next = afterLoc;
	        }

	        return ContinueSentinel;
	      },
	      finish: function finish(finallyLoc) {
	        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	          var entry = this.tryEntries[i];

	          if (entry.finallyLoc === finallyLoc) {
	            this.complete(entry.completion, entry.afterLoc);
	            resetTryEntry(entry);
	            return ContinueSentinel;
	          }
	        }
	      },
	      "catch": function _catch(tryLoc) {
	        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	          var entry = this.tryEntries[i];

	          if (entry.tryLoc === tryLoc) {
	            var record = entry.completion;

	            if (record.type === "throw") {
	              var thrown = record.arg;
	              resetTryEntry(entry);
	            }

	            return thrown;
	          }
	        } // The context.catch method must only be called with a location
	        // argument that corresponds to a known catch block.


	        throw new Error("illegal catch attempt");
	      },
	      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
	        this.delegate = {
	          iterator: values(iterable),
	          resultName: resultName,
	          nextLoc: nextLoc
	        };

	        if (this.method === "next") {
	          // Deliberately forget the last sent value so that we don't
	          // accidentally pass it on to the delegate.
	          this.arg = undefined;
	        }

	        return ContinueSentinel;
	      }
	    }; // Regardless of whether this script is executing as a CommonJS module
	    // or not, return the runtime object so that we can declare the variable
	    // regeneratorRuntime in the outer scope, which allows this module to be
	    // injected easily by `bin/regenerator --include-runtime script.js`.

	    return exports;
	  }( // If this script is executing as a CommonJS module, use module.exports
	  // as the regeneratorRuntime namespace. Otherwise create a new empty
	  // object. Either way, the resulting object will be used to initialize
	  // the regeneratorRuntime variable at the top of this file.
	  module.exports);

	  try {
	    regeneratorRuntime = runtime;
	  } catch (accidentalStrictMode) {
	    // This module should not be running in strict mode, so the above
	    // assignment should always work unless something is misconfigured. Just
	    // in case runtime.js accidentally runs in strict mode, we can escape
	    // strict mode using a global Function call. This could conceivably fail
	    // if a Content Security Policy forbids using Function, but in that case
	    // the proper solution is to fix the accidental strict mode problem. If
	    // you've misconfigured your bundler to force strict mode and applied a
	    // CSP to forbid Function, and you're not willing to fix either of those
	    // problems, please detail your unique predicament in a GitHub issue.
	    Function("r", "regeneratorRuntime = r")(runtime);
	  }
	});

	var regenerator = runtime_1;

	function asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }

	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}

	function _asyncToGenerator$1(fn) {
	  return function () {
	    var self = this,
	        args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);

	      function _next(value) {
	        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "next", value);
	      }

	      function _throw(err) {
	        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "throw", err);
	      }

	      _next(undefined);
	    });
	  };
	}

	var asyncToGenerator = _asyncToGenerator$1;

	function _classCallCheck$1(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	var classCallCheck = _classCallCheck$1;

	function _defineProperties$1(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass$2(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties$1(Constructor, staticProps);
	  return Constructor;
	}

	var createClass$1 = _createClass$2;

	var TYPED = _uid('typed_array');
	var VIEW = _uid('view');
	var ABV = !!(_global.ArrayBuffer && _global.DataView);
	var CONSTR = ABV;
	var i$2 = 0;
	var l = 9;
	var Typed;

	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');

	while (i$2 < l) {
	  if (Typed = _global[TypedArrayConstructors[i$2++]]) {
	    _hide(Typed.prototype, TYPED, true);
	    _hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}

	var _typed = {
	  ABV: ABV,
	  CONSTR: CONSTR,
	  TYPED: TYPED,
	  VIEW: VIEW
	};

	// https://tc39.github.io/ecma262/#sec-toindex


	var _toIndex = function (it) {
	  if (it === undefined) return 0;
	  var number = _toInteger(it);
	  var length = _toLength(number);
	  if (number !== length) throw RangeError('Wrong length!');
	  return length;
	};

	var _typedBuffer = createCommonjsModule(function (module, exports) {











	var gOPN = _objectGopn.f;
	var dP = _objectDp.f;


	var ARRAY_BUFFER = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE = 'prototype';
	var WRONG_LENGTH = 'Wrong length!';
	var WRONG_INDEX = 'Wrong index!';
	var $ArrayBuffer = _global[ARRAY_BUFFER];
	var $DataView = _global[DATA_VIEW];
	var Math = _global.Math;
	var RangeError = _global.RangeError;
	// eslint-disable-next-line no-shadow-restricted-names
	var Infinity = _global.Infinity;
	var BaseBuffer = $ArrayBuffer;
	var abs = Math.abs;
	var pow = Math.pow;
	var floor = Math.floor;
	var log = Math.log;
	var LN2 = Math.LN2;
	var BUFFER = 'buffer';
	var BYTE_LENGTH = 'byteLength';
	var BYTE_OFFSET = 'byteOffset';
	var $BUFFER = _descriptors ? '_b' : BUFFER;
	var $LENGTH = _descriptors ? '_l' : BYTE_LENGTH;
	var $OFFSET = _descriptors ? '_o' : BYTE_OFFSET;

	// IEEE754 conversions based on https://github.com/feross/ieee754
	function packIEEE754(value, mLen, nBytes) {
	  var buffer = new Array(nBytes);
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
	  var i = 0;
	  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
	  var e, m, c;
	  value = abs(value);
	  // eslint-disable-next-line no-self-compare
	  if (value != value || value === Infinity) {
	    // eslint-disable-next-line no-self-compare
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if (value * (c = pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }
	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	}
	function unpackIEEE754(buffer, mLen, nBytes) {
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = eLen - 7;
	  var i = nBytes - 1;
	  var s = buffer[i--];
	  var e = s & 127;
	  var m;
	  s >>= 7;
	  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	}

	function unpackI32(bytes) {
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	}
	function packI8(it) {
	  return [it & 0xff];
	}
	function packI16(it) {
	  return [it & 0xff, it >> 8 & 0xff];
	}
	function packI32(it) {
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	}
	function packF64(it) {
	  return packIEEE754(it, 52, 8);
	}
	function packF32(it) {
	  return packIEEE754(it, 23, 4);
	}

	function addGetter(C, key, internal) {
	  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
	}

	function get(view, bytes, index, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = _toIndex(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	}
	function set(view, bytes, index, conversion, value, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = _toIndex(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = conversion(+value);
	  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	}

	if (!_typed.ABV) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    _anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
	    var byteLength = _toIndex(length);
	    this._b = _arrayFill.call(new Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };

	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    _anInstance(this, $DataView, DATA_VIEW);
	    _anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH];
	    var offset = _toInteger(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : _toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };

	  if (_descriptors) {
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }

	  _redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset) {
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /* , littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /* , littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if (!_fails(function () {
	    $ArrayBuffer(1);
	  }) || !_fails(function () {
	    new $ArrayBuffer(-1); // eslint-disable-line no-new
	  }) || _fails(function () {
	    new $ArrayBuffer(); // eslint-disable-line no-new
	    new $ArrayBuffer(1.5); // eslint-disable-line no-new
	    new $ArrayBuffer(NaN); // eslint-disable-line no-new
	    return $ArrayBuffer.name != ARRAY_BUFFER;
	  })) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      _anInstance(this, $ArrayBuffer);
	      return new BaseBuffer(_toIndex(length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
	      if (!((key = keys[j++]) in $ArrayBuffer)) _hide($ArrayBuffer, key, BaseBuffer[key]);
	    }
	    ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2));
	  var $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if (view.getInt8(0) || !view.getInt8(1)) _redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	_setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	_setToStringTag($DataView, DATA_VIEW);
	_hide($DataView[PROTOTYPE], _typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;
	});

	var _arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
	  var O = _toObject(this);
	  var len = _toLength(O.length);
	  var to = _toAbsoluteIndex(target, len);
	  var from = _toAbsoluteIndex(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = Math.min((end === undefined ? len : _toAbsoluteIndex(end, len)) - from, len - to);
	  var inc = 1;
	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }
	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];
	    else delete O[to];
	    to += inc;
	    from += inc;
	  } return O;
	};

	var _typedArray = createCommonjsModule(function (module) {
	if (_descriptors) {
	  var LIBRARY = _library;
	  var global = _global;
	  var fails = _fails;
	  var $export = _export;
	  var $typed = _typed;
	  var $buffer = _typedBuffer;
	  var ctx = _ctx;
	  var anInstance = _anInstance;
	  var propertyDesc = _propertyDesc;
	  var hide = _hide;
	  var redefineAll = _redefineAll;
	  var toInteger = _toInteger;
	  var toLength = _toLength;
	  var toIndex = _toIndex;
	  var toAbsoluteIndex = _toAbsoluteIndex;
	  var toPrimitive = _toPrimitive;
	  var has = _has;
	  var classof = _classof;
	  var isObject = _isObject;
	  var toObject = _toObject;
	  var isArrayIter = _isArrayIter;
	  var create = _objectCreate;
	  var getPrototypeOf = _objectGpo;
	  var gOPN = _objectGopn.f;
	  var getIterFn = core_getIteratorMethod;
	  var uid = _uid;
	  var wks = _wks;
	  var createArrayMethod = _arrayMethods;
	  var createArrayIncludes = _arrayIncludes;
	  var speciesConstructor = _speciesConstructor;
	  var ArrayIterators = es6_array_iterator;
	  var Iterators = _iterators;
	  var $iterDetect = _iterDetect;
	  var setSpecies = _setSpecies;
	  var arrayFill = _arrayFill;
	  var arrayCopyWithin = _arrayCopyWithin;
	  var $DP = _objectDp;
	  var $GOPD = _objectGopd;
	  var dP = $DP.f;
	  var gOPD = $GOPD.f;
	  var RangeError = global.RangeError;
	  var TypeError = global.TypeError;
	  var Uint8Array = global.Uint8Array;
	  var ARRAY_BUFFER = 'ArrayBuffer';
	  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
	  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	  var PROTOTYPE = 'prototype';
	  var ArrayProto = Array[PROTOTYPE];
	  var $ArrayBuffer = $buffer.ArrayBuffer;
	  var $DataView = $buffer.DataView;
	  var arrayForEach = createArrayMethod(0);
	  var arrayFilter = createArrayMethod(2);
	  var arraySome = createArrayMethod(3);
	  var arrayEvery = createArrayMethod(4);
	  var arrayFind = createArrayMethod(5);
	  var arrayFindIndex = createArrayMethod(6);
	  var arrayIncludes = createArrayIncludes(true);
	  var arrayIndexOf = createArrayIncludes(false);
	  var arrayValues = ArrayIterators.values;
	  var arrayKeys = ArrayIterators.keys;
	  var arrayEntries = ArrayIterators.entries;
	  var arrayLastIndexOf = ArrayProto.lastIndexOf;
	  var arrayReduce = ArrayProto.reduce;
	  var arrayReduceRight = ArrayProto.reduceRight;
	  var arrayJoin = ArrayProto.join;
	  var arraySort = ArrayProto.sort;
	  var arraySlice = ArrayProto.slice;
	  var arrayToString = ArrayProto.toString;
	  var arrayToLocaleString = ArrayProto.toLocaleString;
	  var ITERATOR = wks('iterator');
	  var TAG = wks('toStringTag');
	  var TYPED_CONSTRUCTOR = uid('typed_constructor');
	  var DEF_CONSTRUCTOR = uid('def_constructor');
	  var ALL_CONSTRUCTORS = $typed.CONSTR;
	  var TYPED_ARRAY = $typed.TYPED;
	  var VIEW = $typed.VIEW;
	  var WRONG_LENGTH = 'Wrong length!';

	  var $map = createArrayMethod(1, function (O, length) {
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });

	  var LITTLE_ENDIAN = fails(function () {
	    // eslint-disable-next-line no-undef
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });

	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
	    new Uint8Array(1).set({});
	  });

	  var toOffset = function (it, BYTES) {
	    var offset = toInteger(it);
	    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
	    return offset;
	  };

	  var validate = function (it) {
	    if (isObject(it) && TYPED_ARRAY in it) return it;
	    throw TypeError(it + ' is not a typed array!');
	  };

	  var allocate = function (C, length) {
	    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };

	  var speciesFromList = function (O, list) {
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };

	  var fromList = function (C, list) {
	    var index = 0;
	    var length = list.length;
	    var result = allocate(C, length);
	    while (length > index) result[index] = list[index++];
	    return result;
	  };

	  var addGetter = function (it, key, internal) {
	    dP(it, key, { get: function () { return this._d[internal]; } });
	  };

	  var $from = function from(source /* , mapfn, thisArg */) {
	    var O = toObject(source);
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var iterFn = getIterFn(O);
	    var i, length, values, result, step, iterator;
	    if (iterFn != undefined && !isArrayIter(iterFn)) {
	      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
	        values.push(step.value);
	      } O = values;
	    }
	    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
	    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };

	  var $of = function of(/* ...items */) {
	    var index = 0;
	    var length = arguments.length;
	    var result = allocate(this, length);
	    while (length > index) result[index] = arguments[index++];
	    return result;
	  };

	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

	  var $toLocaleString = function toLocaleString() {
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };

	  var proto = {
	    copyWithin: function copyWithin(target, start /* , end */) {
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /* , thisArg */) {
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /* , thisArg */) {
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /* , thisArg */) {
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /* , thisArg */) {
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /* , thisArg */) {
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /* , fromIndex */) {
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /* , fromIndex */) {
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator) { // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /* , thisArg */) {
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse() {
	      var that = this;
	      var length = validate(that).length;
	      var middle = Math.floor(length / 2);
	      var index = 0;
	      var value;
	      while (index < middle) {
	        value = that[index];
	        that[index++] = that[--length];
	        that[length] = value;
	      } return that;
	    },
	    some: function some(callbackfn /* , thisArg */) {
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn) {
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end) {
	      var O = validate(this);
	      var length = O.length;
	      var $begin = toAbsoluteIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
	      );
	    }
	  };

	  var $slice = function slice(start, end) {
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };

	  var $set = function set(arrayLike /* , offset */) {
	    validate(this);
	    var offset = toOffset(arguments[1], 1);
	    var length = this.length;
	    var src = toObject(arrayLike);
	    var len = toLength(src.length);
	    var index = 0;
	    if (len + offset > length) throw RangeError(WRONG_LENGTH);
	    while (index < len) this[offset + index] = src[index++];
	  };

	  var $iterators = {
	    entries: function entries() {
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys() {
	      return arrayKeys.call(validate(this));
	    },
	    values: function values() {
	      return arrayValues.call(validate(this));
	    }
	  };

	  var isTAIndex = function (target, key) {
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key) {
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc) {
	    if (isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ) {
	      target[key] = desc.value;
	      return target;
	    } return dP(target, key, desc);
	  };

	  if (!ALL_CONSTRUCTORS) {
	    $GOPD.f = $getDesc;
	    $DP.f = $setDesc;
	  }

	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty: $setDesc
	  });

	  if (fails(function () { arrayToString.call({}); })) {
	    arrayToString = arrayToLocaleString = function toString() {
	      return arrayJoin.call(this);
	    };
	  }

	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice: $slice,
	    set: $set,
	    constructor: function () { /* noop */ },
	    toString: arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function () { return this[TYPED_ARRAY]; }
	  });

	  // eslint-disable-next-line max-statements
	  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
	    CLAMPED = !!CLAMPED;
	    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
	    var GETTER = 'get' + KEY;
	    var SETTER = 'set' + KEY;
	    var TypedArray = global[NAME];
	    var Base = TypedArray || {};
	    var TAC = TypedArray && getPrototypeOf(TypedArray);
	    var FORCED = !TypedArray || !$typed.ABV;
	    var O = {};
	    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function (that, index) {
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function (that, index, value) {
	      var data = that._d;
	      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function (that, index) {
	      dP(that, index, {
	        get: function () {
	          return getter(this, index);
	        },
	        set: function (value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if (FORCED) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME, '_d');
	        var index = 0;
	        var offset = 0;
	        var buffer, byteLength, length, klass;
	        if (!isObject(data)) {
	          length = toIndex(data);
	          byteLength = length * BYTES;
	          buffer = new $ArrayBuffer(byteLength);
	        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if ($length === undefined) {
	            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if (TYPED_ARRAY in data) {
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while (index < length) addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if (!fails(function () {
	      TypedArray(1);
	    }) || !fails(function () {
	      new TypedArray(-1); // eslint-disable-line no-new
	    }) || !$iterDetect(function (iter) {
	      new TypedArray(); // eslint-disable-line no-new
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(1.5); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if (!isObject(data)) return new Base(toIndex(data));
	        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
	        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator = TypedArrayPrototype[ITERATOR];
	    var CORRECT_ITER_NAME = !!$nativeIterator
	      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
	    var $iterator = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

	    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
	      dP(TypedArrayPrototype, TAG, {
	        get: function () { return NAME; }
	      });
	    }

	    O[NAME] = TypedArray;

	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES
	    });

	    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
	      from: $from,
	      of: $of
	    });

	    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

	    $export($export.P, NAME, proto);

	    setSpecies(NAME);

	    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

	    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

	    $export($export.P + $export.F * fails(function () {
	      new TypedArray(1).slice();
	    }), NAME, { slice: $slice });

	    $export($export.P + $export.F * (fails(function () {
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
	    }) || !fails(function () {
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, { toLocaleString: $toLocaleString });

	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function () { /* empty */ };
	});

	_typedArray('Uint8', 1, function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	_export(_export.G + _export.W + _export.F * !_typed.ABV, {
	  DataView: _typedBuffer.DataView
	});

	var browserPonyfill = createCommonjsModule(function (module, exports) {
	  var __self__ = function (root) {
	    function F() {
	      this.fetch = false;
	    }

	    F.prototype = root;
	    return new F();
	  }(typeof self !== 'undefined' ? self : commonjsGlobal);

	  (function (self) {
	    var irrelevant = function (exports) {
	      var support = {
	        searchParams: 'URLSearchParams' in self,
	        iterable: 'Symbol' in self && 'iterator' in Symbol,
	        blob: 'FileReader' in self && 'Blob' in self && function () {
	          try {
	            new Blob();
	            return true;
	          } catch (e) {
	            return false;
	          }
	        }(),
	        formData: 'FormData' in self,
	        arrayBuffer: 'ArrayBuffer' in self
	      };

	      function isDataView(obj) {
	        return obj && DataView.prototype.isPrototypeOf(obj);
	      }

	      if (support.arrayBuffer) {
	        var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

	        var isArrayBufferView = ArrayBuffer.isView || function (obj) {
	          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
	        };
	      }

	      function normalizeName(name) {
	        if (typeof name !== 'string') {
	          name = String(name);
	        }

	        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
	          throw new TypeError('Invalid character in header field name');
	        }

	        return name.toLowerCase();
	      }

	      function normalizeValue(value) {
	        if (typeof value !== 'string') {
	          value = String(value);
	        }

	        return value;
	      } // Build a destructive iterator for the value list


	      function iteratorFor(items) {
	        var iterator = {
	          next: function next() {
	            var value = items.shift();
	            return {
	              done: value === undefined,
	              value: value
	            };
	          }
	        };

	        if (support.iterable) {
	          iterator[Symbol.iterator] = function () {
	            return iterator;
	          };
	        }

	        return iterator;
	      }

	      function Headers(headers) {
	        this.map = {};

	        if (headers instanceof Headers) {
	          headers.forEach(function (value, name) {
	            this.append(name, value);
	          }, this);
	        } else if (Array.isArray(headers)) {
	          headers.forEach(function (header) {
	            this.append(header[0], header[1]);
	          }, this);
	        } else if (headers) {
	          Object.getOwnPropertyNames(headers).forEach(function (name) {
	            this.append(name, headers[name]);
	          }, this);
	        }
	      }

	      Headers.prototype.append = function (name, value) {
	        name = normalizeName(name);
	        value = normalizeValue(value);
	        var oldValue = this.map[name];
	        this.map[name] = oldValue ? oldValue + ', ' + value : value;
	      };

	      Headers.prototype['delete'] = function (name) {
	        delete this.map[normalizeName(name)];
	      };

	      Headers.prototype.get = function (name) {
	        name = normalizeName(name);
	        return this.has(name) ? this.map[name] : null;
	      };

	      Headers.prototype.has = function (name) {
	        return this.map.hasOwnProperty(normalizeName(name));
	      };

	      Headers.prototype.set = function (name, value) {
	        this.map[normalizeName(name)] = normalizeValue(value);
	      };

	      Headers.prototype.forEach = function (callback, thisArg) {
	        for (var name in this.map) {
	          if (this.map.hasOwnProperty(name)) {
	            callback.call(thisArg, this.map[name], name, this);
	          }
	        }
	      };

	      Headers.prototype.keys = function () {
	        var items = [];
	        this.forEach(function (value, name) {
	          items.push(name);
	        });
	        return iteratorFor(items);
	      };

	      Headers.prototype.values = function () {
	        var items = [];
	        this.forEach(function (value) {
	          items.push(value);
	        });
	        return iteratorFor(items);
	      };

	      Headers.prototype.entries = function () {
	        var items = [];
	        this.forEach(function (value, name) {
	          items.push([name, value]);
	        });
	        return iteratorFor(items);
	      };

	      if (support.iterable) {
	        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
	      }

	      function consumed(body) {
	        if (body.bodyUsed) {
	          return Promise.reject(new TypeError('Already read'));
	        }

	        body.bodyUsed = true;
	      }

	      function fileReaderReady(reader) {
	        return new Promise(function (resolve, reject) {
	          reader.onload = function () {
	            resolve(reader.result);
	          };

	          reader.onerror = function () {
	            reject(reader.error);
	          };
	        });
	      }

	      function readBlobAsArrayBuffer(blob) {
	        var reader = new FileReader();
	        var promise = fileReaderReady(reader);
	        reader.readAsArrayBuffer(blob);
	        return promise;
	      }

	      function readBlobAsText(blob) {
	        var reader = new FileReader();
	        var promise = fileReaderReady(reader);
	        reader.readAsText(blob);
	        return promise;
	      }

	      function readArrayBufferAsText(buf) {
	        var view = new Uint8Array(buf);
	        var chars = new Array(view.length);

	        for (var i = 0; i < view.length; i++) {
	          chars[i] = String.fromCharCode(view[i]);
	        }

	        return chars.join('');
	      }

	      function bufferClone(buf) {
	        if (buf.slice) {
	          return buf.slice(0);
	        } else {
	          var view = new Uint8Array(buf.byteLength);
	          view.set(new Uint8Array(buf));
	          return view.buffer;
	        }
	      }

	      function Body() {
	        this.bodyUsed = false;

	        this._initBody = function (body) {
	          this._bodyInit = body;

	          if (!body) {
	            this._bodyText = '';
	          } else if (typeof body === 'string') {
	            this._bodyText = body;
	          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	            this._bodyBlob = body;
	          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	            this._bodyFormData = body;
	          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	            this._bodyText = body.toString();
	          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	            this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.

	            this._bodyInit = new Blob([this._bodyArrayBuffer]);
	          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	            this._bodyArrayBuffer = bufferClone(body);
	          } else {
	            this._bodyText = body = Object.prototype.toString.call(body);
	          }

	          if (!this.headers.get('content-type')) {
	            if (typeof body === 'string') {
	              this.headers.set('content-type', 'text/plain;charset=UTF-8');
	            } else if (this._bodyBlob && this._bodyBlob.type) {
	              this.headers.set('content-type', this._bodyBlob.type);
	            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	              this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	            }
	          }
	        };

	        if (support.blob) {
	          this.blob = function () {
	            var rejected = consumed(this);

	            if (rejected) {
	              return rejected;
	            }

	            if (this._bodyBlob) {
	              return Promise.resolve(this._bodyBlob);
	            } else if (this._bodyArrayBuffer) {
	              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
	            } else if (this._bodyFormData) {
	              throw new Error('could not read FormData body as blob');
	            } else {
	              return Promise.resolve(new Blob([this._bodyText]));
	            }
	          };

	          this.arrayBuffer = function () {
	            if (this._bodyArrayBuffer) {
	              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
	            } else {
	              return this.blob().then(readBlobAsArrayBuffer);
	            }
	          };
	        }

	        this.text = function () {
	          var rejected = consumed(this);

	          if (rejected) {
	            return rejected;
	          }

	          if (this._bodyBlob) {
	            return readBlobAsText(this._bodyBlob);
	          } else if (this._bodyArrayBuffer) {
	            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
	          } else if (this._bodyFormData) {
	            throw new Error('could not read FormData body as text');
	          } else {
	            return Promise.resolve(this._bodyText);
	          }
	        };

	        if (support.formData) {
	          this.formData = function () {
	            return this.text().then(decode);
	          };
	        }

	        this.json = function () {
	          return this.text().then(JSON.parse);
	        };

	        return this;
	      } // HTTP methods whose capitalization should be normalized


	      var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

	      function normalizeMethod(method) {
	        var upcased = method.toUpperCase();
	        return methods.indexOf(upcased) > -1 ? upcased : method;
	      }

	      function Request(input, options) {
	        options = options || {};
	        var body = options.body;

	        if (input instanceof Request) {
	          if (input.bodyUsed) {
	            throw new TypeError('Already read');
	          }

	          this.url = input.url;
	          this.credentials = input.credentials;

	          if (!options.headers) {
	            this.headers = new Headers(input.headers);
	          }

	          this.method = input.method;
	          this.mode = input.mode;
	          this.signal = input.signal;

	          if (!body && input._bodyInit != null) {
	            body = input._bodyInit;
	            input.bodyUsed = true;
	          }
	        } else {
	          this.url = String(input);
	        }

	        this.credentials = options.credentials || this.credentials || 'same-origin';

	        if (options.headers || !this.headers) {
	          this.headers = new Headers(options.headers);
	        }

	        this.method = normalizeMethod(options.method || this.method || 'GET');
	        this.mode = options.mode || this.mode || null;
	        this.signal = options.signal || this.signal;
	        this.referrer = null;

	        if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	          throw new TypeError('Body not allowed for GET or HEAD requests');
	        }

	        this._initBody(body);
	      }

	      Request.prototype.clone = function () {
	        return new Request(this, {
	          body: this._bodyInit
	        });
	      };

	      function decode(body) {
	        var form = new FormData();
	        body.trim().split('&').forEach(function (bytes) {
	          if (bytes) {
	            var split = bytes.split('=');
	            var name = split.shift().replace(/\+/g, ' ');
	            var value = split.join('=').replace(/\+/g, ' ');
	            form.append(decodeURIComponent(name), decodeURIComponent(value));
	          }
	        });
	        return form;
	      }

	      function parseHeaders(rawHeaders) {
	        var headers = new Headers(); // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
	        // https://tools.ietf.org/html/rfc7230#section-3.2

	        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
	        preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
	          var parts = line.split(':');
	          var key = parts.shift().trim();

	          if (key) {
	            var value = parts.join(':').trim();
	            headers.append(key, value);
	          }
	        });
	        return headers;
	      }

	      Body.call(Request.prototype);

	      function Response(bodyInit, options) {
	        if (!options) {
	          options = {};
	        }

	        this.type = 'default';
	        this.status = options.status === undefined ? 200 : options.status;
	        this.ok = this.status >= 200 && this.status < 300;
	        this.statusText = 'statusText' in options ? options.statusText : 'OK';
	        this.headers = new Headers(options.headers);
	        this.url = options.url || '';

	        this._initBody(bodyInit);
	      }

	      Body.call(Response.prototype);

	      Response.prototype.clone = function () {
	        return new Response(this._bodyInit, {
	          status: this.status,
	          statusText: this.statusText,
	          headers: new Headers(this.headers),
	          url: this.url
	        });
	      };

	      Response.error = function () {
	        var response = new Response(null, {
	          status: 0,
	          statusText: ''
	        });
	        response.type = 'error';
	        return response;
	      };

	      var redirectStatuses = [301, 302, 303, 307, 308];

	      Response.redirect = function (url, status) {
	        if (redirectStatuses.indexOf(status) === -1) {
	          throw new RangeError('Invalid status code');
	        }

	        return new Response(null, {
	          status: status,
	          headers: {
	            location: url
	          }
	        });
	      };

	      exports.DOMException = self.DOMException;

	      try {
	        new exports.DOMException();
	      } catch (err) {
	        exports.DOMException = function (message, name) {
	          this.message = message;
	          this.name = name;
	          var error = Error(message);
	          this.stack = error.stack;
	        };

	        exports.DOMException.prototype = Object.create(Error.prototype);
	        exports.DOMException.prototype.constructor = exports.DOMException;
	      }

	      function fetch(input, init) {
	        return new Promise(function (resolve, reject) {
	          var request = new Request(input, init);

	          if (request.signal && request.signal.aborted) {
	            return reject(new exports.DOMException('Aborted', 'AbortError'));
	          }

	          var xhr = new XMLHttpRequest();

	          function abortXhr() {
	            xhr.abort();
	          }

	          xhr.onload = function () {
	            var options = {
	              status: xhr.status,
	              statusText: xhr.statusText,
	              headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	            };
	            options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
	            var body = 'response' in xhr ? xhr.response : xhr.responseText;
	            resolve(new Response(body, options));
	          };

	          xhr.onerror = function () {
	            reject(new TypeError('Network request failed'));
	          };

	          xhr.ontimeout = function () {
	            reject(new TypeError('Network request failed'));
	          };

	          xhr.onabort = function () {
	            reject(new exports.DOMException('Aborted', 'AbortError'));
	          };

	          xhr.open(request.method, request.url, true);

	          if (request.credentials === 'include') {
	            xhr.withCredentials = true;
	          } else if (request.credentials === 'omit') {
	            xhr.withCredentials = false;
	          }

	          if ('responseType' in xhr && support.blob) {
	            xhr.responseType = 'blob';
	          }

	          request.headers.forEach(function (value, name) {
	            xhr.setRequestHeader(name, value);
	          });

	          if (request.signal) {
	            request.signal.addEventListener('abort', abortXhr);

	            xhr.onreadystatechange = function () {
	              // DONE (success or failure)
	              if (xhr.readyState === 4) {
	                request.signal.removeEventListener('abort', abortXhr);
	              }
	            };
	          }

	          xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
	        });
	      }

	      fetch.polyfill = true;

	      if (!self.fetch) {
	        self.fetch = fetch;
	        self.Headers = Headers;
	        self.Request = Request;
	        self.Response = Response;
	      }

	      exports.Headers = Headers;
	      exports.Request = Request;
	      exports.Response = Response;
	      exports.fetch = fetch;
	      return exports;
	    }({});
	  })(__self__);

	  delete __self__.fetch.polyfill;
	  exports = __self__.fetch; // To enable: import fetch from 'cross-fetch'

	  exports.default = __self__.fetch; // For TypeScript consumers without esModuleInterop.

	  exports.fetch = __self__.fetch; // To enable: import {fetch} from 'cross-fetch'

	  exports.Headers = __self__.Headers;
	  exports.Request = __self__.Request;
	  exports.Response = __self__.Response;
	  module.exports = exports;
	});
	var browserPonyfill_1 = browserPonyfill.fetch;
	var browserPonyfill_2 = browserPonyfill.Headers;
	var browserPonyfill_3 = browserPonyfill.Request;
	var browserPonyfill_4 = browserPonyfill.Response;

	function _defineProperty$1(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	var defineProperty$1 = _defineProperty$1;

	function _objectSpread$1(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? arguments[i] : {};
	    var ownKeys = Object.keys(source);

	    if (typeof Object.getOwnPropertySymbols === 'function') {
	      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
	        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
	      }));
	    }

	    ownKeys.forEach(function (key) {
	      defineProperty$1(target, key, source[key]);
	    });
	  }

	  return target;
	}

	var objectSpread = _objectSpread$1;

	function _arrayWithHoles$1(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	var arrayWithHoles = _arrayWithHoles$1;

	function _iterableToArrayLimit$1(arr, i) {
	  var _arr = [];
	  var _n = true;
	  var _d = false;
	  var _e = undefined;

	  try {
	    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	var iterableToArrayLimit = _iterableToArrayLimit$1;

	function _nonIterableRest$1() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance");
	}

	var nonIterableRest = _nonIterableRest$1;

	function _slicedToArray$1(arr, i) {
	  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
	}

	var slicedToArray = _slicedToArray$1;

	function _objectWithoutPropertiesLoose$1(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;

	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }

	  return target;
	}

	var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose$1;

	function _objectWithoutProperties$1(source, excluded) {
	  if (source == null) return {};
	  var target = objectWithoutPropertiesLoose(source, excluded);
	  var key, i;

	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	      target[key] = source[key];
	    }
	  }

	  return target;
	}

	var objectWithoutProperties = _objectWithoutProperties$1;

	function _isPlaceholder(a) {
	  return a != null && _typeof(a) === 'object' && a['@@functional/placeholder'] === true;
	}

	/**
	 * Optimized internal one-arity curry function.
	 *
	 * @private
	 * @category Function
	 * @param {Function} fn The function to curry.
	 * @return {Function} The curried function.
	 */

	function _curry1(fn) {
	  return function f1(a) {
	    if (arguments.length === 0 || _isPlaceholder(a)) {
	      return f1;
	    } else {
	      return fn.apply(this, arguments);
	    }
	  };
	}

	/**
	 * Returns a function that always returns the given value. Note that for
	 * non-primitives the value returned is a reference to the original value.
	 *
	 * This function is known as `const`, `constant`, or `K` (for K combinator) in
	 * other languages and libraries.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig a -> (* -> a)
	 * @param {*} val The value to wrap in a function
	 * @return {Function} A Function :: * -> val.
	 * @example
	 *
	 *      var t = R.always('Tee');
	 *      t(); //=> 'Tee'
	 */

	var always =
	/*#__PURE__*/
	_curry1(function always(val) {
	  return function () {
	    return val;
	  };
	});

	/**
	 * A function that always returns `false`. Any passed in parameters are ignored.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Function
	 * @sig * -> Boolean
	 * @param {*}
	 * @return {Boolean}
	 * @see R.always, R.T
	 * @example
	 *
	 *      R.F(); //=> false
	 */

	var F =
	/*#__PURE__*/
	always(false);

	/**
	 * A function that always returns `true`. Any passed in parameters are ignored.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Function
	 * @sig * -> Boolean
	 * @param {*}
	 * @return {Boolean}
	 * @see R.always, R.F
	 * @example
	 *
	 *      R.T(); //=> true
	 */

	var T =
	/*#__PURE__*/
	always(true);

	/**
	 * A special placeholder value used to specify "gaps" within curried functions,
	 * allowing partial application of any combination of arguments, regardless of
	 * their positions.
	 *
	 * If `g` is a curried ternary function and `_` is `R.__`, the following are
	 * equivalent:
	 *
	 *   - `g(1, 2, 3)`
	 *   - `g(_, 2, 3)(1)`
	 *   - `g(_, _, 3)(1)(2)`
	 *   - `g(_, _, 3)(1, 2)`
	 *   - `g(_, 2, _)(1, 3)`
	 *   - `g(_, 2)(1)(3)`
	 *   - `g(_, 2)(1, 3)`
	 *   - `g(_, 2)(_, 3)(1)`
	 *
	 * @constant
	 * @memberOf R
	 * @since v0.6.0
	 * @category Function
	 * @example
	 *
	 *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
	 *      greet('Alice'); //=> 'Hello, Alice!'
	 */
	var __ = {
	  '@@functional/placeholder': true
	};

	/**
	 * Optimized internal two-arity curry function.
	 *
	 * @private
	 * @category Function
	 * @param {Function} fn The function to curry.
	 * @return {Function} The curried function.
	 */

	function _curry2(fn) {
	  return function f2(a, b) {
	    switch (arguments.length) {
	      case 0:
	        return f2;

	      case 1:
	        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
	          return fn(a, _b);
	        });

	      default:
	        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
	          return fn(_a, b);
	        }) : _isPlaceholder(b) ? _curry1(function (_b) {
	          return fn(a, _b);
	        }) : fn(a, b);
	    }
	  };
	}

	/**
	 * Adds two values.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Math
	 * @sig Number -> Number -> Number
	 * @param {Number} a
	 * @param {Number} b
	 * @return {Number}
	 * @see R.subtract
	 * @example
	 *
	 *      R.add(2, 3);       //=>  5
	 *      R.add(7)(10);      //=> 17
	 */

	var add =
	/*#__PURE__*/
	_curry2(function add(a, b) {
	  return Number(a) + Number(b);
	});

	/**
	 * Private `concat` function to merge two array-like objects.
	 *
	 * @private
	 * @param {Array|Arguments} [set1=[]] An array-like object.
	 * @param {Array|Arguments} [set2=[]] An array-like object.
	 * @return {Array} A new, merged array.
	 * @example
	 *
	 *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	 */
	function _concat(set1, set2) {
	  set1 = set1 || [];
	  set2 = set2 || [];
	  var idx;
	  var len1 = set1.length;
	  var len2 = set2.length;
	  var result = [];
	  idx = 0;

	  while (idx < len1) {
	    result[result.length] = set1[idx];
	    idx += 1;
	  }

	  idx = 0;

	  while (idx < len2) {
	    result[result.length] = set2[idx];
	    idx += 1;
	  }

	  return result;
	}

	function _arity(n, fn) {
	  /* eslint-disable no-unused-vars */
	  switch (n) {
	    case 0:
	      return function () {
	        return fn.apply(this, arguments);
	      };

	    case 1:
	      return function (a0) {
	        return fn.apply(this, arguments);
	      };

	    case 2:
	      return function (a0, a1) {
	        return fn.apply(this, arguments);
	      };

	    case 3:
	      return function (a0, a1, a2) {
	        return fn.apply(this, arguments);
	      };

	    case 4:
	      return function (a0, a1, a2, a3) {
	        return fn.apply(this, arguments);
	      };

	    case 5:
	      return function (a0, a1, a2, a3, a4) {
	        return fn.apply(this, arguments);
	      };

	    case 6:
	      return function (a0, a1, a2, a3, a4, a5) {
	        return fn.apply(this, arguments);
	      };

	    case 7:
	      return function (a0, a1, a2, a3, a4, a5, a6) {
	        return fn.apply(this, arguments);
	      };

	    case 8:
	      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	        return fn.apply(this, arguments);
	      };

	    case 9:
	      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	        return fn.apply(this, arguments);
	      };

	    case 10:
	      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	        return fn.apply(this, arguments);
	      };

	    default:
	      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
	  }
	}

	/**
	 * Internal curryN function.
	 *
	 * @private
	 * @category Function
	 * @param {Number} length The arity of the curried function.
	 * @param {Array} received An array of arguments received thus far.
	 * @param {Function} fn The function to curry.
	 * @return {Function} The curried function.
	 */

	function _curryN(length, received, fn) {
	  return function () {
	    var combined = [];
	    var argsIdx = 0;
	    var left = length;
	    var combinedIdx = 0;

	    while (combinedIdx < received.length || argsIdx < arguments.length) {
	      var result;

	      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
	        result = received[combinedIdx];
	      } else {
	        result = arguments[argsIdx];
	        argsIdx += 1;
	      }

	      combined[combinedIdx] = result;

	      if (!_isPlaceholder(result)) {
	        left -= 1;
	      }

	      combinedIdx += 1;
	    }

	    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
	  };
	}

	/**
	 * Returns a curried equivalent of the provided function, with the specified
	 * arity. The curried function has two unusual capabilities. First, its
	 * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
	 * following are equivalent:
	 *
	 *   - `g(1)(2)(3)`
	 *   - `g(1)(2, 3)`
	 *   - `g(1, 2)(3)`
	 *   - `g(1, 2, 3)`
	 *
	 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
	 * "gaps", allowing partial application of any combination of arguments,
	 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
	 * the following are equivalent:
	 *
	 *   - `g(1, 2, 3)`
	 *   - `g(_, 2, 3)(1)`
	 *   - `g(_, _, 3)(1)(2)`
	 *   - `g(_, _, 3)(1, 2)`
	 *   - `g(_, 2)(1)(3)`
	 *   - `g(_, 2)(1, 3)`
	 *   - `g(_, 2)(_, 3)(1)`
	 *
	 * @func
	 * @memberOf R
	 * @since v0.5.0
	 * @category Function
	 * @sig Number -> (* -> a) -> (* -> a)
	 * @param {Number} length The arity for the returned function.
	 * @param {Function} fn The function to curry.
	 * @return {Function} A new, curried function.
	 * @see R.curry
	 * @example
	 *
	 *      var sumArgs = (...args) => R.sum(args);
	 *
	 *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
	 *      var f = curriedAddFourNumbers(1, 2);
	 *      var g = f(3);
	 *      g(4); //=> 10
	 */

	var curryN =
	/*#__PURE__*/
	_curry2(function curryN(length, fn) {
	  if (length === 1) {
	    return _curry1(fn);
	  }

	  return _arity(length, _curryN(length, [], fn));
	});

	/**
	 * Creates a new list iteration function from an existing one by adding two new
	 * parameters to its callback function: the current index, and the entire list.
	 *
	 * This would turn, for instance, [`R.map`](#map) function into one that
	 * more closely resembles `Array.prototype.map`. Note that this will only work
	 * for functions in which the iteration callback function is the first
	 * parameter, and where the list is the last parameter. (This latter might be
	 * unimportant if the list parameter is not used.)
	 *
	 * @func
	 * @memberOf R
	 * @since v0.15.0
	 * @category Function
	 * @category List
	 * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
	 * @param {Function} fn A list iteration function that does not pass index or list to its callback
	 * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
	 * @example
	 *
	 *      var mapIndexed = R.addIndex(R.map);
	 *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
	 *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
	 */

	var addIndex =
	/*#__PURE__*/
	_curry1(function addIndex(fn) {
	  return curryN(fn.length, function () {
	    var idx = 0;
	    var origFn = arguments[0];
	    var list = arguments[arguments.length - 1];
	    var args = Array.prototype.slice.call(arguments, 0);

	    args[0] = function () {
	      var result = origFn.apply(this, _concat(arguments, [idx, list]));
	      idx += 1;
	      return result;
	    };

	    return fn.apply(this, args);
	  });
	});

	/**
	 * Optimized internal three-arity curry function.
	 *
	 * @private
	 * @category Function
	 * @param {Function} fn The function to curry.
	 * @return {Function} The curried function.
	 */

	function _curry3(fn) {
	  return function f3(a, b, c) {
	    switch (arguments.length) {
	      case 0:
	        return f3;

	      case 1:
	        return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
	          return fn(a, _b, _c);
	        });

	      case 2:
	        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
	          return fn(_a, b, _c);
	        }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
	          return fn(a, _b, _c);
	        }) : _curry1(function (_c) {
	          return fn(a, b, _c);
	        });

	      default:
	        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
	          return fn(_a, _b, c);
	        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
	          return fn(_a, b, _c);
	        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
	          return fn(a, _b, _c);
	        }) : _isPlaceholder(a) ? _curry1(function (_a) {
	          return fn(_a, b, c);
	        }) : _isPlaceholder(b) ? _curry1(function (_b) {
	          return fn(a, _b, c);
	        }) : _isPlaceholder(c) ? _curry1(function (_c) {
	          return fn(a, b, _c);
	        }) : fn(a, b, c);
	    }
	  };
	}

	/**
	 * Applies a function to the value at the given index of an array, returning a
	 * new copy of the array with the element at the given index replaced with the
	 * result of the function application.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category List
	 * @sig (a -> a) -> Number -> [a] -> [a]
	 * @param {Function} fn The function to apply.
	 * @param {Number} idx The index.
	 * @param {Array|Arguments} list An array-like object whose value
	 *        at the supplied index will be replaced.
	 * @return {Array} A copy of the supplied array-like object with
	 *         the element at index `idx` replaced with the value
	 *         returned by applying `fn` to the existing element.
	 * @see R.update
	 * @example
	 *
	 *      R.adjust(R.add(10), 1, [1, 2, 3]);     //=> [1, 12, 3]
	 *      R.adjust(R.add(10))(1)([1, 2, 3]);     //=> [1, 12, 3]
	 * @symb R.adjust(f, -1, [a, b]) = [a, f(b)]
	 * @symb R.adjust(f, 0, [a, b]) = [f(a), b]
	 */

	var adjust =
	/*#__PURE__*/
	_curry3(function adjust(fn, idx, list) {
	  if (idx >= list.length || idx < -list.length) {
	    return list;
	  }

	  var start = idx < 0 ? list.length : 0;

	  var _idx = start + idx;

	  var _list = _concat(list);

	  _list[_idx] = fn(list[_idx]);
	  return _list;
	});

	/**
	 * Tests whether or not an object is an array.
	 *
	 * @private
	 * @param {*} val The object to test.
	 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
	 * @example
	 *
	 *      _isArray([]); //=> true
	 *      _isArray(null); //=> false
	 *      _isArray({}); //=> false
	 */
	var _isArray$1 = Array.isArray || function _isArray(val) {
	  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
	};

	function _isTransformer(obj) {
	  return typeof obj['@@transducer/step'] === 'function';
	}

	/**
	 * Returns a function that dispatches with different strategies based on the
	 * object in list position (last argument). If it is an array, executes [fn].
	 * Otherwise, if it has a function with one of the given method names, it will
	 * execute that function (functor case). Otherwise, if it is a transformer,
	 * uses transducer [xf] to return a new transformer (transducer case).
	 * Otherwise, it will default to executing [fn].
	 *
	 * @private
	 * @param {Array} methodNames properties to check for a custom implementation
	 * @param {Function} xf transducer to initialize if object is transformer
	 * @param {Function} fn default ramda implementation
	 * @return {Function} A function that dispatches on object in list position
	 */

	function _dispatchable(methodNames, xf, fn) {
	  return function () {
	    if (arguments.length === 0) {
	      return fn();
	    }

	    var args = Array.prototype.slice.call(arguments, 0);
	    var obj = args.pop();

	    if (!_isArray$1(obj)) {
	      var idx = 0;

	      while (idx < methodNames.length) {
	        if (typeof obj[methodNames[idx]] === 'function') {
	          return obj[methodNames[idx]].apply(obj, args);
	        }

	        idx += 1;
	      }

	      if (_isTransformer(obj)) {
	        var transducer = xf.apply(null, args);
	        return transducer(obj);
	      }
	    }

	    return fn.apply(this, arguments);
	  };
	}

	function _reduced(x) {
	  return x && x['@@transducer/reduced'] ? x : {
	    '@@transducer/value': x,
	    '@@transducer/reduced': true
	  };
	}

	var _xfBase = {
	  init: function init() {
	    return this.xf['@@transducer/init']();
	  },
	  result: function result(_result) {
	    return this.xf['@@transducer/result'](_result);
	  }
	};

	var XAll =
	/*#__PURE__*/
	function () {
	  function XAll(f, xf) {
	    this.xf = xf;
	    this.f = f;
	    this.all = true;
	  }

	  XAll.prototype['@@transducer/init'] = _xfBase.init;

	  XAll.prototype['@@transducer/result'] = function (result) {
	    if (this.all) {
	      result = this.xf['@@transducer/step'](result, true);
	    }

	    return this.xf['@@transducer/result'](result);
	  };

	  XAll.prototype['@@transducer/step'] = function (result, input) {
	    if (!this.f(input)) {
	      this.all = false;
	      result = _reduced(this.xf['@@transducer/step'](result, false));
	    }

	    return result;
	  };

	  return XAll;
	}();

	var _xall =
	/*#__PURE__*/
	_curry2(function _xall(f, xf) {
	  return new XAll(f, xf);
	});

	/**
	 * Returns `true` if all elements of the list match the predicate, `false` if
	 * there are any that don't.
	 *
	 * Dispatches to the `all` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> Boolean
	 * @param {Function} fn The predicate function.
	 * @param {Array} list The array to consider.
	 * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
	 *         otherwise.
	 * @see R.any, R.none, R.transduce
	 * @example
	 *
	 *      var equals3 = R.equals(3);
	 *      R.all(equals3)([3, 3, 3, 3]); //=> true
	 *      R.all(equals3)([3, 3, 1, 3]); //=> false
	 */

	var all =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable(['all'], _xall, function all(fn, list) {
	  var idx = 0;

	  while (idx < list.length) {
	    if (!fn(list[idx])) {
	      return false;
	    }

	    idx += 1;
	  }

	  return true;
	}));

	/**
	 * Returns the larger of its two arguments.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig Ord a => a -> a -> a
	 * @param {*} a
	 * @param {*} b
	 * @return {*}
	 * @see R.maxBy, R.min
	 * @example
	 *
	 *      R.max(789, 123); //=> 789
	 *      R.max('a', 'b'); //=> 'b'
	 */

	var max$3 =
	/*#__PURE__*/
	_curry2(function max(a, b) {
	  return b > a ? b : a;
	});

	function _map(fn, functor) {
	  var idx = 0;
	  var len = functor.length;
	  var result = Array(len);

	  while (idx < len) {
	    result[idx] = fn(functor[idx]);
	    idx += 1;
	  }

	  return result;
	}

	function _isString(x) {
	  return Object.prototype.toString.call(x) === '[object String]';
	}

	/**
	 * Tests whether or not an object is similar to an array.
	 *
	 * @private
	 * @category Type
	 * @category List
	 * @sig * -> Boolean
	 * @param {*} x The object to test.
	 * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
	 * @example
	 *
	 *      _isArrayLike([]); //=> true
	 *      _isArrayLike(true); //=> false
	 *      _isArrayLike({}); //=> false
	 *      _isArrayLike({length: 10}); //=> false
	 *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
	 */

	var _isArrayLike =
	/*#__PURE__*/
	_curry1(function isArrayLike(x) {
	  if (_isArray$1(x)) {
	    return true;
	  }

	  if (!x) {
	    return false;
	  }

	  if (_typeof(x) !== 'object') {
	    return false;
	  }

	  if (_isString(x)) {
	    return false;
	  }

	  if (x.nodeType === 1) {
	    return !!x.length;
	  }

	  if (x.length === 0) {
	    return true;
	  }

	  if (x.length > 0) {
	    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
	  }

	  return false;
	});

	var XWrap =
	/*#__PURE__*/
	function () {
	  function XWrap(fn) {
	    this.f = fn;
	  }

	  XWrap.prototype['@@transducer/init'] = function () {
	    throw new Error('init not implemented on XWrap');
	  };

	  XWrap.prototype['@@transducer/result'] = function (acc) {
	    return acc;
	  };

	  XWrap.prototype['@@transducer/step'] = function (acc, x) {
	    return this.f(acc, x);
	  };

	  return XWrap;
	}();

	function _xwrap(fn) {
	  return new XWrap(fn);
	}

	/**
	 * Creates a function that is bound to a context.
	 * Note: `R.bind` does not provide the additional argument-binding capabilities of
	 * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.6.0
	 * @category Function
	 * @category Object
	 * @sig (* -> *) -> {*} -> (* -> *)
	 * @param {Function} fn The function to bind to context
	 * @param {Object} thisObj The context to bind `fn` to
	 * @return {Function} A function that will execute in the context of `thisObj`.
	 * @see R.partial
	 * @example
	 *
	 *      var log = R.bind(console.log, console);
	 *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
	 *      // logs {a: 2}
	 * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
	 */

	var bind$1 =
	/*#__PURE__*/
	_curry2(function bind(fn, thisObj) {
	  return _arity(fn.length, function () {
	    return fn.apply(thisObj, arguments);
	  });
	});

	function _arrayReduce$1(xf, acc, list) {
	  var idx = 0;
	  var len = list.length;

	  while (idx < len) {
	    acc = xf['@@transducer/step'](acc, list[idx]);

	    if (acc && acc['@@transducer/reduced']) {
	      acc = acc['@@transducer/value'];
	      break;
	    }

	    idx += 1;
	  }

	  return xf['@@transducer/result'](acc);
	}

	function _iterableReduce(xf, acc, iter) {
	  var step = iter.next();

	  while (!step.done) {
	    acc = xf['@@transducer/step'](acc, step.value);

	    if (acc && acc['@@transducer/reduced']) {
	      acc = acc['@@transducer/value'];
	      break;
	    }

	    step = iter.next();
	  }

	  return xf['@@transducer/result'](acc);
	}

	function _methodReduce(xf, acc, obj, methodName) {
	  return xf['@@transducer/result'](obj[methodName](bind$1(xf['@@transducer/step'], xf), acc));
	}

	var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
	function _reduce(fn, acc, list) {
	  if (typeof fn === 'function') {
	    fn = _xwrap(fn);
	  }

	  if (_isArrayLike(list)) {
	    return _arrayReduce$1(fn, acc, list);
	  }

	  if (typeof list['fantasy-land/reduce'] === 'function') {
	    return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
	  }

	  if (list[symIterator] != null) {
	    return _iterableReduce(fn, acc, list[symIterator]());
	  }

	  if (typeof list.next === 'function') {
	    return _iterableReduce(fn, acc, list);
	  }

	  if (typeof list.reduce === 'function') {
	    return _methodReduce(fn, acc, list, 'reduce');
	  }

	  throw new TypeError('reduce: list must be array or iterable');
	}

	var XMap =
	/*#__PURE__*/
	function () {
	  function XMap(f, xf) {
	    this.xf = xf;
	    this.f = f;
	  }

	  XMap.prototype['@@transducer/init'] = _xfBase.init;
	  XMap.prototype['@@transducer/result'] = _xfBase.result;

	  XMap.prototype['@@transducer/step'] = function (result, input) {
	    return this.xf['@@transducer/step'](result, this.f(input));
	  };

	  return XMap;
	}();

	var _xmap =
	/*#__PURE__*/
	_curry2(function _xmap(f, xf) {
	  return new XMap(f, xf);
	});

	function _has$1(prop, obj) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	var toString$3 = Object.prototype.toString;

	var _isArguments = function _isArguments() {
	  return toString$3.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
	    return toString$3.call(x) === '[object Arguments]';
	  } : function _isArguments(x) {
	    return _has$1('callee', x);
	  };
	};

	var hasEnumBug = !
	/*#__PURE__*/
	{
	  toString: null
	}.propertyIsEnumerable('toString');
	var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug

	var hasArgsEnumBug =
	/*#__PURE__*/
	function () {

	  return arguments.propertyIsEnumerable('length');
	}();

	var contains = function contains(list, item) {
	  var idx = 0;

	  while (idx < list.length) {
	    if (list[idx] === item) {
	      return true;
	    }

	    idx += 1;
	  }

	  return false;
	};
	/**
	 * Returns a list containing the names of all the enumerable own properties of
	 * the supplied object.
	 * Note that the order of the output array is not guaranteed to be consistent
	 * across different JS platforms.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig {k: v} -> [k]
	 * @param {Object} obj The object to extract properties from
	 * @return {Array} An array of the object's own properties.
	 * @see R.keysIn, R.values
	 * @example
	 *
	 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
	 */


	var _keys = typeof Object.keys === 'function' && !hasArgsEnumBug ? function keys(obj) {
	  return Object(obj) !== obj ? [] : Object.keys(obj);
	} : function keys(obj) {
	  if (Object(obj) !== obj) {
	    return [];
	  }

	  var prop, nIdx;
	  var ks = [];

	  var checkArgsLength = hasArgsEnumBug && _isArguments(obj);

	  for (prop in obj) {
	    if (_has$1(prop, obj) && (!checkArgsLength || prop !== 'length')) {
	      ks[ks.length] = prop;
	    }
	  }

	  if (hasEnumBug) {
	    nIdx = nonEnumerableProps.length - 1;

	    while (nIdx >= 0) {
	      prop = nonEnumerableProps[nIdx];

	      if (_has$1(prop, obj) && !contains(ks, prop)) {
	        ks[ks.length] = prop;
	      }

	      nIdx -= 1;
	    }
	  }

	  return ks;
	};

	var keys$2 =
	/*#__PURE__*/
	_curry1(_keys);

	/**
	 * Takes a function and
	 * a [functor](https://github.com/fantasyland/fantasy-land#functor),
	 * applies the function to each of the functor's values, and returns
	 * a functor of the same shape.
	 *
	 * Ramda provides suitable `map` implementations for `Array` and `Object`,
	 * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
	 *
	 * Dispatches to the `map` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * Also treats functions as functors and will compose them together.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Functor f => (a -> b) -> f a -> f b
	 * @param {Function} fn The function to be called on every element of the input `list`.
	 * @param {Array} list The list to be iterated over.
	 * @return {Array} The new list.
	 * @see R.transduce, R.addIndex
	 * @example
	 *
	 *      var double = x => x * 2;
	 *
	 *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
	 *
	 *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
	 * @symb R.map(f, [a, b]) = [f(a), f(b)]
	 * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
	 * @symb R.map(f, functor_o) = functor_o.map(f)
	 */

	var map$1 =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable(['fantasy-land/map', 'map'], _xmap, function map(fn, functor) {
	  switch (Object.prototype.toString.call(functor)) {
	    case '[object Function]':
	      return curryN(functor.length, function () {
	        return fn.call(this, functor.apply(this, arguments));
	      });

	    case '[object Object]':
	      return _reduce(function (acc, key) {
	        acc[key] = fn(functor[key]);
	        return acc;
	      }, {}, keys$2(functor));

	    default:
	      return _map(fn, functor);
	  }
	}));

	/**
	 * Retrieve the value at a given path.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.0
	 * @category Object
	 * @typedefn Idx = String | Int
	 * @sig [Idx] -> {a} -> a | Undefined
	 * @param {Array} path The path to use.
	 * @param {Object} obj The object to retrieve the nested property from.
	 * @return {*} The data at `path`.
	 * @see R.prop
	 * @example
	 *
	 *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
	 *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
	 */

	var path =
	/*#__PURE__*/
	_curry2(function path(paths, obj) {
	  var val = obj;
	  var idx = 0;

	  while (idx < paths.length) {
	    if (val == null) {
	      return;
	    }

	    val = val[paths[idx]];
	    idx += 1;
	  }

	  return val;
	});

	/**
	 * Returns a function that when supplied an object returns the indicated
	 * property of that object, if it exists.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig s -> {s: a} -> a | Undefined
	 * @param {String} p The property name
	 * @param {Object} obj The object to query
	 * @return {*} The value at `obj.p`.
	 * @see R.path
	 * @example
	 *
	 *      R.prop('x', {x: 100}); //=> 100
	 *      R.prop('x', {}); //=> undefined
	 */

	var prop =
	/*#__PURE__*/
	_curry2(function prop(p, obj) {
	  return path([p], obj);
	});

	/**
	 * Returns a new list by plucking the same named property off all objects in
	 * the list supplied.
	 *
	 * `pluck` will work on
	 * any [functor](https://github.com/fantasyland/fantasy-land#functor) in
	 * addition to arrays, as it is equivalent to `R.map(R.prop(k), f)`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Functor f => k -> f {k: v} -> f v
	 * @param {Number|String} key The key name to pluck off of each object.
	 * @param {Array} f The array or functor to consider.
	 * @return {Array} The list of values for the given key.
	 * @see R.props
	 * @example
	 *
	 *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
	 *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
	 *      R.pluck('val', {a: {val: 3}, b: {val: 5}}); //=> {a: 3, b: 5}
	 * @symb R.pluck('x', [{x: 1, y: 2}, {x: 3, y: 4}, {x: 5, y: 6}]) = [1, 3, 5]
	 * @symb R.pluck(0, [[1, 2], [3, 4], [5, 6]]) = [1, 3, 5]
	 */

	var pluck$1 =
	/*#__PURE__*/
	_curry2(function pluck(p, list) {
	  return map$1(prop(p), list);
	});

	/**
	 * Returns a single item by iterating through the list, successively calling
	 * the iterator function and passing it an accumulator value and the current
	 * value from the array, and then passing the result to the next call.
	 *
	 * The iterator function receives two values: *(acc, value)*. It may use
	 * [`R.reduced`](#reduced) to shortcut the iteration.
	 *
	 * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
	 * is *(value, acc)*.
	 *
	 * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
	 * arrays), unlike the native `Array.prototype.reduce` method. For more details
	 * on this behavior, see:
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
	 *
	 * Dispatches to the `reduce` method of the third argument, if present. When
	 * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
	 * shortcuting, as this is not implemented by `reduce`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig ((a, b) -> a) -> a -> [b] -> a
	 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	 *        current element from the array.
	 * @param {*} acc The accumulator value.
	 * @param {Array} list The list to iterate over.
	 * @return {*} The final, accumulated value.
	 * @see R.reduced, R.addIndex, R.reduceRight
	 * @example
	 *
	 *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
	 *      //          -               -10
	 *      //         / \              / \
	 *      //        -   4           -6   4
	 *      //       / \              / \
	 *      //      -   3   ==>     -3   3
	 *      //     / \              / \
	 *      //    -   2           -1   2
	 *      //   / \              / \
	 *      //  0   1            0   1
	 *
	 * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
	 */

	var reduce$1 =
	/*#__PURE__*/
	_curry3(_reduce);

	/**
	 * Takes a list of predicates and returns a predicate that returns true for a
	 * given list of arguments if every one of the provided predicates is satisfied
	 * by those arguments.
	 *
	 * The function returned is a curried function whose arity matches that of the
	 * highest-arity predicate.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Logic
	 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
	 * @param {Array} predicates An array of predicates to check
	 * @return {Function} The combined predicate
	 * @see R.anyPass
	 * @example
	 *
	 *      var isQueen = R.propEq('rank', 'Q');
	 *      var isSpade = R.propEq('suit', 'â ï¸');
	 *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
	 *
	 *      isQueenOfSpades({rank: 'Q', suit: 'â£ï¸'}); //=> false
	 *      isQueenOfSpades({rank: 'Q', suit: 'â ï¸'}); //=> true
	 */

	var allPass =
	/*#__PURE__*/
	_curry1(function allPass(preds) {
	  return curryN(reduce$1(max$3, 0, pluck$1('length', preds)), function () {
	    var idx = 0;
	    var len = preds.length;

	    while (idx < len) {
	      if (!preds[idx].apply(this, arguments)) {
	        return false;
	      }

	      idx += 1;
	    }

	    return true;
	  });
	});

	/**
	 * Returns `true` if both arguments are `true`; `false` otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Logic
	 * @sig a -> b -> a | b
	 * @param {Any} a
	 * @param {Any} b
	 * @return {Any} the first argument if it is falsy, otherwise the second argument.
	 * @see R.both
	 * @example
	 *
	 *      R.and(true, true); //=> true
	 *      R.and(true, false); //=> false
	 *      R.and(false, true); //=> false
	 *      R.and(false, false); //=> false
	 */

	var and =
	/*#__PURE__*/
	_curry2(function and(a, b) {
	  return a && b;
	});

	var XAny =
	/*#__PURE__*/
	function () {
	  function XAny(f, xf) {
	    this.xf = xf;
	    this.f = f;
	    this.any = false;
	  }

	  XAny.prototype['@@transducer/init'] = _xfBase.init;

	  XAny.prototype['@@transducer/result'] = function (result) {
	    if (!this.any) {
	      result = this.xf['@@transducer/step'](result, false);
	    }

	    return this.xf['@@transducer/result'](result);
	  };

	  XAny.prototype['@@transducer/step'] = function (result, input) {
	    if (this.f(input)) {
	      this.any = true;
	      result = _reduced(this.xf['@@transducer/step'](result, true));
	    }

	    return result;
	  };

	  return XAny;
	}();

	var _xany =
	/*#__PURE__*/
	_curry2(function _xany(f, xf) {
	  return new XAny(f, xf);
	});

	/**
	 * Returns `true` if at least one of elements of the list match the predicate,
	 * `false` otherwise.
	 *
	 * Dispatches to the `any` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> Boolean
	 * @param {Function} fn The predicate function.
	 * @param {Array} list The array to consider.
	 * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
	 *         otherwise.
	 * @see R.all, R.none, R.transduce
	 * @example
	 *
	 *      var lessThan0 = R.flip(R.lt)(0);
	 *      var lessThan2 = R.flip(R.lt)(2);
	 *      R.any(lessThan0)([1, 2]); //=> false
	 *      R.any(lessThan2)([1, 2]); //=> true
	 */

	var any =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable(['any'], _xany, function any(fn, list) {
	  var idx = 0;

	  while (idx < list.length) {
	    if (fn(list[idx])) {
	      return true;
	    }

	    idx += 1;
	  }

	  return false;
	}));

	/**
	 * Takes a list of predicates and returns a predicate that returns true for a
	 * given list of arguments if at least one of the provided predicates is
	 * satisfied by those arguments.
	 *
	 * The function returned is a curried function whose arity matches that of the
	 * highest-arity predicate.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Logic
	 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
	 * @param {Array} predicates An array of predicates to check
	 * @return {Function} The combined predicate
	 * @see R.allPass
	 * @example
	 *
	 *      var isClub = R.propEq('suit', 'â£');
	 *      var isSpade = R.propEq('suit', 'â ');
	 *      var isBlackCard = R.anyPass([isClub, isSpade]);
	 *
	 *      isBlackCard({rank: '10', suit: 'â£'}); //=> true
	 *      isBlackCard({rank: 'Q', suit: 'â '}); //=> true
	 *      isBlackCard({rank: 'Q', suit: 'â¦'}); //=> false
	 */

	var anyPass =
	/*#__PURE__*/
	_curry1(function anyPass(preds) {
	  return curryN(reduce$1(max$3, 0, pluck$1('length', preds)), function () {
	    var idx = 0;
	    var len = preds.length;

	    while (idx < len) {
	      if (preds[idx].apply(this, arguments)) {
	        return true;
	      }

	      idx += 1;
	    }

	    return false;
	  });
	});

	/**
	 * ap applies a list of functions to a list of values.
	 *
	 * Dispatches to the `ap` method of the second argument, if present. Also
	 * treats curried functions as applicatives.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category Function
	 * @sig [a -> b] -> [a] -> [b]
	 * @sig Apply f => f (a -> b) -> f a -> f b
	 * @sig (a -> b -> c) -> (a -> b) -> (a -> c)
	 * @param {*} applyF
	 * @param {*} applyX
	 * @return {*}
	 * @example
	 *
	 *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
	 *      R.ap([R.concat('tasty '), R.toUpper], ['pizza', 'salad']); //=> ["tasty pizza", "tasty salad", "PIZZA", "SALAD"]
	 *
	 *      // R.ap can also be used as S combinator
	 *      // when only two functions are passed
	 *      R.ap(R.concat, R.toUpper)('Ramda') //=> 'RamdaRAMDA'
	 * @symb R.ap([f, g], [a, b]) = [f(a), f(b), g(a), g(b)]
	 */

	var ap =
	/*#__PURE__*/
	_curry2(function ap(applyF, applyX) {
	  return typeof applyX['fantasy-land/ap'] === 'function' ? applyX['fantasy-land/ap'](applyF) : typeof applyF.ap === 'function' ? applyF.ap(applyX) : typeof applyF === 'function' ? function (x) {
	    return applyF(x)(applyX(x));
	  } : // else
	  _reduce(function (acc, f) {
	    return _concat(acc, map$1(f, applyX));
	  }, [], applyF);
	});

	function _aperture(n, list) {
	  var idx = 0;
	  var limit = list.length - (n - 1);
	  var acc = new Array(limit >= 0 ? limit : 0);

	  while (idx < limit) {
	    acc[idx] = Array.prototype.slice.call(list, idx, idx + n);
	    idx += 1;
	  }

	  return acc;
	}

	var XAperture =
	/*#__PURE__*/
	function () {
	  function XAperture(n, xf) {
	    this.xf = xf;
	    this.pos = 0;
	    this.full = false;
	    this.acc = new Array(n);
	  }

	  XAperture.prototype['@@transducer/init'] = _xfBase.init;

	  XAperture.prototype['@@transducer/result'] = function (result) {
	    this.acc = null;
	    return this.xf['@@transducer/result'](result);
	  };

	  XAperture.prototype['@@transducer/step'] = function (result, input) {
	    this.store(input);
	    return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
	  };

	  XAperture.prototype.store = function (input) {
	    this.acc[this.pos] = input;
	    this.pos += 1;

	    if (this.pos === this.acc.length) {
	      this.pos = 0;
	      this.full = true;
	    }
	  };

	  XAperture.prototype.getCopy = function () {
	    return _concat(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
	  };

	  return XAperture;
	}();

	var _xaperture =
	/*#__PURE__*/
	_curry2(function _xaperture(n, xf) {
	  return new XAperture(n, xf);
	});

	/**
	 * Returns a new list, composed of n-tuples of consecutive elements. If `n` is
	 * greater than the length of the list, an empty list is returned.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category List
	 * @sig Number -> [a] -> [[a]]
	 * @param {Number} n The size of the tuples to create
	 * @param {Array} list The list to split into `n`-length tuples
	 * @return {Array} The resulting list of `n`-length tuples
	 * @see R.transduce
	 * @example
	 *
	 *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
	 *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
	 *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
	 */

	var aperture =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable([], _xaperture, _aperture));

	/**
	 * Returns a new list containing the contents of the given list, followed by
	 * the given element.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig a -> [a] -> [a]
	 * @param {*} el The element to add to the end of the new list.
	 * @param {Array} list The list of elements to add a new item to.
	 *        list.
	 * @return {Array} A new list containing the elements of the old list followed by `el`.
	 * @see R.prepend
	 * @example
	 *
	 *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
	 *      R.append('tests', []); //=> ['tests']
	 *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
	 */

	var append =
	/*#__PURE__*/
	_curry2(function append(el, list) {
	  return _concat(list, [el]);
	});

	/**
	 * Applies function `fn` to the argument list `args`. This is useful for
	 * creating a fixed-arity function from a variadic function. `fn` should be a
	 * bound function if context is significant.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.7.0
	 * @category Function
	 * @sig (*... -> a) -> [*] -> a
	 * @param {Function} fn The function which will be called with `args`
	 * @param {Array} args The arguments to call `fn` with
	 * @return {*} result The result, equivalent to `fn(...args)`
	 * @see R.call, R.unapply
	 * @example
	 *
	 *      var nums = [1, 2, 3, -99, 42, 6, 7];
	 *      R.apply(Math.max, nums); //=> 42
	 * @symb R.apply(f, [a, b, c]) = f(a, b, c)
	 */

	var apply =
	/*#__PURE__*/
	_curry2(function apply(fn, args) {
	  return fn.apply(this, args);
	});

	/**
	 * Returns a list of all the enumerable own properties of the supplied object.
	 * Note that the order of the output array is not guaranteed across different
	 * JS platforms.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig {k: v} -> [v]
	 * @param {Object} obj The object to extract values from
	 * @return {Array} An array of the values of the object's own properties.
	 * @see R.valuesIn, R.keys
	 * @example
	 *
	 *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
	 */

	var values =
	/*#__PURE__*/
	_curry1(function values(obj) {
	  var props = keys$2(obj);
	  var len = props.length;
	  var vals = [];
	  var idx = 0;

	  while (idx < len) {
	    vals[idx] = obj[props[idx]];
	    idx += 1;
	  }

	  return vals;
	});

	/**
	 * Given a spec object recursively mapping properties to functions, creates a
	 * function producing an object of the same structure, by mapping each property
	 * to the result of calling its associated function with the supplied arguments.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.20.0
	 * @category Function
	 * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
	 * @param {Object} spec an object recursively mapping properties to functions for
	 *        producing the values for these properties.
	 * @return {Function} A function that returns an object of the same structure
	 * as `spec', with each property set to the value returned by calling its
	 * associated function with the supplied arguments.
	 * @see R.converge, R.juxt
	 * @example
	 *
	 *      var getMetrics = R.applySpec({
	 *        sum: R.add,
	 *        nested: { mul: R.multiply }
	 *      });
	 *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
	 * @symb R.applySpec({ x: f, y: { z: g } })(a, b) = { x: f(a, b), y: { z: g(a, b) } }
	 */

	var applySpec =
	/*#__PURE__*/
	_curry1(function applySpec(spec) {
	  spec = map$1(function (v) {
	    return typeof v == 'function' ? v : applySpec(v);
	  }, spec);
	  return curryN(reduce$1(max$3, 0, pluck$1('length', values(spec))), function () {
	    var args = arguments;
	    return map$1(function (f) {
	      return apply(f, args);
	    }, spec);
	  });
	});

	/**
	* Takes a value and applies a function to it.
	*
	* This function is also known as the `thrush` combinator.
	*
	* @func
	* @memberOf R
	 * @since v0.25.0
	* @category Function
	* @sig a -> (a -> b) -> b
	* @param {*} x The value
	* @param {Function} f The function to apply
	* @return {*} The result of applying `f` to `x`
	* @example
	*
	*      var t42 = R.applyTo(42);
	*      t42(R.identity); //=> 42
	*      t42(R.add(1)); //=> 43
	*/

	var applyTo =
	/*#__PURE__*/
	_curry2(function applyTo(x, f) {
	  return f(x);
	});

	/**
	 * Makes an ascending comparator function out of a function that returns a value
	 * that can be compared with `<` and `>`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.23.0
	 * @category Function
	 * @sig Ord b => (a -> b) -> a -> a -> Number
	 * @param {Function} fn A function of arity one that returns a value that can be compared
	 * @param {*} a The first item to be compared.
	 * @param {*} b The second item to be compared.
	 * @return {Number} `-1` if fn(a) < fn(b), `1` if fn(b) < fn(a), otherwise `0`
	 * @see R.descend
	 * @example
	 *
	 *      var byAge = R.ascend(R.prop('age'));
	 *      var people = [
	 *        // ...
	 *      ];
	 *      var peopleByYoungestFirst = R.sort(byAge, people);
	 */

	var ascend =
	/*#__PURE__*/
	_curry3(function ascend(fn, a, b) {
	  var aa = fn(a);
	  var bb = fn(b);
	  return aa < bb ? -1 : aa > bb ? 1 : 0;
	});

	/**
	 * Makes a shallow clone of an object, setting or overriding the specified
	 * property with the given value. Note that this copies and flattens prototype
	 * properties onto the new object as well. All non-primitive properties are
	 * copied by reference.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Object
	 * @sig String -> a -> {k: v} -> {k: v}
	 * @param {String} prop The property name to set
	 * @param {*} val The new value
	 * @param {Object} obj The object to clone
	 * @return {Object} A new object equivalent to the original except for the changed property.
	 * @see R.dissoc
	 * @example
	 *
	 *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
	 */

	var assoc =
	/*#__PURE__*/
	_curry3(function assoc(prop, val, obj) {
	  var result = {};

	  for (var p in obj) {
	    result[p] = obj[p];
	  }

	  result[prop] = val;
	  return result;
	});

	// 20.1.2.3 Number.isInteger(number)

	var floor$2 = Math.floor;
	var _isInteger = function isInteger(it) {
	  return !_isObject(it) && isFinite(it) && floor$2(it) === it;
	};

	// 20.1.2.3 Number.isInteger(number)


	_export(_export.S, 'Number', { isInteger: _isInteger });

	/**
	 * Determine if the passed argument is an integer.
	 *
	 * @private
	 * @param {*} n
	 * @category Type
	 * @return {Boolean}
	 */
	var _isInteger$1 = Number.isInteger || function _isInteger(n) {
	  return n << 0 === n;
	};

	/**
	 * Checks if the input value is `null` or `undefined`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Type
	 * @sig * -> Boolean
	 * @param {*} x The value to test.
	 * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
	 * @example
	 *
	 *      R.isNil(null); //=> true
	 *      R.isNil(undefined); //=> true
	 *      R.isNil(0); //=> false
	 *      R.isNil([]); //=> false
	 */

	var isNil =
	/*#__PURE__*/
	_curry1(function isNil(x) {
	  return x == null;
	});

	/**
	 * Makes a shallow clone of an object, setting or overriding the nodes required
	 * to create the given path, and placing the specific value at the tail end of
	 * that path. Note that this copies and flattens prototype properties onto the
	 * new object as well. All non-primitive properties are copied by reference.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Object
	 * @typedefn Idx = String | Int
	 * @sig [Idx] -> a -> {a} -> {a}
	 * @param {Array} path the path to set
	 * @param {*} val The new value
	 * @param {Object} obj The object to clone
	 * @return {Object} A new object equivalent to the original except along the specified path.
	 * @see R.dissocPath
	 * @example
	 *
	 *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
	 *
	 *      // Any missing or non-object keys in path will be overridden
	 *      R.assocPath(['a', 'b', 'c'], 42, {a: 5}); //=> {a: {b: {c: 42}}}
	 */

	var assocPath =
	/*#__PURE__*/
	_curry3(function assocPath(path, val, obj) {
	  if (path.length === 0) {
	    return val;
	  }

	  var idx = path[0];

	  if (path.length > 1) {
	    var nextObj = !isNil(obj) && _has$1(idx, obj) ? obj[idx] : _isInteger$1(path[1]) ? [] : {};
	    val = assocPath(Array.prototype.slice.call(path, 1), val, nextObj);
	  }

	  if (_isInteger$1(idx) && _isArray$1(obj)) {
	    var arr = [].concat(obj);
	    arr[idx] = val;
	    return arr;
	  } else {
	    return assoc(idx, val, obj);
	  }
	});

	/**
	 * Wraps a function of any arity (including nullary) in a function that accepts
	 * exactly `n` parameters. Any extraneous parameters will not be passed to the
	 * supplied function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig Number -> (* -> a) -> (* -> a)
	 * @param {Number} n The desired arity of the new function.
	 * @param {Function} fn The function to wrap.
	 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	 *         arity `n`.
	 * @see R.binary, R.unary
	 * @example
	 *
	 *      var takesTwoArgs = (a, b) => [a, b];
	 *
	 *      takesTwoArgs.length; //=> 2
	 *      takesTwoArgs(1, 2); //=> [1, 2]
	 *
	 *      var takesOneArg = R.nAry(1, takesTwoArgs);
	 *      takesOneArg.length; //=> 1
	 *      // Only `n` arguments are passed to the wrapped function
	 *      takesOneArg(1, 2); //=> [1, undefined]
	 * @symb R.nAry(0, f)(a, b) = f()
	 * @symb R.nAry(1, f)(a, b) = f(a)
	 * @symb R.nAry(2, f)(a, b) = f(a, b)
	 */

	var nAry =
	/*#__PURE__*/
	_curry2(function nAry(n, fn) {
	  switch (n) {
	    case 0:
	      return function () {
	        return fn.call(this);
	      };

	    case 1:
	      return function (a0) {
	        return fn.call(this, a0);
	      };

	    case 2:
	      return function (a0, a1) {
	        return fn.call(this, a0, a1);
	      };

	    case 3:
	      return function (a0, a1, a2) {
	        return fn.call(this, a0, a1, a2);
	      };

	    case 4:
	      return function (a0, a1, a2, a3) {
	        return fn.call(this, a0, a1, a2, a3);
	      };

	    case 5:
	      return function (a0, a1, a2, a3, a4) {
	        return fn.call(this, a0, a1, a2, a3, a4);
	      };

	    case 6:
	      return function (a0, a1, a2, a3, a4, a5) {
	        return fn.call(this, a0, a1, a2, a3, a4, a5);
	      };

	    case 7:
	      return function (a0, a1, a2, a3, a4, a5, a6) {
	        return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
	      };

	    case 8:
	      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
	      };

	    case 9:
	      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
	      };

	    case 10:
	      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	      };

	    default:
	      throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
	  }
	});

	/**
	 * Wraps a function of any arity (including nullary) in a function that accepts
	 * exactly 2 parameters. Any extraneous parameters will not be passed to the
	 * supplied function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.0
	 * @category Function
	 * @sig (* -> c) -> (a, b -> c)
	 * @param {Function} fn The function to wrap.
	 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	 *         arity 2.
	 * @see R.nAry, R.unary
	 * @example
	 *
	 *      var takesThreeArgs = function(a, b, c) {
	 *        return [a, b, c];
	 *      };
	 *      takesThreeArgs.length; //=> 3
	 *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
	 *
	 *      var takesTwoArgs = R.binary(takesThreeArgs);
	 *      takesTwoArgs.length; //=> 2
	 *      // Only 2 arguments are passed to the wrapped function
	 *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
	 * @symb R.binary(f)(a, b, c) = f(a, b)
	 */

	var binary =
	/*#__PURE__*/
	_curry1(function binary(fn) {
	  return nAry(2, fn);
	});

	function _isFunction(x) {
	  return Object.prototype.toString.call(x) === '[object Function]';
	}

	/**
	 * "lifts" a function to be the specified arity, so that it may "map over" that
	 * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.7.0
	 * @category Function
	 * @sig Number -> (*... -> *) -> ([*]... -> [*])
	 * @param {Function} fn The function to lift into higher context
	 * @return {Function} The lifted function.
	 * @see R.lift, R.ap
	 * @example
	 *
	 *      var madd3 = R.liftN(3, (...args) => R.sum(args));
	 *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
	 */

	var liftN =
	/*#__PURE__*/
	_curry2(function liftN(arity, fn) {
	  var lifted = curryN(arity, fn);
	  return curryN(arity, function () {
	    return _reduce(ap, map$1(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
	  });
	});

	/**
	 * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other
	 * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.7.0
	 * @category Function
	 * @sig (*... -> *) -> ([*]... -> [*])
	 * @param {Function} fn The function to lift into higher context
	 * @return {Function} The lifted function.
	 * @see R.liftN
	 * @example
	 *
	 *      var madd3 = R.lift((a, b, c) => a + b + c);
	 *
	 *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
	 *
	 *      var madd5 = R.lift((a, b, c, d, e) => a + b + c + d + e);
	 *
	 *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
	 */

	var lift =
	/*#__PURE__*/
	_curry1(function lift(fn) {
	  return liftN(fn.length, fn);
	});

	/**
	 * A function which calls the two provided functions and returns the `&&`
	 * of the results.
	 * It returns the result of the first function if it is false-y and the result
	 * of the second function otherwise. Note that this is short-circuited,
	 * meaning that the second function will not be invoked if the first returns a
	 * false-y value.
	 *
	 * In addition to functions, `R.both` also accepts any fantasy-land compatible
	 * applicative functor.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category Logic
	 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
	 * @param {Function} f A predicate
	 * @param {Function} g Another predicate
	 * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
	 * @see R.and
	 * @example
	 *
	 *      var gt10 = R.gt(R.__, 10)
	 *      var lt20 = R.lt(R.__, 20)
	 *      var f = R.both(gt10, lt20);
	 *      f(15); //=> true
	 *      f(30); //=> false
	 */

	var both =
	/*#__PURE__*/
	_curry2(function both(f, g) {
	  return _isFunction(f) ? function _both() {
	    return f.apply(this, arguments) && g.apply(this, arguments);
	  } : lift(and)(f, g);
	});

	/**
	 * Returns a curried equivalent of the provided function. The curried function
	 * has two unusual capabilities. First, its arguments needn't be provided one
	 * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
	 * following are equivalent:
	 *
	 *   - `g(1)(2)(3)`
	 *   - `g(1)(2, 3)`
	 *   - `g(1, 2)(3)`
	 *   - `g(1, 2, 3)`
	 *
	 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
	 * "gaps", allowing partial application of any combination of arguments,
	 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
	 * the following are equivalent:
	 *
	 *   - `g(1, 2, 3)`
	 *   - `g(_, 2, 3)(1)`
	 *   - `g(_, _, 3)(1)(2)`
	 *   - `g(_, _, 3)(1, 2)`
	 *   - `g(_, 2)(1)(3)`
	 *   - `g(_, 2)(1, 3)`
	 *   - `g(_, 2)(_, 3)(1)`
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig (* -> a) -> (* -> a)
	 * @param {Function} fn The function to curry.
	 * @return {Function} A new, curried function.
	 * @see R.curryN
	 * @example
	 *
	 *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
	 *
	 *      var curriedAddFourNumbers = R.curry(addFourNumbers);
	 *      var f = curriedAddFourNumbers(1, 2);
	 *      var g = f(3);
	 *      g(4); //=> 10
	 */

	var curry =
	/*#__PURE__*/
	_curry1(function curry(fn) {
	  return curryN(fn.length, fn);
	});

	/**
	 * Returns the result of calling its first argument with the remaining
	 * arguments. This is occasionally useful as a converging function for
	 * [`R.converge`](#converge): the first branch can produce a function while the
	 * remaining branches produce values to be passed to that function as its
	 * arguments.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Function
	 * @sig (*... -> a),*... -> a
	 * @param {Function} fn The function to apply to the remaining arguments.
	 * @param {...*} args Any number of positional arguments.
	 * @return {*}
	 * @see R.apply
	 * @example
	 *
	 *      R.call(R.add, 1, 2); //=> 3
	 *
	 *      var indentN = R.pipe(R.repeat(' '),
	 *                           R.join(''),
	 *                           R.replace(/^(?!$)/gm));
	 *
	 *      var format = R.converge(R.call, [
	 *                                  R.pipe(R.prop('indent'), indentN),
	 *                                  R.prop('value')
	 *                              ]);
	 *
	 *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
	 * @symb R.call(f, a, b) = f(a, b)
	 */

	var call =
	/*#__PURE__*/
	curry(function call(fn) {
	  return fn.apply(this, Array.prototype.slice.call(arguments, 1));
	});

	/**
	 * `_makeFlat` is a helper function that returns a one-level or fully recursive
	 * function based on the flag passed in.
	 *
	 * @private
	 */

	function _makeFlat(recursive) {
	  return function flatt(list) {
	    var value, jlen, j;
	    var result = [];
	    var idx = 0;
	    var ilen = list.length;

	    while (idx < ilen) {
	      if (_isArrayLike(list[idx])) {
	        value = recursive ? flatt(list[idx]) : list[idx];
	        j = 0;
	        jlen = value.length;

	        while (j < jlen) {
	          result[result.length] = value[j];
	          j += 1;
	        }
	      } else {
	        result[result.length] = list[idx];
	      }

	      idx += 1;
	    }

	    return result;
	  };
	}

	function _forceReduced(x) {
	  return {
	    '@@transducer/value': x,
	    '@@transducer/reduced': true
	  };
	}

	var preservingReduced = function preservingReduced(xf) {
	  return {
	    '@@transducer/init': _xfBase.init,
	    '@@transducer/result': function transducerResult(result) {
	      return xf['@@transducer/result'](result);
	    },
	    '@@transducer/step': function transducerStep(result, input) {
	      var ret = xf['@@transducer/step'](result, input);
	      return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
	    }
	  };
	};

	var _flatCat = function _xcat(xf) {
	  var rxf = preservingReduced(xf);
	  return {
	    '@@transducer/init': _xfBase.init,
	    '@@transducer/result': function transducerResult(result) {
	      return rxf['@@transducer/result'](result);
	    },
	    '@@transducer/step': function transducerStep(result, input) {
	      return !_isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
	    }
	  };
	};

	var _xchain =
	/*#__PURE__*/
	_curry2(function _xchain(f, xf) {
	  return map$1(f, _flatCat(xf));
	});

	/**
	 * `chain` maps a function over a list and concatenates the results. `chain`
	 * is also known as `flatMap` in some libraries
	 *
	 * Dispatches to the `chain` method of the second argument, if present,
	 * according to the [FantasyLand Chain spec](https://github.com/fantasyland/fantasy-land#chain).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category List
	 * @sig Chain m => (a -> m b) -> m a -> m b
	 * @param {Function} fn The function to map with
	 * @param {Array} list The list to map over
	 * @return {Array} The result of flat-mapping `list` with `fn`
	 * @example
	 *
	 *      var duplicate = n => [n, n];
	 *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
	 *
	 *      R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]
	 */

	var chain =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable(['fantasy-land/chain', 'chain'], _xchain, function chain(fn, monad) {
	  if (typeof monad === 'function') {
	    return function (x) {
	      return fn(monad(x))(x);
	    };
	  }

	  return _makeFlat(false)(map$1(fn, monad));
	}));

	/**
	 * Restricts a number to be within a range.
	 *
	 * Also works for other ordered types such as Strings and Dates.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.20.0
	 * @category Relation
	 * @sig Ord a => a -> a -> a -> a
	 * @param {Number} minimum The lower limit of the clamp (inclusive)
	 * @param {Number} maximum The upper limit of the clamp (inclusive)
	 * @param {Number} value Value to be clamped
	 * @return {Number} Returns `minimum` when `val < minimum`, `maximum` when `val > maximum`, returns `val` otherwise
	 * @example
	 *
	 *      R.clamp(1, 10, -5) // => 1
	 *      R.clamp(1, 10, 15) // => 10
	 *      R.clamp(1, 10, 4)  // => 4
	 */

	var clamp =
	/*#__PURE__*/
	_curry3(function clamp(min, max, value) {
	  if (min > max) {
	    throw new Error('min must not be greater than max in clamp(min, max, value)');
	  }

	  return value < min ? min : value > max ? max : value;
	});

	function _cloneRegExp(pattern) {
	  return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
	}

	/**
	 * Gives a single-word string description of the (native) type of a value,
	 * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
	 * attempt to distinguish user Object types any further, reporting them all as
	 * 'Object'.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Type
	 * @sig (* -> {*}) -> String
	 * @param {*} val The value to test
	 * @return {String}
	 * @example
	 *
	 *      R.type({}); //=> "Object"
	 *      R.type(1); //=> "Number"
	 *      R.type(false); //=> "Boolean"
	 *      R.type('s'); //=> "String"
	 *      R.type(null); //=> "Null"
	 *      R.type([]); //=> "Array"
	 *      R.type(/[A-z]/); //=> "RegExp"
	 *      R.type(() => {}); //=> "Function"
	 *      R.type(undefined); //=> "Undefined"
	 */

	var type =
	/*#__PURE__*/
	_curry1(function type(val) {
	  return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
	});

	/**
	 * Copies an object.
	 *
	 * @private
	 * @param {*} value The value to be copied
	 * @param {Array} refFrom Array containing the source references
	 * @param {Array} refTo Array containing the copied source references
	 * @param {Boolean} deep Whether or not to perform deep cloning.
	 * @return {*} The copied value.
	 */

	function _clone(value, refFrom, refTo, deep) {
	  var copy = function copy(copiedValue) {
	    var len = refFrom.length;
	    var idx = 0;

	    while (idx < len) {
	      if (value === refFrom[idx]) {
	        return refTo[idx];
	      }

	      idx += 1;
	    }

	    refFrom[idx + 1] = value;
	    refTo[idx + 1] = copiedValue;

	    for (var key in value) {
	      copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
	    }

	    return copiedValue;
	  };

	  switch (type(value)) {
	    case 'Object':
	      return copy({});

	    case 'Array':
	      return copy([]);

	    case 'Date':
	      return new Date(value.valueOf());

	    case 'RegExp':
	      return _cloneRegExp(value);

	    default:
	      return value;
	  }
	}

	/**
	 * Creates a deep copy of the value which may contain (nested) `Array`s and
	 * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are
	 * assigned by reference rather than copied
	 *
	 * Dispatches to a `clone` method if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig {*} -> {*}
	 * @param {*} value The object or array to clone
	 * @return {*} A deeply cloned copy of `val`
	 * @example
	 *
	 *      var objects = [{}, {}, {}];
	 *      var objectsClone = R.clone(objects);
	 *      objects === objectsClone; //=> false
	 *      objects[0] === objectsClone[0]; //=> false
	 */

	var clone =
	/*#__PURE__*/
	_curry1(function clone(value) {
	  return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], [], true);
	});

	/**
	 * Makes a comparator function out of a function that reports whether the first
	 * element is less than the second.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig ((a, b) -> Boolean) -> ((a, b) -> Number)
	 * @param {Function} pred A predicate function of arity two which will return `true` if the first argument
	 * is less than the second, `false` otherwise
	 * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`
	 * @example
	 *
	 *      var byAge = R.comparator((a, b) => a.age < b.age);
	 *      var people = [
	 *        // ...
	 *      ];
	 *      var peopleByIncreasingAge = R.sort(byAge, people);
	 */

	var comparator =
	/*#__PURE__*/
	_curry1(function comparator(pred) {
	  return function (a, b) {
	    return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
	  };
	});

	/**
	 * A function that returns the `!` of its argument. It will return `true` when
	 * passed false-y value, and `false` when passed a truth-y one.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Logic
	 * @sig * -> Boolean
	 * @param {*} a any value
	 * @return {Boolean} the logical inverse of passed argument.
	 * @see R.complement
	 * @example
	 *
	 *      R.not(true); //=> false
	 *      R.not(false); //=> true
	 *      R.not(0); //=> true
	 *      R.not(1); //=> false
	 */

	var not$1 =
	/*#__PURE__*/
	_curry1(function not(a) {
	  return !a;
	});

	/**
	 * Takes a function `f` and returns a function `g` such that if called with the same arguments
	 * when `f` returns a "truthy" value, `g` returns `false` and when `f` returns a "falsy" value `g` returns `true`.
	 *
	 * `R.complement` may be applied to any functor
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category Logic
	 * @sig (*... -> *) -> (*... -> Boolean)
	 * @param {Function} f
	 * @return {Function}
	 * @see R.not
	 * @example
	 *
	 *      var isNotNil = R.complement(R.isNil);
	 *      isNil(null); //=> true
	 *      isNotNil(null); //=> false
	 *      isNil(7); //=> false
	 *      isNotNil(7); //=> true
	 */

	var complement =
	/*#__PURE__*/
	lift(not$1);

	function _pipe(f, g) {
	  return function () {
	    return g.call(this, f.apply(this, arguments));
	  };
	}

	/**
	 * This checks whether a function has a [methodname] function. If it isn't an
	 * array it will execute that function otherwise it will default to the ramda
	 * implementation.
	 *
	 * @private
	 * @param {Function} fn ramda implemtation
	 * @param {String} methodname property to check for a custom implementation
	 * @return {Object} Whatever the return value of the method is.
	 */

	function _checkForMethod(methodname, fn) {
	  return function () {
	    var length = arguments.length;

	    if (length === 0) {
	      return fn();
	    }

	    var obj = arguments[length - 1];
	    return _isArray$1(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
	  };
	}

	/**
	 * Returns the elements of the given list or string (or object with a `slice`
	 * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
	 *
	 * Dispatches to the `slice` method of the third argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.4
	 * @category List
	 * @sig Number -> Number -> [a] -> [a]
	 * @sig Number -> Number -> String -> String
	 * @param {Number} fromIndex The start index (inclusive).
	 * @param {Number} toIndex The end index (exclusive).
	 * @param {*} list
	 * @return {*}
	 * @example
	 *
	 *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
	 *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
	 *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
	 *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
	 *      R.slice(0, 3, 'ramda');                     //=> 'ram'
	 */

	var slice =
	/*#__PURE__*/
	_curry3(
	/*#__PURE__*/
	_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
	  return Array.prototype.slice.call(list, fromIndex, toIndex);
	}));

	/**
	 * Returns all but the first element of the given list or string (or object
	 * with a `tail` method).
	 *
	 * Dispatches to the `slice` method of the first argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> [a]
	 * @sig String -> String
	 * @param {*} list
	 * @return {*}
	 * @see R.head, R.init, R.last
	 * @example
	 *
	 *      R.tail([1, 2, 3]);  //=> [2, 3]
	 *      R.tail([1, 2]);     //=> [2]
	 *      R.tail([1]);        //=> []
	 *      R.tail([]);         //=> []
	 *
	 *      R.tail('abc');  //=> 'bc'
	 *      R.tail('ab');   //=> 'b'
	 *      R.tail('a');    //=> ''
	 *      R.tail('');     //=> ''
	 */

	var tail =
	/*#__PURE__*/
	_curry1(
	/*#__PURE__*/
	_checkForMethod('tail',
	/*#__PURE__*/
	slice(1, Infinity)));

	/**
	 * Performs left-to-right function composition. The leftmost function may have
	 * any arity; the remaining functions must be unary.
	 *
	 * In some libraries this function is named `sequence`.
	 *
	 * **Note:** The result of pipe is not automatically curried.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
	 * @param {...Function} functions
	 * @return {Function}
	 * @see R.compose
	 * @example
	 *
	 *      var f = R.pipe(Math.pow, R.negate, R.inc);
	 *
	 *      f(3, 4); // -(3^4) + 1
	 * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
	 */

	function pipe$1() {
	  if (arguments.length === 0) {
	    throw new Error('pipe requires at least one argument');
	  }

	  return _arity(arguments[0].length, reduce$1(_pipe, arguments[0], tail(arguments)));
	}

	/**
	 * Returns a new list or string with the elements or characters in reverse
	 * order.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> [a]
	 * @sig String -> String
	 * @param {Array|String} list
	 * @return {Array|String}
	 * @example
	 *
	 *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
	 *      R.reverse([1, 2]);     //=> [2, 1]
	 *      R.reverse([1]);        //=> [1]
	 *      R.reverse([]);         //=> []
	 *
	 *      R.reverse('abc');      //=> 'cba'
	 *      R.reverse('ab');       //=> 'ba'
	 *      R.reverse('a');        //=> 'a'
	 *      R.reverse('');         //=> ''
	 */

	var reverse =
	/*#__PURE__*/
	_curry1(function reverse(list) {
	  return _isString(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();
	});

	/**
	 * Performs right-to-left function composition. The rightmost function may have
	 * any arity; the remaining functions must be unary.
	 *
	 * **Note:** The result of compose is not automatically curried.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
	 * @param {...Function} ...functions The functions to compose
	 * @return {Function}
	 * @see R.pipe
	 * @example
	 *
	 *      var classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
	 *      var yellGreeting = R.compose(R.toUpper, classyGreeting);
	 *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
	 *
	 *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
	 *
	 * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
	 */

	function compose() {
	  if (arguments.length === 0) {
	    throw new Error('compose requires at least one argument');
	  }

	  return pipe$1.apply(this, reverse(arguments));
	}

	/**
	 * Returns the right-to-left Kleisli composition of the provided functions,
	 * each of which must return a value of a type supported by [`chain`](#chain).
	 *
	 * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), f)`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category Function
	 * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (a -> m z)
	 * @param {...Function} ...functions The functions to compose
	 * @return {Function}
	 * @see R.pipeK
	 * @example
	 *
	 *       //  get :: String -> Object -> Maybe *
	 *       var get = R.curry((propName, obj) => Maybe(obj[propName]))
	 *
	 *       //  getStateCode :: Maybe String -> Maybe String
	 *       var getStateCode = R.composeK(
	 *         R.compose(Maybe.of, R.toUpper),
	 *         get('state'),
	 *         get('address'),
	 *         get('user'),
	 *       );
	 *       getStateCode({"user":{"address":{"state":"ny"}}}); //=> Maybe.Just("NY")
	 *       getStateCode({}); //=> Maybe.Nothing()
	 * @symb R.composeK(f, g, h)(a) = R.chain(f, R.chain(g, h(a)))
	 */

	function composeK() {
	  if (arguments.length === 0) {
	    throw new Error('composeK requires at least one argument');
	  }

	  var init = Array.prototype.slice.call(arguments);
	  var last = init.pop();
	  return compose(compose.apply(this, map$1(chain, init)), last);
	}

	function _pipeP(f, g) {
	  return function () {
	    var ctx = this;
	    return f.apply(ctx, arguments).then(function (x) {
	      return g.call(ctx, x);
	    });
	  };
	}

	/**
	 * Performs left-to-right composition of one or more Promise-returning
	 * functions. The leftmost function may have any arity; the remaining functions
	 * must be unary.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category Function
	 * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
	 * @param {...Function} functions
	 * @return {Function}
	 * @see R.composeP
	 * @example
	 *
	 *      //  followersForUser :: String -> Promise [User]
	 *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
	 */

	function pipeP() {
	  if (arguments.length === 0) {
	    throw new Error('pipeP requires at least one argument');
	  }

	  return _arity(arguments[0].length, reduce$1(_pipeP, arguments[0], tail(arguments)));
	}

	/**
	 * Performs right-to-left composition of one or more Promise-returning
	 * functions. The rightmost function may have any arity; the remaining
	 * functions must be unary.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category Function
	 * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
	 * @param {...Function} functions The functions to compose
	 * @return {Function}
	 * @see R.pipeP
	 * @example
	 *
	 *      var db = {
	 *        users: {
	 *          JOE: {
	 *            name: 'Joe',
	 *            followers: ['STEVE', 'SUZY']
	 *          }
	 *        }
	 *      }
	 *
	 *      // We'll pretend to do a db lookup which returns a promise
	 *      var lookupUser = (userId) => Promise.resolve(db.users[userId])
	 *      var lookupFollowers = (user) => Promise.resolve(user.followers)
	 *      lookupUser('JOE').then(lookupFollowers)
	 *
	 *      //  followersForUser :: String -> Promise [UserId]
	 *      var followersForUser = R.composeP(lookupFollowers, lookupUser);
	 *      followersForUser('JOE').then(followers => console.log('Followers:', followers))
	 *      // Followers: ["STEVE","SUZY"]
	 */

	function composeP() {
	  if (arguments.length === 0) {
	    throw new Error('composeP requires at least one argument');
	  }

	  return pipeP.apply(this, reverse(arguments));
	}

	function _arrayFromIterator(iter) {
	  var list = [];
	  var next;

	  while (!(next = iter.next()).done) {
	    list.push(next.value);
	  }

	  return list;
	}

	function _containsWith(pred, x, list) {
	  var idx = 0;
	  var len = list.length;

	  while (idx < len) {
	    if (pred(x, list[idx])) {
	      return true;
	    }

	    idx += 1;
	  }

	  return false;
	}

	function _functionName(f) {
	  // String(x => x) evaluates to "x => x", so the pattern may not match.
	  var match = String(f).match(/^function (\w*)/);
	  return match == null ? '' : match[1];
	}

	/**
	 * Returns true if its arguments are identical, false otherwise. Values are
	 * identical if they reference the same memory. `NaN` is identical to `NaN`;
	 * `0` and `-0` are not identical.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.15.0
	 * @category Relation
	 * @sig a -> a -> Boolean
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 * @example
	 *
	 *      var o = {};
	 *      R.identical(o, o); //=> true
	 *      R.identical(1, 1); //=> true
	 *      R.identical(1, '1'); //=> false
	 *      R.identical([], []); //=> false
	 *      R.identical(0, -0); //=> false
	 *      R.identical(NaN, NaN); //=> true
	 */

	var identical =
	/*#__PURE__*/
	_curry2(function identical(a, b) {
	  // SameValue algorithm
	  if (a === b) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return a !== 0 || 1 / a === 1 / b;
	  } else {
	    // Step 6.a: NaN == NaN
	    return a !== a && b !== b;
	  }
	});

	/**
	 * private _uniqContentEquals function.
	 * That function is checking equality of 2 iterator contents with 2 assumptions
	 * - iterators lengths are the same
	 * - iterators values are unique
	 *
	 * false-positive result will be returned for comparision of, e.g.
	 * - [1,2,3] and [1,2,3,4]
	 * - [1,1,1] and [1,2,3]
	 * */

	function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
	  var a = _arrayFromIterator(aIterator);

	  var b = _arrayFromIterator(bIterator);

	  function eq(_a, _b) {
	    return _equals(_a, _b, stackA.slice(), stackB.slice());
	  } // if *a* array contains any element that is not included in *b*


	  return !_containsWith(function (b, aItem) {
	    return !_containsWith(eq, aItem, b);
	  }, b, a);
	}

	function _equals(a, b, stackA, stackB) {
	  if (identical(a, b)) {
	    return true;
	  }

	  var typeA = type(a);

	  if (typeA !== type(b)) {
	    return false;
	  }

	  if (a == null || b == null) {
	    return false;
	  }

	  if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
	    return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
	  }

	  if (typeof a.equals === 'function' || typeof b.equals === 'function') {
	    return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
	  }

	  switch (typeA) {
	    case 'Arguments':
	    case 'Array':
	    case 'Object':
	      if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
	        return a === b;
	      }

	      break;

	    case 'Boolean':
	    case 'Number':
	    case 'String':
	      if (!(_typeof(a) === _typeof(b) && identical(a.valueOf(), b.valueOf()))) {
	        return false;
	      }

	      break;

	    case 'Date':
	      if (!identical(a.valueOf(), b.valueOf())) {
	        return false;
	      }

	      break;

	    case 'Error':
	      return a.name === b.name && a.message === b.message;

	    case 'RegExp':
	      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
	        return false;
	      }

	      break;
	  }

	  var idx = stackA.length - 1;

	  while (idx >= 0) {
	    if (stackA[idx] === a) {
	      return stackB[idx] === b;
	    }

	    idx -= 1;
	  }

	  switch (typeA) {
	    case 'Map':
	      if (a.size !== b.size) {
	        return false;
	      }

	      return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));

	    case 'Set':
	      if (a.size !== b.size) {
	        return false;
	      }

	      return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));

	    case 'Arguments':
	    case 'Array':
	    case 'Object':
	    case 'Boolean':
	    case 'Number':
	    case 'String':
	    case 'Date':
	    case 'Error':
	    case 'RegExp':
	    case 'Int8Array':
	    case 'Uint8Array':
	    case 'Uint8ClampedArray':
	    case 'Int16Array':
	    case 'Uint16Array':
	    case 'Int32Array':
	    case 'Uint32Array':
	    case 'Float32Array':
	    case 'Float64Array':
	    case 'ArrayBuffer':
	      break;

	    default:
	      // Values of other types are only equal if identical.
	      return false;
	  }

	  var keysA = keys$2(a);

	  if (keysA.length !== keys$2(b).length) {
	    return false;
	  }

	  var extendedStackA = stackA.concat([a]);
	  var extendedStackB = stackB.concat([b]);
	  idx = keysA.length - 1;

	  while (idx >= 0) {
	    var key = keysA[idx];

	    if (!(_has$1(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
	      return false;
	    }

	    idx -= 1;
	  }

	  return true;
	}

	/**
	 * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
	 * cyclical data structures.
	 *
	 * Dispatches symmetrically to the `equals` methods of both arguments, if
	 * present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.15.0
	 * @category Relation
	 * @sig a -> b -> Boolean
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 * @example
	 *
	 *      R.equals(1, 1); //=> true
	 *      R.equals(1, '1'); //=> false
	 *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
	 *
	 *      var a = {}; a.v = a;
	 *      var b = {}; b.v = b;
	 *      R.equals(a, b); //=> true
	 */

	var equals =
	/*#__PURE__*/
	_curry2(function equals(a, b) {
	  return _equals(a, b, [], []);
	});

	function _indexOf(list, a, idx) {
	  var inf, item; // Array.prototype.indexOf doesn't exist below IE9

	  if (typeof list.indexOf === 'function') {
	    switch (_typeof(a)) {
	      case 'number':
	        if (a === 0) {
	          // manually crawl the list to distinguish between +0 and -0
	          inf = 1 / a;

	          while (idx < list.length) {
	            item = list[idx];

	            if (item === 0 && 1 / item === inf) {
	              return idx;
	            }

	            idx += 1;
	          }

	          return -1;
	        } else if (a !== a) {
	          // NaN
	          while (idx < list.length) {
	            item = list[idx];

	            if (typeof item === 'number' && item !== item) {
	              return idx;
	            }

	            idx += 1;
	          }

	          return -1;
	        } // non-zero numbers can utilise Set


	        return list.indexOf(a, idx);
	      // all these types can utilise Set

	      case 'string':
	      case 'boolean':
	      case 'function':
	      case 'undefined':
	        return list.indexOf(a, idx);

	      case 'object':
	        if (a === null) {
	          // null can utilise Set
	          return list.indexOf(a, idx);
	        }

	    }
	  } // anything else not covered above, defer to R.equals


	  while (idx < list.length) {
	    if (equals(list[idx], a)) {
	      return idx;
	    }

	    idx += 1;
	  }

	  return -1;
	}

	function _contains(a, list) {
	  return _indexOf(list, a, 0) >= 0;
	}

	function _quote(s) {
	  var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b') // \b matches word boundary; [\b] matches backspace
	  .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
	  return '"' + escaped.replace(/"/g, '\\"') + '"';
	}

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

	var getTime$1 = Date.prototype.getTime;
	var $toISOString = Date.prototype.toISOString;

	var lz = function (num) {
	  return num > 9 ? num : '0' + num;
	};

	// PhantomJS / old WebKit has a broken implementations
	var _dateToIsoString = (_fails(function () {
	  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
	}) || !_fails(function () {
	  $toISOString.call(new Date(NaN));
	})) ? function toISOString() {
	  if (!isFinite(getTime$1.call(this))) throw RangeError('Invalid time value');
	  var d = this;
	  var y = d.getUTCFullYear();
	  var m = d.getUTCMilliseconds();
	  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
	  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	} : $toISOString;

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()



	// PhantomJS / old WebKit has a broken implementations
	_export(_export.P + _export.F * (Date.prototype.toISOString !== _dateToIsoString), 'Date', {
	  toISOString: _dateToIsoString
	});

	/**
	 * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
	 */
	var pad = function pad(n) {
	  return (n < 10 ? '0' : '') + n;
	};

	var _toISOString = typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
	  return d.toISOString();
	} : function _toISOString(d) {
	  return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
	};

	function _complement(f) {
	  return function () {
	    return !f.apply(this, arguments);
	  };
	}

	function _filter(fn, list) {
	  var idx = 0;
	  var len = list.length;
	  var result = [];

	  while (idx < len) {
	    if (fn(list[idx])) {
	      result[result.length] = list[idx];
	    }

	    idx += 1;
	  }

	  return result;
	}

	function _isObject$1(x) {
	  return Object.prototype.toString.call(x) === '[object Object]';
	}

	var XFilter =
	/*#__PURE__*/
	function () {
	  function XFilter(f, xf) {
	    this.xf = xf;
	    this.f = f;
	  }

	  XFilter.prototype['@@transducer/init'] = _xfBase.init;
	  XFilter.prototype['@@transducer/result'] = _xfBase.result;

	  XFilter.prototype['@@transducer/step'] = function (result, input) {
	    return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
	  };

	  return XFilter;
	}();

	var _xfilter =
	/*#__PURE__*/
	_curry2(function _xfilter(f, xf) {
	  return new XFilter(f, xf);
	});

	/**
	 * Takes a predicate and a `Filterable`, and returns a new filterable of the
	 * same type containing the members of the given filterable which satisfy the
	 * given predicate. Filterable objects include plain objects or any object
	 * that has a filter method such as `Array`.
	 *
	 * Dispatches to the `filter` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Filterable f => (a -> Boolean) -> f a -> f a
	 * @param {Function} pred
	 * @param {Array} filterable
	 * @return {Array} Filterable
	 * @see R.reject, R.transduce, R.addIndex
	 * @example
	 *
	 *      var isEven = n => n % 2 === 0;
	 *
	 *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
	 *
	 *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
	 */

	var filter$1 =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable(['filter'], _xfilter, function (pred, filterable) {
	  return _isObject$1(filterable) ? _reduce(function (acc, key) {
	    if (pred(filterable[key])) {
	      acc[key] = filterable[key];
	    }

	    return acc;
	  }, {}, keys$2(filterable)) : // else
	  _filter(pred, filterable);
	}));

	/**
	 * The complement of [`filter`](#filter).
	 *
	 * Acts as a transducer if a transformer is given in list position. Filterable
	 * objects include plain objects or any object that has a filter method such
	 * as `Array`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Filterable f => (a -> Boolean) -> f a -> f a
	 * @param {Function} pred
	 * @param {Array} filterable
	 * @return {Array}
	 * @see R.filter, R.transduce, R.addIndex
	 * @example
	 *
	 *      var isOdd = (n) => n % 2 === 1;
	 *
	 *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
	 *
	 *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
	 */

	var reject =
	/*#__PURE__*/
	_curry2(function reject(pred, filterable) {
	  return filter$1(_complement(pred), filterable);
	});

	function _toString(x, seen) {
	  var recur = function recur(y) {
	    var xs = seen.concat([x]);
	    return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
	  }; //  mapPairs :: (Object, [String]) -> [String]


	  var mapPairs = function mapPairs(obj, keys) {
	    return _map(function (k) {
	      return _quote(k) + ': ' + recur(obj[k]);
	    }, keys.slice().sort());
	  };

	  switch (Object.prototype.toString.call(x)) {
	    case '[object Arguments]':
	      return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';

	    case '[object Array]':
	      return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
	        return /^\d+$/.test(k);
	      }, keys$2(x)))).join(', ') + ']';

	    case '[object Boolean]':
	      return _typeof(x) === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();

	    case '[object Date]':
	      return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';

	    case '[object Null]':
	      return 'null';

	    case '[object Number]':
	      return _typeof(x) === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);

	    case '[object String]':
	      return _typeof(x) === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);

	    case '[object Undefined]':
	      return 'undefined';

	    default:
	      if (typeof x.toString === 'function') {
	        var repr = x.toString();

	        if (repr !== '[object Object]') {
	          return repr;
	        }
	      }

	      return '{' + mapPairs(x, keys$2(x)).join(', ') + '}';
	  }
	}

	/**
	 * Returns the string representation of the given value. `eval`'ing the output
	 * should result in a value equivalent to the input value. Many of the built-in
	 * `toString` methods do not satisfy this requirement.
	 *
	 * If the given value is an `[object Object]` with a `toString` method other
	 * than `Object.prototype.toString`, this method is invoked with no arguments
	 * to produce the return value. This means user-defined constructor functions
	 * can provide a suitable `toString` method. For example:
	 *
	 *     function Point(x, y) {
	 *       this.x = x;
	 *       this.y = y;
	 *     }
	 *
	 *     Point.prototype.toString = function() {
	 *       return 'new Point(' + this.x + ', ' + this.y + ')';
	 *     };
	 *
	 *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category String
	 * @sig * -> String
	 * @param {*} val
	 * @return {String}
	 * @example
	 *
	 *      R.toString(42); //=> '42'
	 *      R.toString('abc'); //=> '"abc"'
	 *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
	 *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
	 *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
	 */

	var toString$4 =
	/*#__PURE__*/
	_curry1(function toString(val) {
	  return _toString(val, []);
	});

	/**
	 * Returns the result of concatenating the given lists or strings.
	 *
	 * Note: `R.concat` expects both arguments to be of the same type,
	 * unlike the native `Array.prototype.concat` method. It will throw
	 * an error if you `concat` an Array with a non-Array value.
	 *
	 * Dispatches to the `concat` method of the first argument, if present.
	 * Can also concatenate two members of a [fantasy-land
	 * compatible semigroup](https://github.com/fantasyland/fantasy-land#semigroup).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> [a] -> [a]
	 * @sig String -> String -> String
	 * @param {Array|String} firstList The first list
	 * @param {Array|String} secondList The second list
	 * @return {Array|String} A list consisting of the elements of `firstList` followed by the elements of
	 * `secondList`.
	 *
	 * @example
	 *
	 *      R.concat('ABC', 'DEF'); // 'ABCDEF'
	 *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	 *      R.concat([], []); //=> []
	 */

	var concat$2 =
	/*#__PURE__*/
	_curry2(function concat(a, b) {
	  if (_isArray$1(a)) {
	    if (_isArray$1(b)) {
	      return a.concat(b);
	    }

	    throw new TypeError(toString$4(b) + ' is not an array');
	  }

	  if (_isString(a)) {
	    if (_isString(b)) {
	      return a + b;
	    }

	    throw new TypeError(toString$4(b) + ' is not a string');
	  }

	  if (a != null && _isFunction(a['fantasy-land/concat'])) {
	    return a['fantasy-land/concat'](b);
	  }

	  if (a != null && _isFunction(a.concat)) {
	    return a.concat(b);
	  }

	  throw new TypeError(toString$4(a) + ' does not have a method named "concat" or "fantasy-land/concat"');
	});

	/**
	 * Returns a function, `fn`, which encapsulates `if/else, if/else, ...` logic.
	 * `R.cond` takes a list of [predicate, transformer] pairs. All of the arguments
	 * to `fn` are applied to each of the predicates in turn until one returns a
	 * "truthy" value, at which point `fn` returns the result of applying its
	 * arguments to the corresponding transformer. If none of the predicates
	 * matches, `fn` returns undefined.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.6.0
	 * @category Logic
	 * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
	 * @param {Array} pairs A list of [predicate, transformer]
	 * @return {Function}
	 * @example
	 *
	 *      var fn = R.cond([
	 *        [R.equals(0),   R.always('water freezes at 0Â°C')],
	 *        [R.equals(100), R.always('water boils at 100Â°C')],
	 *        [R.T,           temp => 'nothing special happens at ' + temp + 'Â°C']
	 *      ]);
	 *      fn(0); //=> 'water freezes at 0Â°C'
	 *      fn(50); //=> 'nothing special happens at 50Â°C'
	 *      fn(100); //=> 'water boils at 100Â°C'
	 */

	var cond =
	/*#__PURE__*/
	_curry1(function cond(pairs) {
	  var arity = reduce$1(max$3, 0, map$1(function (pair) {
	    return pair[0].length;
	  }, pairs));
	  return _arity(arity, function () {
	    var idx = 0;

	    while (idx < pairs.length) {
	      if (pairs[idx][0].apply(this, arguments)) {
	        return pairs[idx][1].apply(this, arguments);
	      }

	      idx += 1;
	    }
	  });
	});

	/**
	 * Wraps a constructor function inside a curried function that can be called
	 * with the same arguments and returns the same type. The arity of the function
	 * returned is specified to allow using variadic constructor functions.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.4.0
	 * @category Function
	 * @sig Number -> (* -> {*}) -> (* -> {*})
	 * @param {Number} n The arity of the constructor function.
	 * @param {Function} Fn The constructor function to wrap.
	 * @return {Function} A wrapped, curried constructor function.
	 * @example
	 *
	 *      // Variadic Constructor function
	 *      function Salad() {
	 *        this.ingredients = arguments;
	 *      }
	 *
	 *      Salad.prototype.recipe = function() {
	 *        var instructions = R.map(ingredient => 'Add a dollop of ' + ingredient, this.ingredients);
	 *        return R.join('\n', instructions);
	 *      };
	 *
	 *      var ThreeLayerSalad = R.constructN(3, Salad);
	 *
	 *      // Notice we no longer need the 'new' keyword, and the constructor is curried for 3 arguments.
	 *      var salad = ThreeLayerSalad('Mayonnaise')('Potato Chips')('Ketchup');
	 *
	 *      console.log(salad.recipe());
	 *      // Add a dollop of Mayonnaise
	 *      // Add a dollop of Potato Chips
	 *      // Add a dollop of Ketchup
	 */

	var constructN =
	/*#__PURE__*/
	_curry2(function constructN(n, Fn) {
	  if (n > 10) {
	    throw new Error('Constructor with greater than ten arguments');
	  }

	  if (n === 0) {
	    return function () {
	      return new Fn();
	    };
	  }

	  return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
	    switch (arguments.length) {
	      case 1:
	        return new Fn($0);

	      case 2:
	        return new Fn($0, $1);

	      case 3:
	        return new Fn($0, $1, $2);

	      case 4:
	        return new Fn($0, $1, $2, $3);

	      case 5:
	        return new Fn($0, $1, $2, $3, $4);

	      case 6:
	        return new Fn($0, $1, $2, $3, $4, $5);

	      case 7:
	        return new Fn($0, $1, $2, $3, $4, $5, $6);

	      case 8:
	        return new Fn($0, $1, $2, $3, $4, $5, $6, $7);

	      case 9:
	        return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);

	      case 10:
	        return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
	    }
	  }));
	});

	/**
	 * Wraps a constructor function inside a curried function that can be called
	 * with the same arguments and returns the same type.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig (* -> {*}) -> (* -> {*})
	 * @param {Function} fn The constructor function to wrap.
	 * @return {Function} A wrapped, curried constructor function.
	 * @see R.invoker
	 * @example
	 *
	 *      // Constructor function
	 *      function Animal(kind) {
	 *        this.kind = kind;
	 *      };
	 *      Animal.prototype.sighting = function() {
	 *        return "It's a " + this.kind + "!";
	 *      }
	 *
	 *      var AnimalConstructor = R.construct(Animal)
	 *
	 *      // Notice we no longer need the 'new' keyword:
	 *      AnimalConstructor('Pig'); //=> {"kind": "Pig", "sighting": function (){...}};
	 *
	 *      var animalTypes = ["Lion", "Tiger", "Bear"];
	 *      var animalSighting = R.invoker(0, 'sighting');
	 *      var sightNewAnimal = R.compose(animalSighting, AnimalConstructor);
	 *      R.map(sightNewAnimal, animalTypes); //=> ["It's a Lion!", "It's a Tiger!", "It's a Bear!"]
	 */

	var construct$1 =
	/*#__PURE__*/
	_curry1(function construct(Fn) {
	  return constructN(Fn.length, Fn);
	});

	/**
	 * Returns `true` if the specified value is equal, in [`R.equals`](#equals)
	 * terms, to at least one element of the given list; `false` otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig a -> [a] -> Boolean
	 * @param {Object} a The item to compare against.
	 * @param {Array} list The array to consider.
	 * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
	 * @see R.any
	 * @example
	 *
	 *      R.contains(3, [1, 2, 3]); //=> true
	 *      R.contains(4, [1, 2, 3]); //=> false
	 *      R.contains({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
	 *      R.contains([42], [[42]]); //=> true
	 */

	var contains$1 =
	/*#__PURE__*/
	_curry2(_contains);

	/**
	 * Accepts a converging function and a list of branching functions and returns
	 * a new function. When invoked, this new function is applied to some
	 * arguments, each branching function is applied to those same arguments. The
	 * results of each branching function are passed as arguments to the converging
	 * function to produce the return value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.4.2
	 * @category Function
	 * @sig ((x1, x2, ...) -> z) -> [((a, b, ...) -> x1), ((a, b, ...) -> x2), ...] -> (a -> b -> ... -> z)
	 * @param {Function} after A function. `after` will be invoked with the return values of
	 *        `fn1` and `fn2` as its arguments.
	 * @param {Array} functions A list of functions.
	 * @return {Function} A new function.
	 * @see R.useWith
	 * @example
	 *
	 *      var average = R.converge(R.divide, [R.sum, R.length])
	 *      average([1, 2, 3, 4, 5, 6, 7]) //=> 4
	 *
	 *      var strangeConcat = R.converge(R.concat, [R.toUpper, R.toLower])
	 *      strangeConcat("Yodel") //=> "YODELyodel"
	 *
	 * @symb R.converge(f, [g, h])(a, b) = f(g(a, b), h(a, b))
	 */

	var converge =
	/*#__PURE__*/
	_curry2(function converge(after, fns) {
	  return curryN(reduce$1(max$3, 0, pluck$1('length', fns)), function () {
	    var args = arguments;
	    var context = this;
	    return after.apply(context, _map(function (fn) {
	      return fn.apply(context, args);
	    }, fns));
	  });
	});

	var XReduceBy =
	/*#__PURE__*/
	function () {
	  function XReduceBy(valueFn, valueAcc, keyFn, xf) {
	    this.valueFn = valueFn;
	    this.valueAcc = valueAcc;
	    this.keyFn = keyFn;
	    this.xf = xf;
	    this.inputs = {};
	  }

	  XReduceBy.prototype['@@transducer/init'] = _xfBase.init;

	  XReduceBy.prototype['@@transducer/result'] = function (result) {
	    var key;

	    for (key in this.inputs) {
	      if (_has$1(key, this.inputs)) {
	        result = this.xf['@@transducer/step'](result, this.inputs[key]);

	        if (result['@@transducer/reduced']) {
	          result = result['@@transducer/value'];
	          break;
	        }
	      }
	    }

	    this.inputs = null;
	    return this.xf['@@transducer/result'](result);
	  };

	  XReduceBy.prototype['@@transducer/step'] = function (result, input) {
	    var key = this.keyFn(input);
	    this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
	    this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
	    return result;
	  };

	  return XReduceBy;
	}();

	var _xreduceBy =
	/*#__PURE__*/
	_curryN(4, [], function _xreduceBy(valueFn, valueAcc, keyFn, xf) {
	  return new XReduceBy(valueFn, valueAcc, keyFn, xf);
	});

	/**
	 * Groups the elements of the list according to the result of calling
	 * the String-returning function `keyFn` on each element and reduces the elements
	 * of each group to a single value via the reducer function `valueFn`.
	 *
	 * This function is basically a more general [`groupBy`](#groupBy) function.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.20.0
	 * @category List
	 * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
	 * @param {Function} valueFn The function that reduces the elements of each group to a single
	 *        value. Receives two values, accumulator for a particular group and the current element.
	 * @param {*} acc The (initial) accumulator value for each group.
	 * @param {Function} keyFn The function that maps the list's element into a key.
	 * @param {Array} list The array to group.
	 * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
	 *         `valueFn` for elements which produced that key when passed to `keyFn`.
	 * @see R.groupBy, R.reduce
	 * @example
	 *
	 *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);
	 *      var namesByGrade = reduceToNamesBy(function(student) {
	 *        var score = student.score;
	 *        return score < 65 ? 'F' :
	 *               score < 70 ? 'D' :
	 *               score < 80 ? 'C' :
	 *               score < 90 ? 'B' : 'A';
	 *      });
	 *      var students = [{name: 'Lucy', score: 92},
	 *                      {name: 'Drew', score: 85},
	 *                      // ...
	 *                      {name: 'Bart', score: 62}];
	 *      namesByGrade(students);
	 *      // {
	 *      //   'A': ['Lucy'],
	 *      //   'B': ['Drew']
	 *      //   // ...,
	 *      //   'F': ['Bart']
	 *      // }
	 */

	var reduceBy =
	/*#__PURE__*/
	_curryN(4, [],
	/*#__PURE__*/
	_dispatchable([], _xreduceBy, function reduceBy(valueFn, valueAcc, keyFn, list) {
	  return _reduce(function (acc, elt) {
	    var key = keyFn(elt);
	    acc[key] = valueFn(_has$1(key, acc) ? acc[key] : valueAcc, elt);
	    return acc;
	  }, {}, list);
	}));

	/**
	 * Counts the elements of a list according to how many match each value of a
	 * key generated by the supplied function. Returns an object mapping the keys
	 * produced by `fn` to the number of occurrences in the list. Note that all
	 * keys are coerced to strings because of how JavaScript objects work.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig (a -> String) -> [a] -> {*}
	 * @param {Function} fn The function used to map values to keys.
	 * @param {Array} list The list to count elements from.
	 * @return {Object} An object mapping keys to number of occurrences in the list.
	 * @example
	 *
	 *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
	 *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
	 *
	 *      var letters = ['a', 'b', 'A', 'a', 'B', 'c'];
	 *      R.countBy(R.toLower)(letters);   //=> {'a': 3, 'b': 2, 'c': 1}
	 */

	var countBy =
	/*#__PURE__*/
	reduceBy(function (acc, elem) {
	  return acc + 1;
	}, 0);

	/**
	 * Decrements its argument.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Math
	 * @sig Number -> Number
	 * @param {Number} n
	 * @return {Number} n - 1
	 * @see R.inc
	 * @example
	 *
	 *      R.dec(42); //=> 41
	 */

	var dec =
	/*#__PURE__*/
	add(-1);

	/**
	 * Returns the second argument if it is not `null`, `undefined` or `NaN`;
	 * otherwise the first argument is returned.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category Logic
	 * @sig a -> b -> a | b
	 * @param {a} default The default value.
	 * @param {b} val `val` will be returned instead of `default` unless `val` is `null`, `undefined` or `NaN`.
	 * @return {*} The second value if it is not `null`, `undefined` or `NaN`, otherwise the default value
	 * @example
	 *
	 *      var defaultTo42 = R.defaultTo(42);
	 *
	 *      defaultTo42(null);  //=> 42
	 *      defaultTo42(undefined);  //=> 42
	 *      defaultTo42('Ramda');  //=> 'Ramda'
	 *      // parseInt('string') results in NaN
	 *      defaultTo42(parseInt('string')); //=> 42
	 */

	var defaultTo =
	/*#__PURE__*/
	_curry2(function defaultTo(d, v) {
	  return v == null || v !== v ? d : v;
	});

	/**
	 * Makes a descending comparator function out of a function that returns a value
	 * that can be compared with `<` and `>`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.23.0
	 * @category Function
	 * @sig Ord b => (a -> b) -> a -> a -> Number
	 * @param {Function} fn A function of arity one that returns a value that can be compared
	 * @param {*} a The first item to be compared.
	 * @param {*} b The second item to be compared.
	 * @return {Number} `-1` if fn(a) > fn(b), `1` if fn(b) > fn(a), otherwise `0`
	 * @see R.ascend
	 * @example
	 *
	 *      var byAge = R.descend(R.prop('age'));
	 *      var people = [
	 *        // ...
	 *      ];
	 *      var peopleByOldestFirst = R.sort(byAge, people);
	 */

	var descend =
	/*#__PURE__*/
	_curry3(function descend(fn, a, b) {
	  var aa = fn(a);
	  var bb = fn(b);
	  return aa > bb ? -1 : aa < bb ? 1 : 0;
	});

	/**
	 * Finds the set (i.e. no duplicates) of all elements in the first list not
	 * contained in the second list. Objects and Arrays are compared in terms of
	 * value equality, not reference equality.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig [*] -> [*] -> [*]
	 * @param {Array} list1 The first list.
	 * @param {Array} list2 The second list.
	 * @return {Array} The elements in `list1` that are not in `list2`.
	 * @see R.differenceWith, R.symmetricDifference, R.symmetricDifferenceWith, R.without
	 * @example
	 *
	 *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
	 *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
	 *      R.difference([{a: 1}, {b: 2}], [{a: 1}, {c: 3}]) //=> [{b: 2}]
	 */

	var difference =
	/*#__PURE__*/
	_curry2(function difference(first, second) {
	  var out = [];
	  var idx = 0;
	  var firstLen = first.length;

	  while (idx < firstLen) {
	    if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
	      out[out.length] = first[idx];
	    }

	    idx += 1;
	  }

	  return out;
	});

	/**
	 * Finds the set (i.e. no duplicates) of all elements in the first list not
	 * contained in the second list. Duplication is determined according to the
	 * value returned by applying the supplied predicate to two list elements.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
	 * @param {Function} pred A predicate used to test whether two items are equal.
	 * @param {Array} list1 The first list.
	 * @param {Array} list2 The second list.
	 * @return {Array} The elements in `list1` that are not in `list2`.
	 * @see R.difference, R.symmetricDifference, R.symmetricDifferenceWith
	 * @example
	 *
	 *      var cmp = (x, y) => x.a === y.a;
	 *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
	 *      var l2 = [{a: 3}, {a: 4}];
	 *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
	 */

	var differenceWith =
	/*#__PURE__*/
	_curry3(function differenceWith(pred, first, second) {
	  var out = [];
	  var idx = 0;
	  var firstLen = first.length;

	  while (idx < firstLen) {
	    if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
	      out.push(first[idx]);
	    }

	    idx += 1;
	  }

	  return out;
	});

	/**
	 * Returns a new object that does not contain a `prop` property.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category Object
	 * @sig String -> {k: v} -> {k: v}
	 * @param {String} prop The name of the property to dissociate
	 * @param {Object} obj The object to clone
	 * @return {Object} A new object equivalent to the original but without the specified property
	 * @see R.assoc
	 * @example
	 *
	 *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
	 */

	var dissoc =
	/*#__PURE__*/
	_curry2(function dissoc(prop, obj) {
	  var result = {};

	  for (var p in obj) {
	    result[p] = obj[p];
	  }

	  delete result[prop];
	  return result;
	});

	/**
	 * Removes the sub-list of `list` starting at index `start` and containing
	 * `count` elements. _Note that this is not destructive_: it returns a copy of
	 * the list with the changes.
	 * <small>No lists have been harmed in the application of this function.</small>
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.2
	 * @category List
	 * @sig Number -> Number -> [a] -> [a]
	 * @param {Number} start The position to start removing elements
	 * @param {Number} count The number of elements to remove
	 * @param {Array} list The list to remove from
	 * @return {Array} A new Array with `count` elements from `start` removed.
	 * @example
	 *
	 *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
	 */

	var remove$1 =
	/*#__PURE__*/
	_curry3(function remove(start, count, list) {
	  var result = Array.prototype.slice.call(list, 0);
	  result.splice(start, count);
	  return result;
	});

	/**
	 * Returns a new copy of the array with the element at the provided index
	 * replaced with the given value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category List
	 * @sig Number -> a -> [a] -> [a]
	 * @param {Number} idx The index to update.
	 * @param {*} x The value to exist at the given index of the returned array.
	 * @param {Array|Arguments} list The source array-like object to be updated.
	 * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
	 * @see R.adjust
	 * @example
	 *
	 *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
	 *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
	 * @symb R.update(-1, a, [b, c]) = [b, a]
	 * @symb R.update(0, a, [b, c]) = [a, c]
	 * @symb R.update(1, a, [b, c]) = [b, a]
	 */

	var update =
	/*#__PURE__*/
	_curry3(function update(idx, x, list) {
	  return adjust(always(x), idx, list);
	});

	/**
	 * Makes a shallow clone of an object, omitting the property at the given path.
	 * Note that this copies and flattens prototype properties onto the new object
	 * as well. All non-primitive properties are copied by reference.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.11.0
	 * @category Object
	 * @typedefn Idx = String | Int
	 * @sig [Idx] -> {k: v} -> {k: v}
	 * @param {Array} path The path to the value to omit
	 * @param {Object} obj The object to clone
	 * @return {Object} A new object without the property at path
	 * @see R.assocPath
	 * @example
	 *
	 *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
	 */

	var dissocPath =
	/*#__PURE__*/
	_curry2(function dissocPath(path, obj) {
	  switch (path.length) {
	    case 0:
	      return obj;

	    case 1:
	      return _isInteger$1(path[0]) ? remove$1(path[0], 1, obj) : dissoc(path[0], obj);

	    default:
	      var head = path[0];
	      var tail = Array.prototype.slice.call(path, 1);

	      if (obj[head] == null) {
	        return obj;
	      } else if (_isInteger$1(path[0])) {
	        return update(head, dissocPath(tail, obj[head]), obj);
	      } else {
	        return assoc(head, dissocPath(tail, obj[head]), obj);
	      }

	  }
	});

	/**
	 * Divides two numbers. Equivalent to `a / b`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Math
	 * @sig Number -> Number -> Number
	 * @param {Number} a The first value.
	 * @param {Number} b The second value.
	 * @return {Number} The result of `a / b`.
	 * @see R.multiply
	 * @example
	 *
	 *      R.divide(71, 100); //=> 0.71
	 *
	 *      var half = R.divide(R.__, 2);
	 *      half(42); //=> 21
	 *
	 *      var reciprocal = R.divide(1);
	 *      reciprocal(4);   //=> 0.25
	 */

	var divide =
	/*#__PURE__*/
	_curry2(function divide(a, b) {
	  return a / b;
	});

	var XDrop =
	/*#__PURE__*/
	function () {
	  function XDrop(n, xf) {
	    this.xf = xf;
	    this.n = n;
	  }

	  XDrop.prototype['@@transducer/init'] = _xfBase.init;
	  XDrop.prototype['@@transducer/result'] = _xfBase.result;

	  XDrop.prototype['@@transducer/step'] = function (result, input) {
	    if (this.n > 0) {
	      this.n -= 1;
	      return result;
	    }

	    return this.xf['@@transducer/step'](result, input);
	  };

	  return XDrop;
	}();

	var _xdrop =
	/*#__PURE__*/
	_curry2(function _xdrop(n, xf) {
	  return new XDrop(n, xf);
	});

	/**
	 * Returns all but the first `n` elements of the given list, string, or
	 * transducer/transformer (or object with a `drop` method).
	 *
	 * Dispatches to the `drop` method of the second argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Number -> [a] -> [a]
	 * @sig Number -> String -> String
	 * @param {Number} n
	 * @param {*} list
	 * @return {*} A copy of list without the first `n` elements
	 * @see R.take, R.transduce, R.dropLast, R.dropWhile
	 * @example
	 *
	 *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
	 *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
	 *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
	 *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
	 *      R.drop(3, 'ramda');               //=> 'da'
	 */

	var drop =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable(['drop'], _xdrop, function drop(n, xs) {
	  return slice(Math.max(0, n), Infinity, xs);
	}));

	var XTake =
	/*#__PURE__*/
	function () {
	  function XTake(n, xf) {
	    this.xf = xf;
	    this.n = n;
	    this.i = 0;
	  }

	  XTake.prototype['@@transducer/init'] = _xfBase.init;
	  XTake.prototype['@@transducer/result'] = _xfBase.result;

	  XTake.prototype['@@transducer/step'] = function (result, input) {
	    this.i += 1;
	    var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
	    return this.n >= 0 && this.i >= this.n ? _reduced(ret) : ret;
	  };

	  return XTake;
	}();

	var _xtake =
	/*#__PURE__*/
	_curry2(function _xtake(n, xf) {
	  return new XTake(n, xf);
	});

	/**
	 * Returns the first `n` elements of the given list, string, or
	 * transducer/transformer (or object with a `take` method).
	 *
	 * Dispatches to the `take` method of the second argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Number -> [a] -> [a]
	 * @sig Number -> String -> String
	 * @param {Number} n
	 * @param {*} list
	 * @return {*}
	 * @see R.drop
	 * @example
	 *
	 *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
	 *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
	 *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	 *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	 *      R.take(3, 'ramda');               //=> 'ram'
	 *
	 *      var personnel = [
	 *        'Dave Brubeck',
	 *        'Paul Desmond',
	 *        'Eugene Wright',
	 *        'Joe Morello',
	 *        'Gerry Mulligan',
	 *        'Bob Bates',
	 *        'Joe Dodge',
	 *        'Ron Crotty'
	 *      ];
	 *
	 *      var takeFive = R.take(5);
	 *      takeFive(personnel);
	 *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
	 * @symb R.take(-1, [a, b]) = [a, b]
	 * @symb R.take(0, [a, b]) = []
	 * @symb R.take(1, [a, b]) = [a]
	 * @symb R.take(2, [a, b]) = [a, b]
	 */

	var take$1 =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable(['take'], _xtake, function take(n, xs) {
	  return slice(0, n < 0 ? Infinity : n, xs);
	}));

	function dropLast(n, xs) {
	  return take$1(n < xs.length ? xs.length - n : 0, xs);
	}

	var XDropLast =
	/*#__PURE__*/
	function () {
	  function XDropLast(n, xf) {
	    this.xf = xf;
	    this.pos = 0;
	    this.full = false;
	    this.acc = new Array(n);
	  }

	  XDropLast.prototype['@@transducer/init'] = _xfBase.init;

	  XDropLast.prototype['@@transducer/result'] = function (result) {
	    this.acc = null;
	    return this.xf['@@transducer/result'](result);
	  };

	  XDropLast.prototype['@@transducer/step'] = function (result, input) {
	    if (this.full) {
	      result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
	    }

	    this.store(input);
	    return result;
	  };

	  XDropLast.prototype.store = function (input) {
	    this.acc[this.pos] = input;
	    this.pos += 1;

	    if (this.pos === this.acc.length) {
	      this.pos = 0;
	      this.full = true;
	    }
	  };

	  return XDropLast;
	}();

	var _xdropLast =
	/*#__PURE__*/
	_curry2(function _xdropLast(n, xf) {
	  return new XDropLast(n, xf);
	});

	/**
	 * Returns a list containing all but the last `n` elements of the given `list`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category List
	 * @sig Number -> [a] -> [a]
	 * @sig Number -> String -> String
	 * @param {Number} n The number of elements of `list` to skip.
	 * @param {Array} list The list of elements to consider.
	 * @return {Array} A copy of the list with only the first `list.length - n` elements
	 * @see R.takeLast, R.drop, R.dropWhile, R.dropLastWhile
	 * @example
	 *
	 *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
	 *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
	 *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
	 *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
	 *      R.dropLast(3, 'ramda');               //=> 'ra'
	 */

	var dropLast$1 =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable([], _xdropLast, dropLast));

	function dropLastWhile(pred, xs) {
	  var idx = xs.length - 1;

	  while (idx >= 0 && pred(xs[idx])) {
	    idx -= 1;
	  }

	  return slice(0, idx + 1, xs);
	}

	var XDropLastWhile =
	/*#__PURE__*/
	function () {
	  function XDropLastWhile(fn, xf) {
	    this.f = fn;
	    this.retained = [];
	    this.xf = xf;
	  }

	  XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;

	  XDropLastWhile.prototype['@@transducer/result'] = function (result) {
	    this.retained = null;
	    return this.xf['@@transducer/result'](result);
	  };

	  XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
	    return this.f(input) ? this.retain(result, input) : this.flush(result, input);
	  };

	  XDropLastWhile.prototype.flush = function (result, input) {
	    result = _reduce(this.xf['@@transducer/step'], result, this.retained);
	    this.retained = [];
	    return this.xf['@@transducer/step'](result, input);
	  };

	  XDropLastWhile.prototype.retain = function (result, input) {
	    this.retained.push(input);
	    return result;
	  };

	  return XDropLastWhile;
	}();

	var _xdropLastWhile =
	/*#__PURE__*/
	_curry2(function _xdropLastWhile(fn, xf) {
	  return new XDropLastWhile(fn, xf);
	});

	/**
	 * Returns a new list excluding all the tailing elements of a given list which
	 * satisfy the supplied predicate function. It passes each value from the right
	 * to the supplied predicate function, skipping elements until the predicate
	 * function returns a `falsy` value. The predicate function is applied to one argument:
	 * *(value)*.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> [a]
	 * @sig (a -> Boolean) -> String -> String
	 * @param {Function} predicate The function to be called on each element
	 * @param {Array} xs The collection to iterate over.
	 * @return {Array} A new array without any trailing elements that return `falsy` values from the `predicate`.
	 * @see R.takeLastWhile, R.addIndex, R.drop, R.dropWhile
	 * @example
	 *
	 *      var lteThree = x => x <= 3;
	 *
	 *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
	 *
	 *      R.dropLastWhile(x => x !== 'd' , 'Ramda'); //=> 'Ramd'
	 */

	var dropLastWhile$1 =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable([], _xdropLastWhile, dropLastWhile));

	var XDropRepeatsWith =
	/*#__PURE__*/
	function () {
	  function XDropRepeatsWith(pred, xf) {
	    this.xf = xf;
	    this.pred = pred;
	    this.lastValue = undefined;
	    this.seenFirstValue = false;
	  }

	  XDropRepeatsWith.prototype['@@transducer/init'] = _xfBase.init;
	  XDropRepeatsWith.prototype['@@transducer/result'] = _xfBase.result;

	  XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
	    var sameAsLast = false;

	    if (!this.seenFirstValue) {
	      this.seenFirstValue = true;
	    } else if (this.pred(this.lastValue, input)) {
	      sameAsLast = true;
	    }

	    this.lastValue = input;
	    return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
	  };

	  return XDropRepeatsWith;
	}();

	var _xdropRepeatsWith =
	/*#__PURE__*/
	_curry2(function _xdropRepeatsWith(pred, xf) {
	  return new XDropRepeatsWith(pred, xf);
	});

	/**
	 * Returns the nth element of the given list or string. If n is negative the
	 * element at index length + n is returned.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Number -> [a] -> a | Undefined
	 * @sig Number -> String -> String
	 * @param {Number} offset
	 * @param {*} list
	 * @return {*}
	 * @example
	 *
	 *      var list = ['foo', 'bar', 'baz', 'quux'];
	 *      R.nth(1, list); //=> 'bar'
	 *      R.nth(-1, list); //=> 'quux'
	 *      R.nth(-99, list); //=> undefined
	 *
	 *      R.nth(2, 'abc'); //=> 'c'
	 *      R.nth(3, 'abc'); //=> ''
	 * @symb R.nth(-1, [a, b, c]) = c
	 * @symb R.nth(0, [a, b, c]) = a
	 * @symb R.nth(1, [a, b, c]) = b
	 */

	var nth =
	/*#__PURE__*/
	_curry2(function nth(offset, list) {
	  var idx = offset < 0 ? list.length + offset : offset;
	  return _isString(list) ? list.charAt(idx) : list[idx];
	});

	/**
	 * Returns the last element of the given list or string.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.4
	 * @category List
	 * @sig [a] -> a | Undefined
	 * @sig String -> String
	 * @param {*} list
	 * @return {*}
	 * @see R.init, R.head, R.tail
	 * @example
	 *
	 *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
	 *      R.last([]); //=> undefined
	 *
	 *      R.last('abc'); //=> 'c'
	 *      R.last(''); //=> ''
	 */

	var last$1 =
	/*#__PURE__*/
	nth(-1);

	/**
	 * Returns a new list without any consecutively repeating elements. Equality is
	 * determined by applying the supplied predicate to each pair of consecutive elements. The
	 * first element in a series of equal elements will be preserved.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category List
	 * @sig ((a, a) -> Boolean) -> [a] -> [a]
	 * @param {Function} pred A predicate used to test whether two items are equal.
	 * @param {Array} list The array to consider.
	 * @return {Array} `list` without repeating elements.
	 * @see R.transduce
	 * @example
	 *
	 *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
	 *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
	 */

	var dropRepeatsWith =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable([], _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
	  var result = [];
	  var idx = 1;
	  var len = list.length;

	  if (len !== 0) {
	    result[0] = list[0];

	    while (idx < len) {
	      if (!pred(last$1(result), list[idx])) {
	        result[result.length] = list[idx];
	      }

	      idx += 1;
	    }
	  }

	  return result;
	}));

	/**
	 * Returns a new list without any consecutively repeating elements.
	 * [`R.equals`](#equals) is used to determine equality.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category List
	 * @sig [a] -> [a]
	 * @param {Array} list The array to consider.
	 * @return {Array} `list` without repeating elements.
	 * @see R.transduce
	 * @example
	 *
	 *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
	 */

	var dropRepeats =
	/*#__PURE__*/
	_curry1(
	/*#__PURE__*/
	_dispatchable([],
	/*#__PURE__*/
	_xdropRepeatsWith(equals),
	/*#__PURE__*/
	dropRepeatsWith(equals)));

	var XDropWhile =
	/*#__PURE__*/
	function () {
	  function XDropWhile(f, xf) {
	    this.xf = xf;
	    this.f = f;
	  }

	  XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
	  XDropWhile.prototype['@@transducer/result'] = _xfBase.result;

	  XDropWhile.prototype['@@transducer/step'] = function (result, input) {
	    if (this.f) {
	      if (this.f(input)) {
	        return result;
	      }

	      this.f = null;
	    }

	    return this.xf['@@transducer/step'](result, input);
	  };

	  return XDropWhile;
	}();

	var _xdropWhile =
	/*#__PURE__*/
	_curry2(function _xdropWhile(f, xf) {
	  return new XDropWhile(f, xf);
	});

	/**
	 * Returns a new list excluding the leading elements of a given list which
	 * satisfy the supplied predicate function. It passes each value to the supplied
	 * predicate function, skipping elements while the predicate function returns
	 * `true`. The predicate function is applied to one argument: *(value)*.
	 *
	 * Dispatches to the `dropWhile` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> [a]
	 * @sig (a -> Boolean) -> String -> String
	 * @param {Function} fn The function called per iteration.
	 * @param {Array} xs The collection to iterate over.
	 * @return {Array} A new array.
	 * @see R.takeWhile, R.transduce, R.addIndex
	 * @example
	 *
	 *      var lteTwo = x => x <= 2;
	 *
	 *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
	 *
	 *      R.dropWhile(x => x !== 'd' , 'Ramda'); //=> 'da'
	 */

	var dropWhile =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable(['dropWhile'], _xdropWhile, function dropWhile(pred, xs) {
	  var idx = 0;
	  var len = xs.length;

	  while (idx < len && pred(xs[idx])) {
	    idx += 1;
	  }

	  return slice(idx, Infinity, xs);
	}));

	/**
	 * Returns `true` if one or both of its arguments are `true`. Returns `false`
	 * if both arguments are `false`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Logic
	 * @sig a -> b -> a | b
	 * @param {Any} a
	 * @param {Any} b
	 * @return {Any} the first argument if truthy, otherwise the second argument.
	 * @see R.either
	 * @example
	 *
	 *      R.or(true, true); //=> true
	 *      R.or(true, false); //=> true
	 *      R.or(false, true); //=> true
	 *      R.or(false, false); //=> false
	 */

	var or =
	/*#__PURE__*/
	_curry2(function or(a, b) {
	  return a || b;
	});

	/**
	 * A function wrapping calls to the two functions in an `||` operation,
	 * returning the result of the first function if it is truth-y and the result
	 * of the second function otherwise. Note that this is short-circuited,
	 * meaning that the second function will not be invoked if the first returns a
	 * truth-y value.
	 *
	 * In addition to functions, `R.either` also accepts any fantasy-land compatible
	 * applicative functor.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category Logic
	 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
	 * @param {Function} f a predicate
	 * @param {Function} g another predicate
	 * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
	 * @see R.or
	 * @example
	 *
	 *      var gt10 = x => x > 10;
	 *      var even = x => x % 2 === 0;
	 *      var f = R.either(gt10, even);
	 *      f(101); //=> true
	 *      f(8); //=> true
	 */

	var either =
	/*#__PURE__*/
	_curry2(function either(f, g) {
	  return _isFunction(f) ? function _either() {
	    return f.apply(this, arguments) || g.apply(this, arguments);
	  } : lift(or)(f, g);
	});

	/**
	 * Returns the empty value of its argument's type. Ramda defines the empty
	 * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
	 * types are supported if they define `<Type>.empty`,
	 * `<Type>.prototype.empty` or implement the
	 * [FantasyLand Monoid spec](https://github.com/fantasyland/fantasy-land#monoid).
	 *
	 * Dispatches to the `empty` method of the first argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category Function
	 * @sig a -> a
	 * @param {*} x
	 * @return {*}
	 * @example
	 *
	 *      R.empty(Just(42));      //=> Nothing()
	 *      R.empty([1, 2, 3]);     //=> []
	 *      R.empty('unicorns');    //=> ''
	 *      R.empty({x: 1, y: 2});  //=> {}
	 */

	var empty$3 =
	/*#__PURE__*/
	_curry1(function empty(x) {
	  return x != null && typeof x['fantasy-land/empty'] === 'function' ? x['fantasy-land/empty']() : x != null && x.constructor != null && typeof x.constructor['fantasy-land/empty'] === 'function' ? x.constructor['fantasy-land/empty']() : x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray$1(x) ? [] : _isString(x) ? '' : _isObject$1(x) ? {} : _isArguments(x) ? function () {
	    return arguments;
	  }() : // else
	  void 0;
	});

	/**
	 * Returns a new list containing the last `n` elements of the given list.
	 * If `n > list.length`, returns a list of `list.length` elements.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category List
	 * @sig Number -> [a] -> [a]
	 * @sig Number -> String -> String
	 * @param {Number} n The number of elements to return.
	 * @param {Array} xs The collection to consider.
	 * @return {Array}
	 * @see R.dropLast
	 * @example
	 *
	 *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
	 *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
	 *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	 *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	 *      R.takeLast(3, 'ramda');               //=> 'mda'
	 */

	var takeLast$1 =
	/*#__PURE__*/
	_curry2(function takeLast(n, xs) {
	  return drop(n >= 0 ? xs.length - n : 0, xs);
	});

	/**
	 * Checks if a list ends with the provided values
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category List
	 * @sig [a] -> Boolean
	 * @sig String -> Boolean
	 * @param {*} suffix
	 * @param {*} list
	 * @return {Boolean}
	 * @example
	 *
	 *      R.endsWith('c', 'abc')                //=> true
	 *      R.endsWith('b', 'abc')                //=> false
	 *      R.endsWith(['c'], ['a', 'b', 'c'])    //=> true
	 *      R.endsWith(['b'], ['a', 'b', 'c'])    //=> false
	 */

	var endsWith =
	/*#__PURE__*/
	_curry2(function (suffix, list) {
	  return equals(takeLast$1(suffix.length, list), suffix);
	});

	/**
	 * Takes a function and two values in its domain and returns `true` if the
	 * values map to the same value in the codomain; `false` otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.18.0
	 * @category Relation
	 * @sig (a -> b) -> a -> a -> Boolean
	 * @param {Function} f
	 * @param {*} x
	 * @param {*} y
	 * @return {Boolean}
	 * @example
	 *
	 *      R.eqBy(Math.abs, 5, -5); //=> true
	 */

	var eqBy =
	/*#__PURE__*/
	_curry3(function eqBy(f, x, y) {
	  return equals(f(x), f(y));
	});

	/**
	 * Reports whether two objects have the same value, in [`R.equals`](#equals)
	 * terms, for the specified property. Useful as a curried predicate.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig k -> {k: v} -> {k: v} -> Boolean
	 * @param {String} prop The name of the property to compare
	 * @param {Object} obj1
	 * @param {Object} obj2
	 * @return {Boolean}
	 *
	 * @example
	 *
	 *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
	 *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
	 *      R.eqProps('a', o1, o2); //=> false
	 *      R.eqProps('c', o1, o2); //=> true
	 */

	var eqProps =
	/*#__PURE__*/
	_curry3(function eqProps(prop, obj1, obj2) {
	  return equals(obj1[prop], obj2[prop]);
	});

	/**
	 * Creates a new object by recursively evolving a shallow copy of `object`,
	 * according to the `transformation` functions. All non-primitive properties
	 * are copied by reference.
	 *
	 * A `transformation` function will not be invoked if its corresponding key
	 * does not exist in the evolved object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Object
	 * @sig {k: (v -> v)} -> {k: v} -> {k: v}
	 * @param {Object} transformations The object specifying transformation functions to apply
	 *        to the object.
	 * @param {Object} object The object to be transformed.
	 * @return {Object} The transformed object.
	 * @example
	 *
	 *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
	 *      var transformations = {
	 *        firstName: R.trim,
	 *        lastName: R.trim, // Will not get invoked.
	 *        data: {elapsed: R.add(1), remaining: R.add(-1)}
	 *      };
	 *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
	 */

	var evolve =
	/*#__PURE__*/
	_curry2(function evolve(transformations, object) {
	  var result = {};
	  var transformation, key, type;

	  for (key in object) {
	    transformation = transformations[key];
	    type = _typeof(transformation);
	    result[key] = type === 'function' ? transformation(object[key]) : transformation && type === 'object' ? evolve(transformation, object[key]) : object[key];
	  }

	  return result;
	});

	var XFind =
	/*#__PURE__*/
	function () {
	  function XFind(f, xf) {
	    this.xf = xf;
	    this.f = f;
	    this.found = false;
	  }

	  XFind.prototype['@@transducer/init'] = _xfBase.init;

	  XFind.prototype['@@transducer/result'] = function (result) {
	    if (!this.found) {
	      result = this.xf['@@transducer/step'](result, void 0);
	    }

	    return this.xf['@@transducer/result'](result);
	  };

	  XFind.prototype['@@transducer/step'] = function (result, input) {
	    if (this.f(input)) {
	      this.found = true;
	      result = _reduced(this.xf['@@transducer/step'](result, input));
	    }

	    return result;
	  };

	  return XFind;
	}();

	var _xfind =
	/*#__PURE__*/
	_curry2(function _xfind(f, xf) {
	  return new XFind(f, xf);
	});

	/**
	 * Returns the first element of the list which matches the predicate, or
	 * `undefined` if no element matches.
	 *
	 * Dispatches to the `find` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> a | undefined
	 * @param {Function} fn The predicate function used to determine if the element is the
	 *        desired one.
	 * @param {Array} list The array to consider.
	 * @return {Object} The element found, or `undefined`.
	 * @see R.transduce
	 * @example
	 *
	 *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	 *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
	 *      R.find(R.propEq('a', 4))(xs); //=> undefined
	 */

	var find$1 =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable(['find'], _xfind, function find(fn, list) {
	  var idx = 0;
	  var len = list.length;

	  while (idx < len) {
	    if (fn(list[idx])) {
	      return list[idx];
	    }

	    idx += 1;
	  }
	}));

	var XFindIndex =
	/*#__PURE__*/
	function () {
	  function XFindIndex(f, xf) {
	    this.xf = xf;
	    this.f = f;
	    this.idx = -1;
	    this.found = false;
	  }

	  XFindIndex.prototype['@@transducer/init'] = _xfBase.init;

	  XFindIndex.prototype['@@transducer/result'] = function (result) {
	    if (!this.found) {
	      result = this.xf['@@transducer/step'](result, -1);
	    }

	    return this.xf['@@transducer/result'](result);
	  };

	  XFindIndex.prototype['@@transducer/step'] = function (result, input) {
	    this.idx += 1;

	    if (this.f(input)) {
	      this.found = true;
	      result = _reduced(this.xf['@@transducer/step'](result, this.idx));
	    }

	    return result;
	  };

	  return XFindIndex;
	}();

	var _xfindIndex =
	/*#__PURE__*/
	_curry2(function _xfindIndex(f, xf) {
	  return new XFindIndex(f, xf);
	});

	/**
	 * Returns the index of the first element of the list which matches the
	 * predicate, or `-1` if no element matches.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.1
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> Number
	 * @param {Function} fn The predicate function used to determine if the element is the
	 * desired one.
	 * @param {Array} list The array to consider.
	 * @return {Number} The index of the element found, or `-1`.
	 * @see R.transduce
	 * @example
	 *
	 *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	 *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
	 *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
	 */

	var findIndex$1 =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable([], _xfindIndex, function findIndex(fn, list) {
	  var idx = 0;
	  var len = list.length;

	  while (idx < len) {
	    if (fn(list[idx])) {
	      return idx;
	    }

	    idx += 1;
	  }

	  return -1;
	}));

	var XFindLast =
	/*#__PURE__*/
	function () {
	  function XFindLast(f, xf) {
	    this.xf = xf;
	    this.f = f;
	  }

	  XFindLast.prototype['@@transducer/init'] = _xfBase.init;

	  XFindLast.prototype['@@transducer/result'] = function (result) {
	    return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
	  };

	  XFindLast.prototype['@@transducer/step'] = function (result, input) {
	    if (this.f(input)) {
	      this.last = input;
	    }

	    return result;
	  };

	  return XFindLast;
	}();

	var _xfindLast =
	/*#__PURE__*/
	_curry2(function _xfindLast(f, xf) {
	  return new XFindLast(f, xf);
	});

	/**
	 * Returns the last element of the list which matches the predicate, or
	 * `undefined` if no element matches.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.1
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> a | undefined
	 * @param {Function} fn The predicate function used to determine if the element is the
	 * desired one.
	 * @param {Array} list The array to consider.
	 * @return {Object} The element found, or `undefined`.
	 * @see R.transduce
	 * @example
	 *
	 *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
	 *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
	 *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
	 */

	var findLast =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable([], _xfindLast, function findLast(fn, list) {
	  var idx = list.length - 1;

	  while (idx >= 0) {
	    if (fn(list[idx])) {
	      return list[idx];
	    }

	    idx -= 1;
	  }
	}));

	var XFindLastIndex =
	/*#__PURE__*/
	function () {
	  function XFindLastIndex(f, xf) {
	    this.xf = xf;
	    this.f = f;
	    this.idx = -1;
	    this.lastIdx = -1;
	  }

	  XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;

	  XFindLastIndex.prototype['@@transducer/result'] = function (result) {
	    return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
	  };

	  XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
	    this.idx += 1;

	    if (this.f(input)) {
	      this.lastIdx = this.idx;
	    }

	    return result;
	  };

	  return XFindLastIndex;
	}();

	var _xfindLastIndex =
	/*#__PURE__*/
	_curry2(function _xfindLastIndex(f, xf) {
	  return new XFindLastIndex(f, xf);
	});

	/**
	 * Returns the index of the last element of the list which matches the
	 * predicate, or `-1` if no element matches.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.1
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> Number
	 * @param {Function} fn The predicate function used to determine if the element is the
	 * desired one.
	 * @param {Array} list The array to consider.
	 * @return {Number} The index of the element found, or `-1`.
	 * @see R.transduce
	 * @example
	 *
	 *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
	 *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
	 *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
	 */

	var findLastIndex =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable([], _xfindLastIndex, function findLastIndex(fn, list) {
	  var idx = list.length - 1;

	  while (idx >= 0) {
	    if (fn(list[idx])) {
	      return idx;
	    }

	    idx -= 1;
	  }

	  return -1;
	}));

	/**
	 * Returns a new list by pulling every item out of it (and all its sub-arrays)
	 * and putting them in a new array, depth-first.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> [b]
	 * @param {Array} list The array to consider.
	 * @return {Array} The flattened list.
	 * @see R.unnest
	 * @example
	 *
	 *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
	 *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
	 */

	var flatten$1 =
	/*#__PURE__*/
	_curry1(
	/*#__PURE__*/
	_makeFlat(true));

	/**
	 * Returns a new function much like the supplied one, except that the first two
	 * arguments' order is reversed.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig ((a, b, c, ...) -> z) -> (b -> a -> c -> ... -> z)
	 * @param {Function} fn The function to invoke with its first two parameters reversed.
	 * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
	 * @example
	 *
	 *      var mergeThree = (a, b, c) => [].concat(a, b, c);
	 *
	 *      mergeThree(1, 2, 3); //=> [1, 2, 3]
	 *
	 *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
	 * @symb R.flip(f)(a, b, c) = f(b, a, c)
	 */

	var flip =
	/*#__PURE__*/
	_curry1(function flip(fn) {
	  return curryN(fn.length, function (a, b) {
	    var args = Array.prototype.slice.call(arguments, 0);
	    args[0] = b;
	    args[1] = a;
	    return fn.apply(this, args);
	  });
	});

	/**
	 * Iterate over an input `list`, calling a provided function `fn` for each
	 * element in the list.
	 *
	 * `fn` receives one argument: *(value)*.
	 *
	 * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
	 * arrays), unlike the native `Array.prototype.forEach` method. For more
	 * details on this behavior, see:
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
	 *
	 * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
	 * the original array. In some libraries this function is named `each`.
	 *
	 * Dispatches to the `forEach` method of the second argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.1
	 * @category List
	 * @sig (a -> *) -> [a] -> [a]
	 * @param {Function} fn The function to invoke. Receives one argument, `value`.
	 * @param {Array} list The list to iterate over.
	 * @return {Array} The original list.
	 * @see R.addIndex
	 * @example
	 *
	 *      var printXPlusFive = x => console.log(x + 5);
	 *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
	 *      // logs 6
	 *      // logs 7
	 *      // logs 8
	 * @symb R.forEach(f, [a, b, c]) = [a, b, c]
	 */

	var forEach =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_checkForMethod('forEach', function forEach(fn, list) {
	  var len = list.length;
	  var idx = 0;

	  while (idx < len) {
	    fn(list[idx]);
	    idx += 1;
	  }

	  return list;
	}));

	/**
	 * Iterate over an input `object`, calling a provided function `fn` for each
	 * key and value in the object.
	 *
	 * `fn` receives three argument: *(value, key, obj)*.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.23.0
	 * @category Object
	 * @sig ((a, String, StrMap a) -> Any) -> StrMap a -> StrMap a
	 * @param {Function} fn The function to invoke. Receives three argument, `value`, `key`, `obj`.
	 * @param {Object} obj The object to iterate over.
	 * @return {Object} The original object.
	 * @example
	 *
	 *      var printKeyConcatValue = (value, key) => console.log(key + ':' + value);
	 *      R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=> {x: 1, y: 2}
	 *      // logs x:1
	 *      // logs y:2
	 * @symb R.forEachObjIndexed(f, {x: a, y: b}) = {x: a, y: b}
	 */

	var forEachObjIndexed =
	/*#__PURE__*/
	_curry2(function forEachObjIndexed(fn, obj) {
	  var keyList = keys$2(obj);
	  var idx = 0;

	  while (idx < keyList.length) {
	    var key = keyList[idx];
	    fn(obj[key], key, obj);
	    idx += 1;
	  }

	  return obj;
	});

	/**
	 * Creates a new object from a list key-value pairs. If a key appears in
	 * multiple pairs, the rightmost pair is included in the object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category List
	 * @sig [[k,v]] -> {k: v}
	 * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
	 * @return {Object} The object made by pairing up `keys` and `values`.
	 * @see R.toPairs, R.pair
	 * @example
	 *
	 *      R.fromPairs([['a', 1], ['b', 2], ['c', 3]]); //=> {a: 1, b: 2, c: 3}
	 */

	var fromPairs =
	/*#__PURE__*/
	_curry1(function fromPairs(pairs) {
	  var result = {};
	  var idx = 0;

	  while (idx < pairs.length) {
	    result[pairs[idx][0]] = pairs[idx][1];
	    idx += 1;
	  }

	  return result;
	});

	/**
	 * Splits a list into sub-lists stored in an object, based on the result of
	 * calling a String-returning function on each element, and grouping the
	 * results according to values returned.
	 *
	 * Dispatches to the `groupBy` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig (a -> String) -> [a] -> {String: [a]}
	 * @param {Function} fn Function :: a -> String
	 * @param {Array} list The array to group
	 * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
	 *         that produced that key when passed to `fn`.
	 * @see R.transduce
	 * @example
	 *
	 *      var byGrade = R.groupBy(function(student) {
	 *        var score = student.score;
	 *        return score < 65 ? 'F' :
	 *               score < 70 ? 'D' :
	 *               score < 80 ? 'C' :
	 *               score < 90 ? 'B' : 'A';
	 *      });
	 *      var students = [{name: 'Abby', score: 84},
	 *                      {name: 'Eddy', score: 58},
	 *                      // ...
	 *                      {name: 'Jack', score: 69}];
	 *      byGrade(students);
	 *      // {
	 *      //   'A': [{name: 'Dianne', score: 99}],
	 *      //   'B': [{name: 'Abby', score: 84}]
	 *      //   // ...,
	 *      //   'F': [{name: 'Eddy', score: 58}]
	 *      // }
	 */

	var groupBy$1 =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_checkForMethod('groupBy',
	/*#__PURE__*/
	reduceBy(function (acc, item) {
	  if (acc == null) {
	    acc = [];
	  }

	  acc.push(item);
	  return acc;
	}, null)));

	/**
	 * Takes a list and returns a list of lists where each sublist's elements are
	 * all satisfied pairwise comparison according to the provided function.
	 * Only adjacent elements are passed to the comparison function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.21.0
	 * @category List
	 * @sig ((a, a) â Boolean) â [a] â [[a]]
	 * @param {Function} fn Function for determining whether two given (adjacent)
	 *        elements should be in the same group
	 * @param {Array} list The array to group. Also accepts a string, which will be
	 *        treated as a list of characters.
	 * @return {List} A list that contains sublists of elements,
	 *         whose concatenations are equal to the original list.
	 * @example
	 *
	 * R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
	 * //=> [[0], [1, 1], [2], [3], [5], [8], [13], [21]]
	 *
	 * R.groupWith((a, b) => a + 1 === b, [0, 1, 1, 2, 3, 5, 8, 13, 21])
	 * //=> [[0, 1], [1, 2, 3], [5], [8], [13], [21]]
	 *
	 * R.groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
	 * //=> [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
	 *
	 * R.groupWith(R.eqBy(isVowel), 'aestiou')
	 * //=> ['ae', 'st', 'iou']
	 */

	var groupWith =
	/*#__PURE__*/
	_curry2(function (fn, list) {
	  var res = [];
	  var idx = 0;
	  var len = list.length;

	  while (idx < len) {
	    var nextidx = idx + 1;

	    while (nextidx < len && fn(list[nextidx - 1], list[nextidx])) {
	      nextidx += 1;
	    }

	    res.push(list.slice(idx, nextidx));
	    idx = nextidx;
	  }

	  return res;
	});

	/**
	 * Returns `true` if the first argument is greater than the second; `false`
	 * otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig Ord a => a -> a -> Boolean
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 * @see R.lt
	 * @example
	 *
	 *      R.gt(2, 1); //=> true
	 *      R.gt(2, 2); //=> false
	 *      R.gt(2, 3); //=> false
	 *      R.gt('a', 'z'); //=> false
	 *      R.gt('z', 'a'); //=> true
	 */

	var gt =
	/*#__PURE__*/
	_curry2(function gt(a, b) {
	  return a > b;
	});

	/**
	 * Returns `true` if the first argument is greater than or equal to the second;
	 * `false` otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig Ord a => a -> a -> Boolean
	 * @param {Number} a
	 * @param {Number} b
	 * @return {Boolean}
	 * @see R.lte
	 * @example
	 *
	 *      R.gte(2, 1); //=> true
	 *      R.gte(2, 2); //=> true
	 *      R.gte(2, 3); //=> false
	 *      R.gte('a', 'z'); //=> false
	 *      R.gte('z', 'a'); //=> true
	 */

	var gte =
	/*#__PURE__*/
	_curry2(function gte(a, b) {
	  return a >= b;
	});

	/**
	 * Returns whether or not an object has an own property with the specified name
	 *
	 * @func
	 * @memberOf R
	 * @since v0.7.0
	 * @category Object
	 * @sig s -> {s: x} -> Boolean
	 * @param {String} prop The name of the property to check for.
	 * @param {Object} obj The object to query.
	 * @return {Boolean} Whether the property exists.
	 * @example
	 *
	 *      var hasName = R.has('name');
	 *      hasName({name: 'alice'});   //=> true
	 *      hasName({name: 'bob'});     //=> true
	 *      hasName({});                //=> false
	 *
	 *      var point = {x: 0, y: 0};
	 *      var pointHas = R.has(R.__, point);
	 *      pointHas('x');  //=> true
	 *      pointHas('y');  //=> true
	 *      pointHas('z');  //=> false
	 */

	var has =
	/*#__PURE__*/
	_curry2(_has$1);

	/**
	 * Returns whether or not an object or its prototype chain has a property with
	 * the specified name
	 *
	 * @func
	 * @memberOf R
	 * @since v0.7.0
	 * @category Object
	 * @sig s -> {s: x} -> Boolean
	 * @param {String} prop The name of the property to check for.
	 * @param {Object} obj The object to query.
	 * @return {Boolean} Whether the property exists.
	 * @example
	 *
	 *      function Rectangle(width, height) {
	 *        this.width = width;
	 *        this.height = height;
	 *      }
	 *      Rectangle.prototype.area = function() {
	 *        return this.width * this.height;
	 *      };
	 *
	 *      var square = new Rectangle(2, 2);
	 *      R.hasIn('width', square);  //=> true
	 *      R.hasIn('area', square);  //=> true
	 */

	var hasIn =
	/*#__PURE__*/
	_curry2(function hasIn(prop, obj) {
	  return prop in obj;
	});

	/**
	 * Returns the first element of the given list or string. In some libraries
	 * this function is named `first`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> a | Undefined
	 * @sig String -> String
	 * @param {Array|String} list
	 * @return {*}
	 * @see R.tail, R.init, R.last
	 * @example
	 *
	 *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
	 *      R.head([]); //=> undefined
	 *
	 *      R.head('abc'); //=> 'a'
	 *      R.head(''); //=> ''
	 */

	var head =
	/*#__PURE__*/
	nth(0);

	function _identity(x) {
	  return x;
	}

	/**
	 * A function that does nothing but return the parameter supplied to it. Good
	 * as a default or placeholder function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig a -> a
	 * @param {*} x The value to return.
	 * @return {*} The input value, `x`.
	 * @example
	 *
	 *      R.identity(1); //=> 1
	 *
	 *      var obj = {};
	 *      R.identity(obj) === obj; //=> true
	 * @symb R.identity(a) = a
	 */

	var identity$1 =
	/*#__PURE__*/
	_curry1(_identity);

	/**
	 * Creates a function that will process either the `onTrue` or the `onFalse`
	 * function depending upon the result of the `condition` predicate.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Logic
	 * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
	 * @param {Function} condition A predicate function
	 * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
	 * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
	 * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
	 *                    function depending upon the result of the `condition` predicate.
	 * @see R.unless, R.when
	 * @example
	 *
	 *      var incCount = R.ifElse(
	 *        R.has('count'),
	 *        R.over(R.lensProp('count'), R.inc),
	 *        R.assoc('count', 1)
	 *      );
	 *      incCount({});           //=> { count: 1 }
	 *      incCount({ count: 1 }); //=> { count: 2 }
	 */

	var ifElse =
	/*#__PURE__*/
	_curry3(function ifElse(condition, onTrue, onFalse) {
	  return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
	    return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
	  });
	});

	/**
	 * Increments its argument.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Math
	 * @sig Number -> Number
	 * @param {Number} n
	 * @return {Number} n + 1
	 * @see R.dec
	 * @example
	 *
	 *      R.inc(42); //=> 43
	 */

	var inc =
	/*#__PURE__*/
	add(1);

	/**
	 * Given a function that generates a key, turns a list of objects into an
	 * object indexing the objects by the given key. Note that if multiple
	 * objects generate the same value for the indexing key only the last value
	 * will be included in the generated object.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category List
	 * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
	 * @param {Function} fn Function :: a -> String
	 * @param {Array} array The array of objects to index
	 * @return {Object} An object indexing each array element by the given property.
	 * @example
	 *
	 *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
	 *      R.indexBy(R.prop('id'), list);
	 *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
	 */

	var indexBy =
	/*#__PURE__*/
	reduceBy(function (acc, elem) {
	  return elem;
	}, null);

	/**
	 * Returns the position of the first occurrence of an item in an array, or -1
	 * if the item is not included in the array. [`R.equals`](#equals) is used to
	 * determine equality.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig a -> [a] -> Number
	 * @param {*} target The item to find.
	 * @param {Array} xs The array to search in.
	 * @return {Number} the index of the target, or -1 if the target is not found.
	 * @see R.lastIndexOf
	 * @example
	 *
	 *      R.indexOf(3, [1,2,3,4]); //=> 2
	 *      R.indexOf(10, [1,2,3,4]); //=> -1
	 */

	var indexOf$1 =
	/*#__PURE__*/
	_curry2(function indexOf(target, xs) {
	  return typeof xs.indexOf === 'function' && !_isArray$1(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
	});

	/**
	 * Returns all but the last element of the given list or string.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category List
	 * @sig [a] -> [a]
	 * @sig String -> String
	 * @param {*} list
	 * @return {*}
	 * @see R.last, R.head, R.tail
	 * @example
	 *
	 *      R.init([1, 2, 3]);  //=> [1, 2]
	 *      R.init([1, 2]);     //=> [1]
	 *      R.init([1]);        //=> []
	 *      R.init([]);         //=> []
	 *
	 *      R.init('abc');  //=> 'ab'
	 *      R.init('ab');   //=> 'a'
	 *      R.init('a');    //=> ''
	 *      R.init('');     //=> ''
	 */

	var init =
	/*#__PURE__*/
	slice(0, -1);

	/**
	 * Takes a predicate `pred`, a list `xs`, and a list `ys`, and returns a list
	 * `xs'` comprising each of the elements of `xs` which is equal to one or more
	 * elements of `ys` according to `pred`.
	 *
	 * `pred` must be a binary function expecting an element from each list.
	 *
	 * `xs`, `ys`, and `xs'` are treated as sets, semantically, so ordering should
	 * not be significant, but since `xs'` is ordered the implementation guarantees
	 * that its values are in the same order as they appear in `xs`. Duplicates are
	 * not removed, so `xs'` may contain duplicates if `xs` contains duplicates.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category Relation
	 * @sig ((a, b) -> Boolean) -> [a] -> [b] -> [a]
	 * @param {Function} pred
	 * @param {Array} xs
	 * @param {Array} ys
	 * @return {Array}
	 * @see R.intersection
	 * @example
	 *
	 *      R.innerJoin(
	 *        (record, id) => record.id === id,
	 *        [{id: 824, name: 'Richie Furay'},
	 *         {id: 956, name: 'Dewey Martin'},
	 *         {id: 313, name: 'Bruce Palmer'},
	 *         {id: 456, name: 'Stephen Stills'},
	 *         {id: 177, name: 'Neil Young'}],
	 *        [177, 456, 999]
	 *      );
	 *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
	 */

	var innerJoin =
	/*#__PURE__*/
	_curry3(function innerJoin(pred, xs, ys) {
	  return _filter(function (x) {
	    return _containsWith(pred, x, ys);
	  }, xs);
	});

	/**
	 * Inserts the supplied element into the list, at the specified `index`. _Note that

	 * this is not destructive_: it returns a copy of the list with the changes.
	 * <small>No lists have been harmed in the application of this function.</small>
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.2
	 * @category List
	 * @sig Number -> a -> [a] -> [a]
	 * @param {Number} index The position to insert the element
	 * @param {*} elt The element to insert into the Array
	 * @param {Array} list The list to insert into
	 * @return {Array} A new Array with `elt` inserted at `index`.
	 * @example
	 *
	 *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
	 */

	var insert =
	/*#__PURE__*/
	_curry3(function insert(idx, elt, list) {
	  idx = idx < list.length && idx >= 0 ? idx : list.length;
	  var result = Array.prototype.slice.call(list, 0);
	  result.splice(idx, 0, elt);
	  return result;
	});

	/**
	 * Inserts the sub-list into the list, at the specified `index`. _Note that this is not
	 * destructive_: it returns a copy of the list with the changes.
	 * <small>No lists have been harmed in the application of this function.</small>
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category List
	 * @sig Number -> [a] -> [a] -> [a]
	 * @param {Number} index The position to insert the sub-list
	 * @param {Array} elts The sub-list to insert into the Array
	 * @param {Array} list The list to insert the sub-list into
	 * @return {Array} A new Array with `elts` inserted starting at `index`.
	 * @example
	 *
	 *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
	 */

	var insertAll =
	/*#__PURE__*/
	_curry3(function insertAll(idx, elts, list) {
	  idx = idx < list.length && idx >= 0 ? idx : list.length;
	  return [].concat(Array.prototype.slice.call(list, 0, idx), elts, Array.prototype.slice.call(list, idx));
	});

	var _Set =
	/*#__PURE__*/
	function () {
	  function _Set() {
	    /* globals Set */
	    this._nativeSet = typeof Set === 'function' ? new Set() : null;
	    this._items = {};
	  } // until we figure out why jsdoc chokes on this
	  // @param item The item to add to the Set
	  // @returns {boolean} true if the item did not exist prior, otherwise false
	  //


	  _Set.prototype.add = function (item) {
	    return !hasOrAdd(item, true, this);
	  }; //
	  // @param item The item to check for existence in the Set
	  // @returns {boolean} true if the item exists in the Set, otherwise false
	  //


	  _Set.prototype.has = function (item) {
	    return hasOrAdd(item, false, this);
	  }; //
	  // Combines the logic for checking whether an item is a member of the set and
	  // for adding a new item to the set.
	  //
	  // @param item       The item to check or add to the Set instance.
	  // @param shouldAdd  If true, the item will be added to the set if it doesn't
	  //                   already exist.
	  // @param set        The set instance to check or add to.
	  // @return {boolean} true if the item already existed, otherwise false.
	  //


	  return _Set;
	}();

	function hasOrAdd(item, shouldAdd, set) {
	  var type = _typeof(item);

	  var prevSize, newSize;

	  switch (type) {
	    case 'string':
	    case 'number':
	      // distinguish between +0 and -0
	      if (item === 0 && 1 / item === -Infinity) {
	        if (set._items['-0']) {
	          return true;
	        } else {
	          if (shouldAdd) {
	            set._items['-0'] = true;
	          }

	          return false;
	        }
	      } // these types can all utilise the native Set


	      if (set._nativeSet !== null) {
	        if (shouldAdd) {
	          prevSize = set._nativeSet.size;

	          set._nativeSet.add(item);

	          newSize = set._nativeSet.size;
	          return newSize === prevSize;
	        } else {
	          return set._nativeSet.has(item);
	        }
	      } else {
	        if (!(type in set._items)) {
	          if (shouldAdd) {
	            set._items[type] = {};
	            set._items[type][item] = true;
	          }

	          return false;
	        } else if (item in set._items[type]) {
	          return true;
	        } else {
	          if (shouldAdd) {
	            set._items[type][item] = true;
	          }

	          return false;
	        }
	      }

	    case 'boolean':
	      // set._items['boolean'] holds a two element array
	      // representing [ falseExists, trueExists ]
	      if (type in set._items) {
	        var bIdx = item ? 1 : 0;

	        if (set._items[type][bIdx]) {
	          return true;
	        } else {
	          if (shouldAdd) {
	            set._items[type][bIdx] = true;
	          }

	          return false;
	        }
	      } else {
	        if (shouldAdd) {
	          set._items[type] = item ? [false, true] : [true, false];
	        }

	        return false;
	      }

	    case 'function':
	      // compare functions for reference equality
	      if (set._nativeSet !== null) {
	        if (shouldAdd) {
	          prevSize = set._nativeSet.size;

	          set._nativeSet.add(item);

	          newSize = set._nativeSet.size;
	          return newSize === prevSize;
	        } else {
	          return set._nativeSet.has(item);
	        }
	      } else {
	        if (!(type in set._items)) {
	          if (shouldAdd) {
	            set._items[type] = [item];
	          }

	          return false;
	        }

	        if (!_contains(item, set._items[type])) {
	          if (shouldAdd) {
	            set._items[type].push(item);
	          }

	          return false;
	        }

	        return true;
	      }

	    case 'undefined':
	      if (set._items[type]) {
	        return true;
	      } else {
	        if (shouldAdd) {
	          set._items[type] = true;
	        }

	        return false;
	      }

	    case 'object':
	      if (item === null) {
	        if (!set._items['null']) {
	          if (shouldAdd) {
	            set._items['null'] = true;
	          }

	          return false;
	        }

	        return true;
	      }

	    /* falls through */

	    default:
	      // reduce the search size of heterogeneous sets by creating buckets
	      // for each type.
	      type = Object.prototype.toString.call(item);

	      if (!(type in set._items)) {
	        if (shouldAdd) {
	          set._items[type] = [item];
	        }

	        return false;
	      } // scan through all previously applied items


	      if (!_contains(item, set._items[type])) {
	        if (shouldAdd) {
	          set._items[type].push(item);
	        }

	        return false;
	      }

	      return true;
	  }
	} // A simple Set type that honours R.equals semantics

	/**
	 * Returns a new list containing only one copy of each element in the original
	 * list, based upon the value returned by applying the supplied function to
	 * each list element. Prefers the first item if the supplied function produces
	 * the same value on two items. [`R.equals`](#equals) is used for comparison.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category List
	 * @sig (a -> b) -> [a] -> [a]
	 * @param {Function} fn A function used to produce a value to use during comparisons.
	 * @param {Array} list The array to consider.
	 * @return {Array} The list of unique items.
	 * @example
	 *
	 *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
	 */

	var uniqBy =
	/*#__PURE__*/
	_curry2(function uniqBy(fn, list) {
	  var set = new _Set();
	  var result = [];
	  var idx = 0;
	  var appliedItem, item;

	  while (idx < list.length) {
	    item = list[idx];
	    appliedItem = fn(item);

	    if (set.add(appliedItem)) {
	      result.push(item);
	    }

	    idx += 1;
	  }

	  return result;
	});

	/**
	 * Returns a new list containing only one copy of each element in the original
	 * list. [`R.equals`](#equals) is used to determine equality.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> [a]
	 * @param {Array} list The array to consider.
	 * @return {Array} The list of unique items.
	 * @example
	 *
	 *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
	 *      R.uniq([1, '1']);     //=> [1, '1']
	 *      R.uniq([[42], [42]]); //=> [[42]]
	 */

	var uniq =
	/*#__PURE__*/
	uniqBy(identity$1);

	/**
	 * Combines two lists into a set (i.e. no duplicates) composed of those
	 * elements common to both lists.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig [*] -> [*] -> [*]
	 * @param {Array} list1 The first list.
	 * @param {Array} list2 The second list.
	 * @return {Array} The list of elements found in both `list1` and `list2`.
	 * @see R.innerJoin
	 * @example
	 *
	 *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
	 */

	var intersection =
	/*#__PURE__*/
	_curry2(function intersection(list1, list2) {
	  var lookupList, filteredList;

	  if (list1.length > list2.length) {
	    lookupList = list1;
	    filteredList = list2;
	  } else {
	    lookupList = list2;
	    filteredList = list1;
	  }

	  return uniq(_filter(flip(_contains)(lookupList), filteredList));
	});

	/**
	 * Creates a new list with the separator interposed between elements.
	 *
	 * Dispatches to the `intersperse` method of the second argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category List
	 * @sig a -> [a] -> [a]
	 * @param {*} separator The element to add to the list.
	 * @param {Array} list The list to be interposed.
	 * @return {Array} The new list.
	 * @example
	 *
	 *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
	 */

	var intersperse =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_checkForMethod('intersperse', function intersperse(separator, list) {
	  var out = [];
	  var idx = 0;
	  var length = list.length;

	  while (idx < length) {
	    if (idx === length - 1) {
	      out.push(list[idx]);
	    } else {
	      out.push(list[idx], separator);
	    }

	    idx += 1;
	  }

	  return out;
	}));

	function _objectAssign$1(target) {
	  if (target == null) {
	    throw new TypeError('Cannot convert undefined or null to object');
	  }

	  var output = Object(target);
	  var idx = 1;
	  var length = arguments.length;

	  while (idx < length) {
	    var source = arguments[idx];

	    if (source != null) {
	      for (var nextKey in source) {
	        if (_has$1(nextKey, source)) {
	          output[nextKey] = source[nextKey];
	        }
	      }
	    }

	    idx += 1;
	  }

	  return output;
	}

	var _assign$1 = typeof Object.assign === 'function' ? Object.assign : _objectAssign$1;

	/**
	 * Creates an object containing a single key:value pair.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.18.0
	 * @category Object
	 * @sig String -> a -> {String:a}
	 * @param {String} key
	 * @param {*} val
	 * @return {Object}
	 * @see R.pair
	 * @example
	 *
	 *      var matchPhrases = R.compose(
	 *        R.objOf('must'),
	 *        R.map(R.objOf('match_phrase'))
	 *      );
	 *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
	 */

	var objOf =
	/*#__PURE__*/
	_curry2(function objOf(key, val) {
	  var obj = {};
	  obj[key] = val;
	  return obj;
	});

	var _stepCatArray = {
	  '@@transducer/init': Array,
	  '@@transducer/step': function transducerStep(xs, x) {
	    xs.push(x);
	    return xs;
	  },
	  '@@transducer/result': _identity
	};
	var _stepCatString = {
	  '@@transducer/init': String,
	  '@@transducer/step': function transducerStep(a, b) {
	    return a + b;
	  },
	  '@@transducer/result': _identity
	};
	var _stepCatObject = {
	  '@@transducer/init': Object,
	  '@@transducer/step': function transducerStep(result, input) {
	    return _assign$1(result, _isArrayLike(input) ? objOf(input[0], input[1]) : input);
	  },
	  '@@transducer/result': _identity
	};
	function _stepCat(obj) {
	  if (_isTransformer(obj)) {
	    return obj;
	  }

	  if (_isArrayLike(obj)) {
	    return _stepCatArray;
	  }

	  if (typeof obj === 'string') {
	    return _stepCatString;
	  }

	  if (_typeof(obj) === 'object') {
	    return _stepCatObject;
	  }

	  throw new Error('Cannot create transformer for ' + obj);
	}

	/**
	 * Transforms the items of the list with the transducer and appends the
	 * transformed items to the accumulator using an appropriate iterator function
	 * based on the accumulator type.
	 *
	 * The accumulator can be an array, string, object or a transformer. Iterated
	 * items will be appended to arrays and concatenated to strings. Objects will
	 * be merged directly or 2-item arrays will be merged as key, value pairs.
	 *
	 * The accumulator can also be a transformer object that provides a 2-arity
	 * reducing iterator function, step, 0-arity initial value function, init, and
	 * 1-arity result extraction function result. The step function is used as the
	 * iterator function in reduce. The result function is used to convert the
	 * final accumulator into the return type and in most cases is R.identity. The
	 * init function is used to provide the initial accumulator.
	 *
	 * The iteration is performed with [`R.reduce`](#reduce) after initializing the
	 * transducer.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category List
	 * @sig a -> (b -> b) -> [c] -> a
	 * @param {*} acc The initial accumulator value.
	 * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
	 * @param {Array} list The list to iterate over.
	 * @return {*} The final, accumulated value.
	 * @example
	 *
	 *      var numbers = [1, 2, 3, 4];
	 *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
	 *
	 *      R.into([], transducer, numbers); //=> [2, 3]
	 *
	 *      var intoArray = R.into([]);
	 *      intoArray(transducer, numbers); //=> [2, 3]
	 */

	var into =
	/*#__PURE__*/
	_curry3(function into(acc, xf, list) {
	  return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
	});

	/**
	 * Same as [`R.invertObj`](#invertObj), however this accounts for objects with
	 * duplicate values by putting the values into an array.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Object
	 * @sig {s: x} -> {x: [ s, ... ]}
	 * @param {Object} obj The object or array to invert
	 * @return {Object} out A new object with keys in an array.
	 * @see R.invertObj
	 * @example
	 *
	 *      var raceResultsByFirstName = {
	 *        first: 'alice',
	 *        second: 'jake',
	 *        third: 'alice',
	 *      };
	 *      R.invert(raceResultsByFirstName);
	 *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
	 */

	var invert =
	/*#__PURE__*/
	_curry1(function invert(obj) {
	  var props = keys$2(obj);
	  var len = props.length;
	  var idx = 0;
	  var out = {};

	  while (idx < len) {
	    var key = props[idx];
	    var val = obj[key];
	    var list = _has$1(val, out) ? out[val] : out[val] = [];
	    list[list.length] = key;
	    idx += 1;
	  }

	  return out;
	});

	/**
	 * Returns a new object with the keys of the given object as values, and the
	 * values of the given object, which are coerced to strings, as keys. Note
	 * that the last key found is preferred when handling the same value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Object
	 * @sig {s: x} -> {x: s}
	 * @param {Object} obj The object or array to invert
	 * @return {Object} out A new object
	 * @see R.invert
	 * @example
	 *
	 *      var raceResults = {
	 *        first: 'alice',
	 *        second: 'jake'
	 *      };
	 *      R.invertObj(raceResults);
	 *      //=> { 'alice': 'first', 'jake':'second' }
	 *
	 *      // Alternatively:
	 *      var raceResults = ['alice', 'jake'];
	 *      R.invertObj(raceResults);
	 *      //=> { 'alice': '0', 'jake':'1' }
	 */

	var invertObj =
	/*#__PURE__*/
	_curry1(function invertObj(obj) {
	  var props = keys$2(obj);
	  var len = props.length;
	  var idx = 0;
	  var out = {};

	  while (idx < len) {
	    var key = props[idx];
	    out[obj[key]] = key;
	    idx += 1;
	  }

	  return out;
	});

	/**
	 * Turns a named method with a specified arity into a function that can be
	 * called directly supplied with arguments and a target object.
	 *
	 * The returned function is curried and accepts `arity + 1` parameters where
	 * the final parameter is the target object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
	 * @param {Number} arity Number of arguments the returned function should take
	 *        before the target object.
	 * @param {String} method Name of the method to call.
	 * @return {Function} A new curried function.
	 * @see R.construct
	 * @example
	 *
	 *      var sliceFrom = R.invoker(1, 'slice');
	 *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
	 *      var sliceFrom6 = R.invoker(2, 'slice')(6);
	 *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
	 * @symb R.invoker(0, 'method')(o) = o['method']()
	 * @symb R.invoker(1, 'method')(a, o) = o['method'](a)
	 * @symb R.invoker(2, 'method')(a, b, o) = o['method'](a, b)
	 */

	var invoker =
	/*#__PURE__*/
	_curry2(function invoker(arity, method) {
	  return curryN(arity + 1, function () {
	    var target = arguments[arity];

	    if (target != null && _isFunction(target[method])) {
	      return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
	    }

	    throw new TypeError(toString$4(target) + ' does not have a method named "' + method + '"');
	  });
	});

	/**
	 * See if an object (`val`) is an instance of the supplied constructor. This
	 * function will check up the inheritance chain, if any.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category Type
	 * @sig (* -> {*}) -> a -> Boolean
	 * @param {Object} ctor A constructor
	 * @param {*} val The value to test
	 * @return {Boolean}
	 * @example
	 *
	 *      R.is(Object, {}); //=> true
	 *      R.is(Number, 1); //=> true
	 *      R.is(Object, 1); //=> false
	 *      R.is(String, 's'); //=> true
	 *      R.is(String, new String('')); //=> true
	 *      R.is(Object, new String('')); //=> true
	 *      R.is(Object, 's'); //=> false
	 *      R.is(Number, {}); //=> false
	 */

	var is$1 =
	/*#__PURE__*/
	_curry2(function is(Ctor, val) {
	  return val != null && val.constructor === Ctor || val instanceof Ctor;
	});

	/**
	 * Returns `true` if the given value is its type's empty value; `false`
	 * otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Logic
	 * @sig a -> Boolean
	 * @param {*} x
	 * @return {Boolean}
	 * @see R.empty
	 * @example
	 *
	 *      R.isEmpty([1, 2, 3]);   //=> false
	 *      R.isEmpty([]);          //=> true
	 *      R.isEmpty('');          //=> true
	 *      R.isEmpty(null);        //=> false
	 *      R.isEmpty({});          //=> true
	 *      R.isEmpty({length: 0}); //=> false
	 */

	var isEmpty$1 =
	/*#__PURE__*/
	_curry1(function isEmpty(x) {
	  return x != null && equals(x, empty$3(x));
	});

	/**
	 * Returns a string made by inserting the `separator` between each element and
	 * concatenating all the elements into a single string.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig String -> [a] -> String
	 * @param {Number|String} separator The string used to separate the elements.
	 * @param {Array} xs The elements to join into a string.
	 * @return {String} str The string made by concatenating `xs` with `separator`.
	 * @see R.split
	 * @example
	 *
	 *      var spacer = R.join(' ');
	 *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
	 *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
	 */

	var join =
	/*#__PURE__*/
	invoker(1, 'join');

	/**
	 * juxt applies a list of functions to a list of values.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category Function
	 * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
	 * @param {Array} fns An array of functions
	 * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
	 * @see R.applySpec
	 * @example
	 *
	 *      var getRange = R.juxt([Math.min, Math.max]);
	 *      getRange(3, 4, 9, -3); //=> [-3, 9]
	 * @symb R.juxt([f, g, h])(a, b) = [f(a, b), g(a, b), h(a, b)]
	 */

	var juxt =
	/*#__PURE__*/
	_curry1(function juxt(fns) {
	  return converge(function () {
	    return Array.prototype.slice.call(arguments, 0);
	  }, fns);
	});

	/**
	 * Returns a list containing the names of all the properties of the supplied
	 * object, including prototype properties.
	 * Note that the order of the output array is not guaranteed to be consistent
	 * across different JS platforms.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.0
	 * @category Object
	 * @sig {k: v} -> [k]
	 * @param {Object} obj The object to extract properties from
	 * @return {Array} An array of the object's own and prototype properties.
	 * @see R.keys, R.valuesIn
	 * @example
	 *
	 *      var F = function() { this.x = 'X'; };
	 *      F.prototype.y = 'Y';
	 *      var f = new F();
	 *      R.keysIn(f); //=> ['x', 'y']
	 */

	var keysIn =
	/*#__PURE__*/
	_curry1(function keysIn(obj) {
	  var prop;
	  var ks = [];

	  for (prop in obj) {
	    ks[ks.length] = prop;
	  }

	  return ks;
	});

	/**
	 * Returns the position of the last occurrence of an item in an array, or -1 if
	 * the item is not included in the array. [`R.equals`](#equals) is used to
	 * determine equality.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig a -> [a] -> Number
	 * @param {*} target The item to find.
	 * @param {Array} xs The array to search in.
	 * @return {Number} the index of the target, or -1 if the target is not found.
	 * @see R.indexOf
	 * @example
	 *
	 *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
	 *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
	 */

	var lastIndexOf =
	/*#__PURE__*/
	_curry2(function lastIndexOf(target, xs) {
	  if (typeof xs.lastIndexOf === 'function' && !_isArray$1(xs)) {
	    return xs.lastIndexOf(target);
	  } else {
	    var idx = xs.length - 1;

	    while (idx >= 0) {
	      if (equals(xs[idx], target)) {
	        return idx;
	      }

	      idx -= 1;
	    }

	    return -1;
	  }
	});

	function _isNumber(x) {
	  return Object.prototype.toString.call(x) === '[object Number]';
	}

	/**
	 * Returns the number of elements in the array by returning `list.length`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category List
	 * @sig [a] -> Number
	 * @param {Array} list The array to inspect.
	 * @return {Number} The length of the array.
	 * @example
	 *
	 *      R.length([]); //=> 0
	 *      R.length([1, 2, 3]); //=> 3
	 */

	var length =
	/*#__PURE__*/
	_curry1(function length(list) {
	  return list != null && _isNumber(list.length) ? list.length : NaN;
	});

	/**
	 * Returns a lens for the given getter and setter functions. The getter "gets"
	 * the value of the focus; the setter "sets" the value of the focus. The setter
	 * should not mutate the data structure.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Object
	 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	 * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
	 * @param {Function} getter
	 * @param {Function} setter
	 * @return {Lens}
	 * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
	 * @example
	 *
	 *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
	 *
	 *      R.view(xLens, {x: 1, y: 2});            //=> 1
	 *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
	 *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
	 */

	var lens =
	/*#__PURE__*/
	_curry2(function lens(getter, setter) {
	  return function (toFunctorFn) {
	    return function (target) {
	      return map$1(function (focus) {
	        return setter(focus, target);
	      }, toFunctorFn(getter(target)));
	    };
	  };
	});

	/**
	 * Returns a lens whose focus is the specified index.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category Object
	 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	 * @sig Number -> Lens s a
	 * @param {Number} n
	 * @return {Lens}
	 * @see R.view, R.set, R.over
	 * @example
	 *
	 *      var headLens = R.lensIndex(0);
	 *
	 *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
	 *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
	 *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
	 */

	var lensIndex =
	/*#__PURE__*/
	_curry1(function lensIndex(n) {
	  return lens(nth(n), update(n));
	});

	/**
	 * Returns a lens whose focus is the specified path.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category Object
	 * @typedefn Idx = String | Int
	 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	 * @sig [Idx] -> Lens s a
	 * @param {Array} path The path to use.
	 * @return {Lens}
	 * @see R.view, R.set, R.over
	 * @example
	 *
	 *      var xHeadYLens = R.lensPath(['x', 0, 'y']);
	 *
	 *      R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
	 *      //=> 2
	 *      R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
	 *      //=> {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
	 *      R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
	 *      //=> {x: [{y: -2, z: 3}, {y: 4, z: 5}]}
	 */

	var lensPath =
	/*#__PURE__*/
	_curry1(function lensPath(p) {
	  return lens(path(p), assocPath(p));
	});

	/**
	 * Returns a lens whose focus is the specified property.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category Object
	 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	 * @sig String -> Lens s a
	 * @param {String} k
	 * @return {Lens}
	 * @see R.view, R.set, R.over
	 * @example
	 *
	 *      var xLens = R.lensProp('x');
	 *
	 *      R.view(xLens, {x: 1, y: 2});            //=> 1
	 *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
	 *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
	 */

	var lensProp =
	/*#__PURE__*/
	_curry1(function lensProp(k) {
	  return lens(prop(k), assoc(k));
	});

	/**
	 * Returns `true` if the first argument is less than the second; `false`
	 * otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig Ord a => a -> a -> Boolean
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 * @see R.gt
	 * @example
	 *
	 *      R.lt(2, 1); //=> false
	 *      R.lt(2, 2); //=> false
	 *      R.lt(2, 3); //=> true
	 *      R.lt('a', 'z'); //=> true
	 *      R.lt('z', 'a'); //=> false
	 */

	var lt =
	/*#__PURE__*/
	_curry2(function lt(a, b) {
	  return a < b;
	});

	/**
	 * Returns `true` if the first argument is less than or equal to the second;
	 * `false` otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig Ord a => a -> a -> Boolean
	 * @param {Number} a
	 * @param {Number} b
	 * @return {Boolean}
	 * @see R.gte
	 * @example
	 *
	 *      R.lte(2, 1); //=> false
	 *      R.lte(2, 2); //=> true
	 *      R.lte(2, 3); //=> true
	 *      R.lte('a', 'z'); //=> true
	 *      R.lte('z', 'a'); //=> false
	 */

	var lte =
	/*#__PURE__*/
	_curry2(function lte(a, b) {
	  return a <= b;
	});

	/**
	 * The `mapAccum` function behaves like a combination of map and reduce; it
	 * applies a function to each element of a list, passing an accumulating
	 * parameter from left to right, and returning a final value of this
	 * accumulator together with the new list.
	 *
	 * The iterator function receives two arguments, *acc* and *value*, and should
	 * return a tuple *[acc, value]*.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category List
	 * @sig ((acc, x) -> (acc, y)) -> acc -> [x] -> (acc, [y])
	 * @param {Function} fn The function to be called on every element of the input `list`.
	 * @param {*} acc The accumulator value.
	 * @param {Array} list The list to iterate over.
	 * @return {*} The final, accumulated value.
	 * @see R.addIndex, R.mapAccumRight
	 * @example
	 *
	 *      var digits = ['1', '2', '3', '4'];
	 *      var appender = (a, b) => [a + b, a + b];
	 *
	 *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
	 * @symb R.mapAccum(f, a, [b, c, d]) = [
	 *   f(f(f(a, b)[0], c)[0], d)[0],
	 *   [
	 *     f(a, b)[1],
	 *     f(f(a, b)[0], c)[1],
	 *     f(f(f(a, b)[0], c)[0], d)[1]
	 *   ]
	 * ]
	 */

	var mapAccum =
	/*#__PURE__*/
	_curry3(function mapAccum(fn, acc, list) {
	  var idx = 0;
	  var len = list.length;
	  var result = [];
	  var tuple = [acc];

	  while (idx < len) {
	    tuple = fn(tuple[0], list[idx]);
	    result[idx] = tuple[1];
	    idx += 1;
	  }

	  return [tuple[0], result];
	});

	/**
	 * The `mapAccumRight` function behaves like a combination of map and reduce; it
	 * applies a function to each element of a list, passing an accumulating
	 * parameter from right to left, and returning a final value of this
	 * accumulator together with the new list.
	 *
	 * Similar to [`mapAccum`](#mapAccum), except moves through the input list from
	 * the right to the left.
	 *
	 * The iterator function receives two arguments, *value* and *acc*, and should
	 * return a tuple *[value, acc]*.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category List
	 * @sig ((x, acc) -> (y, acc)) -> acc -> [x] -> ([y], acc)
	 * @param {Function} fn The function to be called on every element of the input `list`.
	 * @param {*} acc The accumulator value.
	 * @param {Array} list The list to iterate over.
	 * @return {*} The final, accumulated value.
	 * @see R.addIndex, R.mapAccum
	 * @example
	 *
	 *      var digits = ['1', '2', '3', '4'];
	 *      var append = (a, b) => [a + b, a + b];
	 *
	 *      R.mapAccumRight(append, 5, digits); //=> [['12345', '2345', '345', '45'], '12345']
	 * @symb R.mapAccumRight(f, a, [b, c, d]) = [
	 *   [
	 *     f(b, f(c, f(d, a)[0])[0])[1],
	 *     f(c, f(d, a)[0])[1],
	 *     f(d, a)[1],
	 *   ]
	 *   f(b, f(c, f(d, a)[0])[0])[0],
	 * ]
	 */

	var mapAccumRight =
	/*#__PURE__*/
	_curry3(function mapAccumRight(fn, acc, list) {
	  var idx = list.length - 1;
	  var result = [];
	  var tuple = [acc];

	  while (idx >= 0) {
	    tuple = fn(list[idx], tuple[0]);
	    result[idx] = tuple[1];
	    idx -= 1;
	  }

	  return [result, tuple[0]];
	});

	/**
	 * An Object-specific version of [`map`](#map). The function is applied to three
	 * arguments: *(value, key, obj)*. If only the value is significant, use
	 * [`map`](#map) instead.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Object
	 * @sig ((*, String, Object) -> *) -> Object -> Object
	 * @param {Function} fn
	 * @param {Object} obj
	 * @return {Object}
	 * @see R.map
	 * @example
	 *
	 *      var values = { x: 1, y: 2, z: 3 };
	 *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
	 *
	 *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
	 */

	var mapObjIndexed =
	/*#__PURE__*/
	_curry2(function mapObjIndexed(fn, obj) {
	  return _reduce(function (acc, key) {
	    acc[key] = fn(obj[key], key, obj);
	    return acc;
	  }, {}, keys$2(obj));
	});

	/**
	 * Tests a regular expression against a String. Note that this function will
	 * return an empty array when there are no matches. This differs from
	 * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
	 * which returns `null` when there are no matches.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category String
	 * @sig RegExp -> String -> [String | Undefined]
	 * @param {RegExp} rx A regular expression.
	 * @param {String} str The string to match against
	 * @return {Array} The list of matches or empty array.
	 * @see R.test
	 * @example
	 *
	 *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
	 *      R.match(/a/, 'b'); //=> []
	 *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
	 */

	var match =
	/*#__PURE__*/
	_curry2(function match(rx, str) {
	  return str.match(rx) || [];
	});

	/**
	 * `mathMod` behaves like the modulo operator should mathematically, unlike the
	 * `%` operator (and by extension, [`R.modulo`](#modulo)). So while
	 * `-17 % 5` is `-2`, `mathMod(-17, 5)` is `3`. `mathMod` requires Integer
	 * arguments, and returns NaN when the modulus is zero or negative.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category Math
	 * @sig Number -> Number -> Number
	 * @param {Number} m The dividend.
	 * @param {Number} p the modulus.
	 * @return {Number} The result of `b mod a`.
	 * @see R.modulo
	 * @example
	 *
	 *      R.mathMod(-17, 5);  //=> 3
	 *      R.mathMod(17, 5);   //=> 2
	 *      R.mathMod(17, -5);  //=> NaN
	 *      R.mathMod(17, 0);   //=> NaN
	 *      R.mathMod(17.2, 5); //=> NaN
	 *      R.mathMod(17, 5.3); //=> NaN
	 *
	 *      var clock = R.mathMod(R.__, 12);
	 *      clock(15); //=> 3
	 *      clock(24); //=> 0
	 *
	 *      var seventeenMod = R.mathMod(17);
	 *      seventeenMod(3);  //=> 2
	 *      seventeenMod(4);  //=> 1
	 *      seventeenMod(10); //=> 7
	 */

	var mathMod =
	/*#__PURE__*/
	_curry2(function mathMod(m, p) {
	  if (!_isInteger$1(m)) {
	    return NaN;
	  }

	  if (!_isInteger$1(p) || p < 1) {
	    return NaN;
	  }

	  return (m % p + p) % p;
	});

	/**
	 * Takes a function and two values, and returns whichever value produces the
	 * larger result when passed to the provided function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Relation
	 * @sig Ord b => (a -> b) -> a -> a -> a
	 * @param {Function} f
	 * @param {*} a
	 * @param {*} b
	 * @return {*}
	 * @see R.max, R.minBy
	 * @example
	 *
	 *      //  square :: Number -> Number
	 *      var square = n => n * n;
	 *
	 *      R.maxBy(square, -3, 2); //=> -3
	 *
	 *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
	 *      R.reduce(R.maxBy(square), 0, []); //=> 0
	 */

	var maxBy =
	/*#__PURE__*/
	_curry3(function maxBy(f, a, b) {
	  return f(b) > f(a) ? b : a;
	});

	/**
	 * Adds together all the elements of a list.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Math
	 * @sig [Number] -> Number
	 * @param {Array} list An array of numbers
	 * @return {Number} The sum of all the numbers in the list.
	 * @see R.reduce
	 * @example
	 *
	 *      R.sum([2,4,6,8,100,1]); //=> 121
	 */

	var sum =
	/*#__PURE__*/
	reduce$1(add, 0);

	/**
	 * Returns the mean of the given list of numbers.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category Math
	 * @sig [Number] -> Number
	 * @param {Array} list
	 * @return {Number}
	 * @see R.median
	 * @example
	 *
	 *      R.mean([2, 7, 9]); //=> 6
	 *      R.mean([]); //=> NaN
	 */

	var mean =
	/*#__PURE__*/
	_curry1(function mean(list) {
	  return sum(list) / list.length;
	});

	/**
	 * Returns the median of the given list of numbers.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category Math
	 * @sig [Number] -> Number
	 * @param {Array} list
	 * @return {Number}
	 * @see R.mean
	 * @example
	 *
	 *      R.median([2, 9, 7]); //=> 7
	 *      R.median([7, 2, 10, 9]); //=> 8
	 *      R.median([]); //=> NaN
	 */

	var median =
	/*#__PURE__*/
	_curry1(function median(list) {
	  var len = list.length;

	  if (len === 0) {
	    return NaN;
	  }

	  var width = 2 - len % 2;
	  var idx = (len - width) / 2;
	  return mean(Array.prototype.slice.call(list, 0).sort(function (a, b) {
	    return a < b ? -1 : a > b ? 1 : 0;
	  }).slice(idx, idx + width));
	});

	/**
	 * A customisable version of [`R.memoize`](#memoize). `memoizeWith` takes an
	 * additional function that will be applied to a given argument set and used to
	 * create the cache key under which the results of the function to be memoized
	 * will be stored. Care must be taken when implementing key generation to avoid
	 * clashes that may overwrite previous entries erroneously.
	 *
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category Function
	 * @sig (*... -> String) -> (*... -> a) -> (*... -> a)
	 * @param {Function} fn The function to generate the cache key.
	 * @param {Function} fn The function to memoize.
	 * @return {Function} Memoized version of `fn`.
	 * @see R.memoize
	 * @example
	 *
	 *      let count = 0;
	 *      const factorial = R.memoizeWith(R.identity, n => {
	 *        count += 1;
	 *        return R.product(R.range(1, n + 1));
	 *      });
	 *      factorial(5); //=> 120
	 *      factorial(5); //=> 120
	 *      factorial(5); //=> 120
	 *      count; //=> 1
	 */

	var memoizeWith =
	/*#__PURE__*/
	_curry2(function memoizeWith(mFn, fn) {
	  var cache = {};
	  return _arity(fn.length, function () {
	    var key = mFn.apply(this, arguments);

	    if (!_has$1(key, cache)) {
	      cache[key] = fn.apply(this, arguments);
	    }

	    return cache[key];
	  });
	});

	/**
	 * Creates a new function that, when invoked, caches the result of calling `fn`
	 * for a given argument set and returns the result. Subsequent calls to the
	 * memoized `fn` with the same argument set will not result in an additional
	 * call to `fn`; instead, the cached result for that set of arguments will be
	 * returned.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig (*... -> a) -> (*... -> a)
	 * @param {Function} fn The function to memoize.
	 * @return {Function} Memoized version of `fn`.
	 * @see R.memoizeWith
	 * @deprecated since v0.25.0
	 * @example
	 *
	 *      let count = 0;
	 *      const factorial = R.memoize(n => {
	 *        count += 1;
	 *        return R.product(R.range(1, n + 1));
	 *      });
	 *      factorial(5); //=> 120
	 *      factorial(5); //=> 120
	 *      factorial(5); //=> 120
	 *      count; //=> 1
	 */

	var memoize =
	/*#__PURE__*/
	memoizeWith(function () {
	  return toString$4(arguments);
	});

	/**
	 * Create a new object with the own properties of the first object merged with
	 * the own properties of the second object. If a key exists in both objects,
	 * the value from the second object will be used.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig {k: v} -> {k: v} -> {k: v}
	 * @param {Object} l
	 * @param {Object} r
	 * @return {Object}
	 * @see R.mergeDeepRight, R.mergeWith, R.mergeWithKey
	 * @example
	 *
	 *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
	 *      //=> { 'name': 'fred', 'age': 40 }
	 *
	 *      var resetToDefault = R.merge(R.__, {x: 0});
	 *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
	 * @symb R.merge({ x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: 5, z: 3 }
	 */

	var merge$3 =
	/*#__PURE__*/
	_curry2(function merge(l, r) {
	  return _assign$1({}, l, r);
	});

	/**
	 * Merges a list of objects together into one object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category List
	 * @sig [{k: v}] -> {k: v}
	 * @param {Array} list An array of objects
	 * @return {Object} A merged object.
	 * @see R.reduce
	 * @example
	 *
	 *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
	 *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
	 * @symb R.mergeAll([{ x: 1 }, { y: 2 }, { z: 3 }]) = { x: 1, y: 2, z: 3 }
	 */

	var mergeAll$1 =
	/*#__PURE__*/
	_curry1(function mergeAll(list) {
	  return _assign$1.apply(null, [{}].concat(list));
	});

	/**
	 * Creates a new object with the own properties of the two provided objects. If
	 * a key exists in both objects, the provided function is applied to the key
	 * and the values associated with the key in each object, with the result being
	 * used as the value associated with the key in the returned object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category Object
	 * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
	 * @param {Function} fn
	 * @param {Object} l
	 * @param {Object} r
	 * @return {Object}
	 * @see R.mergeDeepWithKey, R.merge, R.mergeWith
	 * @example
	 *
	 *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
	 *      R.mergeWithKey(concatValues,
	 *                     { a: true, thing: 'foo', values: [10, 20] },
	 *                     { b: true, thing: 'bar', values: [15, 35] });
	 *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
	 * @symb R.mergeWithKey(f, { x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: f('y', 2, 5), z: 3 }
	 */

	var mergeWithKey =
	/*#__PURE__*/
	_curry3(function mergeWithKey(fn, l, r) {
	  var result = {};
	  var k;

	  for (k in l) {
	    if (_has$1(k, l)) {
	      result[k] = _has$1(k, r) ? fn(k, l[k], r[k]) : l[k];
	    }
	  }

	  for (k in r) {
	    if (_has$1(k, r) && !_has$1(k, result)) {
	      result[k] = r[k];
	    }
	  }

	  return result;
	});

	/**
	 * Creates a new object with the own properties of the two provided objects.
	 * If a key exists in both objects:
	 * - and both associated values are also objects then the values will be
	 *   recursively merged.
	 * - otherwise the provided function is applied to the key and associated values
	 *   using the resulting value as the new value associated with the key.
	 * If a key only exists in one object, the value will be associated with the key
	 * of the resulting object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category Object
	 * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
	 * @param {Function} fn
	 * @param {Object} lObj
	 * @param {Object} rObj
	 * @return {Object}
	 * @see R.mergeWithKey, R.mergeDeep, R.mergeDeepWith
	 * @example
	 *
	 *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
	 *      R.mergeDeepWithKey(concatValues,
	 *                         { a: true, c: { thing: 'foo', values: [10, 20] }},
	 *                         { b: true, c: { thing: 'bar', values: [15, 35] }});
	 *      //=> { a: true, b: true, c: { thing: 'bar', values: [10, 20, 15, 35] }}
	 */

	var mergeDeepWithKey =
	/*#__PURE__*/
	_curry3(function mergeDeepWithKey(fn, lObj, rObj) {
	  return mergeWithKey(function (k, lVal, rVal) {
	    if (_isObject$1(lVal) && _isObject$1(rVal)) {
	      return mergeDeepWithKey(fn, lVal, rVal);
	    } else {
	      return fn(k, lVal, rVal);
	    }
	  }, lObj, rObj);
	});

	/**
	 * Creates a new object with the own properties of the first object merged with
	 * the own properties of the second object. If a key exists in both objects:
	 * - and both values are objects, the two values will be recursively merged
	 * - otherwise the value from the first object will be used.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category Object
	 * @sig {a} -> {a} -> {a}
	 * @param {Object} lObj
	 * @param {Object} rObj
	 * @return {Object}
	 * @see R.merge, R.mergeDeepRight, R.mergeDeepWith, R.mergeDeepWithKey
	 * @example
	 *
	 *      R.mergeDeepLeft({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
	 *                      { age: 40, contact: { email: 'baa@example.com' }});
	 *      //=> { name: 'fred', age: 10, contact: { email: 'moo@example.com' }}
	 */

	var mergeDeepLeft =
	/*#__PURE__*/
	_curry2(function mergeDeepLeft(lObj, rObj) {
	  return mergeDeepWithKey(function (k, lVal, rVal) {
	    return lVal;
	  }, lObj, rObj);
	});

	/**
	 * Creates a new object with the own properties of the first object merged with
	 * the own properties of the second object. If a key exists in both objects:
	 * - and both values are objects, the two values will be recursively merged
	 * - otherwise the value from the second object will be used.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category Object
	 * @sig {a} -> {a} -> {a}
	 * @param {Object} lObj
	 * @param {Object} rObj
	 * @return {Object}
	 * @see R.merge, R.mergeDeepLeft, R.mergeDeepWith, R.mergeDeepWithKey
	 * @example
	 *
	 *      R.mergeDeepRight({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
	 *                       { age: 40, contact: { email: 'baa@example.com' }});
	 *      //=> { name: 'fred', age: 40, contact: { email: 'baa@example.com' }}
	 */

	var mergeDeepRight =
	/*#__PURE__*/
	_curry2(function mergeDeepRight(lObj, rObj) {
	  return mergeDeepWithKey(function (k, lVal, rVal) {
	    return rVal;
	  }, lObj, rObj);
	});

	/**
	 * Creates a new object with the own properties of the two provided objects.
	 * If a key exists in both objects:
	 * - and both associated values are also objects then the values will be
	 *   recursively merged.
	 * - otherwise the provided function is applied to associated values using the
	 *   resulting value as the new value associated with the key.
	 * If a key only exists in one object, the value will be associated with the key
	 * of the resulting object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category Object
	 * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
	 * @param {Function} fn
	 * @param {Object} lObj
	 * @param {Object} rObj
	 * @return {Object}
	 * @see R.mergeWith, R.mergeDeep, R.mergeDeepWithKey
	 * @example
	 *
	 *      R.mergeDeepWith(R.concat,
	 *                      { a: true, c: { values: [10, 20] }},
	 *                      { b: true, c: { values: [15, 35] }});
	 *      //=> { a: true, b: true, c: { values: [10, 20, 15, 35] }}
	 */

	var mergeDeepWith =
	/*#__PURE__*/
	_curry3(function mergeDeepWith(fn, lObj, rObj) {
	  return mergeDeepWithKey(function (k, lVal, rVal) {
	    return fn(lVal, rVal);
	  }, lObj, rObj);
	});

	/**
	 * Creates a new object with the own properties of the two provided objects. If
	 * a key exists in both objects, the provided function is applied to the values
	 * associated with the key in each object, with the result being used as the
	 * value associated with the key in the returned object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category Object
	 * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
	 * @param {Function} fn
	 * @param {Object} l
	 * @param {Object} r
	 * @return {Object}
	 * @see R.mergeDeepWith, R.merge, R.mergeWithKey
	 * @example
	 *
	 *      R.mergeWith(R.concat,
	 *                  { a: true, values: [10, 20] },
	 *                  { b: true, values: [15, 35] });
	 *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
	 */

	var mergeWith =
	/*#__PURE__*/
	_curry3(function mergeWith(fn, l, r) {
	  return mergeWithKey(function (_, _l, _r) {
	    return fn(_l, _r);
	  }, l, r);
	});

	/**
	 * Returns the smaller of its two arguments.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig Ord a => a -> a -> a
	 * @param {*} a
	 * @param {*} b
	 * @return {*}
	 * @see R.minBy, R.max
	 * @example
	 *
	 *      R.min(789, 123); //=> 123
	 *      R.min('a', 'b'); //=> 'a'
	 */

	var min$4 =
	/*#__PURE__*/
	_curry2(function min(a, b) {
	  return b < a ? b : a;
	});

	/**
	 * Takes a function and two values, and returns whichever value produces the
	 * smaller result when passed to the provided function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Relation
	 * @sig Ord b => (a -> b) -> a -> a -> a
	 * @param {Function} f
	 * @param {*} a
	 * @param {*} b
	 * @return {*}
	 * @see R.min, R.maxBy
	 * @example
	 *
	 *      //  square :: Number -> Number
	 *      var square = n => n * n;
	 *
	 *      R.minBy(square, -3, 2); //=> 2
	 *
	 *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
	 *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
	 */

	var minBy =
	/*#__PURE__*/
	_curry3(function minBy(f, a, b) {
	  return f(b) < f(a) ? b : a;
	});

	/**
	 * Divides the first parameter by the second and returns the remainder. Note
	 * that this function preserves the JavaScript-style behavior for modulo. For
	 * mathematical modulo see [`mathMod`](#mathMod).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.1
	 * @category Math
	 * @sig Number -> Number -> Number
	 * @param {Number} a The value to the divide.
	 * @param {Number} b The pseudo-modulus
	 * @return {Number} The result of `b % a`.
	 * @see R.mathMod
	 * @example
	 *
	 *      R.modulo(17, 3); //=> 2
	 *      // JS behavior:
	 *      R.modulo(-17, 3); //=> -2
	 *      R.modulo(17, -3); //=> 2
	 *
	 *      var isOdd = R.modulo(R.__, 2);
	 *      isOdd(42); //=> 0
	 *      isOdd(21); //=> 1
	 */

	var modulo =
	/*#__PURE__*/
	_curry2(function modulo(a, b) {
	  return a % b;
	});

	/**
	 * Multiplies two numbers. Equivalent to `a * b` but curried.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Math
	 * @sig Number -> Number -> Number
	 * @param {Number} a The first value.
	 * @param {Number} b The second value.
	 * @return {Number} The result of `a * b`.
	 * @see R.divide
	 * @example
	 *
	 *      var double = R.multiply(2);
	 *      var triple = R.multiply(3);
	 *      double(3);       //=>  6
	 *      triple(4);       //=> 12
	 *      R.multiply(2, 5);  //=> 10
	 */

	var multiply =
	/*#__PURE__*/
	_curry2(function multiply(a, b) {
	  return a * b;
	});

	/**
	 * Negates its argument.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Math
	 * @sig Number -> Number
	 * @param {Number} n
	 * @return {Number}
	 * @example
	 *
	 *      R.negate(42); //=> -42
	 */

	var negate =
	/*#__PURE__*/
	_curry1(function negate(n) {
	  return -n;
	});

	/**
	 * Returns `true` if no elements of the list match the predicate, `false`
	 * otherwise.
	 *
	 * Dispatches to the `any` method of the second argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> Boolean
	 * @param {Function} fn The predicate function.
	 * @param {Array} list The array to consider.
	 * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
	 * @see R.all, R.any
	 * @example
	 *
	 *      var isEven = n => n % 2 === 0;
	 *      var isOdd = n => n % 2 === 1;
	 *
	 *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
	 *      R.none(isOdd, [1, 3, 5, 7, 8, 11]); //=> false
	 */

	var none$1 =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_complement(
	/*#__PURE__*/
	_dispatchable(['any'], _xany, any)));

	/**
	 * Returns a function which returns its nth argument.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Function
	 * @sig Number -> *... -> *
	 * @param {Number} n
	 * @return {Function}
	 * @example
	 *
	 *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
	 *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
	 * @symb R.nthArg(-1)(a, b, c) = c
	 * @symb R.nthArg(0)(a, b, c) = a
	 * @symb R.nthArg(1)(a, b, c) = b
	 */

	var nthArg =
	/*#__PURE__*/
	_curry1(function nthArg(n) {
	  var arity = n < 0 ? 1 : n + 1;
	  return curryN(arity, function () {
	    return nth(n, arguments);
	  });
	});

	/**
	 * `o` is a curried composition function that returns a unary function.
	 * Like [`compose`](#compose), `o` performs right-to-left function composition.
	 * Unlike [`compose`](#compose), the rightmost function passed to `o` will be
	 * invoked with only one argument.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category Function
	 * @sig (b -> c) -> (a -> b) -> a -> c
	 * @param {Function} f
	 * @param {Function} g
	 * @return {Function}
	 * @see R.compose, R.pipe
	 * @example
	 *
	 *      var classyGreeting = name => "The name's " + name.last + ", " + name.first + " " + name.last
	 *      var yellGreeting = R.o(R.toUpper, classyGreeting);
	 *      yellGreeting({first: 'James', last: 'Bond'}); //=> "THE NAME'S BOND, JAMES BOND"
	 *
	 *      R.o(R.multiply(10), R.add(10))(-4) //=> 60
	 *
	 * @symb R.o(f, g, x) = f(g(x))
	 */

	var o =
	/*#__PURE__*/
	_curry3(function o(f, g, x) {
	  return f(g(x));
	});

	function _of(x) {
	  return [x];
	}

	/**
	 * Returns a singleton array containing the value provided.
	 *
	 * Note this `of` is different from the ES6 `of`; See
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category Function
	 * @sig a -> [a]
	 * @param {*} x any value
	 * @return {Array} An array wrapping `x`.
	 * @example
	 *
	 *      R.of(null); //=> [null]
	 *      R.of([42]); //=> [[42]]
	 */

	var of$1 =
	/*#__PURE__*/
	_curry1(_of);

	/**
	 * Returns a partial copy of an object omitting the keys specified.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig [String] -> {String: *} -> {String: *}
	 * @param {Array} names an array of String property names to omit from the new object
	 * @param {Object} obj The object to copy from
	 * @return {Object} A new object with properties from `names` not on it.
	 * @see R.pick
	 * @example
	 *
	 *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
	 */

	var omit =
	/*#__PURE__*/
	_curry2(function omit(names, obj) {
	  var result = {};
	  var index = {};
	  var idx = 0;
	  var len = names.length;

	  while (idx < len) {
	    index[names[idx]] = 1;
	    idx += 1;
	  }

	  for (var prop in obj) {
	    if (!index.hasOwnProperty(prop)) {
	      result[prop] = obj[prop];
	    }
	  }

	  return result;
	});

	/**
	 * Accepts a function `fn` and returns a function that guards invocation of
	 * `fn` such that `fn` can only ever be called once, no matter how many times
	 * the returned function is invoked. The first value calculated is returned in
	 * subsequent invocations.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig (a... -> b) -> (a... -> b)
	 * @param {Function} fn The function to wrap in a call-only-once wrapper.
	 * @return {Function} The wrapped function.
	 * @example
	 *
	 *      var addOneOnce = R.once(x => x + 1);
	 *      addOneOnce(10); //=> 11
	 *      addOneOnce(addOneOnce(50)); //=> 11
	 */

	var once =
	/*#__PURE__*/
	_curry1(function once(fn) {
	  var called = false;
	  var result;
	  return _arity(fn.length, function () {
	    if (called) {
	      return result;
	    }

	    called = true;
	    result = fn.apply(this, arguments);
	    return result;
	  });
	});

	// transforms the held value with the provided function.

	var Identity = function Identity(x) {
	  return {
	    value: x,
	    map: function map(f) {
	      return Identity(f(x));
	    }
	  };
	};
	/**
	 * Returns the result of "setting" the portion of the given data structure
	 * focused by the given lens to the result of applying the given function to
	 * the focused value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category Object
	 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	 * @sig Lens s a -> (a -> a) -> s -> s
	 * @param {Lens} lens
	 * @param {*} v
	 * @param {*} x
	 * @return {*}
	 * @see R.prop, R.lensIndex, R.lensProp
	 * @example
	 *
	 *      var headLens = R.lensIndex(0);
	 *
	 *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
	 */


	var over =
	/*#__PURE__*/
	_curry3(function over(lens, f, x) {
	  // The value returned by the getter function is first transformed with `f`,
	  // then set as the value of an `Identity`. This is then mapped over with the
	  // setter function of the lens.
	  return lens(function (y) {
	    return Identity(f(y));
	  })(x).value;
	});

	/**
	 * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.18.0
	 * @category List
	 * @sig a -> b -> (a,b)
	 * @param {*} fst
	 * @param {*} snd
	 * @return {Array}
	 * @see R.objOf, R.of
	 * @example
	 *
	 *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
	 */

	var pair =
	/*#__PURE__*/
	_curry2(function pair(fst, snd) {
	  return [fst, snd];
	});

	function _createPartialApplicator(concat) {
	  return _curry2(function (fn, args) {
	    return _arity(Math.max(0, fn.length - args.length), function () {
	      return fn.apply(this, concat(args, arguments));
	    });
	  });
	}

	/**
	 * Takes a function `f` and a list of arguments, and returns a function `g`.
	 * When applied, `g` returns the result of applying `f` to the arguments
	 * provided initially followed by the arguments provided to `g`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category Function
	 * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
	 * @param {Function} f
	 * @param {Array} args
	 * @return {Function}
	 * @see R.partialRight
	 * @example
	 *
	 *      var multiply2 = (a, b) => a * b;
	 *      var double = R.partial(multiply2, [2]);
	 *      double(2); //=> 4
	 *
	 *      var greet = (salutation, title, firstName, lastName) =>
	 *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
	 *
	 *      var sayHello = R.partial(greet, ['Hello']);
	 *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
	 *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
	 * @symb R.partial(f, [a, b])(c, d) = f(a, b, c, d)
	 */

	var partial =
	/*#__PURE__*/
	_createPartialApplicator(_concat);

	/**
	 * Takes a function `f` and a list of arguments, and returns a function `g`.
	 * When applied, `g` returns the result of applying `f` to the arguments
	 * provided to `g` followed by the arguments provided initially.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category Function
	 * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
	 * @param {Function} f
	 * @param {Array} args
	 * @return {Function}
	 * @see R.partial
	 * @example
	 *
	 *      var greet = (salutation, title, firstName, lastName) =>
	 *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
	 *
	 *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
	 *
	 *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
	 * @symb R.partialRight(f, [a, b])(c, d) = f(c, d, a, b)
	 */

	var partialRight =
	/*#__PURE__*/
	_createPartialApplicator(
	/*#__PURE__*/
	flip(_concat));

	/**
	 * Takes a predicate and a list or other `Filterable` object and returns the
	 * pair of filterable objects of the same type of elements which do and do not
	 * satisfy, the predicate, respectively. Filterable objects include plain objects or any object
	 * that has a filter method such as `Array`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.4
	 * @category List
	 * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
	 * @param {Function} pred A predicate to determine which side the element belongs to.
	 * @param {Array} filterable the list (or other filterable) to partition.
	 * @return {Array} An array, containing first the subset of elements that satisfy the
	 *         predicate, and second the subset of elements that do not satisfy.
	 * @see R.filter, R.reject
	 * @example
	 *
	 *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
	 *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
	 *
	 *      R.partition(R.contains('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
	 *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
	 */

	var partition$2 =
	/*#__PURE__*/
	juxt([filter$1, reject]);

	/**
	 * Determines whether a nested path on an object has a specific value, in
	 * [`R.equals`](#equals) terms. Most likely used to filter a list.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.7.0
	 * @category Relation
	 * @typedefn Idx = String | Int
	 * @sig [Idx] -> a -> {a} -> Boolean
	 * @param {Array} path The path of the nested property to use
	 * @param {*} val The value to compare the nested property with
	 * @param {Object} obj The object to check the nested property in
	 * @return {Boolean} `true` if the value equals the nested object property,
	 *         `false` otherwise.
	 * @example
	 *
	 *      var user1 = { address: { zipCode: 90210 } };
	 *      var user2 = { address: { zipCode: 55555 } };
	 *      var user3 = { name: 'Bob' };
	 *      var users = [ user1, user2, user3 ];
	 *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
	 *      R.filter(isFamous, users); //=> [ user1 ]
	 */

	var pathEq =
	/*#__PURE__*/
	_curry3(function pathEq(_path, val, obj) {
	  return equals(path(_path, obj), val);
	});

	/**
	 * If the given, non-null object has a value at the given path, returns the
	 * value at that path. Otherwise returns the provided default value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.18.0
	 * @category Object
	 * @typedefn Idx = String | Int
	 * @sig a -> [Idx] -> {a} -> a
	 * @param {*} d The default value.
	 * @param {Array} p The path to use.
	 * @param {Object} obj The object to retrieve the nested property from.
	 * @return {*} The data at `path` of the supplied object or the default value.
	 * @example
	 *
	 *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
	 *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
	 */

	var pathOr =
	/*#__PURE__*/
	_curry3(function pathOr(d, p, obj) {
	  return defaultTo(d, path(p, obj));
	});

	/**
	 * Returns `true` if the specified object property at given path satisfies the
	 * given predicate; `false` otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category Logic
	 * @typedefn Idx = String | Int
	 * @sig (a -> Boolean) -> [Idx] -> {a} -> Boolean
	 * @param {Function} pred
	 * @param {Array} propPath
	 * @param {*} obj
	 * @return {Boolean}
	 * @see R.propSatisfies, R.path
	 * @example
	 *
	 *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
	 */

	var pathSatisfies =
	/*#__PURE__*/
	_curry3(function pathSatisfies(pred, propPath, obj) {
	  return propPath.length > 0 && pred(path(propPath, obj));
	});

	/**
	 * Returns a partial copy of an object containing only the keys specified. If
	 * the key does not exist, the property is ignored.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig [k] -> {k: v} -> {k: v}
	 * @param {Array} names an array of String property names to copy onto a new object
	 * @param {Object} obj The object to copy from
	 * @return {Object} A new object with only properties from `names` on it.
	 * @see R.omit, R.props
	 * @example
	 *
	 *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	 *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
	 */

	var pick =
	/*#__PURE__*/
	_curry2(function pick(names, obj) {
	  var result = {};
	  var idx = 0;

	  while (idx < names.length) {
	    if (names[idx] in obj) {
	      result[names[idx]] = obj[names[idx]];
	    }

	    idx += 1;
	  }

	  return result;
	});

	/**
	 * Similar to `pick` except that this one includes a `key: undefined` pair for
	 * properties that don't exist.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig [k] -> {k: v} -> {k: v}
	 * @param {Array} names an array of String property names to copy onto a new object
	 * @param {Object} obj The object to copy from
	 * @return {Object} A new object with only properties from `names` on it.
	 * @see R.pick
	 * @example
	 *
	 *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	 *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
	 */

	var pickAll =
	/*#__PURE__*/
	_curry2(function pickAll(names, obj) {
	  var result = {};
	  var idx = 0;
	  var len = names.length;

	  while (idx < len) {
	    var name = names[idx];
	    result[name] = obj[name];
	    idx += 1;
	  }

	  return result;
	});

	/**
	 * Returns a partial copy of an object containing only the keys that satisfy
	 * the supplied predicate.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Object
	 * @sig ((v, k) -> Boolean) -> {k: v} -> {k: v}
	 * @param {Function} pred A predicate to determine whether or not a key
	 *        should be included on the output object.
	 * @param {Object} obj The object to copy from
	 * @return {Object} A new object with only properties that satisfy `pred`
	 *         on it.
	 * @see R.pick, R.filter
	 * @example
	 *
	 *      var isUpperCase = (val, key) => key.toUpperCase() === key;
	 *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
	 */

	var pickBy =
	/*#__PURE__*/
	_curry2(function pickBy(test, obj) {
	  var result = {};

	  for (var prop in obj) {
	    if (test(obj[prop], prop, obj)) {
	      result[prop] = obj[prop];
	    }
	  }

	  return result;
	});

	/**
	 * Returns the left-to-right Kleisli composition of the provided functions,
	 * each of which must return a value of a type supported by [`chain`](#chain).
	 *
	 * `R.pipeK(f, g, h)` is equivalent to `R.pipe(f, R.chain(g), R.chain(h))`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category Function
	 * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (a -> m z)
	 * @param {...Function}
	 * @return {Function}
	 * @see R.composeK
	 * @example
	 *
	 *      //  parseJson :: String -> Maybe *
	 *      //  get :: String -> Object -> Maybe *
	 *
	 *      //  getStateCode :: Maybe String -> Maybe String
	 *      var getStateCode = R.pipeK(
	 *        parseJson,
	 *        get('user'),
	 *        get('address'),
	 *        get('state'),
	 *        R.compose(Maybe.of, R.toUpper)
	 *      );
	 *
	 *      getStateCode('{"user":{"address":{"state":"ny"}}}');
	 *      //=> Just('NY')
	 *      getStateCode('[Invalid JSON]');
	 *      //=> Nothing()
	 * @symb R.pipeK(f, g, h)(a) = R.chain(h, R.chain(g, f(a)))
	 */

	function pipeK() {
	  if (arguments.length === 0) {
	    throw new Error('pipeK requires at least one argument');
	  }

	  return composeK.apply(this, reverse(arguments));
	}

	/**
	 * Returns a new list with the given element at the front, followed by the
	 * contents of the list.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig a -> [a] -> [a]
	 * @param {*} el The item to add to the head of the output list.
	 * @param {Array} list The array to add to the tail of the output list.
	 * @return {Array} A new array.
	 * @see R.append
	 * @example
	 *
	 *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
	 */

	var prepend =
	/*#__PURE__*/
	_curry2(function prepend(el, list) {
	  return _concat([el], list);
	});

	/**
	 * Multiplies together all the elements of a list.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Math
	 * @sig [Number] -> Number
	 * @param {Array} list An array of numbers
	 * @return {Number} The product of all the numbers in the list.
	 * @see R.reduce
	 * @example
	 *
	 *      R.product([2,4,6,8,100,1]); //=> 38400
	 */

	var product =
	/*#__PURE__*/
	reduce$1(multiply, 1);

	/**
	 * Accepts a function `fn` and a list of transformer functions and returns a
	 * new curried function. When the new function is invoked, it calls the
	 * function `fn` with parameters consisting of the result of calling each
	 * supplied handler on successive arguments to the new function.
	 *
	 * If more arguments are passed to the returned function than transformer
	 * functions, those arguments are passed directly to `fn` as additional
	 * parameters. If you expect additional arguments that don't need to be
	 * transformed, although you can ignore them, it's best to pass an identity
	 * function so that the new function reports the correct arity.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig ((x1, x2, ...) -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
	 * @param {Function} fn The function to wrap.
	 * @param {Array} transformers A list of transformer functions
	 * @return {Function} The wrapped function.
	 * @see R.converge
	 * @example
	 *
	 *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
	 *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
	 *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
	 *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
	 * @symb R.useWith(f, [g, h])(a, b) = f(g(a), h(b))
	 */

	var useWith =
	/*#__PURE__*/
	_curry2(function useWith(fn, transformers) {
	  return curryN(transformers.length, function () {
	    var args = [];
	    var idx = 0;

	    while (idx < transformers.length) {
	      args.push(transformers[idx].call(this, arguments[idx]));
	      idx += 1;
	    }

	    return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
	  });
	});

	/**
	 * Reasonable analog to SQL `select` statement.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @category Relation
	 * @sig [k] -> [{k: v}] -> [{k: v}]
	 * @param {Array} props The property names to project
	 * @param {Array} objs The objects to query
	 * @return {Array} An array of objects with just the `props` properties.
	 * @example
	 *
	 *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
	 *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
	 *      var kids = [abby, fred];
	 *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
	 */

	var project =
	/*#__PURE__*/
	useWith(_map, [pickAll, identity$1]); // passing `identity` gives correct arity

	/**
	 * Returns `true` if the specified object property is equal, in
	 * [`R.equals`](#equals) terms, to the given value; `false` otherwise.
	 * You can test multiple properties with [`R.where`](#where).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig String -> a -> Object -> Boolean
	 * @param {String} name
	 * @param {*} val
	 * @param {*} obj
	 * @return {Boolean}
	 * @see R.whereEq, R.propSatisfies, R.equals
	 * @example
	 *
	 *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
	 *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
	 *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
	 *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
	 *      var kids = [abby, fred, rusty, alois];
	 *      var hasBrownHair = R.propEq('hair', 'brown');
	 *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
	 */

	var propEq =
	/*#__PURE__*/
	_curry3(function propEq(name, val, obj) {
	  return equals(val, obj[name]);
	});

	/**
	 * Returns `true` if the specified object property is of the given type;
	 * `false` otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category Type
	 * @sig Type -> String -> Object -> Boolean
	 * @param {Function} type
	 * @param {String} name
	 * @param {*} obj
	 * @return {Boolean}
	 * @see R.is, R.propSatisfies
	 * @example
	 *
	 *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
	 *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
	 *      R.propIs(Number, 'x', {});            //=> false
	 */

	var propIs =
	/*#__PURE__*/
	_curry3(function propIs(type, name, obj) {
	  return is$1(type, obj[name]);
	});

	/**
	 * If the given, non-null object has an own property with the specified name,
	 * returns the value of that property. Otherwise returns the provided default
	 * value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.6.0
	 * @category Object
	 * @sig a -> String -> Object -> a
	 * @param {*} val The default value.
	 * @param {String} p The name of the property to return.
	 * @param {Object} obj The object to query.
	 * @return {*} The value of given property of the supplied object or the default value.
	 * @example
	 *
	 *      var alice = {
	 *        name: 'ALICE',
	 *        age: 101
	 *      };
	 *      var favorite = R.prop('favoriteLibrary');
	 *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
	 *
	 *      favorite(alice);  //=> undefined
	 *      favoriteWithDefault(alice);  //=> 'Ramda'
	 */

	var propOr =
	/*#__PURE__*/
	_curry3(function propOr(val, p, obj) {
	  return obj != null && _has$1(p, obj) ? obj[p] : val;
	});

	/**
	 * Returns `true` if the specified object property satisfies the given
	 * predicate; `false` otherwise. You can test multiple properties with
	 * [`R.where`](#where).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category Logic
	 * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
	 * @param {Function} pred
	 * @param {String} name
	 * @param {*} obj
	 * @return {Boolean}
	 * @see R.where, R.propEq, R.propIs
	 * @example
	 *
	 *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
	 */

	var propSatisfies =
	/*#__PURE__*/
	_curry3(function propSatisfies(pred, name, obj) {
	  return pred(obj[name]);
	});

	/**
	 * Acts as multiple `prop`: array of keys in, array of values out. Preserves
	 * order.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig [k] -> {k: v} -> [v]
	 * @param {Array} ps The property names to fetch
	 * @param {Object} obj The object to query
	 * @return {Array} The corresponding values or partially applied function.
	 * @example
	 *
	 *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
	 *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
	 *
	 *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
	 *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
	 */

	var props =
	/*#__PURE__*/
	_curry2(function props(ps, obj) {
	  var len = ps.length;
	  var out = [];
	  var idx = 0;

	  while (idx < len) {
	    out[idx] = obj[ps[idx]];
	    idx += 1;
	  }

	  return out;
	});

	/**
	 * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Number -> Number -> [Number]
	 * @param {Number} from The first number in the list.
	 * @param {Number} to One more than the last number in the list.
	 * @return {Array} The list of numbers in tthe set `[a, b)`.
	 * @example
	 *
	 *      R.range(1, 5);    //=> [1, 2, 3, 4]
	 *      R.range(50, 53);  //=> [50, 51, 52]
	 */

	var range$1 =
	/*#__PURE__*/
	_curry2(function range(from, to) {
	  if (!(_isNumber(from) && _isNumber(to))) {
	    throw new TypeError('Both arguments to range must be numbers');
	  }

	  var result = [];
	  var n = from;

	  while (n < to) {
	    result.push(n);
	    n += 1;
	  }

	  return result;
	});

	/**
	 * Returns a single item by iterating through the list, successively calling
	 * the iterator function and passing it an accumulator value and the current
	 * value from the array, and then passing the result to the next call.
	 *
	 * Similar to [`reduce`](#reduce), except moves through the input list from the
	 * right to the left.
	 *
	 * The iterator function receives two values: *(value, acc)*, while the arguments'
	 * order of `reduce`'s iterator function is *(acc, value)*.
	 *
	 * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
	 * arrays), unlike the native `Array.prototype.reduceRight` method. For more details
	 * on this behavior, see:
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig ((a, b) -> b) -> b -> [a] -> b
	 * @param {Function} fn The iterator function. Receives two values, the current element from the array
	 *        and the accumulator.
	 * @param {*} acc The accumulator value.
	 * @param {Array} list The list to iterate over.
	 * @return {*} The final, accumulated value.
	 * @see R.reduce, R.addIndex
	 * @example
	 *
	 *      R.reduceRight(R.subtract, 0, [1, 2, 3, 4]) // => (1 - (2 - (3 - (4 - 0)))) = -2
	 *      //    -               -2
	 *      //   / \              / \
	 *      //  1   -            1   3
	 *      //     / \              / \
	 *      //    2   -     ==>    2  -1
	 *      //       / \              / \
	 *      //      3   -            3   4
	 *      //         / \              / \
	 *      //        4   0            4   0
	 *
	 * @symb R.reduceRight(f, a, [b, c, d]) = f(b, f(c, f(d, a)))
	 */

	var reduceRight =
	/*#__PURE__*/
	_curry3(function reduceRight(fn, acc, list) {
	  var idx = list.length - 1;

	  while (idx >= 0) {
	    acc = fn(list[idx], acc);
	    idx -= 1;
	  }

	  return acc;
	});

	/**
	 * Like [`reduce`](#reduce), `reduceWhile` returns a single item by iterating
	 * through the list, successively calling the iterator function. `reduceWhile`
	 * also takes a predicate that is evaluated before each step. If the predicate
	 * returns `false`, it "short-circuits" the iteration and returns the current
	 * value of the accumulator.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.22.0
	 * @category List
	 * @sig ((a, b) -> Boolean) -> ((a, b) -> a) -> a -> [b] -> a
	 * @param {Function} pred The predicate. It is passed the accumulator and the
	 *        current element.
	 * @param {Function} fn The iterator function. Receives two values, the
	 *        accumulator and the current element.
	 * @param {*} a The accumulator value.
	 * @param {Array} list The list to iterate over.
	 * @return {*} The final, accumulated value.
	 * @see R.reduce, R.reduced
	 * @example
	 *
	 *      var isOdd = (acc, x) => x % 2 === 1;
	 *      var xs = [1, 3, 5, 60, 777, 800];
	 *      R.reduceWhile(isOdd, R.add, 0, xs); //=> 9
	 *
	 *      var ys = [2, 4, 6]
	 *      R.reduceWhile(isOdd, R.add, 111, ys); //=> 111
	 */

	var reduceWhile =
	/*#__PURE__*/
	_curryN(4, [], function _reduceWhile(pred, fn, a, list) {
	  return _reduce(function (acc, x) {
	    return pred(acc, x) ? fn(acc, x) : _reduced(acc);
	  }, a, list);
	});

	/**
	 * Returns a value wrapped to indicate that it is the final value of the reduce
	 * and transduce functions. The returned value should be considered a black
	 * box: the internal structure is not guaranteed to be stable.
	 *
	 * Note: this optimization is unavailable to functions not explicitly listed
	 * above. For instance, it is not currently supported by
	 * [`reduceRight`](#reduceRight).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.15.0
	 * @category List
	 * @sig a -> *
	 * @param {*} x The final value of the reduce.
	 * @return {*} The wrapped value.
	 * @see R.reduce, R.transduce
	 * @example
	 *
	 *     R.reduce(
	 *       (acc, item) => item > 3 ? R.reduced(acc) : acc.concat(item),
	 *       [],
	 *       [1, 2, 3, 4, 5]) // [1, 2, 3]
	 */

	var reduced =
	/*#__PURE__*/
	_curry1(_reduced);

	/**
	 * Calls an input function `n` times, returning an array containing the results
	 * of those function calls.
	 *
	 * `fn` is passed one argument: The current value of `n`, which begins at `0`
	 * and is gradually incremented to `n - 1`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.3
	 * @category List
	 * @sig (Number -> a) -> Number -> [a]
	 * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
	 * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
	 * @return {Array} An array containing the return values of all calls to `fn`.
	 * @see R.repeat
	 * @example
	 *
	 *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
	 * @symb R.times(f, 0) = []
	 * @symb R.times(f, 1) = [f(0)]
	 * @symb R.times(f, 2) = [f(0), f(1)]
	 */

	var times =
	/*#__PURE__*/
	_curry2(function times(fn, n) {
	  var len = Number(n);
	  var idx = 0;
	  var list;

	  if (len < 0 || isNaN(len)) {
	    throw new RangeError('n must be a non-negative number');
	  }

	  list = new Array(len);

	  while (idx < len) {
	    list[idx] = fn(idx);
	    idx += 1;
	  }

	  return list;
	});

	/**
	 * Returns a fixed list of size `n` containing a specified identical value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.1
	 * @category List
	 * @sig a -> n -> [a]
	 * @param {*} value The value to repeat.
	 * @param {Number} n The desired size of the output list.
	 * @return {Array} A new array containing `n` `value`s.
	 * @see R.times
	 * @example
	 *
	 *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
	 *
	 *      var obj = {};
	 *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
	 *      repeatedObjs[0] === repeatedObjs[1]; //=> true
	 * @symb R.repeat(a, 0) = []
	 * @symb R.repeat(a, 1) = [a]
	 * @symb R.repeat(a, 2) = [a, a]
	 */

	var repeat$1 =
	/*#__PURE__*/
	_curry2(function repeat(value, n) {
	  return times(always(value), n);
	});

	/**
	 * Replace a substring or regex match in a string with a replacement.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.7.0
	 * @category String
	 * @sig RegExp|String -> String -> String -> String
	 * @param {RegExp|String} pattern A regular expression or a substring to match.
	 * @param {String} replacement The string to replace the matches with.
	 * @param {String} str The String to do the search and replacement in.
	 * @return {String} The result.
	 * @example
	 *
	 *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
	 *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
	 *
	 *      // Use the "g" (global) flag to replace all occurrences:
	 *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
	 */

	var replace =
	/*#__PURE__*/
	_curry3(function replace(regex, replacement, str) {
	  return str.replace(regex, replacement);
	});

	/**
	 * Scan is similar to [`reduce`](#reduce), but returns a list of successively
	 * reduced values from the left
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category List
	 * @sig ((a, b) -> a) -> a -> [b] -> [a]
	 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	 *        current element from the array
	 * @param {*} acc The accumulator value.
	 * @param {Array} list The list to iterate over.
	 * @return {Array} A list of all intermediately reduced values.
	 * @see R.reduce
	 * @example
	 *
	 *      var numbers = [1, 2, 3, 4];
	 *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
	 * @symb R.scan(f, a, [b, c]) = [a, f(a, b), f(f(a, b), c)]
	 */

	var scan$1 =
	/*#__PURE__*/
	_curry3(function scan(fn, acc, list) {
	  var idx = 0;
	  var len = list.length;
	  var result = [acc];

	  while (idx < len) {
	    acc = fn(acc, list[idx]);
	    result[idx + 1] = acc;
	    idx += 1;
	  }

	  return result;
	});

	/**
	 * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
	 * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
	 * Applicative of Traversable.
	 *
	 * Dispatches to the `sequence` method of the second argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category List
	 * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
	 * @param {Function} of
	 * @param {*} traversable
	 * @return {*}
	 * @see R.traverse
	 * @example
	 *
	 *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
	 *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
	 *
	 *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
	 *      R.sequence(R.of, Nothing());       //=> [Nothing()]
	 */

	var sequence =
	/*#__PURE__*/
	_curry2(function sequence(of, traversable) {
	  return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (x, acc) {
	    return ap(map$1(prepend, x), acc);
	  }, of([]), traversable);
	});

	/**
	 * Returns the result of "setting" the portion of the given data structure
	 * focused by the given lens to the given value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category Object
	 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	 * @sig Lens s a -> a -> s -> s
	 * @param {Lens} lens
	 * @param {*} v
	 * @param {*} x
	 * @return {*}
	 * @see R.prop, R.lensIndex, R.lensProp
	 * @example
	 *
	 *      var xLens = R.lensProp('x');
	 *
	 *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
	 *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
	 */

	var set$1 =
	/*#__PURE__*/
	_curry3(function set(lens, v, x) {
	  return over(lens, always(v), x);
	});

	/**
	 * Returns a copy of the list, sorted according to the comparator function,
	 * which should accept two values at a time and return a negative number if the
	 * first value is smaller, a positive number if it's larger, and zero if they
	 * are equal. Please note that this is a **copy** of the list. It does not
	 * modify the original.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig ((a, a) -> Number) -> [a] -> [a]
	 * @param {Function} comparator A sorting function :: a -> b -> Int
	 * @param {Array} list The list to sort
	 * @return {Array} a new array with its elements sorted by the comparator function.
	 * @example
	 *
	 *      var diff = function(a, b) { return a - b; };
	 *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
	 */

	var sort =
	/*#__PURE__*/
	_curry2(function sort(comparator, list) {
	  return Array.prototype.slice.call(list, 0).sort(comparator);
	});

	/**
	 * Sorts the list according to the supplied function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig Ord b => (a -> b) -> [a] -> [a]
	 * @param {Function} fn
	 * @param {Array} list The list to sort.
	 * @return {Array} A new list sorted by the keys generated by `fn`.
	 * @example
	 *
	 *      var sortByFirstItem = R.sortBy(R.prop(0));
	 *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
	 *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
	 *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
	 *      var alice = {
	 *        name: 'ALICE',
	 *        age: 101
	 *      };
	 *      var bob = {
	 *        name: 'Bob',
	 *        age: -10
	 *      };
	 *      var clara = {
	 *        name: 'clara',
	 *        age: 314.159
	 *      };
	 *      var people = [clara, bob, alice];
	 *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
	 */

	var sortBy =
	/*#__PURE__*/
	_curry2(function sortBy(fn, list) {
	  return Array.prototype.slice.call(list, 0).sort(function (a, b) {
	    var aa = fn(a);
	    var bb = fn(b);
	    return aa < bb ? -1 : aa > bb ? 1 : 0;
	  });
	});

	/**
	 * Sorts a list according to a list of comparators.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.23.0
	 * @category Relation
	 * @sig [(a, a) -> Number] -> [a] -> [a]
	 * @param {Array} functions A list of comparator functions.
	 * @param {Array} list The list to sort.
	 * @return {Array} A new list sorted according to the comarator functions.
	 * @example
	 *
	 *      var alice = {
	 *        name: 'alice',
	 *        age: 40
	 *      };
	 *      var bob = {
	 *        name: 'bob',
	 *        age: 30
	 *      };
	 *      var clara = {
	 *        name: 'clara',
	 *        age: 40
	 *      };
	 *      var people = [clara, bob, alice];
	 *      var ageNameSort = R.sortWith([
	 *        R.descend(R.prop('age')),
	 *        R.ascend(R.prop('name'))
	 *      ]);
	 *      ageNameSort(people); //=> [alice, clara, bob]
	 */

	var sortWith =
	/*#__PURE__*/
	_curry2(function sortWith(fns, list) {
	  return Array.prototype.slice.call(list, 0).sort(function (a, b) {
	    var result = 0;
	    var i = 0;

	    while (result === 0 && i < fns.length) {
	      result = fns[i](a, b);
	      i += 1;
	    }

	    return result;
	  });
	});

	/**
	 * Splits a string into an array of strings based on the given
	 * separator.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category String
	 * @sig (String | RegExp) -> String -> [String]
	 * @param {String|RegExp} sep The pattern.
	 * @param {String} str The string to separate into an array.
	 * @return {Array} The array of strings from `str` separated by `str`.
	 * @see R.join
	 * @example
	 *
	 *      var pathComponents = R.split('/');
	 *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
	 *
	 *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
	 */

	var split =
	/*#__PURE__*/
	invoker(1, 'split');

	/**
	 * Splits a given list or string at a given index.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category List
	 * @sig Number -> [a] -> [[a], [a]]
	 * @sig Number -> String -> [String, String]
	 * @param {Number} index The index where the array/string is split.
	 * @param {Array|String} array The array/string to be split.
	 * @return {Array}
	 * @example
	 *
	 *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
	 *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
	 *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
	 */

	var splitAt =
	/*#__PURE__*/
	_curry2(function splitAt(index, array) {
	  return [slice(0, index, array), slice(index, length(array), array)];
	});

	/**
	 * Splits a collection into slices of the specified length.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category List
	 * @sig Number -> [a] -> [[a]]
	 * @sig Number -> String -> [String]
	 * @param {Number} n
	 * @param {Array} list
	 * @return {Array}
	 * @example
	 *
	 *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
	 *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
	 */

	var splitEvery =
	/*#__PURE__*/
	_curry2(function splitEvery(n, list) {
	  if (n <= 0) {
	    throw new Error('First argument to splitEvery must be a positive integer');
	  }

	  var result = [];
	  var idx = 0;

	  while (idx < list.length) {
	    result.push(slice(idx, idx += n, list));
	  }

	  return result;
	});

	/**
	 * Takes a list and a predicate and returns a pair of lists with the following properties:
	 *
	 *  - the result of concatenating the two output lists is equivalent to the input list;
	 *  - none of the elements of the first output list satisfies the predicate; and
	 *  - if the second output list is non-empty, its first element satisfies the predicate.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> [[a], [a]]
	 * @param {Function} pred The predicate that determines where the array is split.
	 * @param {Array} list The array to be split.
	 * @return {Array}
	 * @example
	 *
	 *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
	 */

	var splitWhen =
	/*#__PURE__*/
	_curry2(function splitWhen(pred, list) {
	  var idx = 0;
	  var len = list.length;
	  var prefix = [];

	  while (idx < len && !pred(list[idx])) {
	    prefix.push(list[idx]);
	    idx += 1;
	  }

	  return [prefix, Array.prototype.slice.call(list, idx)];
	});

	/**
	 * Checks if a list starts with the provided values
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category List
	 * @sig [a] -> Boolean
	 * @sig String -> Boolean
	 * @param {*} prefix
	 * @param {*} list
	 * @return {Boolean}
	 * @example
	 *
	 *      R.startsWith('a', 'abc')                //=> true
	 *      R.startsWith('b', 'abc')                //=> false
	 *      R.startsWith(['a'], ['a', 'b', 'c'])    //=> true
	 *      R.startsWith(['b'], ['a', 'b', 'c'])    //=> false
	 */

	var startsWith =
	/*#__PURE__*/
	_curry2(function (prefix, list) {
	  return equals(take$1(prefix.length, list), prefix);
	});

	/**
	 * Subtracts its second argument from its first argument.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Math
	 * @sig Number -> Number -> Number
	 * @param {Number} a The first value.
	 * @param {Number} b The second value.
	 * @return {Number} The result of `a - b`.
	 * @see R.add
	 * @example
	 *
	 *      R.subtract(10, 8); //=> 2
	 *
	 *      var minus5 = R.subtract(R.__, 5);
	 *      minus5(17); //=> 12
	 *
	 *      var complementaryAngle = R.subtract(90);
	 *      complementaryAngle(30); //=> 60
	 *      complementaryAngle(72); //=> 18
	 */

	var subtract =
	/*#__PURE__*/
	_curry2(function subtract(a, b) {
	  return Number(a) - Number(b);
	});

	/**
	 * Finds the set (i.e. no duplicates) of all elements contained in the first or
	 * second list, but not both.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category Relation
	 * @sig [*] -> [*] -> [*]
	 * @param {Array} list1 The first list.
	 * @param {Array} list2 The second list.
	 * @return {Array} The elements in `list1` or `list2`, but not both.
	 * @see R.symmetricDifferenceWith, R.difference, R.differenceWith
	 * @example
	 *
	 *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
	 *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
	 */

	var symmetricDifference =
	/*#__PURE__*/
	_curry2(function symmetricDifference(list1, list2) {
	  return concat$2(difference(list1, list2), difference(list2, list1));
	});

	/**
	 * Finds the set (i.e. no duplicates) of all elements contained in the first or
	 * second list, but not both. Duplication is determined according to the value
	 * returned by applying the supplied predicate to two list elements.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category Relation
	 * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
	 * @param {Function} pred A predicate used to test whether two items are equal.
	 * @param {Array} list1 The first list.
	 * @param {Array} list2 The second list.
	 * @return {Array} The elements in `list1` or `list2`, but not both.
	 * @see R.symmetricDifference, R.difference, R.differenceWith
	 * @example
	 *
	 *      var eqA = R.eqBy(R.prop('a'));
	 *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
	 *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
	 *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
	 */

	var symmetricDifferenceWith =
	/*#__PURE__*/
	_curry3(function symmetricDifferenceWith(pred, list1, list2) {
	  return concat$2(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
	});

	/**
	 * Returns a new list containing the last `n` elements of a given list, passing
	 * each value to the supplied predicate function, and terminating when the
	 * predicate function returns `false`. Excludes the element that caused the
	 * predicate function to fail. The predicate function is passed one argument:
	 * *(value)*.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> [a]
	 * @sig (a -> Boolean) -> String -> String
	 * @param {Function} fn The function called per iteration.
	 * @param {Array} xs The collection to iterate over.
	 * @return {Array} A new array.
	 * @see R.dropLastWhile, R.addIndex
	 * @example
	 *
	 *      var isNotOne = x => x !== 1;
	 *
	 *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
	 *
	 *      R.takeLastWhile(x => x !== 'R' , 'Ramda'); //=> 'amda'
	 */

	var takeLastWhile =
	/*#__PURE__*/
	_curry2(function takeLastWhile(fn, xs) {
	  var idx = xs.length - 1;

	  while (idx >= 0 && fn(xs[idx])) {
	    idx -= 1;
	  }

	  return slice(idx + 1, Infinity, xs);
	});

	var XTakeWhile =
	/*#__PURE__*/
	function () {
	  function XTakeWhile(f, xf) {
	    this.xf = xf;
	    this.f = f;
	  }

	  XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
	  XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;

	  XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
	    return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
	  };

	  return XTakeWhile;
	}();

	var _xtakeWhile =
	/*#__PURE__*/
	_curry2(function _xtakeWhile(f, xf) {
	  return new XTakeWhile(f, xf);
	});

	/**
	 * Returns a new list containing the first `n` elements of a given list,
	 * passing each value to the supplied predicate function, and terminating when
	 * the predicate function returns `false`. Excludes the element that caused the
	 * predicate function to fail. The predicate function is passed one argument:
	 * *(value)*.
	 *
	 * Dispatches to the `takeWhile` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> [a]
	 * @sig (a -> Boolean) -> String -> String
	 * @param {Function} fn The function called per iteration.
	 * @param {Array} xs The collection to iterate over.
	 * @return {Array} A new array.
	 * @see R.dropWhile, R.transduce, R.addIndex
	 * @example
	 *
	 *      var isNotFour = x => x !== 4;
	 *
	 *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
	 *
	 *      R.takeWhile(x => x !== 'd' , 'Ramda'); //=> 'Ram'
	 */

	var takeWhile$1 =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable(['takeWhile'], _xtakeWhile, function takeWhile(fn, xs) {
	  var idx = 0;
	  var len = xs.length;

	  while (idx < len && fn(xs[idx])) {
	    idx += 1;
	  }

	  return slice(0, idx, xs);
	}));

	var XTap =
	/*#__PURE__*/
	function () {
	  function XTap(f, xf) {
	    this.xf = xf;
	    this.f = f;
	  }

	  XTap.prototype['@@transducer/init'] = _xfBase.init;
	  XTap.prototype['@@transducer/result'] = _xfBase.result;

	  XTap.prototype['@@transducer/step'] = function (result, input) {
	    this.f(input);
	    return this.xf['@@transducer/step'](result, input);
	  };

	  return XTap;
	}();

	var _xtap =
	/*#__PURE__*/
	_curry2(function _xtap(f, xf) {
	  return new XTap(f, xf);
	});

	/**
	 * Runs the given function with the supplied object, then returns the object.
	 *
	 * Acts as a transducer if a transformer is given as second parameter.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig (a -> *) -> a -> a
	 * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
	 * @param {*} x
	 * @return {*} `x`.
	 * @example
	 *
	 *      var sayX = x => console.log('x is ' + x);
	 *      R.tap(sayX, 100); //=> 100
	 *      // logs 'x is 100'
	 * @symb R.tap(f, a) = a
	 */

	var tap$1 =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	_dispatchable([], _xtap, function tap(fn, x) {
	  fn(x);
	  return x;
	}));

	function _isRegExp(x) {
	  return Object.prototype.toString.call(x) === '[object RegExp]';
	}

	/**
	 * Determines whether a given string matches a given regular expression.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category String
	 * @sig RegExp -> String -> Boolean
	 * @param {RegExp} pattern
	 * @param {String} str
	 * @return {Boolean}
	 * @see R.match
	 * @example
	 *
	 *      R.test(/^x/, 'xyz'); //=> true
	 *      R.test(/^y/, 'xyz'); //=> false
	 */

	var test$1 =
	/*#__PURE__*/
	_curry2(function test(pattern, str) {
	  if (!_isRegExp(pattern)) {
	    throw new TypeError('âtestâ requires a value of type RegExp as its first argument; received ' + toString$4(pattern));
	  }

	  return _cloneRegExp(pattern).test(str);
	});

	/**
	 * The lower case version of a string.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category String
	 * @sig String -> String
	 * @param {String} str The string to lower case.
	 * @return {String} The lower case version of `str`.
	 * @see R.toUpper
	 * @example
	 *
	 *      R.toLower('XYZ'); //=> 'xyz'
	 */

	var toLower =
	/*#__PURE__*/
	invoker(0, 'toLowerCase');

	/**
	 * Converts an object into an array of key, value arrays. Only the object's
	 * own properties are used.
	 * Note that the order of the output array is not guaranteed to be consistent
	 * across different JS platforms.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.4.0
	 * @category Object
	 * @sig {String: *} -> [[String,*]]
	 * @param {Object} obj The object to extract from
	 * @return {Array} An array of key, value arrays from the object's own properties.
	 * @see R.fromPairs
	 * @example
	 *
	 *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
	 */

	var toPairs =
	/*#__PURE__*/
	_curry1(function toPairs(obj) {
	  var pairs = [];

	  for (var prop in obj) {
	    if (_has$1(prop, obj)) {
	      pairs[pairs.length] = [prop, obj[prop]];
	    }
	  }

	  return pairs;
	});

	/**
	 * Converts an object into an array of key, value arrays. The object's own
	 * properties and prototype properties are used. Note that the order of the
	 * output array is not guaranteed to be consistent across different JS
	 * platforms.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.4.0
	 * @category Object
	 * @sig {String: *} -> [[String,*]]
	 * @param {Object} obj The object to extract from
	 * @return {Array} An array of key, value arrays from the object's own
	 *         and prototype properties.
	 * @example
	 *
	 *      var F = function() { this.x = 'X'; };
	 *      F.prototype.y = 'Y';
	 *      var f = new F();
	 *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
	 */

	var toPairsIn =
	/*#__PURE__*/
	_curry1(function toPairsIn(obj) {
	  var pairs = [];

	  for (var prop in obj) {
	    pairs[pairs.length] = [prop, obj[prop]];
	  }

	  return pairs;
	});

	/**
	 * The upper case version of a string.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category String
	 * @sig String -> String
	 * @param {String} str The string to upper case.
	 * @return {String} The upper case version of `str`.
	 * @see R.toLower
	 * @example
	 *
	 *      R.toUpper('abc'); //=> 'ABC'
	 */

	var toUpper =
	/*#__PURE__*/
	invoker(0, 'toUpperCase');

	/**
	 * Initializes a transducer using supplied iterator function. Returns a single
	 * item by iterating through the list, successively calling the transformed
	 * iterator function and passing it an accumulator value and the current value
	 * from the array, and then passing the result to the next call.
	 *
	 * The iterator function receives two values: *(acc, value)*. It will be
	 * wrapped as a transformer to initialize the transducer. A transformer can be
	 * passed directly in place of an iterator function. In both cases, iteration
	 * may be stopped early with the [`R.reduced`](#reduced) function.
	 *
	 * A transducer is a function that accepts a transformer and returns a
	 * transformer and can be composed directly.
	 *
	 * A transformer is an an object that provides a 2-arity reducing iterator
	 * function, step, 0-arity initial value function, init, and 1-arity result
	 * extraction function, result. The step function is used as the iterator
	 * function in reduce. The result function is used to convert the final
	 * accumulator into the return type and in most cases is
	 * [`R.identity`](#identity). The init function can be used to provide an
	 * initial accumulator, but is ignored by transduce.
	 *
	 * The iteration is performed with [`R.reduce`](#reduce) after initializing the transducer.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category List
	 * @sig (c -> c) -> ((a, b) -> a) -> a -> [b] -> a
	 * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
	 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	 *        current element from the array. Wrapped as transformer, if necessary, and used to
	 *        initialize the transducer
	 * @param {*} acc The initial accumulator value.
	 * @param {Array} list The list to iterate over.
	 * @return {*} The final, accumulated value.
	 * @see R.reduce, R.reduced, R.into
	 * @example
	 *
	 *      var numbers = [1, 2, 3, 4];
	 *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
	 *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
	 *
	 *      var isOdd = (x) => x % 2 === 1;
	 *      var firstOddTransducer = R.compose(R.filter(isOdd), R.take(1));
	 *      R.transduce(firstOddTransducer, R.flip(R.append), [], R.range(0, 100)); //=> [1]
	 */

	var transduce =
	/*#__PURE__*/
	curryN(4, function transduce(xf, fn, acc, list) {
	  return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
	});

	/**
	 * Transposes the rows and columns of a 2D list.
	 * When passed a list of `n` lists of length `x`,
	 * returns a list of `x` lists of length `n`.
	 *
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category List
	 * @sig [[a]] -> [[a]]
	 * @param {Array} list A 2D list
	 * @return {Array} A 2D list
	 * @example
	 *
	 *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
	 *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
	 *
	 *      // If some of the rows are shorter than the following rows, their elements are skipped:
	 *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
	 * @symb R.transpose([[a], [b], [c]]) = [a, b, c]
	 * @symb R.transpose([[a, b], [c, d]]) = [[a, c], [b, d]]
	 * @symb R.transpose([[a, b], [c]]) = [[a, c], [b]]
	 */

	var transpose =
	/*#__PURE__*/
	_curry1(function transpose(outerlist) {
	  var i = 0;
	  var result = [];

	  while (i < outerlist.length) {
	    var innerlist = outerlist[i];
	    var j = 0;

	    while (j < innerlist.length) {
	      if (typeof result[j] === 'undefined') {
	        result[j] = [];
	      }

	      result[j].push(innerlist[j]);
	      j += 1;
	    }

	    i += 1;
	  }

	  return result;
	});

	/**
	 * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
	 * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
	 * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
	 * into an Applicative of Traversable.
	 *
	 * Dispatches to the `traverse` method of the third argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category List
	 * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
	 * @param {Function} of
	 * @param {Function} f
	 * @param {*} traversable
	 * @return {*}
	 * @see R.sequence
	 * @example
	 *
	 *      // Returns `Nothing` if the given divisor is `0`
	 *      safeDiv = n => d => d === 0 ? Nothing() : Just(n / d)
	 *
	 *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Just([5, 2.5, 2])
	 *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing
	 */

	var traverse =
	/*#__PURE__*/
	_curry3(function traverse(of, f, traversable) {
	  return typeof traversable['fantasy-land/traverse'] === 'function' ? traversable['fantasy-land/traverse'](f, of) : sequence(of, map$1(f, traversable));
	});

	var ws = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" + "\u2029\uFEFF";
	var zeroWidth = "\u200B";
	var hasProtoTrim = typeof String.prototype.trim === 'function';
	/**
	 * Removes (strips) whitespace from both ends of the string.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.6.0
	 * @category String
	 * @sig String -> String
	 * @param {String} str The string to trim.
	 * @return {String} Trimmed version of `str`.
	 * @example
	 *
	 *      R.trim('   xyz  '); //=> 'xyz'
	 *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
	 */

	var _trim = !hasProtoTrim ||
	/*#__PURE__*/
	ws.trim() || !
	/*#__PURE__*/
	zeroWidth.trim() ? function trim(str) {
	  var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
	  var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
	  return str.replace(beginRx, '').replace(endRx, '');
	} : function trim(str) {
	  return str.trim();
	};

	var trim$1 =
	/*#__PURE__*/
	_curry1(_trim);

	/**
	 * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
	 * function evaluates the `tryer`; if it does not throw, it simply returns the
	 * result. If the `tryer` *does* throw, the returned function evaluates the
	 * `catcher` function and returns its result. Note that for effective
	 * composition with this function, both the `tryer` and `catcher` functions
	 * must return the same type of results.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.20.0
	 * @category Function
	 * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
	 * @param {Function} tryer The function that may throw.
	 * @param {Function} catcher The function that will be evaluated if `tryer` throws.
	 * @return {Function} A new function that will catch exceptions and send then to the catcher.
	 * @example
	 *
	 *      R.tryCatch(R.prop('x'), R.F)({x: true}); //=> true
	 *      R.tryCatch(R.prop('x'), R.F)(null);      //=> false
	 */

	var tryCatch =
	/*#__PURE__*/
	_curry2(function _tryCatch(tryer, catcher) {
	  return _arity(tryer.length, function () {
	    try {
	      return tryer.apply(this, arguments);
	    } catch (e) {
	      return catcher.apply(this, _concat([e], arguments));
	    }
	  });
	});

	/**
	 * Takes a function `fn`, which takes a single array argument, and returns a
	 * function which:
	 *
	 *   - takes any number of positional arguments;
	 *   - passes these arguments to `fn` as an array; and
	 *   - returns the result.
	 *
	 * In other words, `R.unapply` derives a variadic function from a function which
	 * takes an array. `R.unapply` is the inverse of [`R.apply`](#apply).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Function
	 * @sig ([*...] -> a) -> (*... -> a)
	 * @param {Function} fn
	 * @return {Function}
	 * @see R.apply
	 * @example
	 *
	 *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
	 * @symb R.unapply(f)(a, b) = f([a, b])
	 */

	var unapply =
	/*#__PURE__*/
	_curry1(function unapply(fn) {
	  return function () {
	    return fn(Array.prototype.slice.call(arguments, 0));
	  };
	});

	/**
	 * Wraps a function of any arity (including nullary) in a function that accepts
	 * exactly 1 parameter. Any extraneous parameters will not be passed to the
	 * supplied function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.0
	 * @category Function
	 * @sig (* -> b) -> (a -> b)
	 * @param {Function} fn The function to wrap.
	 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	 *         arity 1.
	 * @see R.binary, R.nAry
	 * @example
	 *
	 *      var takesTwoArgs = function(a, b) {
	 *        return [a, b];
	 *      };
	 *      takesTwoArgs.length; //=> 2
	 *      takesTwoArgs(1, 2); //=> [1, 2]
	 *
	 *      var takesOneArg = R.unary(takesTwoArgs);
	 *      takesOneArg.length; //=> 1
	 *      // Only 1 argument is passed to the wrapped function
	 *      takesOneArg(1, 2); //=> [1, undefined]
	 * @symb R.unary(f)(a, b, c) = f(a)
	 */

	var unary =
	/*#__PURE__*/
	_curry1(function unary(fn) {
	  return nAry(1, fn);
	});

	/**
	 * Returns a function of arity `n` from a (manually) curried function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category Function
	 * @sig Number -> (a -> b) -> (a -> c)
	 * @param {Number} length The arity for the returned function.
	 * @param {Function} fn The function to uncurry.
	 * @return {Function} A new function.
	 * @see R.curry
	 * @example
	 *
	 *      var addFour = a => b => c => d => a + b + c + d;
	 *
	 *      var uncurriedAddFour = R.uncurryN(4, addFour);
	 *      uncurriedAddFour(1, 2, 3, 4); //=> 10
	 */

	var uncurryN =
	/*#__PURE__*/
	_curry2(function uncurryN(depth, fn) {
	  return curryN(depth, function () {
	    var currentDepth = 1;
	    var value = fn;
	    var idx = 0;
	    var endIdx;

	    while (currentDepth <= depth && typeof value === 'function') {
	      endIdx = currentDepth === depth ? arguments.length : idx + value.length;
	      value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
	      currentDepth += 1;
	      idx = endIdx;
	    }

	    return value;
	  });
	});

	/**
	 * Builds a list from a seed value. Accepts an iterator function, which returns
	 * either false to stop iteration or an array of length 2 containing the value
	 * to add to the resulting list and the seed to be used in the next call to the
	 * iterator function.
	 *
	 * The iterator function receives one argument: *(seed)*.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category List
	 * @sig (a -> [b]) -> * -> [b]
	 * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
	 *        either false to quit iteration or an array of length two to proceed. The element
	 *        at index 0 of this array will be added to the resulting array, and the element
	 *        at index 1 will be passed to the next call to `fn`.
	 * @param {*} seed The seed value.
	 * @return {Array} The final list.
	 * @example
	 *
	 *      var f = n => n > 50 ? false : [-n, n + 10];
	 *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
	 * @symb R.unfold(f, x) = [f(x)[0], f(f(x)[1])[0], f(f(f(x)[1])[1])[0], ...]
	 */

	var unfold =
	/*#__PURE__*/
	_curry2(function unfold(fn, seed) {
	  var pair = fn(seed);
	  var result = [];

	  while (pair && pair.length) {
	    result[result.length] = pair[0];
	    pair = fn(pair[1]);
	  }

	  return result;
	});

	/**
	 * Combines two lists into a set (i.e. no duplicates) composed of the elements
	 * of each list.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig [*] -> [*] -> [*]
	 * @param {Array} as The first list.
	 * @param {Array} bs The second list.
	 * @return {Array} The first and second lists concatenated, with
	 *         duplicates removed.
	 * @example
	 *
	 *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
	 */

	var union =
	/*#__PURE__*/
	_curry2(
	/*#__PURE__*/
	compose(uniq, _concat));

	/**
	 * Returns a new list containing only one copy of each element in the original
	 * list, based upon the value returned by applying the supplied predicate to
	 * two list elements. Prefers the first item if two items compare equal based
	 * on the predicate.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.0
	 * @category List
	 * @sig ((a, a) -> Boolean) -> [a] -> [a]
	 * @param {Function} pred A predicate used to test whether two items are equal.
	 * @param {Array} list The array to consider.
	 * @return {Array} The list of unique items.
	 * @example
	 *
	 *      var strEq = R.eqBy(String);
	 *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
	 *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
	 *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
	 *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
	 */

	var uniqWith =
	/*#__PURE__*/
	_curry2(function uniqWith(pred, list) {
	  var idx = 0;
	  var len = list.length;
	  var result = [];
	  var item;

	  while (idx < len) {
	    item = list[idx];

	    if (!_containsWith(pred, item, result)) {
	      result[result.length] = item;
	    }

	    idx += 1;
	  }

	  return result;
	});

	/**
	 * Combines two lists into a set (i.e. no duplicates) composed of the elements
	 * of each list. Duplication is determined according to the value returned by
	 * applying the supplied predicate to two list elements.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig ((a, a) -> Boolean) -> [*] -> [*] -> [*]
	 * @param {Function} pred A predicate used to test whether two items are equal.
	 * @param {Array} list1 The first list.
	 * @param {Array} list2 The second list.
	 * @return {Array} The first and second lists concatenated, with
	 *         duplicates removed.
	 * @see R.union
	 * @example
	 *
	 *      var l1 = [{a: 1}, {a: 2}];
	 *      var l2 = [{a: 1}, {a: 4}];
	 *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
	 */

	var unionWith =
	/*#__PURE__*/
	_curry3(function unionWith(pred, list1, list2) {
	  return uniqWith(pred, _concat(list1, list2));
	});

	/**
	 * Tests the final argument by passing it to the given predicate function. If
	 * the predicate is not satisfied, the function will return the result of
	 * calling the `whenFalseFn` function with the same argument. If the predicate
	 * is satisfied, the argument is returned as is.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.18.0
	 * @category Logic
	 * @sig (a -> Boolean) -> (a -> a) -> a -> a
	 * @param {Function} pred        A predicate function
	 * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
	 *                               to a falsy value.
	 * @param {*}        x           An object to test with the `pred` function and
	 *                               pass to `whenFalseFn` if necessary.
	 * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
	 * @see R.ifElse, R.when
	 * @example
	 *
	 *      let safeInc = R.unless(R.isNil, R.inc);
	 *      safeInc(null); //=> null
	 *      safeInc(1); //=> 2
	 */

	var unless =
	/*#__PURE__*/
	_curry3(function unless(pred, whenFalseFn, x) {
	  return pred(x) ? x : whenFalseFn(x);
	});

	/**
	 * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
	 * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category List
	 * @sig Chain c => c (c a) -> c a
	 * @param {*} list
	 * @return {*}
	 * @see R.flatten, R.chain
	 * @example
	 *
	 *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
	 *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
	 */

	var unnest =
	/*#__PURE__*/
	chain(_identity);

	/**
	 * Takes a predicate, a transformation function, and an initial value,
	 * and returns a value of the same type as the initial value.
	 * It does so by applying the transformation until the predicate is satisfied,
	 * at which point it returns the satisfactory value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.20.0
	 * @category Logic
	 * @sig (a -> Boolean) -> (a -> a) -> a -> a
	 * @param {Function} pred A predicate function
	 * @param {Function} fn The iterator function
	 * @param {*} init Initial value
	 * @return {*} Final value that satisfies predicate
	 * @example
	 *
	 *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
	 */

	var until =
	/*#__PURE__*/
	_curry3(function until(pred, fn, init) {
	  var val = init;

	  while (!pred(val)) {
	    val = fn(val);
	  }

	  return val;
	});

	/**
	 * Returns a list of all the properties, including prototype properties, of the
	 * supplied object.
	 * Note that the order of the output array is not guaranteed to be consistent
	 * across different JS platforms.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.0
	 * @category Object
	 * @sig {k: v} -> [v]
	 * @param {Object} obj The object to extract values from
	 * @return {Array} An array of the values of the object's own and prototype properties.
	 * @see R.values, R.keysIn
	 * @example
	 *
	 *      var F = function() { this.x = 'X'; };
	 *      F.prototype.y = 'Y';
	 *      var f = new F();
	 *      R.valuesIn(f); //=> ['X', 'Y']
	 */

	var valuesIn =
	/*#__PURE__*/
	_curry1(function valuesIn(obj) {
	  var prop;
	  var vs = [];

	  for (prop in obj) {
	    vs[vs.length] = obj[prop];
	  }

	  return vs;
	});

	var Const = function Const(x) {
	  return {
	    value: x,
	    'fantasy-land/map': function fantasyLandMap() {
	      return this;
	    }
	  };
	};
	/**
	 * Returns a "view" of the given data structure, determined by the given lens.
	 * The lens's focus determines which portion of the data structure is visible.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category Object
	 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	 * @sig Lens s a -> s -> a
	 * @param {Lens} lens
	 * @param {*} x
	 * @return {*}
	 * @see R.prop, R.lensIndex, R.lensProp
	 * @example
	 *
	 *      var xLens = R.lensProp('x');
	 *
	 *      R.view(xLens, {x: 1, y: 2});  //=> 1
	 *      R.view(xLens, {x: 4, y: 2});  //=> 4
	 */


	var view =
	/*#__PURE__*/
	_curry2(function view(lens, x) {
	  // Using `Const` effectively ignores the setter function of the `lens`,
	  // leaving the value returned by the getter function unmodified.
	  return lens(Const)(x).value;
	});

	/**
	 * Tests the final argument by passing it to the given predicate function. If
	 * the predicate is satisfied, the function will return the result of calling
	 * the `whenTrueFn` function with the same argument. If the predicate is not
	 * satisfied, the argument is returned as is.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.18.0
	 * @category Logic
	 * @sig (a -> Boolean) -> (a -> a) -> a -> a
	 * @param {Function} pred       A predicate function
	 * @param {Function} whenTrueFn A function to invoke when the `condition`
	 *                              evaluates to a truthy value.
	 * @param {*}        x          An object to test with the `pred` function and
	 *                              pass to `whenTrueFn` if necessary.
	 * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
	 * @see R.ifElse, R.unless
	 * @example
	 *
	 *      // truncate :: String -> String
	 *      var truncate = R.when(
	 *        R.propSatisfies(R.gt(R.__, 10), 'length'),
	 *        R.pipe(R.take(10), R.append('â¦'), R.join(''))
	 *      );
	 *      truncate('12345');         //=> '12345'
	 *      truncate('0123456789ABC'); //=> '0123456789â¦'
	 */

	var when =
	/*#__PURE__*/
	_curry3(function when(pred, whenTrueFn, x) {
	  return pred(x) ? whenTrueFn(x) : x;
	});

	/**
	 * Takes a spec object and a test object; returns true if the test satisfies
	 * the spec. Each of the spec's own properties must be a predicate function.
	 * Each predicate is applied to the value of the corresponding property of the
	 * test object. `where` returns true if all the predicates return true, false
	 * otherwise.
	 *
	 * `where` is well suited to declaratively expressing constraints for other
	 * functions such as [`filter`](#filter) and [`find`](#find).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.1
	 * @category Object
	 * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
	 * @param {Object} spec
	 * @param {Object} testObj
	 * @return {Boolean}
	 * @see R.propSatisfies, R.whereEq
	 * @example
	 *
	 *      // pred :: Object -> Boolean
	 *      var pred = R.where({
	 *        a: R.equals('foo'),
	 *        b: R.complement(R.equals('bar')),
	 *        x: R.gt(R.__, 10),
	 *        y: R.lt(R.__, 20)
	 *      });
	 *
	 *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
	 *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
	 *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
	 *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
	 *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
	 */

	var where =
	/*#__PURE__*/
	_curry2(function where(spec, testObj) {
	  for (var prop in spec) {
	    if (_has$1(prop, spec) && !spec[prop](testObj[prop])) {
	      return false;
	    }
	  }

	  return true;
	});

	/**
	 * Takes a spec object and a test object; returns true if the test satisfies
	 * the spec, false otherwise. An object satisfies the spec if, for each of the
	 * spec's own properties, accessing that property of the object gives the same
	 * value (in [`R.equals`](#equals) terms) as accessing that property of the
	 * spec.
	 *
	 * `whereEq` is a specialization of [`where`](#where).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category Object
	 * @sig {String: *} -> {String: *} -> Boolean
	 * @param {Object} spec
	 * @param {Object} testObj
	 * @return {Boolean}
	 * @see R.propEq, R.where
	 * @example
	 *
	 *      // pred :: Object -> Boolean
	 *      var pred = R.whereEq({a: 1, b: 2});
	 *
	 *      pred({a: 1});              //=> false
	 *      pred({a: 1, b: 2});        //=> true
	 *      pred({a: 1, b: 2, c: 3});  //=> true
	 *      pred({a: 1, b: 1});        //=> false
	 */

	var whereEq =
	/*#__PURE__*/
	_curry2(function whereEq(spec, testObj) {
	  return where(map$1(equals, spec), testObj);
	});

	/**
	 * Returns a new list without values in the first argument.
	 * [`R.equals`](#equals) is used to determine equality.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category List
	 * @sig [a] -> [a] -> [a]
	 * @param {Array} list1 The values to be removed from `list2`.
	 * @param {Array} list2 The array to remove values from.
	 * @return {Array} The new array without values in `list1`.
	 * @see R.transduce, R.difference
	 * @example
	 *
	 *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
	 */

	var without =
	/*#__PURE__*/
	_curry2(function (xs, list) {
	  return reject(flip(_contains)(xs), list);
	});

	/**
	 * Creates a new list out of the two supplied by creating each possible pair
	 * from the lists.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> [b] -> [[a,b]]
	 * @param {Array} as The first list.
	 * @param {Array} bs The second list.
	 * @return {Array} The list made by combining each possible pair from
	 *         `as` and `bs` into pairs (`[a, b]`).
	 * @example
	 *
	 *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
	 * @symb R.xprod([a, b], [c, d]) = [[a, c], [a, d], [b, c], [b, d]]
	 */

	var xprod =
	/*#__PURE__*/
	_curry2(function xprod(a, b) {
	  // = xprodWith(prepend); (takes about 3 times as long...)
	  var idx = 0;
	  var ilen = a.length;
	  var j;
	  var jlen = b.length;
	  var result = [];

	  while (idx < ilen) {
	    j = 0;

	    while (j < jlen) {
	      result[result.length] = [a[idx], b[j]];
	      j += 1;
	    }

	    idx += 1;
	  }

	  return result;
	});

	/**
	 * Creates a new list out of the two supplied by pairing up equally-positioned
	 * items from both lists. The returned list is truncated to the length of the
	 * shorter of the two input lists.
	 * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> [b] -> [[a,b]]
	 * @param {Array} list1 The first array to consider.
	 * @param {Array} list2 The second array to consider.
	 * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
	 * @example
	 *
	 *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
	 * @symb R.zip([a, b, c], [d, e, f]) = [[a, d], [b, e], [c, f]]
	 */

	var zip$2 =
	/*#__PURE__*/
	_curry2(function zip(a, b) {
	  var rv = [];
	  var idx = 0;
	  var len = Math.min(a.length, b.length);

	  while (idx < len) {
	    rv[idx] = [a[idx], b[idx]];
	    idx += 1;
	  }

	  return rv;
	});

	/**
	 * Creates a new object out of a list of keys and a list of values.
	 * Key/value pairing is truncated to the length of the shorter of the two lists.
	 * Note: `zipObj` is equivalent to `pipe(zip, fromPairs)`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category List
	 * @sig [String] -> [*] -> {String: *}
	 * @param {Array} keys The array that will be properties on the output object.
	 * @param {Array} values The list of values on the output object.
	 * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
	 * @example
	 *
	 *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
	 */

	var zipObj =
	/*#__PURE__*/
	_curry2(function zipObj(keys, values) {
	  var idx = 0;
	  var len = Math.min(keys.length, values.length);
	  var out = {};

	  while (idx < len) {
	    out[keys[idx]] = values[idx];
	    idx += 1;
	  }

	  return out;
	});

	/**
	 * Creates a new list out of the two supplied by applying the function to each
	 * equally-positioned pair in the lists. The returned list is truncated to the
	 * length of the shorter of the two input lists.
	 *
	 * @function
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig ((a, b) -> c) -> [a] -> [b] -> [c]
	 * @param {Function} fn The function used to combine the two elements into one value.
	 * @param {Array} list1 The first array to consider.
	 * @param {Array} list2 The second array to consider.
	 * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
	 *         using `fn`.
	 * @example
	 *
	 *      var f = (x, y) => {
	 *        // ...
	 *      };
	 *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
	 *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
	 * @symb R.zipWith(fn, [a, b, c], [d, e, f]) = [fn(a, d), fn(b, e), fn(c, f)]
	 */

	var zipWith =
	/*#__PURE__*/
	_curry3(function zipWith(fn, a, b) {
	  var rv = [];
	  var idx = 0;
	  var len = Math.min(a.length, b.length);

	  while (idx < len) {
	    rv[idx] = fn(a[idx], b[idx]);
	    idx += 1;
	  }

	  return rv;
	});



	var es = /*#__PURE__*/Object.freeze({
		F: F,
		T: T,
		__: __,
		add: add,
		addIndex: addIndex,
		adjust: adjust,
		all: all,
		allPass: allPass,
		always: always,
		and: and,
		any: any,
		anyPass: anyPass,
		ap: ap,
		aperture: aperture,
		append: append,
		apply: apply,
		applySpec: applySpec,
		applyTo: applyTo,
		ascend: ascend,
		assoc: assoc,
		assocPath: assocPath,
		binary: binary,
		bind: bind$1,
		both: both,
		call: call,
		chain: chain,
		clamp: clamp,
		clone: clone,
		comparator: comparator,
		complement: complement,
		compose: compose,
		composeK: composeK,
		composeP: composeP,
		concat: concat$2,
		cond: cond,
		construct: construct$1,
		constructN: constructN,
		contains: contains$1,
		converge: converge,
		countBy: countBy,
		curry: curry,
		curryN: curryN,
		dec: dec,
		defaultTo: defaultTo,
		descend: descend,
		difference: difference,
		differenceWith: differenceWith,
		dissoc: dissoc,
		dissocPath: dissocPath,
		divide: divide,
		drop: drop,
		dropLast: dropLast$1,
		dropLastWhile: dropLastWhile$1,
		dropRepeats: dropRepeats,
		dropRepeatsWith: dropRepeatsWith,
		dropWhile: dropWhile,
		either: either,
		empty: empty$3,
		endsWith: endsWith,
		eqBy: eqBy,
		eqProps: eqProps,
		equals: equals,
		evolve: evolve,
		filter: filter$1,
		find: find$1,
		findIndex: findIndex$1,
		findLast: findLast,
		findLastIndex: findLastIndex,
		flatten: flatten$1,
		flip: flip,
		forEach: forEach,
		forEachObjIndexed: forEachObjIndexed,
		fromPairs: fromPairs,
		groupBy: groupBy$1,
		groupWith: groupWith,
		gt: gt,
		gte: gte,
		has: has,
		hasIn: hasIn,
		head: head,
		identical: identical,
		identity: identity$1,
		ifElse: ifElse,
		inc: inc,
		indexBy: indexBy,
		indexOf: indexOf$1,
		init: init,
		innerJoin: innerJoin,
		insert: insert,
		insertAll: insertAll,
		intersection: intersection,
		intersperse: intersperse,
		into: into,
		invert: invert,
		invertObj: invertObj,
		invoker: invoker,
		is: is$1,
		isEmpty: isEmpty$1,
		isNil: isNil,
		join: join,
		juxt: juxt,
		keys: keys$2,
		keysIn: keysIn,
		last: last$1,
		lastIndexOf: lastIndexOf,
		length: length,
		lens: lens,
		lensIndex: lensIndex,
		lensPath: lensPath,
		lensProp: lensProp,
		lift: lift,
		liftN: liftN,
		lt: lt,
		lte: lte,
		map: map$1,
		mapAccum: mapAccum,
		mapAccumRight: mapAccumRight,
		mapObjIndexed: mapObjIndexed,
		match: match,
		mathMod: mathMod,
		max: max$3,
		maxBy: maxBy,
		mean: mean,
		median: median,
		memoize: memoize,
		memoizeWith: memoizeWith,
		merge: merge$3,
		mergeAll: mergeAll$1,
		mergeDeepLeft: mergeDeepLeft,
		mergeDeepRight: mergeDeepRight,
		mergeDeepWith: mergeDeepWith,
		mergeDeepWithKey: mergeDeepWithKey,
		mergeWith: mergeWith,
		mergeWithKey: mergeWithKey,
		min: min$4,
		minBy: minBy,
		modulo: modulo,
		multiply: multiply,
		nAry: nAry,
		negate: negate,
		none: none$1,
		not: not$1,
		nth: nth,
		nthArg: nthArg,
		o: o,
		objOf: objOf,
		of: of$1,
		omit: omit,
		once: once,
		or: or,
		over: over,
		pair: pair,
		partial: partial,
		partialRight: partialRight,
		partition: partition$2,
		path: path,
		pathEq: pathEq,
		pathOr: pathOr,
		pathSatisfies: pathSatisfies,
		pick: pick,
		pickAll: pickAll,
		pickBy: pickBy,
		pipe: pipe$1,
		pipeK: pipeK,
		pipeP: pipeP,
		pluck: pluck$1,
		prepend: prepend,
		product: product,
		project: project,
		prop: prop,
		propEq: propEq,
		propIs: propIs,
		propOr: propOr,
		propSatisfies: propSatisfies,
		props: props,
		range: range$1,
		reduce: reduce$1,
		reduceBy: reduceBy,
		reduceRight: reduceRight,
		reduceWhile: reduceWhile,
		reduced: reduced,
		reject: reject,
		remove: remove$1,
		repeat: repeat$1,
		replace: replace,
		reverse: reverse,
		scan: scan$1,
		sequence: sequence,
		set: set$1,
		slice: slice,
		sort: sort,
		sortBy: sortBy,
		sortWith: sortWith,
		split: split,
		splitAt: splitAt,
		splitEvery: splitEvery,
		splitWhen: splitWhen,
		startsWith: startsWith,
		subtract: subtract,
		sum: sum,
		symmetricDifference: symmetricDifference,
		symmetricDifferenceWith: symmetricDifferenceWith,
		tail: tail,
		take: take$1,
		takeLast: takeLast$1,
		takeLastWhile: takeLastWhile,
		takeWhile: takeWhile$1,
		tap: tap$1,
		test: test$1,
		times: times,
		toLower: toLower,
		toPairs: toPairs,
		toPairsIn: toPairsIn,
		toString: toString$4,
		toUpper: toUpper,
		transduce: transduce,
		transpose: transpose,
		traverse: traverse,
		trim: trim$1,
		tryCatch: tryCatch,
		type: type,
		unapply: unapply,
		unary: unary,
		uncurryN: uncurryN,
		unfold: unfold,
		union: union,
		unionWith: unionWith,
		uniq: uniq,
		uniqBy: uniqBy,
		uniqWith: uniqWith,
		unless: unless,
		unnest: unnest,
		until: until,
		update: update,
		useWith: useWith,
		values: values,
		valuesIn: valuesIn,
		view: view,
		when: when,
		where: where,
		whereEq: whereEq,
		without: without,
		xprod: xprod,
		zip: zip$2,
		zipObj: zipObj,
		zipWith: zipWith
	});

	// 19.1.2.12 Object.isFrozen(O)


	_objectSap('isFrozen', function ($isFrozen) {
	  return function isFrozen(it) {
	    return _isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

	var moment = createCommonjsModule(function (module, exports) {

	  (function (global, factory) {
	    module.exports = factory();
	  })(commonjsGlobal, function () {

	    var hookCallback;

	    function hooks() {
	      return hookCallback.apply(null, arguments);
	    } // This is done to register the method called with moment()
	    // without creating circular dependencies.


	    function setHookCallback(callback) {
	      hookCallback = callback;
	    }

	    function isArray(input) {
	      return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	    }

	    function isObject(input) {
	      // IE8 will treat undefined and null as object if it wasn't for
	      // input != null
	      return input != null && Object.prototype.toString.call(input) === '[object Object]';
	    }

	    function isObjectEmpty(obj) {
	      if (Object.getOwnPropertyNames) {
	        return Object.getOwnPropertyNames(obj).length === 0;
	      } else {
	        var k;

	        for (k in obj) {
	          if (obj.hasOwnProperty(k)) {
	            return false;
	          }
	        }

	        return true;
	      }
	    }

	    function isUndefined(input) {
	      return input === void 0;
	    }

	    function isNumber(input) {
	      return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
	    }

	    function isDate(input) {
	      return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	    }

	    function map(arr, fn) {
	      var res = [],
	          i;

	      for (i = 0; i < arr.length; ++i) {
	        res.push(fn(arr[i], i));
	      }

	      return res;
	    }

	    function hasOwnProp(a, b) {
	      return Object.prototype.hasOwnProperty.call(a, b);
	    }

	    function extend(a, b) {
	      for (var i in b) {
	        if (hasOwnProp(b, i)) {
	          a[i] = b[i];
	        }
	      }

	      if (hasOwnProp(b, 'toString')) {
	        a.toString = b.toString;
	      }

	      if (hasOwnProp(b, 'valueOf')) {
	        a.valueOf = b.valueOf;
	      }

	      return a;
	    }

	    function createUTC(input, format, locale, strict) {
	      return createLocalOrUTC(input, format, locale, strict, true).utc();
	    }

	    function defaultParsingFlags() {
	      // We need to deep clone this object.
	      return {
	        empty: false,
	        unusedTokens: [],
	        unusedInput: [],
	        overflow: -2,
	        charsLeftOver: 0,
	        nullInput: false,
	        invalidMonth: null,
	        invalidFormat: false,
	        userInvalidated: false,
	        iso: false,
	        parsedDateParts: [],
	        meridiem: null,
	        rfc2822: false,
	        weekdayMismatch: false
	      };
	    }

	    function getParsingFlags(m) {
	      if (m._pf == null) {
	        m._pf = defaultParsingFlags();
	      }

	      return m._pf;
	    }

	    var some;

	    if (Array.prototype.some) {
	      some = Array.prototype.some;
	    } else {
	      some = function some(fun) {
	        var t = Object(this);
	        var len = t.length >>> 0;

	        for (var i = 0; i < len; i++) {
	          if (i in t && fun.call(this, t[i], i, t)) {
	            return true;
	          }
	        }

	        return false;
	      };
	    }

	    function isValid(m) {
	      if (m._isValid == null) {
	        var flags = getParsingFlags(m);
	        var parsedParts = some.call(flags.parsedDateParts, function (i) {
	          return i != null;
	        });
	        var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

	        if (m._strict) {
	          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
	        }

	        if (Object.isFrozen == null || !Object.isFrozen(m)) {
	          m._isValid = isNowValid;
	        } else {
	          return isNowValid;
	        }
	      }

	      return m._isValid;
	    }

	    function createInvalid(flags) {
	      var m = createUTC(NaN);

	      if (flags != null) {
	        extend(getParsingFlags(m), flags);
	      } else {
	        getParsingFlags(m).userInvalidated = true;
	      }

	      return m;
	    } // Plugins that add properties should also add the key here (null value),
	    // so we can properly clone ourselves.


	    var momentProperties = hooks.momentProperties = [];

	    function copyConfig(to, from) {
	      var i, prop, val;

	      if (!isUndefined(from._isAMomentObject)) {
	        to._isAMomentObject = from._isAMomentObject;
	      }

	      if (!isUndefined(from._i)) {
	        to._i = from._i;
	      }

	      if (!isUndefined(from._f)) {
	        to._f = from._f;
	      }

	      if (!isUndefined(from._l)) {
	        to._l = from._l;
	      }

	      if (!isUndefined(from._strict)) {
	        to._strict = from._strict;
	      }

	      if (!isUndefined(from._tzm)) {
	        to._tzm = from._tzm;
	      }

	      if (!isUndefined(from._isUTC)) {
	        to._isUTC = from._isUTC;
	      }

	      if (!isUndefined(from._offset)) {
	        to._offset = from._offset;
	      }

	      if (!isUndefined(from._pf)) {
	        to._pf = getParsingFlags(from);
	      }

	      if (!isUndefined(from._locale)) {
	        to._locale = from._locale;
	      }

	      if (momentProperties.length > 0) {
	        for (i = 0; i < momentProperties.length; i++) {
	          prop = momentProperties[i];
	          val = from[prop];

	          if (!isUndefined(val)) {
	            to[prop] = val;
	          }
	        }
	      }

	      return to;
	    }

	    var updateInProgress = false; // Moment prototype object

	    function Moment(config) {
	      copyConfig(this, config);
	      this._d = new Date(config._d != null ? config._d.getTime() : NaN);

	      if (!this.isValid()) {
	        this._d = new Date(NaN);
	      } // Prevent infinite loop in case updateOffset creates new moment
	      // objects.


	      if (updateInProgress === false) {
	        updateInProgress = true;
	        hooks.updateOffset(this);
	        updateInProgress = false;
	      }
	    }

	    function isMoment(obj) {
	      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
	    }

	    function absFloor(number) {
	      if (number < 0) {
	        // -0 -> 0
	        return Math.ceil(number) || 0;
	      } else {
	        return Math.floor(number);
	      }
	    }

	    function toInt(argumentForCoercion) {
	      var coercedNumber = +argumentForCoercion,
	          value = 0;

	      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	        value = absFloor(coercedNumber);
	      }

	      return value;
	    } // compare two arrays, return the number of differences


	    function compareArrays(array1, array2, dontConvert) {
	      var len = Math.min(array1.length, array2.length),
	          lengthDiff = Math.abs(array1.length - array2.length),
	          diffs = 0,
	          i;

	      for (i = 0; i < len; i++) {
	        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
	          diffs++;
	        }
	      }

	      return diffs + lengthDiff;
	    }

	    function warn(msg) {
	      if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
	        console.warn('Deprecation warning: ' + msg);
	      }
	    }

	    function deprecate(msg, fn) {
	      var firstTime = true;
	      return extend(function () {
	        if (hooks.deprecationHandler != null) {
	          hooks.deprecationHandler(null, msg);
	        }

	        if (firstTime) {
	          var args = [];
	          var arg;

	          for (var i = 0; i < arguments.length; i++) {
	            arg = '';

	            if (_typeof(arguments[i]) === 'object') {
	              arg += '\n[' + i + '] ';

	              for (var key in arguments[0]) {
	                arg += key + ': ' + arguments[0][key] + ', ';
	              }

	              arg = arg.slice(0, -2); // Remove trailing comma and space
	            } else {
	              arg = arguments[i];
	            }

	            args.push(arg);
	          }

	          warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
	          firstTime = false;
	        }

	        return fn.apply(this, arguments);
	      }, fn);
	    }

	    var deprecations = {};

	    function deprecateSimple(name, msg) {
	      if (hooks.deprecationHandler != null) {
	        hooks.deprecationHandler(name, msg);
	      }

	      if (!deprecations[name]) {
	        warn(msg);
	        deprecations[name] = true;
	      }
	    }

	    hooks.suppressDeprecationWarnings = false;
	    hooks.deprecationHandler = null;

	    function isFunction(input) {
	      return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	    }

	    function set(config) {
	      var prop, i;

	      for (i in config) {
	        prop = config[i];

	        if (isFunction(prop)) {
	          this[i] = prop;
	        } else {
	          this['_' + i] = prop;
	        }
	      }

	      this._config = config; // Lenient ordinal parsing accepts just a number in addition to
	      // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
	      // TODO: Remove "ordinalParse" fallback in next major release.

	      this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
	    }

	    function mergeConfigs(parentConfig, childConfig) {
	      var res = extend({}, parentConfig),
	          prop;

	      for (prop in childConfig) {
	        if (hasOwnProp(childConfig, prop)) {
	          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	            res[prop] = {};
	            extend(res[prop], parentConfig[prop]);
	            extend(res[prop], childConfig[prop]);
	          } else if (childConfig[prop] != null) {
	            res[prop] = childConfig[prop];
	          } else {
	            delete res[prop];
	          }
	        }
	      }

	      for (prop in parentConfig) {
	        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
	          // make sure changes to properties don't modify parent config
	          res[prop] = extend({}, res[prop]);
	        }
	      }

	      return res;
	    }

	    function Locale(config) {
	      if (config != null) {
	        this.set(config);
	      }
	    }

	    var keys;

	    if (Object.keys) {
	      keys = Object.keys;
	    } else {
	      keys = function keys(obj) {
	        var i,
	            res = [];

	        for (i in obj) {
	          if (hasOwnProp(obj, i)) {
	            res.push(i);
	          }
	        }

	        return res;
	      };
	    }

	    var defaultCalendar = {
	      sameDay: '[Today at] LT',
	      nextDay: '[Tomorrow at] LT',
	      nextWeek: 'dddd [at] LT',
	      lastDay: '[Yesterday at] LT',
	      lastWeek: '[Last] dddd [at] LT',
	      sameElse: 'L'
	    };

	    function calendar(key, mom, now) {
	      var output = this._calendar[key] || this._calendar['sameElse'];
	      return isFunction(output) ? output.call(mom, now) : output;
	    }

	    var defaultLongDateFormat = {
	      LTS: 'h:mm:ss A',
	      LT: 'h:mm A',
	      L: 'MM/DD/YYYY',
	      LL: 'MMMM D, YYYY',
	      LLL: 'MMMM D, YYYY h:mm A',
	      LLLL: 'dddd, MMMM D, YYYY h:mm A'
	    };

	    function longDateFormat(key) {
	      var format = this._longDateFormat[key],
	          formatUpper = this._longDateFormat[key.toUpperCase()];

	      if (format || !formatUpper) {
	        return format;
	      }

	      this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	        return val.slice(1);
	      });
	      return this._longDateFormat[key];
	    }

	    var defaultInvalidDate = 'Invalid date';

	    function invalidDate() {
	      return this._invalidDate;
	    }

	    var defaultOrdinal = '%d';
	    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

	    function ordinal(number) {
	      return this._ordinal.replace('%d', number);
	    }

	    var defaultRelativeTime = {
	      future: 'in %s',
	      past: '%s ago',
	      s: 'a few seconds',
	      ss: '%d seconds',
	      m: 'a minute',
	      mm: '%d minutes',
	      h: 'an hour',
	      hh: '%d hours',
	      d: 'a day',
	      dd: '%d days',
	      M: 'a month',
	      MM: '%d months',
	      y: 'a year',
	      yy: '%d years'
	    };

	    function relativeTime(number, withoutSuffix, string, isFuture) {
	      var output = this._relativeTime[string];
	      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
	    }

	    function pastFuture(diff, output) {
	      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	      return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	    }

	    var aliases = {};

	    function addUnitAlias(unit, shorthand) {
	      var lowerCase = unit.toLowerCase();
	      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	    }

	    function normalizeUnits(units) {
	      return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	    }

	    function normalizeObjectUnits(inputObject) {
	      var normalizedInput = {},
	          normalizedProp,
	          prop;

	      for (prop in inputObject) {
	        if (hasOwnProp(inputObject, prop)) {
	          normalizedProp = normalizeUnits(prop);

	          if (normalizedProp) {
	            normalizedInput[normalizedProp] = inputObject[prop];
	          }
	        }
	      }

	      return normalizedInput;
	    }

	    var priorities = {};

	    function addUnitPriority(unit, priority) {
	      priorities[unit] = priority;
	    }

	    function getPrioritizedUnits(unitsObj) {
	      var units = [];

	      for (var u in unitsObj) {
	        units.push({
	          unit: u,
	          priority: priorities[u]
	        });
	      }

	      units.sort(function (a, b) {
	        return a.priority - b.priority;
	      });
	      return units;
	    }

	    function zeroFill(number, targetLength, forceSign) {
	      var absNumber = '' + Math.abs(number),
	          zerosToFill = targetLength - absNumber.length,
	          sign = number >= 0;
	      return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	    }

	    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
	    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
	    var formatFunctions = {};
	    var formatTokenFunctions = {}; // token:    'M'
	    // padded:   ['MM', 2]
	    // ordinal:  'Mo'
	    // callback: function () { this.month() + 1 }

	    function addFormatToken(token, padded, ordinal, callback) {
	      var func = callback;

	      if (typeof callback === 'string') {
	        func = function func() {
	          return this[callback]();
	        };
	      }

	      if (token) {
	        formatTokenFunctions[token] = func;
	      }

	      if (padded) {
	        formatTokenFunctions[padded[0]] = function () {
	          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	        };
	      }

	      if (ordinal) {
	        formatTokenFunctions[ordinal] = function () {
	          return this.localeData().ordinal(func.apply(this, arguments), token);
	        };
	      }
	    }

	    function removeFormattingTokens(input) {
	      if (input.match(/\[[\s\S]/)) {
	        return input.replace(/^\[|\]$/g, '');
	      }

	      return input.replace(/\\/g, '');
	    }

	    function makeFormatFunction(format) {
	      var array = format.match(formattingTokens),
	          i,
	          length;

	      for (i = 0, length = array.length; i < length; i++) {
	        if (formatTokenFunctions[array[i]]) {
	          array[i] = formatTokenFunctions[array[i]];
	        } else {
	          array[i] = removeFormattingTokens(array[i]);
	        }
	      }

	      return function (mom) {
	        var output = '',
	            i;

	        for (i = 0; i < length; i++) {
	          output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
	        }

	        return output;
	      };
	    } // format date using native date object


	    function formatMoment(m, format) {
	      if (!m.isValid()) {
	        return m.localeData().invalidDate();
	      }

	      format = expandFormat(format, m.localeData());
	      formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
	      return formatFunctions[format](m);
	    }

	    function expandFormat(format, locale) {
	      var i = 5;

	      function replaceLongDateFormatTokens(input) {
	        return locale.longDateFormat(input) || input;
	      }

	      localFormattingTokens.lastIndex = 0;

	      while (i >= 0 && localFormattingTokens.test(format)) {
	        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	        localFormattingTokens.lastIndex = 0;
	        i -= 1;
	      }

	      return format;
	    }

	    var match1 = /\d/; //       0 - 9

	    var match2 = /\d\d/; //      00 - 99

	    var match3 = /\d{3}/; //     000 - 999

	    var match4 = /\d{4}/; //    0000 - 9999

	    var match6 = /[+-]?\d{6}/; // -999999 - 999999

	    var match1to2 = /\d\d?/; //       0 - 99

	    var match3to4 = /\d\d\d\d?/; //     999 - 9999

	    var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999

	    var match1to3 = /\d{1,3}/; //       0 - 999

	    var match1to4 = /\d{1,4}/; //       0 - 9999

	    var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

	    var matchUnsigned = /\d+/; //       0 - inf

	    var matchSigned = /[+-]?\d+/; //    -inf - inf

	    var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

	    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

	    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
	    // any word (or two) characters or numbers including two/three word month in arabic.
	    // includes scottish gaelic two word and hyphenated months

	    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
	    var regexes = {};

	    function addRegexToken(token, regex, strictRegex) {
	      regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	        return isStrict && strictRegex ? strictRegex : regex;
	      };
	    }

	    function getParseRegexForToken(token, config) {
	      if (!hasOwnProp(regexes, token)) {
	        return new RegExp(unescapeFormat(token));
	      }

	      return regexes[token](config._strict, config._locale);
	    } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


	    function unescapeFormat(s) {
	      return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	        return p1 || p2 || p3 || p4;
	      }));
	    }

	    function regexEscape(s) {
	      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }

	    var tokens = {};

	    function addParseToken(token, callback) {
	      var i,
	          func = callback;

	      if (typeof token === 'string') {
	        token = [token];
	      }

	      if (isNumber(callback)) {
	        func = function func(input, array) {
	          array[callback] = toInt(input);
	        };
	      }

	      for (i = 0; i < token.length; i++) {
	        tokens[token[i]] = func;
	      }
	    }

	    function addWeekParseToken(token, callback) {
	      addParseToken(token, function (input, array, config, token) {
	        config._w = config._w || {};
	        callback(input, config._w, config, token);
	      });
	    }

	    function addTimeToArrayFromToken(token, input, config) {
	      if (input != null && hasOwnProp(tokens, token)) {
	        tokens[token](input, config._a, config, token);
	      }
	    }

	    var YEAR = 0;
	    var MONTH = 1;
	    var DATE = 2;
	    var HOUR = 3;
	    var MINUTE = 4;
	    var SECOND = 5;
	    var MILLISECOND = 6;
	    var WEEK = 7;
	    var WEEKDAY = 8; // FORMATTING

	    addFormatToken('Y', 0, 0, function () {
	      var y = this.year();
	      return y <= 9999 ? '' + y : '+' + y;
	    });
	    addFormatToken(0, ['YY', 2], 0, function () {
	      return this.year() % 100;
	    });
	    addFormatToken(0, ['YYYY', 4], 0, 'year');
	    addFormatToken(0, ['YYYYY', 5], 0, 'year');
	    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

	    addUnitAlias('year', 'y'); // PRIORITIES

	    addUnitPriority('year', 1); // PARSING

	    addRegexToken('Y', matchSigned);
	    addRegexToken('YY', match1to2, match2);
	    addRegexToken('YYYY', match1to4, match4);
	    addRegexToken('YYYYY', match1to6, match6);
	    addRegexToken('YYYYYY', match1to6, match6);
	    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	    addParseToken('YYYY', function (input, array) {
	      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
	    });
	    addParseToken('YY', function (input, array) {
	      array[YEAR] = hooks.parseTwoDigitYear(input);
	    });
	    addParseToken('Y', function (input, array) {
	      array[YEAR] = parseInt(input, 10);
	    }); // HELPERS

	    function daysInYear(year) {
	      return isLeapYear(year) ? 366 : 365;
	    }

	    function isLeapYear(year) {
	      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
	    } // HOOKS


	    hooks.parseTwoDigitYear = function (input) {
	      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    }; // MOMENTS


	    var getSetYear = makeGetSet('FullYear', true);

	    function getIsLeapYear() {
	      return isLeapYear(this.year());
	    }

	    function makeGetSet(unit, keepTime) {
	      return function (value) {
	        if (value != null) {
	          set$1(this, unit, value);
	          hooks.updateOffset(this, keepTime);
	          return this;
	        } else {
	          return get(this, unit);
	        }
	      };
	    }

	    function get(mom, unit) {
	      return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	    }

	    function set$1(mom, unit, value) {
	      if (mom.isValid() && !isNaN(value)) {
	        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
	          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
	        } else {
	          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	        }
	      }
	    } // MOMENTS


	    function stringGet(units) {
	      units = normalizeUnits(units);

	      if (isFunction(this[units])) {
	        return this[units]();
	      }

	      return this;
	    }

	    function stringSet(units, value) {
	      if (_typeof(units) === 'object') {
	        units = normalizeObjectUnits(units);
	        var prioritized = getPrioritizedUnits(units);

	        for (var i = 0; i < prioritized.length; i++) {
	          this[prioritized[i].unit](units[prioritized[i].unit]);
	        }
	      } else {
	        units = normalizeUnits(units);

	        if (isFunction(this[units])) {
	          return this[units](value);
	        }
	      }

	      return this;
	    }

	    function mod(n, x) {
	      return (n % x + x) % x;
	    }

	    var indexOf;

	    if (Array.prototype.indexOf) {
	      indexOf = Array.prototype.indexOf;
	    } else {
	      indexOf = function indexOf(o) {
	        // I know
	        var i;

	        for (i = 0; i < this.length; ++i) {
	          if (this[i] === o) {
	            return i;
	          }
	        }

	        return -1;
	      };
	    }

	    function daysInMonth(year, month) {
	      if (isNaN(year) || isNaN(month)) {
	        return NaN;
	      }

	      var modMonth = mod(month, 12);
	      year += (month - modMonth) / 12;
	      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
	    } // FORMATTING


	    addFormatToken('M', ['MM', 2], 'Mo', function () {
	      return this.month() + 1;
	    });
	    addFormatToken('MMM', 0, 0, function (format) {
	      return this.localeData().monthsShort(this, format);
	    });
	    addFormatToken('MMMM', 0, 0, function (format) {
	      return this.localeData().months(this, format);
	    }); // ALIASES

	    addUnitAlias('month', 'M'); // PRIORITY

	    addUnitPriority('month', 8); // PARSING

	    addRegexToken('M', match1to2);
	    addRegexToken('MM', match1to2, match2);
	    addRegexToken('MMM', function (isStrict, locale) {
	      return locale.monthsShortRegex(isStrict);
	    });
	    addRegexToken('MMMM', function (isStrict, locale) {
	      return locale.monthsRegex(isStrict);
	    });
	    addParseToken(['M', 'MM'], function (input, array) {
	      array[MONTH] = toInt(input) - 1;
	    });
	    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	      var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


	      if (month != null) {
	        array[MONTH] = month;
	      } else {
	        getParsingFlags(config).invalidMonth = input;
	      }
	    }); // LOCALES

	    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
	    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

	    function localeMonths(m, format) {
	      if (!m) {
	        return isArray(this._months) ? this._months : this._months['standalone'];
	      }

	      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
	    }

	    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

	    function localeMonthsShort(m, format) {
	      if (!m) {
	        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
	      }

	      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	    }

	    function handleStrictParse(monthName, format, strict) {
	      var i,
	          ii,
	          mom,
	          llc = monthName.toLocaleLowerCase();

	      if (!this._monthsParse) {
	        // this is not used
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];

	        for (i = 0; i < 12; ++i) {
	          mom = createUTC([2000, i]);
	          this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
	          this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
	        }
	      }

	      if (strict) {
	        if (format === 'MMM') {
	          ii = indexOf.call(this._shortMonthsParse, llc);
	          return ii !== -1 ? ii : null;
	        } else {
	          ii = indexOf.call(this._longMonthsParse, llc);
	          return ii !== -1 ? ii : null;
	        }
	      } else {
	        if (format === 'MMM') {
	          ii = indexOf.call(this._shortMonthsParse, llc);

	          if (ii !== -1) {
	            return ii;
	          }

	          ii = indexOf.call(this._longMonthsParse, llc);
	          return ii !== -1 ? ii : null;
	        } else {
	          ii = indexOf.call(this._longMonthsParse, llc);

	          if (ii !== -1) {
	            return ii;
	          }

	          ii = indexOf.call(this._shortMonthsParse, llc);
	          return ii !== -1 ? ii : null;
	        }
	      }
	    }

	    function localeMonthsParse(monthName, format, strict) {
	      var i, mom, regex;

	      if (this._monthsParseExact) {
	        return handleStrictParse.call(this, monthName, format, strict);
	      }

	      if (!this._monthsParse) {
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];
	      } // TODO: add sorting
	      // Sorting makes sure if one month (or abbr) is a prefix of another
	      // see sorting in computeMonthsParse


	      for (i = 0; i < 12; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, i]);

	        if (strict && !this._longMonthsParse[i]) {
	          this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	          this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	        }

	        if (!strict && !this._monthsParse[i]) {
	          regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	          this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	        } // test the regex


	        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	          return i;
	        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	          return i;
	        } else if (!strict && this._monthsParse[i].test(monthName)) {
	          return i;
	        }
	      }
	    } // MOMENTS


	    function setMonth(mom, value) {
	      var dayOfMonth;

	      if (!mom.isValid()) {
	        // No op
	        return mom;
	      }

	      if (typeof value === 'string') {
	        if (/^\d+$/.test(value)) {
	          value = toInt(value);
	        } else {
	          value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

	          if (!isNumber(value)) {
	            return mom;
	          }
	        }
	      }

	      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

	      mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

	      return mom;
	    }

	    function getSetMonth(value) {
	      if (value != null) {
	        setMonth(this, value);
	        hooks.updateOffset(this, true);
	        return this;
	      } else {
	        return get(this, 'Month');
	      }
	    }

	    function getDaysInMonth() {
	      return daysInMonth(this.year(), this.month());
	    }

	    var defaultMonthsShortRegex = matchWord;

	    function monthsShortRegex(isStrict) {
	      if (this._monthsParseExact) {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	          computeMonthsParse.call(this);
	        }

	        if (isStrict) {
	          return this._monthsShortStrictRegex;
	        } else {
	          return this._monthsShortRegex;
	        }
	      } else {
	        if (!hasOwnProp(this, '_monthsShortRegex')) {
	          this._monthsShortRegex = defaultMonthsShortRegex;
	        }

	        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
	      }
	    }

	    var defaultMonthsRegex = matchWord;

	    function monthsRegex(isStrict) {
	      if (this._monthsParseExact) {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	          computeMonthsParse.call(this);
	        }

	        if (isStrict) {
	          return this._monthsStrictRegex;
	        } else {
	          return this._monthsRegex;
	        }
	      } else {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	          this._monthsRegex = defaultMonthsRegex;
	        }

	        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
	      }
	    }

	    function computeMonthsParse() {
	      function cmpLenRev(a, b) {
	        return b.length - a.length;
	      }

	      var shortPieces = [],
	          longPieces = [],
	          mixedPieces = [],
	          i,
	          mom;

	      for (i = 0; i < 12; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, i]);
	        shortPieces.push(this.monthsShort(mom, ''));
	        longPieces.push(this.months(mom, ''));
	        mixedPieces.push(this.months(mom, ''));
	        mixedPieces.push(this.monthsShort(mom, ''));
	      } // Sorting makes sure if one month (or abbr) is a prefix of another it
	      // will match the longer piece.


	      shortPieces.sort(cmpLenRev);
	      longPieces.sort(cmpLenRev);
	      mixedPieces.sort(cmpLenRev);

	      for (i = 0; i < 12; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	      }

	      for (i = 0; i < 24; i++) {
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	      }

	      this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	      this._monthsShortRegex = this._monthsRegex;
	      this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	      this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	    }

	    function createDate(y, m, d, h, M, s, ms) {
	      // can't just apply() to create a date:
	      // https://stackoverflow.com/q/181348
	      var date; // the date constructor remaps years 0-99 to 1900-1999

	      if (y < 100 && y >= 0) {
	        // preserve leap years using a full 400 year cycle, then reset
	        date = new Date(y + 400, m, d, h, M, s, ms);

	        if (isFinite(date.getFullYear())) {
	          date.setFullYear(y);
	        }
	      } else {
	        date = new Date(y, m, d, h, M, s, ms);
	      }

	      return date;
	    }

	    function createUTCDate(y) {
	      var date; // the Date.UTC function remaps years 0-99 to 1900-1999

	      if (y < 100 && y >= 0) {
	        var args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset

	        args[0] = y + 400;
	        date = new Date(Date.UTC.apply(null, args));

	        if (isFinite(date.getUTCFullYear())) {
	          date.setUTCFullYear(y);
	        }
	      } else {
	        date = new Date(Date.UTC.apply(null, arguments));
	      }

	      return date;
	    } // start-of-first-week - start-of-year


	    function firstWeekOffset(year, dow, doy) {
	      var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	      fwd = 7 + dow - doy,
	          // first-week day local weekday -- which local weekday is fwd
	      fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
	      return -fwdlw + fwd - 1;
	    } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


	    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	      var localWeekday = (7 + weekday - dow) % 7,
	          weekOffset = firstWeekOffset(year, dow, doy),
	          dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	          resYear,
	          resDayOfYear;

	      if (dayOfYear <= 0) {
	        resYear = year - 1;
	        resDayOfYear = daysInYear(resYear) + dayOfYear;
	      } else if (dayOfYear > daysInYear(year)) {
	        resYear = year + 1;
	        resDayOfYear = dayOfYear - daysInYear(year);
	      } else {
	        resYear = year;
	        resDayOfYear = dayOfYear;
	      }

	      return {
	        year: resYear,
	        dayOfYear: resDayOfYear
	      };
	    }

	    function weekOfYear(mom, dow, doy) {
	      var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	          week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	          resWeek,
	          resYear;

	      if (week < 1) {
	        resYear = mom.year() - 1;
	        resWeek = week + weeksInYear(resYear, dow, doy);
	      } else if (week > weeksInYear(mom.year(), dow, doy)) {
	        resWeek = week - weeksInYear(mom.year(), dow, doy);
	        resYear = mom.year() + 1;
	      } else {
	        resYear = mom.year();
	        resWeek = week;
	      }

	      return {
	        week: resWeek,
	        year: resYear
	      };
	    }

	    function weeksInYear(year, dow, doy) {
	      var weekOffset = firstWeekOffset(year, dow, doy),
	          weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	    } // FORMATTING


	    addFormatToken('w', ['ww', 2], 'wo', 'week');
	    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

	    addUnitAlias('week', 'w');
	    addUnitAlias('isoWeek', 'W'); // PRIORITIES

	    addUnitPriority('week', 5);
	    addUnitPriority('isoWeek', 5); // PARSING

	    addRegexToken('w', match1to2);
	    addRegexToken('ww', match1to2, match2);
	    addRegexToken('W', match1to2);
	    addRegexToken('WW', match1to2, match2);
	    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	      week[token.substr(0, 1)] = toInt(input);
	    }); // HELPERS
	    // LOCALES

	    function localeWeek(mom) {
	      return weekOfYear(mom, this._week.dow, this._week.doy).week;
	    }

	    var defaultLocaleWeek = {
	      dow: 0,
	      // Sunday is the first day of the week.
	      doy: 6 // The week that contains Jan 6th is the first week of the year.

	    };

	    function localeFirstDayOfWeek() {
	      return this._week.dow;
	    }

	    function localeFirstDayOfYear() {
	      return this._week.doy;
	    } // MOMENTS


	    function getSetWeek(input) {
	      var week = this.localeData().week(this);
	      return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    function getSetISOWeek(input) {
	      var week = weekOfYear(this, 1, 4).week;
	      return input == null ? week : this.add((input - week) * 7, 'd');
	    } // FORMATTING


	    addFormatToken('d', 0, 'do', 'day');
	    addFormatToken('dd', 0, 0, function (format) {
	      return this.localeData().weekdaysMin(this, format);
	    });
	    addFormatToken('ddd', 0, 0, function (format) {
	      return this.localeData().weekdaysShort(this, format);
	    });
	    addFormatToken('dddd', 0, 0, function (format) {
	      return this.localeData().weekdays(this, format);
	    });
	    addFormatToken('e', 0, 0, 'weekday');
	    addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

	    addUnitAlias('day', 'd');
	    addUnitAlias('weekday', 'e');
	    addUnitAlias('isoWeekday', 'E'); // PRIORITY

	    addUnitPriority('day', 11);
	    addUnitPriority('weekday', 11);
	    addUnitPriority('isoWeekday', 11); // PARSING

	    addRegexToken('d', match1to2);
	    addRegexToken('e', match1to2);
	    addRegexToken('E', match1to2);
	    addRegexToken('dd', function (isStrict, locale) {
	      return locale.weekdaysMinRegex(isStrict);
	    });
	    addRegexToken('ddd', function (isStrict, locale) {
	      return locale.weekdaysShortRegex(isStrict);
	    });
	    addRegexToken('dddd', function (isStrict, locale) {
	      return locale.weekdaysRegex(isStrict);
	    });
	    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	      var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


	      if (weekday != null) {
	        week.d = weekday;
	      } else {
	        getParsingFlags(config).invalidWeekday = input;
	      }
	    });
	    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	      week[token] = toInt(input);
	    }); // HELPERS

	    function parseWeekday(input, locale) {
	      if (typeof input !== 'string') {
	        return input;
	      }

	      if (!isNaN(input)) {
	        return parseInt(input, 10);
	      }

	      input = locale.weekdaysParse(input);

	      if (typeof input === 'number') {
	        return input;
	      }

	      return null;
	    }

	    function parseIsoWeekday(input, locale) {
	      if (typeof input === 'string') {
	        return locale.weekdaysParse(input) % 7 || 7;
	      }

	      return isNaN(input) ? null : input;
	    } // LOCALES


	    function shiftWeekdays(ws, n) {
	      return ws.slice(n, 7).concat(ws.slice(0, n));
	    }

	    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

	    function localeWeekdays(m, format) {
	      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
	      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
	    }

	    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

	    function localeWeekdaysShort(m) {
	      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
	    }

	    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

	    function localeWeekdaysMin(m) {
	      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
	    }

	    function handleStrictParse$1(weekdayName, format, strict) {
	      var i,
	          ii,
	          mom,
	          llc = weekdayName.toLocaleLowerCase();

	      if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._minWeekdaysParse = [];

	        for (i = 0; i < 7; ++i) {
	          mom = createUTC([2000, 1]).day(i);
	          this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
	          this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
	          this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
	        }
	      }

	      if (strict) {
	        if (format === 'dddd') {
	          ii = indexOf.call(this._weekdaysParse, llc);
	          return ii !== -1 ? ii : null;
	        } else if (format === 'ddd') {
	          ii = indexOf.call(this._shortWeekdaysParse, llc);
	          return ii !== -1 ? ii : null;
	        } else {
	          ii = indexOf.call(this._minWeekdaysParse, llc);
	          return ii !== -1 ? ii : null;
	        }
	      } else {
	        if (format === 'dddd') {
	          ii = indexOf.call(this._weekdaysParse, llc);

	          if (ii !== -1) {
	            return ii;
	          }

	          ii = indexOf.call(this._shortWeekdaysParse, llc);

	          if (ii !== -1) {
	            return ii;
	          }

	          ii = indexOf.call(this._minWeekdaysParse, llc);
	          return ii !== -1 ? ii : null;
	        } else if (format === 'ddd') {
	          ii = indexOf.call(this._shortWeekdaysParse, llc);

	          if (ii !== -1) {
	            return ii;
	          }

	          ii = indexOf.call(this._weekdaysParse, llc);

	          if (ii !== -1) {
	            return ii;
	          }

	          ii = indexOf.call(this._minWeekdaysParse, llc);
	          return ii !== -1 ? ii : null;
	        } else {
	          ii = indexOf.call(this._minWeekdaysParse, llc);

	          if (ii !== -1) {
	            return ii;
	          }

	          ii = indexOf.call(this._weekdaysParse, llc);

	          if (ii !== -1) {
	            return ii;
	          }

	          ii = indexOf.call(this._shortWeekdaysParse, llc);
	          return ii !== -1 ? ii : null;
	        }
	      }
	    }

	    function localeWeekdaysParse(weekdayName, format, strict) {
	      var i, mom, regex;

	      if (this._weekdaysParseExact) {
	        return handleStrictParse$1.call(this, weekdayName, format, strict);
	      }

	      if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._minWeekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._fullWeekdaysParse = [];
	      }

	      for (i = 0; i < 7; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, 1]).day(i);

	        if (strict && !this._fullWeekdaysParse[i]) {
	          this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
	          this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
	          this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
	        }

	        if (!this._weekdaysParse[i]) {
	          regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	          this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	        } // test the regex


	        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
	          return i;
	        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
	          return i;
	        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
	          return i;
	        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	          return i;
	        }
	      }
	    } // MOMENTS


	    function getSetDayOfWeek(input) {
	      if (!this.isValid()) {
	        return input != null ? this : NaN;
	      }

	      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

	      if (input != null) {
	        input = parseWeekday(input, this.localeData());
	        return this.add(input - day, 'd');
	      } else {
	        return day;
	      }
	    }

	    function getSetLocaleDayOfWeek(input) {
	      if (!this.isValid()) {
	        return input != null ? this : NaN;
	      }

	      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	      return input == null ? weekday : this.add(input - weekday, 'd');
	    }

	    function getSetISODayOfWeek(input) {
	      if (!this.isValid()) {
	        return input != null ? this : NaN;
	      } // behaves the same as moment#day except
	      // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	      // as a setter, sunday should belong to the previous week.


	      if (input != null) {
	        var weekday = parseIsoWeekday(input, this.localeData());
	        return this.day(this.day() % 7 ? weekday : weekday - 7);
	      } else {
	        return this.day() || 7;
	      }
	    }

	    var defaultWeekdaysRegex = matchWord;

	    function weekdaysRegex(isStrict) {
	      if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	          computeWeekdaysParse.call(this);
	        }

	        if (isStrict) {
	          return this._weekdaysStrictRegex;
	        } else {
	          return this._weekdaysRegex;
	        }
	      } else {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	          this._weekdaysRegex = defaultWeekdaysRegex;
	        }

	        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
	      }
	    }

	    var defaultWeekdaysShortRegex = matchWord;

	    function weekdaysShortRegex(isStrict) {
	      if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	          computeWeekdaysParse.call(this);
	        }

	        if (isStrict) {
	          return this._weekdaysShortStrictRegex;
	        } else {
	          return this._weekdaysShortRegex;
	        }
	      } else {
	        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
	          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
	        }

	        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
	      }
	    }

	    var defaultWeekdaysMinRegex = matchWord;

	    function weekdaysMinRegex(isStrict) {
	      if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	          computeWeekdaysParse.call(this);
	        }

	        if (isStrict) {
	          return this._weekdaysMinStrictRegex;
	        } else {
	          return this._weekdaysMinRegex;
	        }
	      } else {
	        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
	          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
	        }

	        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
	      }
	    }

	    function computeWeekdaysParse() {
	      function cmpLenRev(a, b) {
	        return b.length - a.length;
	      }

	      var minPieces = [],
	          shortPieces = [],
	          longPieces = [],
	          mixedPieces = [],
	          i,
	          mom,
	          minp,
	          shortp,
	          longp;

	      for (i = 0; i < 7; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, 1]).day(i);
	        minp = this.weekdaysMin(mom, '');
	        shortp = this.weekdaysShort(mom, '');
	        longp = this.weekdays(mom, '');
	        minPieces.push(minp);
	        shortPieces.push(shortp);
	        longPieces.push(longp);
	        mixedPieces.push(minp);
	        mixedPieces.push(shortp);
	        mixedPieces.push(longp);
	      } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	      // will match the longer piece.


	      minPieces.sort(cmpLenRev);
	      shortPieces.sort(cmpLenRev);
	      longPieces.sort(cmpLenRev);
	      mixedPieces.sort(cmpLenRev);

	      for (i = 0; i < 7; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	      }

	      this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	      this._weekdaysShortRegex = this._weekdaysRegex;
	      this._weekdaysMinRegex = this._weekdaysRegex;
	      this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	      this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	      this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
	    } // FORMATTING


	    function hFormat() {
	      return this.hours() % 12 || 12;
	    }

	    function kFormat() {
	      return this.hours() || 24;
	    }

	    addFormatToken('H', ['HH', 2], 0, 'hour');
	    addFormatToken('h', ['hh', 2], 0, hFormat);
	    addFormatToken('k', ['kk', 2], 0, kFormat);
	    addFormatToken('hmm', 0, 0, function () {
	      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	    });
	    addFormatToken('hmmss', 0, 0, function () {
	      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
	    });
	    addFormatToken('Hmm', 0, 0, function () {
	      return '' + this.hours() + zeroFill(this.minutes(), 2);
	    });
	    addFormatToken('Hmmss', 0, 0, function () {
	      return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
	    });

	    function meridiem(token, lowercase) {
	      addFormatToken(token, 0, 0, function () {
	        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	      });
	    }

	    meridiem('a', true);
	    meridiem('A', false); // ALIASES

	    addUnitAlias('hour', 'h'); // PRIORITY

	    addUnitPriority('hour', 13); // PARSING

	    function matchMeridiem(isStrict, locale) {
	      return locale._meridiemParse;
	    }

	    addRegexToken('a', matchMeridiem);
	    addRegexToken('A', matchMeridiem);
	    addRegexToken('H', match1to2);
	    addRegexToken('h', match1to2);
	    addRegexToken('k', match1to2);
	    addRegexToken('HH', match1to2, match2);
	    addRegexToken('hh', match1to2, match2);
	    addRegexToken('kk', match1to2, match2);
	    addRegexToken('hmm', match3to4);
	    addRegexToken('hmmss', match5to6);
	    addRegexToken('Hmm', match3to4);
	    addRegexToken('Hmmss', match5to6);
	    addParseToken(['H', 'HH'], HOUR);
	    addParseToken(['k', 'kk'], function (input, array, config) {
	      var kInput = toInt(input);
	      array[HOUR] = kInput === 24 ? 0 : kInput;
	    });
	    addParseToken(['a', 'A'], function (input, array, config) {
	      config._isPm = config._locale.isPM(input);
	      config._meridiem = input;
	    });
	    addParseToken(['h', 'hh'], function (input, array, config) {
	      array[HOUR] = toInt(input);
	      getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmm', function (input, array, config) {
	      var pos = input.length - 2;
	      array[HOUR] = toInt(input.substr(0, pos));
	      array[MINUTE] = toInt(input.substr(pos));
	      getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmmss', function (input, array, config) {
	      var pos1 = input.length - 4;
	      var pos2 = input.length - 2;
	      array[HOUR] = toInt(input.substr(0, pos1));
	      array[MINUTE] = toInt(input.substr(pos1, 2));
	      array[SECOND] = toInt(input.substr(pos2));
	      getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('Hmm', function (input, array, config) {
	      var pos = input.length - 2;
	      array[HOUR] = toInt(input.substr(0, pos));
	      array[MINUTE] = toInt(input.substr(pos));
	    });
	    addParseToken('Hmmss', function (input, array, config) {
	      var pos1 = input.length - 4;
	      var pos2 = input.length - 2;
	      array[HOUR] = toInt(input.substr(0, pos1));
	      array[MINUTE] = toInt(input.substr(pos1, 2));
	      array[SECOND] = toInt(input.substr(pos2));
	    }); // LOCALES

	    function localeIsPM(input) {
	      // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	      // Using charAt should be more compatible.
	      return (input + '').toLowerCase().charAt(0) === 'p';
	    }

	    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

	    function localeMeridiem(hours, minutes, isLower) {
	      if (hours > 11) {
	        return isLower ? 'pm' : 'PM';
	      } else {
	        return isLower ? 'am' : 'AM';
	      }
	    } // MOMENTS
	    // Setting the hour should keep the time, because the user explicitly
	    // specified which hour they want. So trying to maintain the same hour (in
	    // a new timezone) makes sense. Adding/subtracting hours does not follow
	    // this rule.


	    var getSetHour = makeGetSet('Hours', true);
	    var baseConfig = {
	      calendar: defaultCalendar,
	      longDateFormat: defaultLongDateFormat,
	      invalidDate: defaultInvalidDate,
	      ordinal: defaultOrdinal,
	      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
	      relativeTime: defaultRelativeTime,
	      months: defaultLocaleMonths,
	      monthsShort: defaultLocaleMonthsShort,
	      week: defaultLocaleWeek,
	      weekdays: defaultLocaleWeekdays,
	      weekdaysMin: defaultLocaleWeekdaysMin,
	      weekdaysShort: defaultLocaleWeekdaysShort,
	      meridiemParse: defaultLocaleMeridiemParse
	    }; // internal storage for locale config files

	    var locales = {};
	    var localeFamilies = {};
	    var globalLocale;

	    function normalizeLocale(key) {
	      return key ? key.toLowerCase().replace('_', '-') : key;
	    } // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


	    function chooseLocale(names) {
	      var i = 0,
	          j,
	          next,
	          locale,
	          split;

	      while (i < names.length) {
	        split = normalizeLocale(names[i]).split('-');
	        j = split.length;
	        next = normalizeLocale(names[i + 1]);
	        next = next ? next.split('-') : null;

	        while (j > 0) {
	          locale = loadLocale(split.slice(0, j).join('-'));

	          if (locale) {
	            return locale;
	          }

	          if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	            //the next array item is better than a shallower substring of this one
	            break;
	          }

	          j--;
	        }

	        i++;
	      }

	      return globalLocale;
	    }

	    function loadLocale(name) {
	      var oldLocale = null; // TODO: Find a better way to register and load all the locales in Node

	      if (!locales[name] && 'object' !== 'undefined' && module && module.exports) {
	        try {
	          oldLocale = globalLocale._abbr;
	          var aliasedRequire = commonjsRequire;
	          aliasedRequire('./locale/' + name);
	          getSetGlobalLocale(oldLocale);
	        } catch (e) {}
	      }

	      return locales[name];
	    } // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.


	    function getSetGlobalLocale(key, values) {
	      var data;

	      if (key) {
	        if (isUndefined(values)) {
	          data = getLocale(key);
	        } else {
	          data = defineLocale(key, values);
	        }

	        if (data) {
	          // moment.duration._locale = moment._locale = data;
	          globalLocale = data;
	        } else {
	          if (typeof console !== 'undefined' && console.warn) {
	            //warn user if arguments are passed but the locale could not be set
	            console.warn('Locale ' + key + ' not found. Did you forget to load it?');
	          }
	        }
	      }

	      return globalLocale._abbr;
	    }

	    function defineLocale(name, config) {
	      if (config !== null) {
	        var locale,
	            parentConfig = baseConfig;
	        config.abbr = name;

	        if (locales[name] != null) {
	          deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
	          parentConfig = locales[name]._config;
	        } else if (config.parentLocale != null) {
	          if (locales[config.parentLocale] != null) {
	            parentConfig = locales[config.parentLocale]._config;
	          } else {
	            locale = loadLocale(config.parentLocale);

	            if (locale != null) {
	              parentConfig = locale._config;
	            } else {
	              if (!localeFamilies[config.parentLocale]) {
	                localeFamilies[config.parentLocale] = [];
	              }

	              localeFamilies[config.parentLocale].push({
	                name: name,
	                config: config
	              });
	              return null;
	            }
	          }
	        }

	        locales[name] = new Locale(mergeConfigs(parentConfig, config));

	        if (localeFamilies[name]) {
	          localeFamilies[name].forEach(function (x) {
	            defineLocale(x.name, x.config);
	          });
	        } // backwards compat for now: also set the locale
	        // make sure we set the locale AFTER all child locales have been
	        // created, so we won't end up with the child locale set.


	        getSetGlobalLocale(name);
	        return locales[name];
	      } else {
	        // useful for testing
	        delete locales[name];
	        return null;
	      }
	    }

	    function updateLocale(name, config) {
	      if (config != null) {
	        var locale,
	            tmpLocale,
	            parentConfig = baseConfig; // MERGE

	        tmpLocale = loadLocale(name);

	        if (tmpLocale != null) {
	          parentConfig = tmpLocale._config;
	        }

	        config = mergeConfigs(parentConfig, config);
	        locale = new Locale(config);
	        locale.parentLocale = locales[name];
	        locales[name] = locale; // backwards compat for now: also set the locale

	        getSetGlobalLocale(name);
	      } else {
	        // pass null for config to unupdate, useful for tests
	        if (locales[name] != null) {
	          if (locales[name].parentLocale != null) {
	            locales[name] = locales[name].parentLocale;
	          } else if (locales[name] != null) {
	            delete locales[name];
	          }
	        }
	      }

	      return locales[name];
	    } // returns locale data


	    function getLocale(key) {
	      var locale;

	      if (key && key._locale && key._locale._abbr) {
	        key = key._locale._abbr;
	      }

	      if (!key) {
	        return globalLocale;
	      }

	      if (!isArray(key)) {
	        //short-circuit everything else
	        locale = loadLocale(key);

	        if (locale) {
	          return locale;
	        }

	        key = [key];
	      }

	      return chooseLocale(key);
	    }

	    function listLocales() {
	      return keys(locales);
	    }

	    function checkOverflow(m) {
	      var overflow;
	      var a = m._a;

	      if (a && getParsingFlags(m).overflow === -2) {
	        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

	        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	          overflow = DATE;
	        }

	        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	          overflow = WEEK;
	        }

	        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	          overflow = WEEKDAY;
	        }

	        getParsingFlags(m).overflow = overflow;
	      }

	      return m;
	    } // Pick the first defined of two or three arguments.


	    function defaults(a, b, c) {
	      if (a != null) {
	        return a;
	      }

	      if (b != null) {
	        return b;
	      }

	      return c;
	    }

	    function currentDateArray(config) {
	      // hooks is actually the exported moment object
	      var nowValue = new Date(hooks.now());

	      if (config._useUTC) {
	        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	      }

	      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	    } // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]


	    function configFromArray(config) {
	      var i,
	          date,
	          input = [],
	          currentDate,
	          expectedWeekday,
	          yearToUse;

	      if (config._d) {
	        return;
	      }

	      currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

	      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	        dayOfYearFromWeekInfo(config);
	      } //if the day of the year is set, figure out what it is


	      if (config._dayOfYear != null) {
	        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

	        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
	          getParsingFlags(config)._overflowDayOfYear = true;
	        }

	        date = createUTCDate(yearToUse, 0, config._dayOfYear);
	        config._a[MONTH] = date.getUTCMonth();
	        config._a[DATE] = date.getUTCDate();
	      } // Default to current date.
	      // * if no year, month, day of month are given, default to today
	      // * if day of month is given, default month and year
	      // * if month is given, default only year
	      // * if year is given, don't default anything


	      for (i = 0; i < 3 && config._a[i] == null; ++i) {
	        config._a[i] = input[i] = currentDate[i];
	      } // Zero out whatever was not defaulted, including time


	      for (; i < 7; i++) {
	        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
	      } // Check for 24:00:00.000


	      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
	        config._nextDay = true;
	        config._a[HOUR] = 0;
	      }

	      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
	      // with parseZone.

	      if (config._tzm != null) {
	        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	      }

	      if (config._nextDay) {
	        config._a[HOUR] = 24;
	      } // check for mismatching day of week


	      if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
	        getParsingFlags(config).weekdayMismatch = true;
	      }
	    }

	    function dayOfYearFromWeekInfo(config) {
	      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
	      w = config._w;

	      if (w.GG != null || w.W != null || w.E != null) {
	        dow = 1;
	        doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
	        // how we interpret now (local, utc, fixed offset). So create
	        // a now version of current config (take local/utc/offset flags, and
	        // create now).

	        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
	        week = defaults(w.W, 1);
	        weekday = defaults(w.E, 1);

	        if (weekday < 1 || weekday > 7) {
	          weekdayOverflow = true;
	        }
	      } else {
	        dow = config._locale._week.dow;
	        doy = config._locale._week.doy;
	        var curWeek = weekOfYear(createLocal(), dow, doy);
	        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

	        week = defaults(w.w, curWeek.week);

	        if (w.d != null) {
	          // weekday -- low day numbers are considered next week
	          weekday = w.d;

	          if (weekday < 0 || weekday > 6) {
	            weekdayOverflow = true;
	          }
	        } else if (w.e != null) {
	          // local weekday -- counting starts from beginning of week
	          weekday = w.e + dow;

	          if (w.e < 0 || w.e > 6) {
	            weekdayOverflow = true;
	          }
	        } else {
	          // default to beginning of week
	          weekday = dow;
	        }
	      }

	      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	        getParsingFlags(config)._overflowWeeks = true;
	      } else if (weekdayOverflow != null) {
	        getParsingFlags(config)._overflowWeekday = true;
	      } else {
	        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	        config._a[YEAR] = temp.year;
	        config._dayOfYear = temp.dayOfYear;
	      }
	    } // iso 8601 regex
	    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


	    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
	    var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard
	    ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]]; // iso time formats and regexes

	    var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
	    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i; // date from iso format

	    function configFromISO(config) {
	      var i,
	          l,
	          string = config._i,
	          match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	          allowTime,
	          dateFormat,
	          timeFormat,
	          tzFormat;

	      if (match) {
	        getParsingFlags(config).iso = true;

	        for (i = 0, l = isoDates.length; i < l; i++) {
	          if (isoDates[i][1].exec(match[1])) {
	            dateFormat = isoDates[i][0];
	            allowTime = isoDates[i][2] !== false;
	            break;
	          }
	        }

	        if (dateFormat == null) {
	          config._isValid = false;
	          return;
	        }

	        if (match[3]) {
	          for (i = 0, l = isoTimes.length; i < l; i++) {
	            if (isoTimes[i][1].exec(match[3])) {
	              // match[2] should be 'T' or space
	              timeFormat = (match[2] || ' ') + isoTimes[i][0];
	              break;
	            }
	          }

	          if (timeFormat == null) {
	            config._isValid = false;
	            return;
	          }
	        }

	        if (!allowTime && timeFormat != null) {
	          config._isValid = false;
	          return;
	        }

	        if (match[4]) {
	          if (tzRegex.exec(match[4])) {
	            tzFormat = 'Z';
	          } else {
	            config._isValid = false;
	            return;
	          }
	        }

	        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	        configFromStringAndFormat(config);
	      } else {
	        config._isValid = false;
	      }
	    } // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3


	    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

	    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
	      var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

	      if (secondStr) {
	        result.push(parseInt(secondStr, 10));
	      }

	      return result;
	    }

	    function untruncateYear(yearStr) {
	      var year = parseInt(yearStr, 10);

	      if (year <= 49) {
	        return 2000 + year;
	      } else if (year <= 999) {
	        return 1900 + year;
	      }

	      return year;
	    }

	    function preprocessRFC2822(s) {
	      // Remove comments and folding whitespace and replace multiple-spaces with a single space
	      return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
	    }

	    function checkWeekday(weekdayStr, parsedInput, config) {
	      if (weekdayStr) {
	        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
	        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
	            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

	        if (weekdayProvided !== weekdayActual) {
	          getParsingFlags(config).weekdayMismatch = true;
	          config._isValid = false;
	          return false;
	        }
	      }

	      return true;
	    }

	    var obsOffsets = {
	      UT: 0,
	      GMT: 0,
	      EDT: -4 * 60,
	      EST: -5 * 60,
	      CDT: -5 * 60,
	      CST: -6 * 60,
	      MDT: -6 * 60,
	      MST: -7 * 60,
	      PDT: -7 * 60,
	      PST: -8 * 60
	    };

	    function calculateOffset(obsOffset, militaryOffset, numOffset) {
	      if (obsOffset) {
	        return obsOffsets[obsOffset];
	      } else if (militaryOffset) {
	        // the only allowed military tz is Z
	        return 0;
	      } else {
	        var hm = parseInt(numOffset, 10);
	        var m = hm % 100,
	            h = (hm - m) / 100;
	        return h * 60 + m;
	      }
	    } // date and time from ref 2822 format


	    function configFromRFC2822(config) {
	      var match = rfc2822.exec(preprocessRFC2822(config._i));

	      if (match) {
	        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

	        if (!checkWeekday(match[1], parsedArray, config)) {
	          return;
	        }

	        config._a = parsedArray;
	        config._tzm = calculateOffset(match[8], match[9], match[10]);
	        config._d = createUTCDate.apply(null, config._a);

	        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

	        getParsingFlags(config).rfc2822 = true;
	      } else {
	        config._isValid = false;
	      }
	    } // date from iso format or fallback


	    function configFromString(config) {
	      var matched = aspNetJsonRegex.exec(config._i);

	      if (matched !== null) {
	        config._d = new Date(+matched[1]);
	        return;
	      }

	      configFromISO(config);

	      if (config._isValid === false) {
	        delete config._isValid;
	      } else {
	        return;
	      }

	      configFromRFC2822(config);

	      if (config._isValid === false) {
	        delete config._isValid;
	      } else {
	        return;
	      } // Final attempt, use Input Fallback


	      hooks.createFromInputFallback(config);
	    }

	    hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
	      config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	    }); // constant that refers to the ISO standard

	    hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


	    hooks.RFC_2822 = function () {}; // date from string and format string


	    function configFromStringAndFormat(config) {
	      // TODO: Move this to another part of the creation flow to prevent circular deps
	      if (config._f === hooks.ISO_8601) {
	        configFromISO(config);
	        return;
	      }

	      if (config._f === hooks.RFC_2822) {
	        configFromRFC2822(config);
	        return;
	      }

	      config._a = [];
	      getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

	      var string = '' + config._i,
	          i,
	          parsedInput,
	          tokens,
	          token,
	          skipped,
	          stringLength = string.length,
	          totalParsedInputLength = 0;
	      tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

	      for (i = 0; i < tokens.length; i++) {
	        token = tokens[i];
	        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,
	        //         'regex', getParseRegexForToken(token, config));

	        if (parsedInput) {
	          skipped = string.substr(0, string.indexOf(parsedInput));

	          if (skipped.length > 0) {
	            getParsingFlags(config).unusedInput.push(skipped);
	          }

	          string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	          totalParsedInputLength += parsedInput.length;
	        } // don't parse if it's not a known token


	        if (formatTokenFunctions[token]) {
	          if (parsedInput) {
	            getParsingFlags(config).empty = false;
	          } else {
	            getParsingFlags(config).unusedTokens.push(token);
	          }

	          addTimeToArrayFromToken(token, parsedInput, config);
	        } else if (config._strict && !parsedInput) {
	          getParsingFlags(config).unusedTokens.push(token);
	        }
	      } // add remaining unparsed input length to the string


	      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

	      if (string.length > 0) {
	        getParsingFlags(config).unusedInput.push(string);
	      } // clear _12h flag if hour is <= 12


	      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
	        getParsingFlags(config).bigHour = undefined;
	      }

	      getParsingFlags(config).parsedDateParts = config._a.slice(0);
	      getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

	      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
	      configFromArray(config);
	      checkOverflow(config);
	    }

	    function meridiemFixWrap(locale, hour, meridiem) {
	      var isPm;

	      if (meridiem == null) {
	        // nothing to do
	        return hour;
	      }

	      if (locale.meridiemHour != null) {
	        return locale.meridiemHour(hour, meridiem);
	      } else if (locale.isPM != null) {
	        // Fallback
	        isPm = locale.isPM(meridiem);

	        if (isPm && hour < 12) {
	          hour += 12;
	        }

	        if (!isPm && hour === 12) {
	          hour = 0;
	        }

	        return hour;
	      } else {
	        // this is not supposed to happen
	        return hour;
	      }
	    } // date from string and array of format strings


	    function configFromStringAndArray(config) {
	      var tempConfig, bestMoment, scoreToBeat, i, currentScore;

	      if (config._f.length === 0) {
	        getParsingFlags(config).invalidFormat = true;
	        config._d = new Date(NaN);
	        return;
	      }

	      for (i = 0; i < config._f.length; i++) {
	        currentScore = 0;
	        tempConfig = copyConfig({}, config);

	        if (config._useUTC != null) {
	          tempConfig._useUTC = config._useUTC;
	        }

	        tempConfig._f = config._f[i];
	        configFromStringAndFormat(tempConfig);

	        if (!isValid(tempConfig)) {
	          continue;
	        } // if there is any input that was not parsed add a penalty for that format


	        currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

	        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
	        getParsingFlags(tempConfig).score = currentScore;

	        if (scoreToBeat == null || currentScore < scoreToBeat) {
	          scoreToBeat = currentScore;
	          bestMoment = tempConfig;
	        }
	      }

	      extend(config, bestMoment || tempConfig);
	    }

	    function configFromObject(config) {
	      if (config._d) {
	        return;
	      }

	      var i = normalizeObjectUnits(config._i);
	      config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	        return obj && parseInt(obj, 10);
	      });
	      configFromArray(config);
	    }

	    function createFromConfig(config) {
	      var res = new Moment(checkOverflow(prepareConfig(config)));

	      if (res._nextDay) {
	        // Adding is smart enough around DST
	        res.add(1, 'd');
	        res._nextDay = undefined;
	      }

	      return res;
	    }

	    function prepareConfig(config) {
	      var input = config._i,
	          format = config._f;
	      config._locale = config._locale || getLocale(config._l);

	      if (input === null || format === undefined && input === '') {
	        return createInvalid({
	          nullInput: true
	        });
	      }

	      if (typeof input === 'string') {
	        config._i = input = config._locale.preparse(input);
	      }

	      if (isMoment(input)) {
	        return new Moment(checkOverflow(input));
	      } else if (isDate(input)) {
	        config._d = input;
	      } else if (isArray(format)) {
	        configFromStringAndArray(config);
	      } else if (format) {
	        configFromStringAndFormat(config);
	      } else {
	        configFromInput(config);
	      }

	      if (!isValid(config)) {
	        config._d = null;
	      }

	      return config;
	    }

	    function configFromInput(config) {
	      var input = config._i;

	      if (isUndefined(input)) {
	        config._d = new Date(hooks.now());
	      } else if (isDate(input)) {
	        config._d = new Date(input.valueOf());
	      } else if (typeof input === 'string') {
	        configFromString(config);
	      } else if (isArray(input)) {
	        config._a = map(input.slice(0), function (obj) {
	          return parseInt(obj, 10);
	        });
	        configFromArray(config);
	      } else if (isObject(input)) {
	        configFromObject(config);
	      } else if (isNumber(input)) {
	        // from milliseconds
	        config._d = new Date(input);
	      } else {
	        hooks.createFromInputFallback(config);
	      }
	    }

	    function createLocalOrUTC(input, format, locale, strict, isUTC) {
	      var c = {};

	      if (locale === true || locale === false) {
	        strict = locale;
	        locale = undefined;
	      }

	      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
	        input = undefined;
	      } // object construction must be done this way.
	      // https://github.com/moment/moment/issues/1423


	      c._isAMomentObject = true;
	      c._useUTC = c._isUTC = isUTC;
	      c._l = locale;
	      c._i = input;
	      c._f = format;
	      c._strict = strict;
	      return createFromConfig(c);
	    }

	    function createLocal(input, format, locale, strict) {
	      return createLocalOrUTC(input, format, locale, strict, false);
	    }

	    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
	      var other = createLocal.apply(null, arguments);

	      if (this.isValid() && other.isValid()) {
	        return other < this ? this : other;
	      } else {
	        return createInvalid();
	      }
	    });
	    var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
	      var other = createLocal.apply(null, arguments);

	      if (this.isValid() && other.isValid()) {
	        return other > this ? this : other;
	      } else {
	        return createInvalid();
	      }
	    }); // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.

	    function pickBy(fn, moments) {
	      var res, i;

	      if (moments.length === 1 && isArray(moments[0])) {
	        moments = moments[0];
	      }

	      if (!moments.length) {
	        return createLocal();
	      }

	      res = moments[0];

	      for (i = 1; i < moments.length; ++i) {
	        if (!moments[i].isValid() || moments[i][fn](res)) {
	          res = moments[i];
	        }
	      }

	      return res;
	    } // TODO: Use [].sort instead?


	    function min() {
	      var args = [].slice.call(arguments, 0);
	      return pickBy('isBefore', args);
	    }

	    function max() {
	      var args = [].slice.call(arguments, 0);
	      return pickBy('isAfter', args);
	    }

	    var now = function now() {
	      return Date.now ? Date.now() : +new Date();
	    };

	    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

	    function isDurationValid(m) {
	      for (var key in m) {
	        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
	          return false;
	        }
	      }

	      var unitHasDecimal = false;

	      for (var i = 0; i < ordering.length; ++i) {
	        if (m[ordering[i]]) {
	          if (unitHasDecimal) {
	            return false; // only allow non-integers for smallest unit
	          }

	          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
	            unitHasDecimal = true;
	          }
	        }
	      }

	      return true;
	    }

	    function isValid$1() {
	      return this._isValid;
	    }

	    function createInvalid$1() {
	      return createDuration(NaN);
	    }

	    function Duration(duration) {
	      var normalizedInput = normalizeObjectUnits(duration),
	          years = normalizedInput.year || 0,
	          quarters = normalizedInput.quarter || 0,
	          months = normalizedInput.month || 0,
	          weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
	          days = normalizedInput.day || 0,
	          hours = normalizedInput.hour || 0,
	          minutes = normalizedInput.minute || 0,
	          seconds = normalizedInput.second || 0,
	          milliseconds = normalizedInput.millisecond || 0;
	      this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

	      this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
	      minutes * 6e4 + // 1000 * 60
	      hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	      // Because of dateAddRemove treats 24 hours as different from a
	      // day when working around DST, we need to store them separately

	      this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
	      // which months you are are talking about, so we have to store
	      // it separately.

	      this._months = +months + quarters * 3 + years * 12;
	      this._data = {};
	      this._locale = getLocale();

	      this._bubble();
	    }

	    function isDuration(obj) {
	      return obj instanceof Duration;
	    }

	    function absRound(number) {
	      if (number < 0) {
	        return Math.round(-1 * number) * -1;
	      } else {
	        return Math.round(number);
	      }
	    } // FORMATTING


	    function offset(token, separator) {
	      addFormatToken(token, 0, 0, function () {
	        var offset = this.utcOffset();
	        var sign = '+';

	        if (offset < 0) {
	          offset = -offset;
	          sign = '-';
	        }

	        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
	      });
	    }

	    offset('Z', ':');
	    offset('ZZ', ''); // PARSING

	    addRegexToken('Z', matchShortOffset);
	    addRegexToken('ZZ', matchShortOffset);
	    addParseToken(['Z', 'ZZ'], function (input, array, config) {
	      config._useUTC = true;
	      config._tzm = offsetFromString(matchShortOffset, input);
	    }); // HELPERS
	    // timezone chunker
	    // '+10:00' > ['10',  '00']
	    // '-1530'  > ['-15', '30']

	    var chunkOffset = /([\+\-]|\d\d)/gi;

	    function offsetFromString(matcher, string) {
	      var matches = (string || '').match(matcher);

	      if (matches === null) {
	        return null;
	      }

	      var chunk = matches[matches.length - 1] || [];
	      var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	      var minutes = +(parts[1] * 60) + toInt(parts[2]);
	      return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
	    } // Return a moment from input, that is local/utc/zone equivalent to model.


	    function cloneWithOffset(input, model) {
	      var res, diff;

	      if (model._isUTC) {
	        res = model.clone();
	        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

	        res._d.setTime(res._d.valueOf() + diff);

	        hooks.updateOffset(res, false);
	        return res;
	      } else {
	        return createLocal(input).local();
	      }
	    }

	    function getDateOffset(m) {
	      // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	      // https://github.com/moment/moment/pull/1871
	      return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	    } // HOOKS
	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.


	    hooks.updateOffset = function () {}; // MOMENTS
	    // keepLocalTime = true means only change the timezone, without
	    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	    // +0200, so we adjust the time as needed, to be valid.
	    //
	    // Keeping the time actually adds/subtracts (one hour)
	    // from the actual represented time. That is why we call updateOffset
	    // a second time. In case it wants us to change the offset again
	    // _changeInProgress == true case, then we have to adjust, because
	    // there is no such time in the given timezone.


	    function getSetOffset(input, keepLocalTime, keepMinutes) {
	      var offset = this._offset || 0,
	          localAdjust;

	      if (!this.isValid()) {
	        return input != null ? this : NaN;
	      }

	      if (input != null) {
	        if (typeof input === 'string') {
	          input = offsetFromString(matchShortOffset, input);

	          if (input === null) {
	            return this;
	          }
	        } else if (Math.abs(input) < 16 && !keepMinutes) {
	          input = input * 60;
	        }

	        if (!this._isUTC && keepLocalTime) {
	          localAdjust = getDateOffset(this);
	        }

	        this._offset = input;
	        this._isUTC = true;

	        if (localAdjust != null) {
	          this.add(localAdjust, 'm');
	        }

	        if (offset !== input) {
	          if (!keepLocalTime || this._changeInProgress) {
	            addSubtract(this, createDuration(input - offset, 'm'), 1, false);
	          } else if (!this._changeInProgress) {
	            this._changeInProgress = true;
	            hooks.updateOffset(this, true);
	            this._changeInProgress = null;
	          }
	        }

	        return this;
	      } else {
	        return this._isUTC ? offset : getDateOffset(this);
	      }
	    }

	    function getSetZone(input, keepLocalTime) {
	      if (input != null) {
	        if (typeof input !== 'string') {
	          input = -input;
	        }

	        this.utcOffset(input, keepLocalTime);
	        return this;
	      } else {
	        return -this.utcOffset();
	      }
	    }

	    function setOffsetToUTC(keepLocalTime) {
	      return this.utcOffset(0, keepLocalTime);
	    }

	    function setOffsetToLocal(keepLocalTime) {
	      if (this._isUTC) {
	        this.utcOffset(0, keepLocalTime);
	        this._isUTC = false;

	        if (keepLocalTime) {
	          this.subtract(getDateOffset(this), 'm');
	        }
	      }

	      return this;
	    }

	    function setOffsetToParsedOffset() {
	      if (this._tzm != null) {
	        this.utcOffset(this._tzm, false, true);
	      } else if (typeof this._i === 'string') {
	        var tZone = offsetFromString(matchOffset, this._i);

	        if (tZone != null) {
	          this.utcOffset(tZone);
	        } else {
	          this.utcOffset(0, true);
	        }
	      }

	      return this;
	    }

	    function hasAlignedHourOffset(input) {
	      if (!this.isValid()) {
	        return false;
	      }

	      input = input ? createLocal(input).utcOffset() : 0;
	      return (this.utcOffset() - input) % 60 === 0;
	    }

	    function isDaylightSavingTime() {
	      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
	    }

	    function isDaylightSavingTimeShifted() {
	      if (!isUndefined(this._isDSTShifted)) {
	        return this._isDSTShifted;
	      }

	      var c = {};
	      copyConfig(c, this);
	      c = prepareConfig(c);

	      if (c._a) {
	        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
	        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
	      } else {
	        this._isDSTShifted = false;
	      }

	      return this._isDSTShifted;
	    }

	    function isLocal() {
	      return this.isValid() ? !this._isUTC : false;
	    }

	    function isUtcOffset() {
	      return this.isValid() ? this._isUTC : false;
	    }

	    function isUtc() {
	      return this.isValid() ? this._isUTC && this._offset === 0 : false;
	    } // ASP.NET json date format regex


	    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	    // and further modified to allow for strings containing both week and day

	    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

	    function createDuration(input, key) {
	      var duration = input,
	          // matching against regexp is expensive, do it on demand
	      match = null,
	          sign,
	          ret,
	          diffRes;

	      if (isDuration(input)) {
	        duration = {
	          ms: input._milliseconds,
	          d: input._days,
	          M: input._months
	        };
	      } else if (isNumber(input)) {
	        duration = {};

	        if (key) {
	          duration[key] = input;
	        } else {
	          duration.milliseconds = input;
	        }
	      } else if (!!(match = aspNetRegex.exec(input))) {
	        sign = match[1] === '-' ? -1 : 1;
	        duration = {
	          y: 0,
	          d: toInt(match[DATE]) * sign,
	          h: toInt(match[HOUR]) * sign,
	          m: toInt(match[MINUTE]) * sign,
	          s: toInt(match[SECOND]) * sign,
	          ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

	        };
	      } else if (!!(match = isoRegex.exec(input))) {
	        sign = match[1] === '-' ? -1 : 1;
	        duration = {
	          y: parseIso(match[2], sign),
	          M: parseIso(match[3], sign),
	          w: parseIso(match[4], sign),
	          d: parseIso(match[5], sign),
	          h: parseIso(match[6], sign),
	          m: parseIso(match[7], sign),
	          s: parseIso(match[8], sign)
	        };
	      } else if (duration == null) {
	        // checks for null or undefined
	        duration = {};
	      } else if (_typeof(duration) === 'object' && ('from' in duration || 'to' in duration)) {
	        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
	        duration = {};
	        duration.ms = diffRes.milliseconds;
	        duration.M = diffRes.months;
	      }

	      ret = new Duration(duration);

	      if (isDuration(input) && hasOwnProp(input, '_locale')) {
	        ret._locale = input._locale;
	      }

	      return ret;
	    }

	    createDuration.fn = Duration.prototype;
	    createDuration.invalid = createInvalid$1;

	    function parseIso(inp, sign) {
	      // We'd normally use ~~inp for this, but unfortunately it also
	      // converts floats to ints.
	      // inp may be undefined, so careful calling replace on it.
	      var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

	      return (isNaN(res) ? 0 : res) * sign;
	    }

	    function positiveMomentsDifference(base, other) {
	      var res = {};
	      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

	      if (base.clone().add(res.months, 'M').isAfter(other)) {
	        --res.months;
	      }

	      res.milliseconds = +other - +base.clone().add(res.months, 'M');
	      return res;
	    }

	    function momentsDifference(base, other) {
	      var res;

	      if (!(base.isValid() && other.isValid())) {
	        return {
	          milliseconds: 0,
	          months: 0
	        };
	      }

	      other = cloneWithOffset(other, base);

	      if (base.isBefore(other)) {
	        res = positiveMomentsDifference(base, other);
	      } else {
	        res = positiveMomentsDifference(other, base);
	        res.milliseconds = -res.milliseconds;
	        res.months = -res.months;
	      }

	      return res;
	    } // TODO: remove 'name' arg after deprecation is removed


	    function createAdder(direction, name) {
	      return function (val, period) {
	        var dur, tmp; //invert the arguments, but complain about it

	        if (period !== null && !isNaN(+period)) {
	          deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
	          tmp = val;
	          val = period;
	          period = tmp;
	        }

	        val = typeof val === 'string' ? +val : val;
	        dur = createDuration(val, period);
	        addSubtract(this, dur, direction);
	        return this;
	      };
	    }

	    function addSubtract(mom, duration, isAdding, updateOffset) {
	      var milliseconds = duration._milliseconds,
	          days = absRound(duration._days),
	          months = absRound(duration._months);

	      if (!mom.isValid()) {
	        // No op
	        return;
	      }

	      updateOffset = updateOffset == null ? true : updateOffset;

	      if (months) {
	        setMonth(mom, get(mom, 'Month') + months * isAdding);
	      }

	      if (days) {
	        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
	      }

	      if (milliseconds) {
	        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	      }

	      if (updateOffset) {
	        hooks.updateOffset(mom, days || months);
	      }
	    }

	    var add = createAdder(1, 'add');
	    var subtract = createAdder(-1, 'subtract');

	    function getCalendarFormat(myMoment, now) {
	      var diff = myMoment.diff(now, 'days', true);
	      return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
	    }

	    function calendar$1(time, formats) {
	      // We want to compare the start of today, vs this.
	      // Getting start-of-today depends on whether we're local/utc/offset or not.
	      var now = time || createLocal(),
	          sod = cloneWithOffset(now, this).startOf('day'),
	          format = hooks.calendarFormat(this, sod) || 'sameElse';
	      var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
	      return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
	    }

	    function clone() {
	      return new Moment(this);
	    }

	    function isAfter(input, units) {
	      var localInput = isMoment(input) ? input : createLocal(input);

	      if (!(this.isValid() && localInput.isValid())) {
	        return false;
	      }

	      units = normalizeUnits(units) || 'millisecond';

	      if (units === 'millisecond') {
	        return this.valueOf() > localInput.valueOf();
	      } else {
	        return localInput.valueOf() < this.clone().startOf(units).valueOf();
	      }
	    }

	    function isBefore(input, units) {
	      var localInput = isMoment(input) ? input : createLocal(input);

	      if (!(this.isValid() && localInput.isValid())) {
	        return false;
	      }

	      units = normalizeUnits(units) || 'millisecond';

	      if (units === 'millisecond') {
	        return this.valueOf() < localInput.valueOf();
	      } else {
	        return this.clone().endOf(units).valueOf() < localInput.valueOf();
	      }
	    }

	    function isBetween(from, to, units, inclusivity) {
	      var localFrom = isMoment(from) ? from : createLocal(from),
	          localTo = isMoment(to) ? to : createLocal(to);

	      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
	        return false;
	      }

	      inclusivity = inclusivity || '()';
	      return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
	    }

	    function isSame(input, units) {
	      var localInput = isMoment(input) ? input : createLocal(input),
	          inputMs;

	      if (!(this.isValid() && localInput.isValid())) {
	        return false;
	      }

	      units = normalizeUnits(units) || 'millisecond';

	      if (units === 'millisecond') {
	        return this.valueOf() === localInput.valueOf();
	      } else {
	        inputMs = localInput.valueOf();
	        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
	      }
	    }

	    function isSameOrAfter(input, units) {
	      return this.isSame(input, units) || this.isAfter(input, units);
	    }

	    function isSameOrBefore(input, units) {
	      return this.isSame(input, units) || this.isBefore(input, units);
	    }

	    function diff(input, units, asFloat) {
	      var that, zoneDelta, output;

	      if (!this.isValid()) {
	        return NaN;
	      }

	      that = cloneWithOffset(input, this);

	      if (!that.isValid()) {
	        return NaN;
	      }

	      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
	      units = normalizeUnits(units);

	      switch (units) {
	        case 'year':
	          output = monthDiff(this, that) / 12;
	          break;

	        case 'month':
	          output = monthDiff(this, that);
	          break;

	        case 'quarter':
	          output = monthDiff(this, that) / 3;
	          break;

	        case 'second':
	          output = (this - that) / 1e3;
	          break;
	        // 1000

	        case 'minute':
	          output = (this - that) / 6e4;
	          break;
	        // 1000 * 60

	        case 'hour':
	          output = (this - that) / 36e5;
	          break;
	        // 1000 * 60 * 60

	        case 'day':
	          output = (this - that - zoneDelta) / 864e5;
	          break;
	        // 1000 * 60 * 60 * 24, negate dst

	        case 'week':
	          output = (this - that - zoneDelta) / 6048e5;
	          break;
	        // 1000 * 60 * 60 * 24 * 7, negate dst

	        default:
	          output = this - that;
	      }

	      return asFloat ? output : absFloor(output);
	    }

	    function monthDiff(a, b) {
	      // difference in months
	      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
	          // b is in (anchor - 1 month, anchor + 1 month)
	      anchor = a.clone().add(wholeMonthDiff, 'months'),
	          anchor2,
	          adjust;

	      if (b - anchor < 0) {
	        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

	        adjust = (b - anchor) / (anchor - anchor2);
	      } else {
	        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

	        adjust = (b - anchor) / (anchor2 - anchor);
	      } //check for negative zero, return zero if negative zero


	      return -(wholeMonthDiff + adjust) || 0;
	    }

	    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

	    function toString() {
	      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	    }

	    function toISOString(keepOffset) {
	      if (!this.isValid()) {
	        return null;
	      }

	      var utc = keepOffset !== true;
	      var m = utc ? this.clone().utc() : this;

	      if (m.year() < 0 || m.year() > 9999) {
	        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
	      }

	      if (isFunction(Date.prototype.toISOString)) {
	        // native implementation is ~50x faster, use it when we can
	        if (utc) {
	          return this.toDate().toISOString();
	        } else {
	          return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
	        }
	      }

	      return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
	    }
	    /**
	     * Return a human readable representation of a moment that can
	     * also be evaluated to get a new moment which is the same
	     *
	     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
	     */


	    function inspect() {
	      if (!this.isValid()) {
	        return 'moment.invalid(/* ' + this._i + ' */)';
	      }

	      var func = 'moment';
	      var zone = '';

	      if (!this.isLocal()) {
	        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
	        zone = 'Z';
	      }

	      var prefix = '[' + func + '("]';
	      var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
	      var datetime = '-MM-DD[T]HH:mm:ss.SSS';
	      var suffix = zone + '[")]';
	      return this.format(prefix + year + datetime + suffix);
	    }

	    function format(inputString) {
	      if (!inputString) {
	        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
	      }

	      var output = formatMoment(this, inputString);
	      return this.localeData().postformat(output);
	    }

	    function from(time, withoutSuffix) {
	      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
	        return createDuration({
	          to: this,
	          from: time
	        }).locale(this.locale()).humanize(!withoutSuffix);
	      } else {
	        return this.localeData().invalidDate();
	      }
	    }

	    function fromNow(withoutSuffix) {
	      return this.from(createLocal(), withoutSuffix);
	    }

	    function to(time, withoutSuffix) {
	      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
	        return createDuration({
	          from: this,
	          to: time
	        }).locale(this.locale()).humanize(!withoutSuffix);
	      } else {
	        return this.localeData().invalidDate();
	      }
	    }

	    function toNow(withoutSuffix) {
	      return this.to(createLocal(), withoutSuffix);
	    } // If passed a locale key, it will set the locale for this
	    // instance.  Otherwise, it will return the locale configuration
	    // variables for this instance.


	    function locale(key) {
	      var newLocaleData;

	      if (key === undefined) {
	        return this._locale._abbr;
	      } else {
	        newLocaleData = getLocale(key);

	        if (newLocaleData != null) {
	          this._locale = newLocaleData;
	        }

	        return this;
	      }
	    }

	    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
	      if (key === undefined) {
	        return this.localeData();
	      } else {
	        return this.locale(key);
	      }
	    });

	    function localeData() {
	      return this._locale;
	    }

	    var MS_PER_SECOND = 1000;
	    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
	    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
	    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):

	    function mod$1(dividend, divisor) {
	      return (dividend % divisor + divisor) % divisor;
	    }

	    function localStartOfDate(y, m, d) {
	      // the date constructor remaps years 0-99 to 1900-1999
	      if (y < 100 && y >= 0) {
	        // preserve leap years using a full 400 year cycle, then reset
	        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
	      } else {
	        return new Date(y, m, d).valueOf();
	      }
	    }

	    function utcStartOfDate(y, m, d) {
	      // Date.UTC remaps years 0-99 to 1900-1999
	      if (y < 100 && y >= 0) {
	        // preserve leap years using a full 400 year cycle, then reset
	        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
	      } else {
	        return Date.UTC(y, m, d);
	      }
	    }

	    function startOf(units) {
	      var time;
	      units = normalizeUnits(units);

	      if (units === undefined || units === 'millisecond' || !this.isValid()) {
	        return this;
	      }

	      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

	      switch (units) {
	        case 'year':
	          time = startOfDate(this.year(), 0, 1);
	          break;

	        case 'quarter':
	          time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
	          break;

	        case 'month':
	          time = startOfDate(this.year(), this.month(), 1);
	          break;

	        case 'week':
	          time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
	          break;

	        case 'isoWeek':
	          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
	          break;

	        case 'day':
	        case 'date':
	          time = startOfDate(this.year(), this.month(), this.date());
	          break;

	        case 'hour':
	          time = this._d.valueOf();
	          time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
	          break;

	        case 'minute':
	          time = this._d.valueOf();
	          time -= mod$1(time, MS_PER_MINUTE);
	          break;

	        case 'second':
	          time = this._d.valueOf();
	          time -= mod$1(time, MS_PER_SECOND);
	          break;
	      }

	      this._d.setTime(time);

	      hooks.updateOffset(this, true);
	      return this;
	    }

	    function endOf(units) {
	      var time;
	      units = normalizeUnits(units);

	      if (units === undefined || units === 'millisecond' || !this.isValid()) {
	        return this;
	      }

	      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

	      switch (units) {
	        case 'year':
	          time = startOfDate(this.year() + 1, 0, 1) - 1;
	          break;

	        case 'quarter':
	          time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
	          break;

	        case 'month':
	          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
	          break;

	        case 'week':
	          time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
	          break;

	        case 'isoWeek':
	          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
	          break;

	        case 'day':
	        case 'date':
	          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
	          break;

	        case 'hour':
	          time = this._d.valueOf();
	          time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
	          break;

	        case 'minute':
	          time = this._d.valueOf();
	          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
	          break;

	        case 'second':
	          time = this._d.valueOf();
	          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
	          break;
	      }

	      this._d.setTime(time);

	      hooks.updateOffset(this, true);
	      return this;
	    }

	    function valueOf() {
	      return this._d.valueOf() - (this._offset || 0) * 60000;
	    }

	    function unix() {
	      return Math.floor(this.valueOf() / 1000);
	    }

	    function toDate() {
	      return new Date(this.valueOf());
	    }

	    function toArray() {
	      var m = this;
	      return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	    }

	    function toObject() {
	      var m = this;
	      return {
	        years: m.year(),
	        months: m.month(),
	        date: m.date(),
	        hours: m.hours(),
	        minutes: m.minutes(),
	        seconds: m.seconds(),
	        milliseconds: m.milliseconds()
	      };
	    }

	    function toJSON() {
	      // new Date(NaN).toJSON() === null
	      return this.isValid() ? this.toISOString() : null;
	    }

	    function isValid$2() {
	      return isValid(this);
	    }

	    function parsingFlags() {
	      return extend({}, getParsingFlags(this));
	    }

	    function invalidAt() {
	      return getParsingFlags(this).overflow;
	    }

	    function creationData() {
	      return {
	        input: this._i,
	        format: this._f,
	        locale: this._locale,
	        isUTC: this._isUTC,
	        strict: this._strict
	      };
	    } // FORMATTING


	    addFormatToken(0, ['gg', 2], 0, function () {
	      return this.weekYear() % 100;
	    });
	    addFormatToken(0, ['GG', 2], 0, function () {
	      return this.isoWeekYear() % 100;
	    });

	    function addWeekYearFormatToken(token, getter) {
	      addFormatToken(0, [token, token.length], 0, getter);
	    }

	    addWeekYearFormatToken('gggg', 'weekYear');
	    addWeekYearFormatToken('ggggg', 'weekYear');
	    addWeekYearFormatToken('GGGG', 'isoWeekYear');
	    addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

	    addUnitAlias('weekYear', 'gg');
	    addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

	    addUnitPriority('weekYear', 1);
	    addUnitPriority('isoWeekYear', 1); // PARSING

	    addRegexToken('G', matchSigned);
	    addRegexToken('g', matchSigned);
	    addRegexToken('GG', match1to2, match2);
	    addRegexToken('gg', match1to2, match2);
	    addRegexToken('GGGG', match1to4, match4);
	    addRegexToken('gggg', match1to4, match4);
	    addRegexToken('GGGGG', match1to6, match6);
	    addRegexToken('ggggg', match1to6, match6);
	    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	      week[token.substr(0, 2)] = toInt(input);
	    });
	    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	      week[token] = hooks.parseTwoDigitYear(input);
	    }); // MOMENTS

	    function getSetWeekYear(input) {
	      return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
	    }

	    function getSetISOWeekYear(input) {
	      return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
	    }

	    function getISOWeeksInYear() {
	      return weeksInYear(this.year(), 1, 4);
	    }

	    function getWeeksInYear() {
	      var weekInfo = this.localeData()._week;

	      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	    }

	    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	      var weeksTarget;

	      if (input == null) {
	        return weekOfYear(this, dow, doy).year;
	      } else {
	        weeksTarget = weeksInYear(input, dow, doy);

	        if (week > weeksTarget) {
	          week = weeksTarget;
	        }

	        return setWeekAll.call(this, input, week, weekday, dow, doy);
	      }
	    }

	    function setWeekAll(weekYear, week, weekday, dow, doy) {
	      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	          date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
	      this.year(date.getUTCFullYear());
	      this.month(date.getUTCMonth());
	      this.date(date.getUTCDate());
	      return this;
	    } // FORMATTING


	    addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

	    addUnitAlias('quarter', 'Q'); // PRIORITY

	    addUnitPriority('quarter', 7); // PARSING

	    addRegexToken('Q', match1);
	    addParseToken('Q', function (input, array) {
	      array[MONTH] = (toInt(input) - 1) * 3;
	    }); // MOMENTS

	    function getSetQuarter(input) {
	      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	    } // FORMATTING


	    addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

	    addUnitAlias('date', 'D'); // PRIORITY

	    addUnitPriority('date', 9); // PARSING

	    addRegexToken('D', match1to2);
	    addRegexToken('DD', match1to2, match2);
	    addRegexToken('Do', function (isStrict, locale) {
	      // TODO: Remove "ordinalParse" fallback in next major release.
	      return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
	    });
	    addParseToken(['D', 'DD'], DATE);
	    addParseToken('Do', function (input, array) {
	      array[DATE] = toInt(input.match(match1to2)[0]);
	    }); // MOMENTS

	    var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

	    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

	    addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

	    addUnitPriority('dayOfYear', 4); // PARSING

	    addRegexToken('DDD', match1to3);
	    addRegexToken('DDDD', match3);
	    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	      config._dayOfYear = toInt(input);
	    }); // HELPERS
	    // MOMENTS

	    function getSetDayOfYear(input) {
	      var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	      return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
	    } // FORMATTING


	    addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

	    addUnitAlias('minute', 'm'); // PRIORITY

	    addUnitPriority('minute', 14); // PARSING

	    addRegexToken('m', match1to2);
	    addRegexToken('mm', match1to2, match2);
	    addParseToken(['m', 'mm'], MINUTE); // MOMENTS

	    var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

	    addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

	    addUnitAlias('second', 's'); // PRIORITY

	    addUnitPriority('second', 15); // PARSING

	    addRegexToken('s', match1to2);
	    addRegexToken('ss', match1to2, match2);
	    addParseToken(['s', 'ss'], SECOND); // MOMENTS

	    var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

	    addFormatToken('S', 0, 0, function () {
	      return ~~(this.millisecond() / 100);
	    });
	    addFormatToken(0, ['SS', 2], 0, function () {
	      return ~~(this.millisecond() / 10);
	    });
	    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	    addFormatToken(0, ['SSSS', 4], 0, function () {
	      return this.millisecond() * 10;
	    });
	    addFormatToken(0, ['SSSSS', 5], 0, function () {
	      return this.millisecond() * 100;
	    });
	    addFormatToken(0, ['SSSSSS', 6], 0, function () {
	      return this.millisecond() * 1000;
	    });
	    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	      return this.millisecond() * 10000;
	    });
	    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	      return this.millisecond() * 100000;
	    });
	    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	      return this.millisecond() * 1000000;
	    }); // ALIASES

	    addUnitAlias('millisecond', 'ms'); // PRIORITY

	    addUnitPriority('millisecond', 16); // PARSING

	    addRegexToken('S', match1to3, match1);
	    addRegexToken('SS', match1to3, match2);
	    addRegexToken('SSS', match1to3, match3);
	    var token;

	    for (token = 'SSSS'; token.length <= 9; token += 'S') {
	      addRegexToken(token, matchUnsigned);
	    }

	    function parseMs(input, array) {
	      array[MILLISECOND] = toInt(('0.' + input) * 1000);
	    }

	    for (token = 'S'; token.length <= 9; token += 'S') {
	      addParseToken(token, parseMs);
	    } // MOMENTS


	    var getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

	    addFormatToken('z', 0, 0, 'zoneAbbr');
	    addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

	    function getZoneAbbr() {
	      return this._isUTC ? 'UTC' : '';
	    }

	    function getZoneName() {
	      return this._isUTC ? 'Coordinated Universal Time' : '';
	    }

	    var proto = Moment.prototype;
	    proto.add = add;
	    proto.calendar = calendar$1;
	    proto.clone = clone;
	    proto.diff = diff;
	    proto.endOf = endOf;
	    proto.format = format;
	    proto.from = from;
	    proto.fromNow = fromNow;
	    proto.to = to;
	    proto.toNow = toNow;
	    proto.get = stringGet;
	    proto.invalidAt = invalidAt;
	    proto.isAfter = isAfter;
	    proto.isBefore = isBefore;
	    proto.isBetween = isBetween;
	    proto.isSame = isSame;
	    proto.isSameOrAfter = isSameOrAfter;
	    proto.isSameOrBefore = isSameOrBefore;
	    proto.isValid = isValid$2;
	    proto.lang = lang;
	    proto.locale = locale;
	    proto.localeData = localeData;
	    proto.max = prototypeMax;
	    proto.min = prototypeMin;
	    proto.parsingFlags = parsingFlags;
	    proto.set = stringSet;
	    proto.startOf = startOf;
	    proto.subtract = subtract;
	    proto.toArray = toArray;
	    proto.toObject = toObject;
	    proto.toDate = toDate;
	    proto.toISOString = toISOString;
	    proto.inspect = inspect;
	    proto.toJSON = toJSON;
	    proto.toString = toString;
	    proto.unix = unix;
	    proto.valueOf = valueOf;
	    proto.creationData = creationData;
	    proto.year = getSetYear;
	    proto.isLeapYear = getIsLeapYear;
	    proto.weekYear = getSetWeekYear;
	    proto.isoWeekYear = getSetISOWeekYear;
	    proto.quarter = proto.quarters = getSetQuarter;
	    proto.month = getSetMonth;
	    proto.daysInMonth = getDaysInMonth;
	    proto.week = proto.weeks = getSetWeek;
	    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
	    proto.weeksInYear = getWeeksInYear;
	    proto.isoWeeksInYear = getISOWeeksInYear;
	    proto.date = getSetDayOfMonth;
	    proto.day = proto.days = getSetDayOfWeek;
	    proto.weekday = getSetLocaleDayOfWeek;
	    proto.isoWeekday = getSetISODayOfWeek;
	    proto.dayOfYear = getSetDayOfYear;
	    proto.hour = proto.hours = getSetHour;
	    proto.minute = proto.minutes = getSetMinute;
	    proto.second = proto.seconds = getSetSecond;
	    proto.millisecond = proto.milliseconds = getSetMillisecond;
	    proto.utcOffset = getSetOffset;
	    proto.utc = setOffsetToUTC;
	    proto.local = setOffsetToLocal;
	    proto.parseZone = setOffsetToParsedOffset;
	    proto.hasAlignedHourOffset = hasAlignedHourOffset;
	    proto.isDST = isDaylightSavingTime;
	    proto.isLocal = isLocal;
	    proto.isUtcOffset = isUtcOffset;
	    proto.isUtc = isUtc;
	    proto.isUTC = isUtc;
	    proto.zoneAbbr = getZoneAbbr;
	    proto.zoneName = getZoneName;
	    proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	    proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	    proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
	    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

	    function createUnix(input) {
	      return createLocal(input * 1000);
	    }

	    function createInZone() {
	      return createLocal.apply(null, arguments).parseZone();
	    }

	    function preParsePostFormat(string) {
	      return string;
	    }

	    var proto$1 = Locale.prototype;
	    proto$1.calendar = calendar;
	    proto$1.longDateFormat = longDateFormat;
	    proto$1.invalidDate = invalidDate;
	    proto$1.ordinal = ordinal;
	    proto$1.preparse = preParsePostFormat;
	    proto$1.postformat = preParsePostFormat;
	    proto$1.relativeTime = relativeTime;
	    proto$1.pastFuture = pastFuture;
	    proto$1.set = set;
	    proto$1.months = localeMonths;
	    proto$1.monthsShort = localeMonthsShort;
	    proto$1.monthsParse = localeMonthsParse;
	    proto$1.monthsRegex = monthsRegex;
	    proto$1.monthsShortRegex = monthsShortRegex;
	    proto$1.week = localeWeek;
	    proto$1.firstDayOfYear = localeFirstDayOfYear;
	    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
	    proto$1.weekdays = localeWeekdays;
	    proto$1.weekdaysMin = localeWeekdaysMin;
	    proto$1.weekdaysShort = localeWeekdaysShort;
	    proto$1.weekdaysParse = localeWeekdaysParse;
	    proto$1.weekdaysRegex = weekdaysRegex;
	    proto$1.weekdaysShortRegex = weekdaysShortRegex;
	    proto$1.weekdaysMinRegex = weekdaysMinRegex;
	    proto$1.isPM = localeIsPM;
	    proto$1.meridiem = localeMeridiem;

	    function get$1(format, index, field, setter) {
	      var locale = getLocale();
	      var utc = createUTC().set(setter, index);
	      return locale[field](utc, format);
	    }

	    function listMonthsImpl(format, index, field) {
	      if (isNumber(format)) {
	        index = format;
	        format = undefined;
	      }

	      format = format || '';

	      if (index != null) {
	        return get$1(format, index, field, 'month');
	      }

	      var i;
	      var out = [];

	      for (i = 0; i < 12; i++) {
	        out[i] = get$1(format, i, field, 'month');
	      }

	      return out;
	    } // ()
	    // (5)
	    // (fmt, 5)
	    // (fmt)
	    // (true)
	    // (true, 5)
	    // (true, fmt, 5)
	    // (true, fmt)


	    function listWeekdaysImpl(localeSorted, format, index, field) {
	      if (typeof localeSorted === 'boolean') {
	        if (isNumber(format)) {
	          index = format;
	          format = undefined;
	        }

	        format = format || '';
	      } else {
	        format = localeSorted;
	        index = format;
	        localeSorted = false;

	        if (isNumber(format)) {
	          index = format;
	          format = undefined;
	        }

	        format = format || '';
	      }

	      var locale = getLocale(),
	          shift = localeSorted ? locale._week.dow : 0;

	      if (index != null) {
	        return get$1(format, (index + shift) % 7, field, 'day');
	      }

	      var i;
	      var out = [];

	      for (i = 0; i < 7; i++) {
	        out[i] = get$1(format, (i + shift) % 7, field, 'day');
	      }

	      return out;
	    }

	    function listMonths(format, index) {
	      return listMonthsImpl(format, index, 'months');
	    }

	    function listMonthsShort(format, index) {
	      return listMonthsImpl(format, index, 'monthsShort');
	    }

	    function listWeekdays(localeSorted, format, index) {
	      return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
	    }

	    function listWeekdaysShort(localeSorted, format, index) {
	      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
	    }

	    function listWeekdaysMin(localeSorted, format, index) {
	      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
	    }

	    getSetGlobalLocale('en', {
	      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
	      ordinal: function ordinal(number) {
	        var b = number % 10,
	            output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
	        return number + output;
	      }
	    }); // Side effect imports

	    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
	    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
	    var mathAbs = Math.abs;

	    function abs() {
	      var data = this._data;
	      this._milliseconds = mathAbs(this._milliseconds);
	      this._days = mathAbs(this._days);
	      this._months = mathAbs(this._months);
	      data.milliseconds = mathAbs(data.milliseconds);
	      data.seconds = mathAbs(data.seconds);
	      data.minutes = mathAbs(data.minutes);
	      data.hours = mathAbs(data.hours);
	      data.months = mathAbs(data.months);
	      data.years = mathAbs(data.years);
	      return this;
	    }

	    function addSubtract$1(duration, input, value, direction) {
	      var other = createDuration(input, value);
	      duration._milliseconds += direction * other._milliseconds;
	      duration._days += direction * other._days;
	      duration._months += direction * other._months;
	      return duration._bubble();
	    } // supports only 2.0-style add(1, 's') or add(duration)


	    function add$1(input, value) {
	      return addSubtract$1(this, input, value, 1);
	    } // supports only 2.0-style subtract(1, 's') or subtract(duration)


	    function subtract$1(input, value) {
	      return addSubtract$1(this, input, value, -1);
	    }

	    function absCeil(number) {
	      if (number < 0) {
	        return Math.floor(number);
	      } else {
	        return Math.ceil(number);
	      }
	    }

	    function bubble() {
	      var milliseconds = this._milliseconds;
	      var days = this._days;
	      var months = this._months;
	      var data = this._data;
	      var seconds, minutes, hours, years, monthsFromDays; // if we have a mix of positive and negative values, bubble down first
	      // check: https://github.com/moment/moment/issues/2166

	      if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
	        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	        days = 0;
	        months = 0;
	      } // The following code bubbles up values, see the tests for
	      // examples of what that means.


	      data.milliseconds = milliseconds % 1000;
	      seconds = absFloor(milliseconds / 1000);
	      data.seconds = seconds % 60;
	      minutes = absFloor(seconds / 60);
	      data.minutes = minutes % 60;
	      hours = absFloor(minutes / 60);
	      data.hours = hours % 24;
	      days += absFloor(hours / 24); // convert days to months

	      monthsFromDays = absFloor(daysToMonths(days));
	      months += monthsFromDays;
	      days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

	      years = absFloor(months / 12);
	      months %= 12;
	      data.days = days;
	      data.months = months;
	      data.years = years;
	      return this;
	    }

	    function daysToMonths(days) {
	      // 400 years have 146097 days (taking into account leap year rules)
	      // 400 years have 12 months === 4800
	      return days * 4800 / 146097;
	    }

	    function monthsToDays(months) {
	      // the reverse of daysToMonths
	      return months * 146097 / 4800;
	    }

	    function as(units) {
	      if (!this.isValid()) {
	        return NaN;
	      }

	      var days;
	      var months;
	      var milliseconds = this._milliseconds;
	      units = normalizeUnits(units);

	      if (units === 'month' || units === 'quarter' || units === 'year') {
	        days = this._days + milliseconds / 864e5;
	        months = this._months + daysToMonths(days);

	        switch (units) {
	          case 'month':
	            return months;

	          case 'quarter':
	            return months / 3;

	          case 'year':
	            return months / 12;
	        }
	      } else {
	        // handle milliseconds separately because of floating point math errors (issue #1867)
	        days = this._days + Math.round(monthsToDays(this._months));

	        switch (units) {
	          case 'week':
	            return days / 7 + milliseconds / 6048e5;

	          case 'day':
	            return days + milliseconds / 864e5;

	          case 'hour':
	            return days * 24 + milliseconds / 36e5;

	          case 'minute':
	            return days * 1440 + milliseconds / 6e4;

	          case 'second':
	            return days * 86400 + milliseconds / 1000;
	          // Math.floor prevents floating point math errors here

	          case 'millisecond':
	            return Math.floor(days * 864e5) + milliseconds;

	          default:
	            throw new Error('Unknown unit ' + units);
	        }
	      }
	    } // TODO: Use this.as('ms')?


	    function valueOf$1() {
	      if (!this.isValid()) {
	        return NaN;
	      }

	      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
	    }

	    function makeAs(alias) {
	      return function () {
	        return this.as(alias);
	      };
	    }

	    var asMilliseconds = makeAs('ms');
	    var asSeconds = makeAs('s');
	    var asMinutes = makeAs('m');
	    var asHours = makeAs('h');
	    var asDays = makeAs('d');
	    var asWeeks = makeAs('w');
	    var asMonths = makeAs('M');
	    var asQuarters = makeAs('Q');
	    var asYears = makeAs('y');

	    function clone$1() {
	      return createDuration(this);
	    }

	    function get$2(units) {
	      units = normalizeUnits(units);
	      return this.isValid() ? this[units + 's']() : NaN;
	    }

	    function makeGetter(name) {
	      return function () {
	        return this.isValid() ? this._data[name] : NaN;
	      };
	    }

	    var milliseconds = makeGetter('milliseconds');
	    var seconds = makeGetter('seconds');
	    var minutes = makeGetter('minutes');
	    var hours = makeGetter('hours');
	    var days = makeGetter('days');
	    var months = makeGetter('months');
	    var years = makeGetter('years');

	    function weeks() {
	      return absFloor(this.days() / 7);
	    }

	    var round = Math.round;
	    var thresholds = {
	      ss: 44,
	      // a few seconds to seconds
	      s: 45,
	      // seconds to minute
	      m: 45,
	      // minutes to hour
	      h: 22,
	      // hours to day
	      d: 26,
	      // days to month
	      M: 11 // months to year

	    }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }

	    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
	      var duration = createDuration(posNegDuration).abs();
	      var seconds = round(duration.as('s'));
	      var minutes = round(duration.as('m'));
	      var hours = round(duration.as('h'));
	      var days = round(duration.as('d'));
	      var months = round(duration.as('M'));
	      var years = round(duration.as('y'));
	      var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
	      a[2] = withoutSuffix;
	      a[3] = +posNegDuration > 0;
	      a[4] = locale;
	      return substituteTimeAgo.apply(null, a);
	    } // This function allows you to set the rounding function for relative time strings


	    function getSetRelativeTimeRounding(roundingFunction) {
	      if (roundingFunction === undefined) {
	        return round;
	      }

	      if (typeof roundingFunction === 'function') {
	        round = roundingFunction;
	        return true;
	      }

	      return false;
	    } // This function allows you to set a threshold for relative time strings


	    function getSetRelativeTimeThreshold(threshold, limit) {
	      if (thresholds[threshold] === undefined) {
	        return false;
	      }

	      if (limit === undefined) {
	        return thresholds[threshold];
	      }

	      thresholds[threshold] = limit;

	      if (threshold === 's') {
	        thresholds.ss = limit - 1;
	      }

	      return true;
	    }

	    function humanize(withSuffix) {
	      if (!this.isValid()) {
	        return this.localeData().invalidDate();
	      }

	      var locale = this.localeData();
	      var output = relativeTime$1(this, !withSuffix, locale);

	      if (withSuffix) {
	        output = locale.pastFuture(+this, output);
	      }

	      return locale.postformat(output);
	    }

	    var abs$1 = Math.abs;

	    function sign(x) {
	      return (x > 0) - (x < 0) || +x;
	    }

	    function toISOString$1() {
	      // for ISO strings we do not use the normal bubbling rules:
	      //  * milliseconds bubble up until they become hours
	      //  * days do not bubble at all
	      //  * months bubble up until they become years
	      // This is because there is no context-free conversion between hours and days
	      // (think of clock changes)
	      // and also not between days and months (28-31 days per month)
	      if (!this.isValid()) {
	        return this.localeData().invalidDate();
	      }

	      var seconds = abs$1(this._milliseconds) / 1000;
	      var days = abs$1(this._days);
	      var months = abs$1(this._months);
	      var minutes, hours, years; // 3600 seconds -> 60 minutes -> 1 hour

	      minutes = absFloor(seconds / 60);
	      hours = absFloor(minutes / 60);
	      seconds %= 60;
	      minutes %= 60; // 12 months -> 1 year

	      years = absFloor(months / 12);
	      months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

	      var Y = years;
	      var M = months;
	      var D = days;
	      var h = hours;
	      var m = minutes;
	      var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
	      var total = this.asSeconds();

	      if (!total) {
	        // this is the same as C#'s (Noda) and python (isodate)...
	        // but not other JS (goog.date)
	        return 'P0D';
	      }

	      var totalSign = total < 0 ? '-' : '';
	      var ymSign = sign(this._months) !== sign(total) ? '-' : '';
	      var daysSign = sign(this._days) !== sign(total) ? '-' : '';
	      var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
	      return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
	    }

	    var proto$2 = Duration.prototype;
	    proto$2.isValid = isValid$1;
	    proto$2.abs = abs;
	    proto$2.add = add$1;
	    proto$2.subtract = subtract$1;
	    proto$2.as = as;
	    proto$2.asMilliseconds = asMilliseconds;
	    proto$2.asSeconds = asSeconds;
	    proto$2.asMinutes = asMinutes;
	    proto$2.asHours = asHours;
	    proto$2.asDays = asDays;
	    proto$2.asWeeks = asWeeks;
	    proto$2.asMonths = asMonths;
	    proto$2.asQuarters = asQuarters;
	    proto$2.asYears = asYears;
	    proto$2.valueOf = valueOf$1;
	    proto$2._bubble = bubble;
	    proto$2.clone = clone$1;
	    proto$2.get = get$2;
	    proto$2.milliseconds = milliseconds;
	    proto$2.seconds = seconds;
	    proto$2.minutes = minutes;
	    proto$2.hours = hours;
	    proto$2.days = days;
	    proto$2.weeks = weeks;
	    proto$2.months = months;
	    proto$2.years = years;
	    proto$2.humanize = humanize;
	    proto$2.toISOString = toISOString$1;
	    proto$2.toString = toISOString$1;
	    proto$2.toJSON = toISOString$1;
	    proto$2.locale = locale;
	    proto$2.localeData = localeData;
	    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
	    proto$2.lang = lang; // Side effect imports
	    // FORMATTING

	    addFormatToken('X', 0, 0, 'unix');
	    addFormatToken('x', 0, 0, 'valueOf'); // PARSING

	    addRegexToken('x', matchSigned);
	    addRegexToken('X', matchTimestamp);
	    addParseToken('X', function (input, array, config) {
	      config._d = new Date(parseFloat(input, 10) * 1000);
	    });
	    addParseToken('x', function (input, array, config) {
	      config._d = new Date(toInt(input));
	    }); // Side effect imports

	    hooks.version = '2.24.0';
	    setHookCallback(createLocal);
	    hooks.fn = proto;
	    hooks.min = min;
	    hooks.max = max;
	    hooks.now = now;
	    hooks.utc = createUTC;
	    hooks.unix = createUnix;
	    hooks.months = listMonths;
	    hooks.isDate = isDate;
	    hooks.locale = getSetGlobalLocale;
	    hooks.invalid = createInvalid;
	    hooks.duration = createDuration;
	    hooks.isMoment = isMoment;
	    hooks.weekdays = listWeekdays;
	    hooks.parseZone = createInZone;
	    hooks.localeData = getLocale;
	    hooks.isDuration = isDuration;
	    hooks.monthsShort = listMonthsShort;
	    hooks.weekdaysMin = listWeekdaysMin;
	    hooks.defineLocale = defineLocale;
	    hooks.updateLocale = updateLocale;
	    hooks.locales = listLocales;
	    hooks.weekdaysShort = listWeekdaysShort;
	    hooks.normalizeUnits = normalizeUnits;
	    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
	    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
	    hooks.calendarFormat = getCalendarFormat;
	    hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

	    hooks.HTML5_FMT = {
	      DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
	      // <input type="datetime-local" />
	      DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
	      // <input type="datetime-local" step="1" />
	      DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
	      // <input type="datetime-local" step="0.001" />
	      DATE: 'YYYY-MM-DD',
	      // <input type="date" />
	      TIME: 'HH:mm',
	      // <input type="time" />
	      TIME_SECONDS: 'HH:mm:ss',
	      // <input type="time" step="1" />
	      TIME_MS: 'HH:mm:ss.SSS',
	      // <input type="time" step="0.001" />
	      WEEK: 'GGGG-[W]WW',
	      // <input type="week" />
	      MONTH: 'YYYY-MM' // <input type="month" />

	    };
	    return hooks;
	  });
	});

	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	_export(_export.S + _export.F * !_descriptors, 'Object', { defineProperties: _objectDps });

	var momentRange = createCommonjsModule(function (module, exports) {
	  !function (t, e) {
	    module.exports = e(moment);
	  }(commonjsGlobal, function (t) {
	    return function (t) {
	      function e(r) {
	        if (n[r]) return n[r].exports;
	        var o = n[r] = {
	          i: r,
	          l: !1,
	          exports: {}
	        };
	        return t[r].call(o.exports, o, o.exports, e), o.l = !0, o.exports;
	      }

	      var n = {};
	      return e.m = t, e.c = n, e.i = function (t) {
	        return t;
	      }, e.d = function (t, n, r) {
	        e.o(t, n) || Object.defineProperty(t, n, {
	          configurable: !1,
	          enumerable: !0,
	          get: r
	        });
	      }, e.n = function (t) {
	        var n = t && t.__esModule ? function () {
	          return t.default;
	        } : function () {
	          return t;
	        };
	        return e.d(n, "a", n), n;
	      }, e.o = function (t, e) {
	        return Object.prototype.hasOwnProperty.call(t, e);
	      }, e.p = "", e(e.s = 3);
	    }([function (t, e, n) {

	      var r = n(5)();

	      t.exports = function (t) {
	        return t !== r && null !== t;
	      };
	    }, function (t, e, n) {

	      t.exports = n(18)() ? Symbol : n(20);
	    }, function (e, n) {
	      e.exports = t;
	    }, function (t, e, n) {

	      function r(t) {
	        return t && t.__esModule ? t : {
	          default: t
	        };
	      }

	      function o(t, e, n) {
	        return e in t ? Object.defineProperty(t, e, {
	          value: n,
	          enumerable: !0,
	          configurable: !0,
	          writable: !0
	        }) : t[e] = n, t;
	      }

	      function i(t, e) {
	        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	      }

	      function u(t) {
	        return t.range = function (e, n) {
	          var r = this;
	          return "string" == typeof e && y.hasOwnProperty(e) ? new h(t(r).startOf(e), t(r).endOf(e)) : new h(e, n);
	        }, t.rangeFromInterval = function (e) {
	          var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
	              r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t();
	          if (t.isMoment(r) || (r = t(r)), !r.isValid()) throw new Error("Invalid date.");
	          var o = r.clone().add(n, e),
	              i = [];
	          return i.push(t.min(r, o)), i.push(t.max(r, o)), new h(i);
	        }, t.rangeFromISOString = function (e) {
	          var n = a(e),
	              r = t.parseZone(n[0]),
	              o = t.parseZone(n[1]);
	          return new h(r, o);
	        }, t.parseZoneRange = t.rangeFromISOString, t.fn.range = t.range, t.range.constructor = h, t.isRange = function (t) {
	          return t instanceof h;
	        }, t.fn.within = function (t) {
	          return t.contains(this.toDate());
	        }, t;
	      }

	      function a(t) {
	        return t.split("/");
	      }

	      Object.defineProperty(e, "__esModule", {
	        value: !0
	      }), e.DateRange = void 0;

	      var s = function () {
	        function t(t, e) {
	          var n = [],
	              r = !0,
	              o = !1,
	              i = void 0;

	          try {
	            for (var u, a = t[Symbol.iterator](); !(r = (u = a.next()).done) && (n.push(u.value), !e || n.length !== e); r = !0) {
	            }
	          } catch (t) {
	            o = !0, i = t;
	          } finally {
	            try {
	              !r && a.return && a.return();
	            } finally {
	              if (o) throw i;
	            }
	          }

	          return n;
	        }

	        return function (e, n) {
	          if (Array.isArray(e)) return e;
	          if (Symbol.iterator in Object(e)) return t(e, n);
	          throw new TypeError("Invalid attempt to destructure non-iterable instance");
	        };
	      }(),
	          c = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (t) {
	        return _typeof(t);
	      } : function (t) {
	        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : _typeof(t);
	      },
	          f = function () {
	        function t(t, e) {
	          for (var n = 0; n < e.length; n++) {
	            var r = e[n];
	            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
	          }
	        }

	        return function (e, n, r) {
	          return n && t(e.prototype, n), r && t(e, r), e;
	        };
	      }();

	      e.extendMoment = u;

	      var l = n(2),
	          v = r(l),
	          d = n(1),
	          p = r(d),
	          y = {
	        year: !0,
	        quarter: !0,
	        month: !0,
	        week: !0,
	        day: !0,
	        hour: !0,
	        minute: !0,
	        second: !0
	      },
	          h = e.DateRange = function () {
	        function t(e, n) {
	          i(this, t);
	          var r = e,
	              o = n;
	          if (1 === arguments.length || void 0 === n) if ("object" === (void 0 === e ? "undefined" : c(e)) && 2 === e.length) {
	            var u = s(e, 2);
	            r = u[0], o = u[1];
	          } else if ("string" == typeof e) {
	            var f = a(e),
	                l = s(f, 2);
	            r = l[0], o = l[1];
	          }
	          this.start = r || 0 === r ? (0, v.default)(r) : (0, v.default)(-864e13), this.end = o || 0 === o ? (0, v.default)(o) : (0, v.default)(864e13);
	        }

	        return f(t, [{
	          key: "adjacent",
	          value: function value(t) {
	            var e = this.start.isSame(t.end),
	                n = this.end.isSame(t.start);
	            return e && t.start.valueOf() <= this.start.valueOf() || n && t.end.valueOf() >= this.end.valueOf();
	          }
	        }, {
	          key: "add",
	          value: function value(t) {
	            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
	              adjacent: !1
	            };
	            return this.overlaps(t, e) ? new this.constructor(v.default.min(this.start, t.start), v.default.max(this.end, t.end)) : null;
	          }
	        }, {
	          key: "by",
	          value: function value(t) {
	            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
	              excludeEnd: !1,
	              step: 1
	            },
	                n = this;
	            return o({}, p.default.iterator, function () {
	              var r = e.step || 1,
	                  o = Math.abs(n.start.diff(n.end, t)) / r,
	                  i = e.excludeEnd || !1,
	                  u = 0;
	              return e.hasOwnProperty("exclusive") && (i = e.exclusive), {
	                next: function next() {
	                  var e = n.start.clone().add(u * r, t),
	                      a = i ? !(u < o) : !(u <= o);
	                  return u++, {
	                    done: a,
	                    value: a ? void 0 : e
	                  };
	                }
	              };
	            });
	          }
	        }, {
	          key: "byRange",
	          value: function value(t) {
	            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
	              excludeEnd: !1,
	              step: 1
	            },
	                n = this,
	                r = e.step || 1,
	                i = this.valueOf() / t.valueOf() / r,
	                u = Math.floor(i),
	                a = e.excludeEnd || !1,
	                s = 0;
	            return e.hasOwnProperty("exclusive") && (a = e.exclusive), o({}, p.default.iterator, function () {
	              return u === 1 / 0 ? {
	                done: !0
	              } : {
	                next: function next() {
	                  var e = (0, v.default)(n.start.valueOf() + t.valueOf() * s * r),
	                      o = u === i && a ? !(s < u) : !(s <= u);
	                  return s++, {
	                    done: o,
	                    value: o ? void 0 : e
	                  };
	                }
	              };
	            });
	          }
	        }, {
	          key: "center",
	          value: function value() {
	            var t = this.start.valueOf() + this.diff() / 2;
	            return (0, v.default)(t);
	          }
	        }, {
	          key: "clone",
	          value: function value() {
	            return new this.constructor(this.start.clone(), this.end.clone());
	          }
	        }, {
	          key: "contains",
	          value: function value(e) {
	            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
	              excludeStart: !1,
	              excludeEnd: !1
	            },
	                r = this.start.valueOf(),
	                o = this.end.valueOf(),
	                i = e.valueOf(),
	                u = e.valueOf(),
	                a = n.excludeStart || !1,
	                s = n.excludeEnd || !1;
	            n.hasOwnProperty("exclusive") && (a = s = n.exclusive), e instanceof t && (i = e.start.valueOf(), u = e.end.valueOf());
	            var c = r < i || r <= i && !a,
	                f = o > u || o >= u && !s;
	            return c && f;
	          }
	        }, {
	          key: "diff",
	          value: function value(t, e) {
	            return this.end.diff(this.start, t, e);
	          }
	        }, {
	          key: "duration",
	          value: function value(t, e) {
	            return this.diff(t, e);
	          }
	        }, {
	          key: "intersect",
	          value: function value(t) {
	            var e = this.start.valueOf(),
	                n = this.end.valueOf(),
	                r = t.start.valueOf(),
	                o = t.end.valueOf(),
	                i = e == n,
	                u = r == o;

	            if (i) {
	              var a = e;
	              if (a == r || a == o) return null;
	              if (a > r && a < o) return this.clone();
	            } else if (u) {
	              var s = r;
	              if (s == e || s == n) return null;
	              if (s > e && s < n) return new this.constructor(s, s);
	            }

	            return e <= r && r < n && n < o ? new this.constructor(r, n) : r < e && e < o && o <= n ? new this.constructor(e, o) : r < e && e <= n && n < o ? this.clone() : e <= r && r <= o && o <= n ? new this.constructor(r, o) : null;
	          }
	        }, {
	          key: "isEqual",
	          value: function value(t) {
	            return this.start.isSame(t.start) && this.end.isSame(t.end);
	          }
	        }, {
	          key: "isSame",
	          value: function value(t) {
	            return this.isEqual(t);
	          }
	        }, {
	          key: "overlaps",
	          value: function value(t) {
	            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
	              adjacent: !1
	            },
	                n = null !== this.intersect(t);
	            return e.adjacent && !n ? this.adjacent(t) : n;
	          }
	        }, {
	          key: "reverseBy",
	          value: function value(t) {
	            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
	              excludeStart: !1,
	              step: 1
	            },
	                n = this;
	            return o({}, p.default.iterator, function () {
	              var r = e.step || 1,
	                  o = Math.abs(n.start.diff(n.end, t)) / r,
	                  i = e.excludeStart || !1,
	                  u = 0;
	              return e.hasOwnProperty("exclusive") && (i = e.exclusive), {
	                next: function next() {
	                  var e = n.end.clone().subtract(u * r, t),
	                      a = i ? !(u < o) : !(u <= o);
	                  return u++, {
	                    done: a,
	                    value: a ? void 0 : e
	                  };
	                }
	              };
	            });
	          }
	        }, {
	          key: "reverseByRange",
	          value: function value(t) {
	            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
	              excludeStart: !1,
	              step: 1
	            },
	                n = this,
	                r = e.step || 1,
	                i = this.valueOf() / t.valueOf() / r,
	                u = Math.floor(i),
	                a = e.excludeStart || !1,
	                s = 0;
	            return e.hasOwnProperty("exclusive") && (a = e.exclusive), o({}, p.default.iterator, function () {
	              return u === 1 / 0 ? {
	                done: !0
	              } : {
	                next: function next() {
	                  var e = (0, v.default)(n.end.valueOf() - t.valueOf() * s * r),
	                      o = u === i && a ? !(s < u) : !(s <= u);
	                  return s++, {
	                    done: o,
	                    value: o ? void 0 : e
	                  };
	                }
	              };
	            });
	          }
	        }, {
	          key: "snapTo",
	          value: function value(t) {
	            var e = this.clone();
	            return e.start.isSame((0, v.default)(-864e13)) || (e.start = e.start.startOf(t)), e.end.isSame((0, v.default)(864e13)) || (e.end = e.end.endOf(t)), e;
	          }
	        }, {
	          key: "subtract",
	          value: function value(t) {
	            var e = this.start.valueOf(),
	                n = this.end.valueOf(),
	                r = t.start.valueOf(),
	                o = t.end.valueOf();
	            return null === this.intersect(t) ? [this] : r <= e && e < n && n <= o ? [] : r <= e && e < o && o < n ? [new this.constructor(o, n)] : e < r && r < n && n <= o ? [new this.constructor(e, r)] : e < r && r < o && o < n ? [new this.constructor(e, r), new this.constructor(o, n)] : e < r && r < n && o < n ? [new this.constructor(e, r), new this.constructor(r, n)] : [];
	          }
	        }, {
	          key: "toDate",
	          value: function value() {
	            return [this.start.toDate(), this.end.toDate()];
	          }
	        }, {
	          key: "toString",
	          value: function value() {
	            return this.start.format() + "/" + this.end.format();
	          }
	        }, {
	          key: "valueOf",
	          value: function value() {
	            return this.end.valueOf() - this.start.valueOf();
	          }
	        }]), t;
	      }();
	    }, function (t, e, n) {

	      var r,
	          o = n(6),
	          i = n(13),
	          u = n(9),
	          a = n(15);
	      r = t.exports = function (t, e) {
	        var n, r, u, s, c;
	        return arguments.length < 2 || "string" != typeof t ? (s = e, e = t, t = null) : s = arguments[2], null == t ? (n = u = !0, r = !1) : (n = a.call(t, "c"), r = a.call(t, "e"), u = a.call(t, "w")), c = {
	          value: e,
	          configurable: n,
	          enumerable: r,
	          writable: u
	        }, s ? o(i(s), c) : c;
	      }, r.gs = function (t, e, n) {
	        var r, s, c, f;
	        return "string" != typeof t ? (c = n, n = e, e = t, t = null) : c = arguments[3], null == e ? e = void 0 : u(e) ? null == n ? n = void 0 : u(n) || (c = n, n = void 0) : (c = e, e = n = void 0), null == t ? (r = !0, s = !1) : (r = a.call(t, "c"), s = a.call(t, "e")), f = {
	          get: e,
	          set: n,
	          configurable: r,
	          enumerable: s
	        }, c ? o(i(c), f) : f;
	      };
	    }, function (t, e, n) {

	      t.exports = function () {};
	    }, function (t, e, n) {

	      t.exports = n(7)() ? Object.assign : n(8);
	    }, function (t, e, n) {

	      t.exports = function () {
	        var t,
	            e = Object.assign;
	        return "function" == typeof e && (t = {
	          foo: "raz"
	        }, e(t, {
	          bar: "dwa"
	        }, {
	          trzy: "trzy"
	        }), t.foo + t.bar + t.trzy === "razdwatrzy");
	      };
	    }, function (t, e, n) {

	      var r = n(10),
	          o = n(14),
	          i = Math.max;

	      t.exports = function (t, e) {
	        var n,
	            u,
	            a,
	            s = i(arguments.length, 2);

	        for (t = Object(o(t)), a = function a(r) {
	          try {
	            t[r] = e[r];
	          } catch (t) {
	            n || (n = t);
	          }
	        }, u = 1; u < s; ++u) {
	          e = arguments[u], r(e).forEach(a);
	        }

	        if (void 0 !== n) throw n;
	        return t;
	      };
	    }, function (t, e, n) {

	      t.exports = function (t) {
	        return "function" == typeof t;
	      };
	    }, function (t, e, n) {

	      t.exports = n(11)() ? Object.keys : n(12);
	    }, function (t, e, n) {

	      t.exports = function () {
	        try {
	          return !0;
	        } catch (t) {
	          return !1;
	        }
	      };
	    }, function (t, e, n) {

	      var r = n(0),
	          o = Object.keys;

	      t.exports = function (t) {
	        return o(r(t) ? Object(t) : t);
	      };
	    }, function (t, e, n) {

	      var r = n(0),
	          o = Array.prototype.forEach,
	          i = Object.create,
	          u = function u(t, e) {
	        var n;

	        for (n in t) {
	          e[n] = t[n];
	        }
	      };

	      t.exports = function (t) {
	        var e = i(null);
	        return o.call(arguments, function (t) {
	          r(t) && u(Object(t), e);
	        }), e;
	      };
	    }, function (t, e, n) {

	      var r = n(0);

	      t.exports = function (t) {
	        if (!r(t)) throw new TypeError("Cannot use null or undefined");
	        return t;
	      };
	    }, function (t, e, n) {

	      t.exports = n(16)() ? String.prototype.contains : n(17);
	    }, function (t, e, n) {

	      var r = "razdwatrzy";

	      t.exports = function () {
	        return "function" == typeof r.contains && !0 === r.contains("dwa") && !1 === r.contains("foo");
	      };
	    }, function (t, e, n) {

	      var r = String.prototype.indexOf;

	      t.exports = function (t) {
	        return r.call(this, t, arguments[1]) > -1;
	      };
	    }, function (t, e, n) {

	      var r = {
	        object: !0,
	        symbol: !0
	      };

	      t.exports = function () {
	        if ("function" != typeof Symbol) return !1;

	        try {
	        } catch (t) {
	          return !1;
	        }

	        return !!r[_typeof(Symbol.iterator)] && !!r[_typeof(Symbol.toPrimitive)] && !!r[_typeof(Symbol.toStringTag)];
	      };
	    }, function (t, e, n) {

	      t.exports = function (t) {
	        return !!t && ("symbol" == _typeof(t) || !!t.constructor && "Symbol" === t.constructor.name && "Symbol" === t[t.constructor.toStringTag]);
	      };
	    }, function (t, e, n) {

	      var r,
	          o,
	          _i,
	          u,
	          a = n(4),
	          s = n(21),
	          c = Object.create,
	          f = Object.defineProperties,
	          l = Object.defineProperty,
	          v = Object.prototype,
	          d = c(null);

	      if ("function" == typeof Symbol) {
	        r = Symbol;

	        try {
	          String(r()), u = !0;
	        } catch (t) {}
	      }

	      var p = function () {
	        var t = c(null);
	        return function (e) {
	          for (var n, r, o = 0; t[e + (o || "")];) {
	            ++o;
	          }

	          return e += o || "", t[e] = !0, n = "@@" + e, l(v, n, a.gs(null, function (t) {
	            r || (r = !0, l(this, n, a(t)), r = !1);
	          })), n;
	        };
	      }();

	      _i = function i(t) {
	        if (this instanceof _i) throw new TypeError("Symbol is not a constructor");
	        return o(t);
	      }, t.exports = o = function t(e) {
	        var n;
	        if (this instanceof t) throw new TypeError("Symbol is not a constructor");
	        return u ? r(e) : (n = c(_i.prototype), e = void 0 === e ? "" : String(e), f(n, {
	          __description__: a("", e),
	          __name__: a("", p(e))
	        }));
	      }, f(o, {
	        for: a(function (t) {
	          return d[t] ? d[t] : d[t] = o(String(t));
	        }),
	        keyFor: a(function (t) {
	          var e;
	          s(t);

	          for (e in d) {
	            if (d[e] === t) return e;
	          }
	        }),
	        hasInstance: a("", r && r.hasInstance || o("hasInstance")),
	        isConcatSpreadable: a("", r && r.isConcatSpreadable || o("isConcatSpreadable")),
	        iterator: a("", r && r.iterator || o("iterator")),
	        match: a("", r && r.match || o("match")),
	        replace: a("", r && r.replace || o("replace")),
	        search: a("", r && r.search || o("search")),
	        species: a("", r && r.species || o("species")),
	        split: a("", r && r.split || o("split")),
	        toPrimitive: a("", r && r.toPrimitive || o("toPrimitive")),
	        toStringTag: a("", r && r.toStringTag || o("toStringTag")),
	        unscopables: a("", r && r.unscopables || o("unscopables"))
	      }), f(_i.prototype, {
	        constructor: a(o),
	        toString: a("", function () {
	          return this.__name__;
	        })
	      }), f(o.prototype, {
	        toString: a(function () {
	          return "Symbol (" + s(this).__description__ + ")";
	        }),
	        valueOf: a(function () {
	          return s(this);
	        })
	      }), l(o.prototype, o.toPrimitive, a("", function () {
	        var t = s(this);
	        return "symbol" == _typeof(t) ? t : t.toString();
	      })), l(o.prototype, o.toStringTag, a("c", "Symbol")), l(_i.prototype, o.toStringTag, a("c", o.prototype[o.toStringTag])), l(_i.prototype, o.toPrimitive, a("c", o.prototype[o.toPrimitive]));
	    }, function (t, e, n) {

	      var r = n(19);

	      t.exports = function (t) {
	        if (!r(t)) throw new TypeError(t + " is not a symbol");
	        return t;
	      };
	    }]);
	  });
	});
	unwrapExports(momentRange);

	function _interopDefault$1(ex) {
	  return ex && _typeof(ex) === 'object' && 'default' in ex ? ex['default'] : ex;
	}

	var _regeneratorRuntime = _interopDefault$1(regenerator);

	var _asyncToGenerator$2 = _interopDefault$1(asyncToGenerator);

	var _classCallCheck$2 = _interopDefault$1(classCallCheck);

	var _createClass$3 = _interopDefault$1(createClass$1);

	var fetch = _interopDefault$1(browserPonyfill);

	var _objectSpread$2 = _interopDefault$1(objectSpread);

	var _slicedToArray$2 = _interopDefault$1(slicedToArray);

	var _defineProperty$2 = _interopDefault$1(defineProperty$1);

	var _objectWithoutProperties$2 = _interopDefault$1(objectWithoutProperties);

	var Moment = _interopDefault$1(moment);

	var momentRange$2 = _interopDefault$1(momentRange);

	var moment$1 = momentRange$2.extendMoment(Moment);
	var TIME_SERIES = {
	  day: function day(range) {
	    return Array.from(range.by('day')).map(function (d) {
	      return d.format('YYYY-MM-DDT00:00:00.000');
	    });
	  },
	  month: function month(range) {
	    return Array.from(range.snapTo('month').by('month')).map(function (d) {
	      return d.format('YYYY-MM-01T00:00:00.000');
	    });
	  },
	  year: function year(range) {
	    return Array.from(range.snapTo('year').by('year')).map(function (d) {
	      return d.format('YYYY-01-01T00:00:00.000');
	    });
	  },
	  hour: function hour(range) {
	    return Array.from(range.by('hour')).map(function (d) {
	      return d.format('YYYY-MM-DDTHH:00:00.000');
	    });
	  },
	  week: function week(range) {
	    return Array.from(range.snapTo('isoweek').by('week')).map(function (d) {
	      return d.startOf('isoweek').format('YYYY-MM-DDT00:00:00.000');
	    });
	  }
	};

	var ResultSet =
	/*#__PURE__*/
	function () {
	  function ResultSet(loadResponse) {
	    _classCallCheck$2(this, ResultSet);

	    this.loadResponse = loadResponse;
	  }

	  _createClass$3(ResultSet, [{
	    key: "series",
	    value: function series(pivotConfig) {
	      var _this = this;

	      return this.seriesNames(pivotConfig).map(function (_ref) {
	        var title = _ref.title,
	            key = _ref.key;
	        return {
	          title: title,
	          series: _this.chartPivot(pivotConfig).map(function (_ref2) {
	            var category = _ref2.category,
	                x = _ref2.x,
	                obj = _objectWithoutProperties$2(_ref2, ["category", "x"]);

	            return {
	              value: obj[key],
	              category: category,
	              x: x
	            };
	          })
	        };
	      });
	    }
	  }, {
	    key: "axisValues",
	    value: function axisValues(axis) {
	      var query = this.loadResponse.query;
	      return function (row) {
	        var value = function value(measure) {
	          return axis.filter(function (d) {
	            return d !== 'measures';
	          }).map(function (d) {
	            return row[d] != null ? row[d] : null;
	          }).concat(measure ? [measure] : []);
	        };

	        if (axis.find(function (d) {
	          return d === 'measures';
	        }) && (query.measures || []).length) {
	          return query.measures.map(value);
	        }

	        return [value()];
	      };
	    }
	  }, {
	    key: "axisValuesString",
	    value: function axisValuesString(axisValues, delimiter) {
	      var formatValue = function formatValue(v) {
	        if (v == null) {
	          return 'â';
	        } else if (v === '') {
	          return '[Empty string]';
	        } else {
	          return v;
	        }
	      };

	      return axisValues.map(formatValue).join(delimiter || ', ');
	    }
	  }, {
	    key: "normalizePivotConfig",
	    value: function normalizePivotConfig(pivotConfig) {
	      var query = this.loadResponse.query;
	      var timeDimensions = (query.timeDimensions || []).filter(function (td) {
	        return !!td.granularity;
	      });
	      pivotConfig = pivotConfig || (timeDimensions.length ? {
	        x: timeDimensions.map(function (td) {
	          return td.dimension;
	        }),
	        y: query.dimensions || []
	      } : {
	        x: query.dimensions || [],
	        y: []
	      });
	      pivotConfig.x = pivotConfig.x || [];
	      pivotConfig.y = pivotConfig.y || [];
	      var allIncludedDimensions = pivotConfig.x.concat(pivotConfig.y);
	      var allDimensions = timeDimensions.map(function (td) {
	        return td.dimension;
	      }).concat(query.dimensions);
	      pivotConfig.x = pivotConfig.x.concat(allDimensions.filter(function (d) {
	        return allIncludedDimensions.indexOf(d) === -1;
	      }));

	      if (!pivotConfig.x.concat(pivotConfig.y).find(function (d) {
	        return d === 'measures';
	      })) {
	        pivotConfig.y = pivotConfig.y.concat(['measures']);
	      }

	      if (pivotConfig.fillMissingDates == null) {
	        pivotConfig.fillMissingDates = true;
	      }

	      return pivotConfig;
	    }
	  }, {
	    key: "timeSeries",
	    value: function timeSeries(timeDimension) {
	      if (!timeDimension.granularity) {
	        return null;
	      }

	      var dateRange = timeDimension.dateRange;

	      if (!dateRange) {
	        var dates = es.pipe(es.map(function (row) {
	          return row[timeDimension.dimension] && moment$1(row[timeDimension.dimension]);
	        }), es.filter(function (r) {
	          return !!r;
	        }))(this.loadResponse.data);
	        dateRange = dates.length && [es.reduce(es.minBy(function (d) {
	          return d.toDate();
	        }), dates[0], dates), es.reduce(es.maxBy(function (d) {
	          return d.toDate();
	        }), dates[0], dates)] || null;
	      }

	      if (!dateRange) {
	        return null;
	      }

	      var start = moment$1(dateRange[0]).format('YYYY-MM-DD 00:00:00');
	      var end = moment$1(dateRange[1]).format('YYYY-MM-DD 23:59:59');
	      var range = moment$1.range(start, end);

	      if (!TIME_SERIES[timeDimension.granularity]) {
	        throw new Error("Unsupported time granularity: ".concat(timeDimension.granularity));
	      }

	      return TIME_SERIES[timeDimension.granularity](range);
	    }
	  }, {
	    key: "pivot",
	    value: function pivot(pivotConfig) {
	      var _this2 = this;

	      pivotConfig = this.normalizePivotConfig(pivotConfig);
	      var groupByXAxis = es.groupBy(function (_ref3) {
	        var xValues = _ref3.xValues;
	        return _this2.axisValuesString(xValues);
	      }); // eslint-disable-next-line no-unused-vars

	      var measureValue = function measureValue(row, measure, xValues) {
	        return row[measure];
	      };

	      if (pivotConfig.fillMissingDates && pivotConfig.x.length === 1 && es.equals(pivotConfig.x, (this.loadResponse.query.timeDimensions || []).filter(function (td) {
	        return !!td.granularity;
	      }).map(function (td) {
	        return td.dimension;
	      }))) {
	        var series = this.timeSeries(this.loadResponse.query.timeDimensions[0]);

	        if (series) {
	          groupByXAxis = function groupByXAxis(rows) {
	            var byXValues = es.groupBy(function (_ref4) {
	              var xValues = _ref4.xValues;
	              return moment$1(xValues[0]).format(moment$1.HTML5_FMT.DATETIME_LOCAL_MS);
	            }, rows);
	            return series.map(function (d) {
	              return _defineProperty$2({}, d, byXValues[d] || [{
	                xValues: [d],
	                row: {}
	              }]);
	            }).reduce(function (a, b) {
	              return Object.assign(a, b);
	            }, {});
	          }; // eslint-disable-next-line no-unused-vars


	          measureValue = function measureValue(row, measure, xValues) {
	            return row[measure] || 0;
	          };
	        }
	      }

	      var xGrouped = es.pipe(es.map(function (row) {
	        return _this2.axisValues(pivotConfig.x)(row).map(function (xValues) {
	          return {
	            xValues: xValues,
	            row: row
	          };
	        });
	      }), es.unnest, groupByXAxis, es.toPairs)(this.loadResponse.data);
	      var allYValues = es.pipe(es.map( // eslint-disable-next-line no-unused-vars
	      function (_ref6) {
	        var _ref7 = _slicedToArray$2(_ref6, 2),
	            xValuesString = _ref7[0],
	            rows = _ref7[1];

	        return es.unnest( // collect Y values only from filled rows
	        rows.filter(function (_ref8) {
	          var row = _ref8.row;
	          return Object.keys(row).length > 0;
	        }).map(function (_ref9) {
	          var row = _ref9.row;
	          return _this2.axisValues(pivotConfig.y)(row);
	        }));
	      }), es.unnest, es.uniq)(xGrouped); // eslint-disable-next-line no-unused-vars

	      return xGrouped.map(function (_ref10) {
	        var _ref11 = _slicedToArray$2(_ref10, 2),
	            xValuesString = _ref11[0],
	            rows = _ref11[1];

	        var xValues = rows[0].xValues;
	        var yGrouped = es.pipe(es.map(function (_ref12) {
	          var row = _ref12.row;
	          return _this2.axisValues(pivotConfig.y)(row).map(function (yValues) {
	            return {
	              yValues: yValues,
	              row: row
	            };
	          });
	        }), es.unnest, es.groupBy(function (_ref13) {
	          var yValues = _ref13.yValues;
	          return _this2.axisValuesString(yValues);
	        }))(rows);
	        return {
	          xValues: xValues,
	          yValuesArray: es.unnest(allYValues.map(function (yValues) {
	            var measure = pivotConfig.x.find(function (d) {
	              return d === 'measures';
	            }) ? ResultSet.measureFromAxis(xValues) : ResultSet.measureFromAxis(yValues);
	            return (yGrouped[_this2.axisValuesString(yValues)] || [{
	              row: {}
	            }]).map(function (_ref14) {
	              var row = _ref14.row;
	              return [yValues, measureValue(row, measure, xValues)];
	            });
	          }))
	        };
	      });
	    }
	  }, {
	    key: "pivotedRows",
	    value: function pivotedRows(pivotConfig) {
	      // TODO
	      return this.chartPivot(pivotConfig);
	    }
	  }, {
	    key: "chartPivot",
	    value: function chartPivot(pivotConfig) {
	      var _this3 = this;

	      return this.pivot(pivotConfig).map(function (_ref15) {
	        var xValues = _ref15.xValues,
	            yValuesArray = _ref15.yValuesArray;
	        return _objectSpread$2({
	          category: _this3.axisValuesString(xValues, ', '),
	          // TODO deprecated
	          x: _this3.axisValuesString(xValues, ', ')
	        }, yValuesArray.map(function (_ref16) {
	          var _ref17 = _slicedToArray$2(_ref16, 2),
	              yValues = _ref17[0],
	              m = _ref17[1];

	          return _defineProperty$2({}, _this3.axisValuesString(yValues, ', '), m && Number.parseFloat(m));
	        }).reduce(function (a, b) {
	          return Object.assign(a, b);
	        }, {}));
	      });
	    }
	  }, {
	    key: "tablePivot",
	    value: function tablePivot(pivotConfig) {
	      var normalizedPivotConfig = this.normalizePivotConfig(pivotConfig);

	      var valueToObject = function valueToObject(valuesArray, measureValue) {
	        return function (field, index) {
	          return _defineProperty$2({}, field === 'measures' ? valuesArray[index] : field, field === 'measures' ? measureValue : valuesArray[index]);
	        };
	      };

	      return this.pivot(normalizedPivotConfig).map(function (_ref20) {
	        var xValues = _ref20.xValues,
	            yValuesArray = _ref20.yValuesArray;
	        return yValuesArray.map(function (_ref21) {
	          var _ref22 = _slicedToArray$2(_ref21, 2),
	              yValues = _ref22[0],
	              m = _ref22[1];

	          return normalizedPivotConfig.x.map(valueToObject(xValues, m)).concat(normalizedPivotConfig.y.map(valueToObject(yValues, m))).reduce(function (a, b) {
	            return Object.assign(a, b);
	          }, {});
	        }).reduce(function (a, b) {
	          return Object.assign(a, b);
	        }, {});
	      });
	    }
	  }, {
	    key: "tableColumns",
	    value: function tableColumns(pivotConfig) {
	      var _this4 = this;

	      var normalizedPivotConfig = this.normalizePivotConfig(pivotConfig);

	      var column = function column(field) {
	        return field === 'measures' ? (_this4.query().measures || []).map(function (m) {
	          return {
	            key: m,
	            title: _this4.loadResponse.annotation.measures[m].title
	          };
	        }) : [{
	          key: field,
	          title: (_this4.loadResponse.annotation.dimensions[field] || _this4.loadResponse.annotation.timeDimensions[field]).title
	        }];
	      };

	      return normalizedPivotConfig.x.map(column).concat(normalizedPivotConfig.y.map(column)).reduce(function (a, b) {
	        return a.concat(b);
	      });
	    }
	  }, {
	    key: "totalRow",
	    value: function totalRow() {
	      return this.chartPivot()[0];
	    }
	  }, {
	    key: "categories",
	    value: function categories(pivotConfig) {
	      // TODO
	      return this.chartPivot(pivotConfig);
	    }
	  }, {
	    key: "seriesNames",
	    value: function seriesNames(pivotConfig) {
	      var _this5 = this;

	      pivotConfig = this.normalizePivotConfig(pivotConfig);
	      return es.pipe(es.map(this.axisValues(pivotConfig.y)), es.unnest, es.uniq)(this.loadResponse.data).map(function (axisValues) {
	        return {
	          title: _this5.axisValuesString(pivotConfig.y.find(function (d) {
	            return d === 'measures';
	          }) ? es.dropLast(1, axisValues).concat(_this5.loadResponse.annotation.measures[ResultSet.measureFromAxis(axisValues)].title) : axisValues, ', '),
	          key: _this5.axisValuesString(axisValues)
	        };
	      });
	    }
	  }, {
	    key: "query",
	    value: function query() {
	      return this.loadResponse.query;
	    }
	  }, {
	    key: "rawData",
	    value: function rawData() {
	      return this.loadResponse.data;
	    }
	  }], [{
	    key: "measureFromAxis",
	    value: function measureFromAxis(axisValues) {
	      return axisValues[axisValues.length - 1];
	    }
	  }]);

	  return ResultSet;
	}();

	var SqlQuery =
	/*#__PURE__*/
	function () {
	  function SqlQuery(sqlQuery) {
	    _classCallCheck$2(this, SqlQuery);

	    this.sqlQuery = sqlQuery;
	  }

	  _createClass$3(SqlQuery, [{
	    key: "rawQuery",
	    value: function rawQuery() {
	      return this.sqlQuery.sql;
	    }
	  }, {
	    key: "sql",
	    value: function sql() {
	      return this.rawQuery().sql[0];
	    }
	  }]);

	  return SqlQuery;
	}();

	var memberMap = function memberMap(memberArray) {
	  return es.fromPairs(memberArray.map(function (m) {
	    return [m.name, m];
	  }));
	};

	var operators = {
	  string: [{
	    name: 'contains',
	    title: 'contains'
	  }, {
	    name: 'notContains',
	    title: 'does not contain'
	  }, {
	    name: 'equals',
	    title: 'equals'
	  }, {
	    name: 'notEquals',
	    title: 'does not equal'
	  }, {
	    name: 'set',
	    title: 'is set'
	  }, {
	    name: 'notSet',
	    title: 'is not set'
	  }],
	  number: [{
	    name: 'equals',
	    title: 'equals'
	  }, {
	    name: 'notEquals',
	    title: 'does not equal'
	  }, {
	    name: 'set',
	    title: 'is set'
	  }, {
	    name: 'notSet',
	    title: 'is not set'
	  }, {
	    name: 'gt',
	    title: '>'
	  }, {
	    name: 'gte',
	    title: '>='
	  }, {
	    name: 'lt',
	    title: '<'
	  }, {
	    name: 'lte',
	    title: '<='
	  }]
	};

	var Meta =
	/*#__PURE__*/
	function () {
	  function Meta(metaResponse) {
	    _classCallCheck$2(this, Meta);

	    this.meta = metaResponse;
	    var cubes = this.meta.cubes;
	    this.cubes = cubes;
	    this.cubesMap = es.fromPairs(cubes.map(function (c) {
	      return [c.name, {
	        measures: memberMap(c.measures),
	        dimensions: memberMap(c.dimensions),
	        segments: memberMap(c.segments)
	      }];
	    }));
	  }

	  _createClass$3(Meta, [{
	    key: "membersForQuery",
	    value: function membersForQuery(query, memberType) {
	      return es.unnest(this.cubes.map(function (c) {
	        return c[memberType];
	      }));
	    }
	  }, {
	    key: "resolveMember",
	    value: function resolveMember(memberName, memberType) {
	      var _this = this;

	      var _memberName$split = memberName.split('.'),
	          _memberName$split2 = _slicedToArray$2(_memberName$split, 1),
	          cube = _memberName$split2[0];

	      if (!this.cubesMap[cube]) {
	        return {
	          title: memberName,
	          error: "Cube not found ".concat(cube, " for path '").concat(memberName, "'")
	        };
	      }

	      var memberTypes = Array.isArray(memberType) ? memberType : [memberType];
	      var member = memberTypes.map(function (type) {
	        return _this.cubesMap[cube][type] && _this.cubesMap[cube][type][memberName];
	      }).find(function (m) {
	        return m;
	      });

	      if (!member) {
	        return {
	          title: memberName,
	          error: "Path not found '".concat(memberName, "'")
	        };
	      }

	      return member;
	    }
	  }, {
	    key: "defaultTimeDimensionNameFor",
	    value: function defaultTimeDimensionNameFor(memberName) {
	      var _this2 = this;

	      var _memberName$split3 = memberName.split('.'),
	          _memberName$split4 = _slicedToArray$2(_memberName$split3, 1),
	          cube = _memberName$split4[0];

	      if (!this.cubesMap[cube]) {
	        return null;
	      }

	      return Object.keys(this.cubesMap[cube].dimensions || {}).find(function (d) {
	        return _this2.cubesMap[cube].dimensions[d].type === 'time';
	      });
	    }
	  }, {
	    key: "filterOperatorsForMember",
	    value: function filterOperatorsForMember(memberName, memberType) {
	      var member = this.resolveMember(memberName, memberType);
	      return operators[member.type] || operators.string;
	    }
	  }]);

	  return Meta;
	}();

	var ProgressResult =
	/*#__PURE__*/
	function () {
	  function ProgressResult(progressResponse) {
	    _classCallCheck$2(this, ProgressResult);

	    this.progressResponse = progressResponse;
	  }

	  _createClass$3(ProgressResult, [{
	    key: "stage",
	    value: function stage() {
	      return this.progressResponse.stage;
	    }
	  }, {
	    key: "timeElapsed",
	    value: function timeElapsed() {
	      return this.progressResponse.timeElapsed;
	    }
	  }]);

	  return ProgressResult;
	}();

	var API_URL = "https://statsbot.co/cubejs-api/v1";
	var mutexCounter = 0;
	var MUTEX_ERROR = 'Mutex has been changed';

	var mutexPromise = function mutexPromise(promise) {
	  return new Promise(function (resolve, reject) {
	    promise.then(function (r) {
	      return resolve(r);
	    }, function (e) {
	      return e !== MUTEX_ERROR && reject(e);
	    });
	  });
	};

	var CubejsApi =
	/*#__PURE__*/
	function () {
	  function CubejsApi(apiToken, options) {
	    _classCallCheck$2(this, CubejsApi);

	    options = options || {};
	    this.apiToken = apiToken;
	    this.apiUrl = options.apiUrl || API_URL;
	  }

	  _createClass$3(CubejsApi, [{
	    key: "request",
	    value: function request(url, config) {
	      return fetch("".concat(this.apiUrl).concat(url), Object.assign({
	        headers: {
	          Authorization: this.apiToken,
	          'Content-Type': 'application/json'
	        }
	      }, config || {}));
	    }
	  }, {
	    key: "loadMethod",
	    value: function loadMethod(request, toResult, options, callback) {
	      var mutexValue = ++mutexCounter;

	      if (typeof options === 'function' && !callback) {
	        callback = options;
	        options = undefined;
	      }

	      options = options || {};
	      var mutexKey = options.mutexKey || 'default';

	      if (options.mutexObj) {
	        options.mutexObj[mutexKey] = mutexValue;
	      }

	      var checkMutex = function checkMutex() {
	        if (options.mutexObj && options.mutexObj[mutexKey] !== mutexValue) {
	          throw MUTEX_ERROR;
	        }
	      };

	      var loadImpl =
	      /*#__PURE__*/
	      function () {
	        var _ref = _asyncToGenerator$2(
	        /*#__PURE__*/
	        _regeneratorRuntime.mark(function _callee() {
	          var response, body;
	          return _regeneratorRuntime.wrap(function _callee$(_context) {
	            while (1) {
	              switch (_context.prev = _context.next) {
	                case 0:
	                  _context.next = 2;
	                  return request();

	                case 2:
	                  response = _context.sent;

	                  if (!(response.status === 502)) {
	                    _context.next = 6;
	                    break;
	                  }

	                  checkMutex();
	                  return _context.abrupt("return", loadImpl());

	                case 6:
	                  _context.next = 8;
	                  return response.json();

	                case 8:
	                  body = _context.sent;

	                  if (!(body.error === 'Continue wait')) {
	                    _context.next = 13;
	                    break;
	                  }

	                  checkMutex();

	                  if (options.progressCallback) {
	                    options.progressCallback(new ProgressResult(body));
	                  }

	                  return _context.abrupt("return", loadImpl());

	                case 13:
	                  if (!(response.status !== 200)) {
	                    _context.next = 16;
	                    break;
	                  }

	                  checkMutex();
	                  throw new Error(body.error);

	                case 16:
	                  checkMutex();
	                  return _context.abrupt("return", toResult(body));

	                case 18:
	                case "end":
	                  return _context.stop();
	              }
	            }
	          }, _callee, this);
	        }));

	        return function loadImpl() {
	          return _ref.apply(this, arguments);
	        };
	      }();

	      if (callback) {
	        mutexPromise(loadImpl()).then(function (r) {
	          return callback(null, r);
	        }, function (e) {
	          return callback(e);
	        });
	      } else {
	        return mutexPromise(loadImpl());
	      }
	    }
	  }, {
	    key: "load",
	    value: function load(query, options, callback) {
	      var _this = this;

	      return this.loadMethod(function () {
	        return _this.request("/load?query=".concat(encodeURIComponent(JSON.stringify(query))));
	      }, function (body) {
	        return new ResultSet(body);
	      }, options, callback);
	    }
	  }, {
	    key: "sql",
	    value: function sql(query, options, callback) {
	      var _this2 = this;

	      return this.loadMethod(function () {
	        return _this2.request("/sql?query=".concat(JSON.stringify(query)));
	      }, function (body) {
	        return new SqlQuery(body);
	      }, options, callback);
	    }
	  }, {
	    key: "meta",
	    value: function meta(options, callback) {
	      var _this3 = this;

	      return this.loadMethod(function () {
	        return _this3.request("/meta");
	      }, function (body) {
	        return new Meta(body);
	      }, options, callback);
	    }
	  }]);

	  return CubejsApi;
	}();

	var index = function index(apiToken, options) {
	  return new CubejsApi(apiToken, options);
	};

	var cubejsClientCore = index;

	exports.CubejsClient = class CubejsClient {
	    constructor(config$$1) {
	        this.config = config$$1;
	    }
	    apiInstace() {
	        if (!this.cubeJsApi) {
	            this.cubeJsApi = cubejsClientCore(this.config.token, this.config.options);
	        }
	        return this.cubeJsApi;
	    }
	    load(...params) {
	        return from(this.apiInstace().load(...params));
	    }
	    sql(...params) {
	        return from(this.apiInstace().sql(...params));
	    }
	    meta(...params) {
	        return from(this.apiInstace().meta(...params));
	    }
	    watch(query, params = {}) {
	        return Observable.create(observer => query.subscribe({
	            next: (query) => __awaiter(this, void 0, void 0, function* () {
	                const resultSet = yield this.apiInstace().load(query, params);
	                observer.next(resultSet);
	            })
	        }));
	    }
	};
	exports.CubejsClient = __decorate([
	    Injectable(),
	    __param(0, Inject('config')),
	    __metadata("design:paramtypes", [Object])
	], exports.CubejsClient);

	var CubejsClientModule_1;
	exports.CubejsClientModule = CubejsClientModule_1 = class CubejsClientModule {
	    static forRoot(config) {
	        return {
	            ngModule: CubejsClientModule_1,
	            providers: [
	                exports.CubejsClient,
	                {
	                    provide: 'config',
	                    useValue: config
	                }
	            ]
	        };
	    }
	};
	exports.CubejsClientModule = CubejsClientModule_1 = __decorate([
	    NgModule({
	        providers: [exports.CubejsClient]
	    })
	], exports.CubejsClientModule);

	/*
	 * Public API Surface of cubejs-client-ngx
	 */

	// This file is not used to build this module. It is only used during editing

	Object.defineProperty(exports, '__esModule', { value: true });

}));
