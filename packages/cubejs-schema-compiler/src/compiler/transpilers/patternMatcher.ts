import { performance } from 'perf_hooks';

/* this list was generated by getTransformPatterns() with additional variants for snake_case */
export const transpiledFieldsPatterns: string[] = [
  'sql',
  '(sqlTable|sql_table)',
  'measures.__id__.(drillMemberReferences|drillMembers|drill_members)',
  // 'measures.__id__.(orderBy|order_by).__idx__.sql', // Matched by simple `sql`
  'measures.__id__.(timeShift|time_shift).__idx__.(timeDimension|time_dimension)',
  'measures.__id__.(reduceBy|reduce_by|groupBy|group_by|addGroupBy|add_group_by)',
  'dimensions.__id__.(reduceBy|reduce_by|groupBy|group_by|addGroupBy|add_group_by)',
  '(preAggregations|pre_aggregations).__id__.indexes.__id__.columns',
  '(preAggregations|pre_aggregations).__id__.(timeDimensionReference|timeDimension|time_dimension|segments|dimensions|measures|rollups|segmentReferences|dimensionReferences|measureReferences|rollupReferences)',
  '(preAggregations|pre_aggregations).__id__.(timeDimensions|time_dimensions).__idx__.dimension',
  '(preAggregations|pre_aggregations).__id__.(outputColumnTypes|output_column_types).__idx__.member',
  'contextMembers',
  'includes',
  'excludes',
  'hierarchies.__id__.levels',
  'cubes.__idx__.(joinPath|join_path)',
  '(accessPolicy|access_policy).__idx__.(rowLevel|row_level).filters.__idx__.member',
  '(accessPolicy|access_policy).__idx__.(rowLevel|row_level).filters.__idx__.values',
  '(accessPolicy|access_policy).__idx__.conditions.__idx__.if',
];

export const transpiledFields: Set<String> = new Set<String>();

transpiledFieldsPatterns.forEach((r) => {
  const fields = r.toString().replace(/.*?([_a-zA-Z|][_a-zA-Z0-9|]*)([^_a-zA-Z0-9|]*)$/, '$1').split('|');
  fields.forEach((f) => transpiledFields.add(f));
});

interface Trie {
  children: { [key: string]: Trie };
  isEnd: boolean;
}

function insertIntoTrie(node: Trie, segments: string[]) {
  if (segments.length === 0) {
    node.isEnd = true;
    return;
  }

  // eslint-disable-next-line prefer-const
  let [first, ...rest] = segments;
  if (first.startsWith('(')) {
    first = first.slice(1);
    first = first.slice(0, -1);
  }

  const internalSegments = first.split('|');

  for (const internalSegment of internalSegments) {
    if (!node.children[internalSegment]) {
      node.children[internalSegment] = { children: {}, isEnd: false };
    }
    insertIntoTrie(node.children[internalSegment] as Trie, rest);
  }
}

function buildTrie(paths: string[]): Trie {
  const root: Trie = { children: {}, isEnd: false };

  for (const path of paths) {
    const segments = path.split('.');
    insertIntoTrie(root, segments);
  }

  return root;
}

const transpiledFieldsPatternsTree: Trie = buildTrie(transpiledFieldsPatterns);

function matchTree(node: Trie, segments: string[]): boolean {
  if (segments.length === 0) {
    return node.isEnd;
  }

  const [first, ...rest] = segments;

  if (node.children[first]) {
    return matchTree(node.children[first], rest);
  } else if (node.children.__idx__ && !Number.isNaN(+first)) {
    return matchTree(node.children.__idx__, rest);
  } else if (node.children.__id__) {
    return matchTree(node.children.__id__, rest);
  } else {
    return false;
  }
}

export const transpiledFieldMatch = (fullPath: string[]): boolean => {
  const matchEndings = ['sql', 'sqlTable', 'sql_table'];
  const last = fullPath[fullPath.length - 1];

  if (matchEndings.includes(last)) {
    return true;
  }

  return matchTree(transpiledFieldsPatternsTree, fullPath);
};
