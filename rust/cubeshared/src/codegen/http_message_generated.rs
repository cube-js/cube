// automatically generated by the FlatBuffers compiler, do not modify

// @generated

extern crate flatbuffers;

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_HTTP_COMMAND: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_HTTP_COMMAND: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_HTTP_COMMAND: [HttpCommand; 4] = [
    HttpCommand::NONE,
    HttpCommand::HttpQuery,
    HttpCommand::HttpResultSet,
    HttpCommand::HttpError,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct HttpCommand(pub u8);
#[allow(non_upper_case_globals)]
impl HttpCommand {
    pub const NONE: Self = Self(0);
    pub const HttpQuery: Self = Self(1);
    pub const HttpResultSet: Self = Self(2);
    pub const HttpError: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::HttpQuery,
        Self::HttpResultSet,
        Self::HttpError,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::HttpQuery => Some("HttpQuery"),
            Self::HttpResultSet => Some("HttpResultSet"),
            Self::HttpError => Some("HttpError"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for HttpCommand {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for HttpCommand {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for HttpCommand {
    type Output = HttpCommand;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for HttpCommand {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for HttpCommand {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for HttpCommand {}
pub struct HttpCommandUnionTableOffset {}

pub enum HttpMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HttpMessage<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpMessage<'a> {
    type Inner = HttpMessage<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HttpMessage<'a> {
    pub const VT_MESSAGE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_COMMAND_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_COMMAND: flatbuffers::VOffsetT = 8;
    pub const VT_CONNECTION_ID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HttpMessage { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HttpMessageArgs<'args>,
    ) -> flatbuffers::WIPOffset<HttpMessage<'bldr>> {
        let mut builder = HttpMessageBuilder::new(_fbb);
        if let Some(x) = args.connection_id {
            builder.add_connection_id(x);
        }
        if let Some(x) = args.command {
            builder.add_command(x);
        }
        builder.add_message_id(args.message_id);
        builder.add_command_type(args.command_type);
        builder.finish()
    }

    #[inline]
    pub fn message_id(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u32>(HttpMessage::VT_MESSAGE_ID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn command_type(&self) -> HttpCommand {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<HttpCommand>(HttpMessage::VT_COMMAND_TYPE, Some(HttpCommand::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn command(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    HttpMessage::VT_COMMAND,
                    None,
                )
        }
    }
    #[inline]
    pub fn connection_id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(HttpMessage::VT_CONNECTION_ID, None)
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_http_query(&self) -> Option<HttpQuery<'a>> {
        if self.command_type() == HttpCommand::HttpQuery {
            self.command().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { HttpQuery::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_http_result_set(&self) -> Option<HttpResultSet<'a>> {
        if self.command_type() == HttpCommand::HttpResultSet {
            self.command().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { HttpResultSet::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_http_error(&self) -> Option<HttpError<'a>> {
        if self.command_type() == HttpCommand::HttpError {
            self.command().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { HttpError::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for HttpMessage<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<u32>("message_id", Self::VT_MESSAGE_ID, false)?
            .visit_union::<HttpCommand, _>(
                "command_type",
                Self::VT_COMMAND_TYPE,
                "command",
                Self::VT_COMMAND,
                false,
                |key, v, pos| match key {
                    HttpCommand::HttpQuery => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<HttpQuery>>(
                            "HttpCommand::HttpQuery",
                            pos,
                        ),
                    HttpCommand::HttpResultSet => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<HttpResultSet>>(
                            "HttpCommand::HttpResultSet",
                            pos,
                        ),
                    HttpCommand::HttpError => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<HttpError>>(
                            "HttpCommand::HttpError",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "connection_id",
                Self::VT_CONNECTION_ID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct HttpMessageArgs<'a> {
    pub message_id: u32,
    pub command_type: HttpCommand,
    pub command: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub connection_id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HttpMessageArgs<'a> {
    #[inline]
    fn default() -> Self {
        HttpMessageArgs {
            message_id: 0,
            command_type: HttpCommand::NONE,
            command: None,
            connection_id: None,
        }
    }
}

pub struct HttpMessageBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpMessageBuilder<'a, 'b> {
    #[inline]
    pub fn add_message_id(&mut self, message_id: u32) {
        self.fbb_
            .push_slot::<u32>(HttpMessage::VT_MESSAGE_ID, message_id, 0);
    }
    #[inline]
    pub fn add_command_type(&mut self, command_type: HttpCommand) {
        self.fbb_.push_slot::<HttpCommand>(
            HttpMessage::VT_COMMAND_TYPE,
            command_type,
            HttpCommand::NONE,
        );
    }
    #[inline]
    pub fn add_command(&mut self, command: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpMessage::VT_COMMAND, command);
    }
    #[inline]
    pub fn add_connection_id(&mut self, connection_id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            HttpMessage::VT_CONNECTION_ID,
            connection_id,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HttpMessageBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HttpMessageBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HttpMessage<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HttpMessage<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HttpMessage");
        ds.field("message_id", &self.message_id());
        ds.field("command_type", &self.command_type());
        match self.command_type() {
            HttpCommand::HttpQuery => {
                if let Some(x) = self.command_as_http_query() {
                    ds.field("command", &x)
                } else {
                    ds.field(
                        "command",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            HttpCommand::HttpResultSet => {
                if let Some(x) = self.command_as_http_result_set() {
                    ds.field("command", &x)
                } else {
                    ds.field(
                        "command",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            HttpCommand::HttpError => {
                if let Some(x) = self.command_as_http_error() {
                    ds.field("command", &x)
                } else {
                    ds.field(
                        "command",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("command", &x)
            }
        };
        ds.field("connection_id", &self.connection_id());
        ds.finish()
    }
}
pub enum HttpQueryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HttpQuery<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpQuery<'a> {
    type Inner = HttpQuery<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HttpQuery<'a> {
    pub const VT_QUERY: flatbuffers::VOffsetT = 4;
    pub const VT_TRACE_OBJ: flatbuffers::VOffsetT = 6;
    pub const VT_INLINE_TABLES: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HttpQuery { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HttpQueryArgs<'args>,
    ) -> flatbuffers::WIPOffset<HttpQuery<'bldr>> {
        let mut builder = HttpQueryBuilder::new(_fbb);
        if let Some(x) = args.inline_tables {
            builder.add_inline_tables(x);
        }
        if let Some(x) = args.trace_obj {
            builder.add_trace_obj(x);
        }
        if let Some(x) = args.query {
            builder.add_query(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn query(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(HttpQuery::VT_QUERY, None)
        }
    }
    #[inline]
    pub fn trace_obj(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(HttpQuery::VT_TRACE_OBJ, None)
        }
    }
    #[inline]
    pub fn inline_tables(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpTable<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpTable>>,
            >>(HttpQuery::VT_INLINE_TABLES, None)
        }
    }
}

impl flatbuffers::Verifiable for HttpQuery<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("query", Self::VT_QUERY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "trace_obj",
                Self::VT_TRACE_OBJ,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<HttpTable>>,
            >>("inline_tables", Self::VT_INLINE_TABLES, false)?
            .finish();
        Ok(())
    }
}
pub struct HttpQueryArgs<'a> {
    pub query: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trace_obj: Option<flatbuffers::WIPOffset<&'a str>>,
    pub inline_tables: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpTable<'a>>>,
        >,
    >,
}
impl<'a> Default for HttpQueryArgs<'a> {
    #[inline]
    fn default() -> Self {
        HttpQueryArgs {
            query: None,
            trace_obj: None,
            inline_tables: None,
        }
    }
}

pub struct HttpQueryBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpQueryBuilder<'a, 'b> {
    #[inline]
    pub fn add_query(&mut self, query: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpQuery::VT_QUERY, query);
    }
    #[inline]
    pub fn add_trace_obj(&mut self, trace_obj: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpQuery::VT_TRACE_OBJ, trace_obj);
    }
    #[inline]
    pub fn add_inline_tables(
        &mut self,
        inline_tables: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<HttpTable<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            HttpQuery::VT_INLINE_TABLES,
            inline_tables,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HttpQueryBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HttpQueryBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HttpQuery<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HttpQuery<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HttpQuery");
        ds.field("query", &self.query());
        ds.field("trace_obj", &self.trace_obj());
        ds.field("inline_tables", &self.inline_tables());
        ds.finish()
    }
}
pub enum HttpTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HttpTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpTable<'a> {
    type Inner = HttpTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HttpTable<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_COLUMNS: flatbuffers::VOffsetT = 6;
    pub const VT_TYPES: flatbuffers::VOffsetT = 8;
    pub const VT_CSV_ROWS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HttpTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HttpTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<HttpTable<'bldr>> {
        let mut builder = HttpTableBuilder::new(_fbb);
        if let Some(x) = args.csv_rows {
            builder.add_csv_rows(x);
        }
        if let Some(x) = args.types {
            builder.add_types(x);
        }
        if let Some(x) = args.columns {
            builder.add_columns(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(HttpTable::VT_NAME, None)
        }
    }
    #[inline]
    pub fn columns(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(HttpTable::VT_COLUMNS, None)
        }
    }
    #[inline]
    pub fn types(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(HttpTable::VT_TYPES, None)
        }
    }
    #[inline]
    pub fn csv_rows(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(HttpTable::VT_CSV_ROWS, None)
        }
    }
}

impl flatbuffers::Verifiable for HttpTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("columns", Self::VT_COLUMNS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("types", Self::VT_TYPES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "csv_rows",
                Self::VT_CSV_ROWS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct HttpTableArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub columns: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub types: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub csv_rows: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HttpTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        HttpTableArgs {
            name: None,
            columns: None,
            types: None,
            csv_rows: None,
        }
    }
}

pub struct HttpTableBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpTableBuilder<'a, 'b> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpTable::VT_NAME, name);
    }
    #[inline]
    pub fn add_columns(
        &mut self,
        columns: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpTable::VT_COLUMNS, columns);
    }
    #[inline]
    pub fn add_types(
        &mut self,
        types: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpTable::VT_TYPES, types);
    }
    #[inline]
    pub fn add_csv_rows(&mut self, csv_rows: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpTable::VT_CSV_ROWS, csv_rows);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HttpTableBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HttpTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HttpTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HttpTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HttpTable");
        ds.field("name", &self.name());
        ds.field("columns", &self.columns());
        ds.field("types", &self.types());
        ds.field("csv_rows", &self.csv_rows());
        ds.finish()
    }
}
pub enum HttpErrorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HttpError<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpError<'a> {
    type Inner = HttpError<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HttpError<'a> {
    pub const VT_ERROR: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HttpError { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HttpErrorArgs<'args>,
    ) -> flatbuffers::WIPOffset<HttpError<'bldr>> {
        let mut builder = HttpErrorBuilder::new(_fbb);
        if let Some(x) = args.error {
            builder.add_error(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn error(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(HttpError::VT_ERROR, None)
        }
    }
}

impl flatbuffers::Verifiable for HttpError<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("error", Self::VT_ERROR, false)?
            .finish();
        Ok(())
    }
}
pub struct HttpErrorArgs<'a> {
    pub error: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HttpErrorArgs<'a> {
    #[inline]
    fn default() -> Self {
        HttpErrorArgs { error: None }
    }
}

pub struct HttpErrorBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpErrorBuilder<'a, 'b> {
    #[inline]
    pub fn add_error(&mut self, error: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpError::VT_ERROR, error);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HttpErrorBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HttpErrorBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HttpError<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HttpError<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HttpError");
        ds.field("error", &self.error());
        ds.finish()
    }
}
pub enum HttpResultSetOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HttpResultSet<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpResultSet<'a> {
    type Inner = HttpResultSet<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HttpResultSet<'a> {
    pub const VT_COLUMNS: flatbuffers::VOffsetT = 4;
    pub const VT_ROWS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HttpResultSet { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HttpResultSetArgs<'args>,
    ) -> flatbuffers::WIPOffset<HttpResultSet<'bldr>> {
        let mut builder = HttpResultSetBuilder::new(_fbb);
        if let Some(x) = args.rows {
            builder.add_rows(x);
        }
        if let Some(x) = args.columns {
            builder.add_columns(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn columns(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(HttpResultSet::VT_COLUMNS, None)
        }
    }
    #[inline]
    pub fn rows(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpRow<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpRow>>,
            >>(HttpResultSet::VT_ROWS, None)
        }
    }
}

impl flatbuffers::Verifiable for HttpResultSet<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("columns", Self::VT_COLUMNS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<HttpRow>>,
            >>("rows", Self::VT_ROWS, false)?
            .finish();
        Ok(())
    }
}
pub struct HttpResultSetArgs<'a> {
    pub columns: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub rows: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpRow<'a>>>>,
    >,
}
impl<'a> Default for HttpResultSetArgs<'a> {
    #[inline]
    fn default() -> Self {
        HttpResultSetArgs {
            columns: None,
            rows: None,
        }
    }
}

pub struct HttpResultSetBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpResultSetBuilder<'a, 'b> {
    #[inline]
    pub fn add_columns(
        &mut self,
        columns: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpResultSet::VT_COLUMNS, columns);
    }
    #[inline]
    pub fn add_rows(
        &mut self,
        rows: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<HttpRow<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpResultSet::VT_ROWS, rows);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HttpResultSetBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HttpResultSetBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HttpResultSet<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HttpResultSet<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HttpResultSet");
        ds.field("columns", &self.columns());
        ds.field("rows", &self.rows());
        ds.finish()
    }
}
pub enum HttpRowOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HttpRow<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpRow<'a> {
    type Inner = HttpRow<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HttpRow<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HttpRow { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HttpRowArgs<'args>,
    ) -> flatbuffers::WIPOffset<HttpRow<'bldr>> {
        let mut builder = HttpRowBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn values(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpColumnValue<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpColumnValue>>,
            >>(HttpRow::VT_VALUES, None)
        }
    }
}

impl flatbuffers::Verifiable for HttpRow<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<HttpColumnValue>>,
            >>("values", Self::VT_VALUES, false)?
            .finish();
        Ok(())
    }
}
pub struct HttpRowArgs<'a> {
    pub values: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpColumnValue<'a>>>,
        >,
    >,
}
impl<'a> Default for HttpRowArgs<'a> {
    #[inline]
    fn default() -> Self {
        HttpRowArgs { values: None }
    }
}

pub struct HttpRowBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpRowBuilder<'a, 'b> {
    #[inline]
    pub fn add_values(
        &mut self,
        values: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<HttpColumnValue<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpRow::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HttpRowBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HttpRowBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HttpRow<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HttpRow<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HttpRow");
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum HttpColumnValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HttpColumnValue<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpColumnValue<'a> {
    type Inner = HttpColumnValue<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HttpColumnValue<'a> {
    pub const VT_STRING_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HttpColumnValue { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HttpColumnValueArgs<'args>,
    ) -> flatbuffers::WIPOffset<HttpColumnValue<'bldr>> {
        let mut builder = HttpColumnValueBuilder::new(_fbb);
        if let Some(x) = args.string_value {
            builder.add_string_value(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn string_value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(HttpColumnValue::VT_STRING_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for HttpColumnValue<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "string_value",
                Self::VT_STRING_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct HttpColumnValueArgs<'a> {
    pub string_value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HttpColumnValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        HttpColumnValueArgs { string_value: None }
    }
}

pub struct HttpColumnValueBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpColumnValueBuilder<'a, 'b> {
    #[inline]
    pub fn add_string_value(&mut self, string_value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            HttpColumnValue::VT_STRING_VALUE,
            string_value,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HttpColumnValueBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HttpColumnValueBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HttpColumnValue<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HttpColumnValue<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HttpColumnValue");
        ds.field("string_value", &self.string_value());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `HttpMessage`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_http_message_unchecked`.
pub fn root_as_http_message(buf: &[u8]) -> Result<HttpMessage<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<HttpMessage>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `HttpMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_http_message_unchecked`.
pub fn size_prefixed_root_as_http_message(
    buf: &[u8],
) -> Result<HttpMessage<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<HttpMessage>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `HttpMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_http_message_unchecked`.
pub fn root_as_http_message_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<HttpMessage<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<HttpMessage<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `HttpMessage` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_http_message_unchecked`.
pub fn size_prefixed_root_as_http_message_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<HttpMessage<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<HttpMessage<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a HttpMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `HttpMessage`.
pub unsafe fn root_as_http_message_unchecked(buf: &[u8]) -> HttpMessage<'_> {
    flatbuffers::root_unchecked::<HttpMessage>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed HttpMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `HttpMessage`.
pub unsafe fn size_prefixed_root_as_http_message_unchecked(buf: &[u8]) -> HttpMessage<'_> {
    flatbuffers::size_prefixed_root_unchecked::<HttpMessage>(buf)
}
#[inline]
pub fn finish_http_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<HttpMessage<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_http_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<HttpMessage<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
