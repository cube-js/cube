/*
 * Cube.js
 *
 * Cube.js Swagger Schema
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */
use cubeorchestrator::query_result_transform::{RequestResultData, TransformedData};

#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct V1LoadResult {
    #[serde(rename = "dataSource", skip_serializing_if = "Option::is_none")]
    pub data_source: Option<String>,
    #[serde(rename = "annotation")]
    pub annotation: Box<crate::models::V1LoadResultAnnotation>,
    #[serde(rename = "data")]
    pub data: Vec<serde_json::Value>,
    #[serde(rename = "refreshKeyValues", skip_serializing_if = "Option::is_none")]
    pub refresh_key_values: Option<Vec<serde_json::Value>>,
}

impl V1LoadResult {
    pub fn new(
        annotation: crate::models::V1LoadResultAnnotation,
        data: Vec<serde_json::Value>,
    ) -> V1LoadResult {
        V1LoadResult {
            data_source: None,
            annotation: Box::new(annotation),
            data,
            refresh_key_values: None,
        }
    }
}

impl From<RequestResultData> for V1LoadResult {
    fn from(rrd: RequestResultData) -> Self {
        let data = match rrd.data {
            None => {
                vec![]
            }
            Some(d) => {
                match d {
                    TransformedData::Compact {
                        members: _members,
                        dataset: _dataset,
                    } => {
                        // TODO V1LoadResult expects only Vanilla results?
                        vec![]
                    }
                    TransformedData::Vanilla(v) => v
                        .iter()
                        .map(|item| serde_json::to_value(item).unwrap_or(serde_json::Value::Null))
                        .collect(),
                }
            }
        };
        let annotation = crate::models::V1LoadResultAnnotation {
            measures: rrd
                .annotation
                .get("measures")
                .map(|v| serde_json::to_value(v).unwrap_or(serde_json::Value::Null))
                .unwrap_or(serde_json::Value::Null),
            dimensions: rrd
                .annotation
                .get("dimensions")
                .map(|v| serde_json::to_value(v).unwrap_or(serde_json::Value::Null))
                .unwrap_or(serde_json::Value::Null),
            segments: rrd
                .annotation
                .get("segments")
                .map(|v| serde_json::to_value(v).unwrap_or(serde_json::Value::Null))
                .unwrap_or(serde_json::Value::Null),
            time_dimensions: rrd
                .annotation
                .get("timeDimensions")
                .map(|v| serde_json::to_value(v).unwrap_or(serde_json::Value::Null))
                .unwrap_or(serde_json::Value::Null),
        };
        V1LoadResult {
            data_source: rrd.data_source,
            annotation: Box::new(annotation),
            data,
            refresh_key_values: rrd.refresh_key_values,
        }
    }
}
