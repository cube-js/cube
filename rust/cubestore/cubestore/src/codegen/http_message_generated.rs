// automatically generated by the FlatBuffers compiler, do not modify

// @generated

extern crate flatbuffers;

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_HTTP_COMMAND: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_HTTP_COMMAND: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_HTTP_COMMAND: [HttpCommand; 4] = [
    HttpCommand::NONE,
    HttpCommand::HttpQuery,
    HttpCommand::HttpResultSet,
    HttpCommand::HttpError,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct HttpCommand(pub u8);
#[allow(non_upper_case_globals)]
impl HttpCommand {
    pub const NONE: Self = Self(0);
    pub const HttpQuery: Self = Self(1);
    pub const HttpResultSet: Self = Self(2);
    pub const HttpError: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::HttpQuery,
        Self::HttpResultSet,
        Self::HttpError,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::HttpQuery => Some("HttpQuery"),
            Self::HttpResultSet => Some("HttpResultSet"),
            Self::HttpError => Some("HttpError"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for HttpCommand {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for HttpCommand {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for HttpCommand {
    type Output = HttpCommand;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for HttpCommand {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for HttpCommand {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for HttpCommand {}
pub struct HttpCommandUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_HTTP_PARAMETER_VALUE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_HTTP_PARAMETER_VALUE: u8 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_HTTP_PARAMETER_VALUE: [HttpParameterValue; 7] = [
    HttpParameterValue::NONE,
    HttpParameterValue::Int64Value,
    HttpParameterValue::BoolValue,
    HttpParameterValue::StringValue,
    HttpParameterValue::BinaryValue,
    HttpParameterValue::Float64Value,
    HttpParameterValue::NullValue,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct HttpParameterValue(pub u8);
#[allow(non_upper_case_globals)]
impl HttpParameterValue {
    pub const NONE: Self = Self(0);
    pub const Int64Value: Self = Self(1);
    pub const BoolValue: Self = Self(2);
    pub const StringValue: Self = Self(3);
    pub const BinaryValue: Self = Self(4);
    pub const Float64Value: Self = Self(5);
    pub const NullValue: Self = Self(6);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::Int64Value,
        Self::BoolValue,
        Self::StringValue,
        Self::BinaryValue,
        Self::Float64Value,
        Self::NullValue,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::Int64Value => Some("Int64Value"),
            Self::BoolValue => Some("BoolValue"),
            Self::StringValue => Some("StringValue"),
            Self::BinaryValue => Some("BinaryValue"),
            Self::Float64Value => Some("Float64Value"),
            Self::NullValue => Some("NullValue"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for HttpParameterValue {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for HttpParameterValue {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for HttpParameterValue {
    type Output = HttpParameterValue;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for HttpParameterValue {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for HttpParameterValue {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for HttpParameterValue {}
pub struct HttpParameterValueUnionTableOffset {}

pub enum HttpMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HttpMessage<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpMessage<'a> {
    type Inner = HttpMessage<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HttpMessage<'a> {
    pub const VT_MESSAGE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_COMMAND_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_COMMAND: flatbuffers::VOffsetT = 8;
    pub const VT_CONNECTION_ID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HttpMessage { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HttpMessageArgs<'args>,
    ) -> flatbuffers::WIPOffset<HttpMessage<'bldr>> {
        let mut builder = HttpMessageBuilder::new(_fbb);
        if let Some(x) = args.connection_id {
            builder.add_connection_id(x);
        }
        if let Some(x) = args.command {
            builder.add_command(x);
        }
        builder.add_message_id(args.message_id);
        builder.add_command_type(args.command_type);
        builder.finish()
    }

    #[inline]
    pub fn message_id(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u32>(HttpMessage::VT_MESSAGE_ID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn command_type(&self) -> HttpCommand {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<HttpCommand>(HttpMessage::VT_COMMAND_TYPE, Some(HttpCommand::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn command(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    HttpMessage::VT_COMMAND,
                    None,
                )
        }
    }
    #[inline]
    pub fn connection_id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(HttpMessage::VT_CONNECTION_ID, None)
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_http_query(&self) -> Option<HttpQuery<'a>> {
        if self.command_type() == HttpCommand::HttpQuery {
            self.command().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { HttpQuery::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_http_result_set(&self) -> Option<HttpResultSet<'a>> {
        if self.command_type() == HttpCommand::HttpResultSet {
            self.command().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { HttpResultSet::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_http_error(&self) -> Option<HttpError<'a>> {
        if self.command_type() == HttpCommand::HttpError {
            self.command().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { HttpError::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for HttpMessage<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<u32>("message_id", Self::VT_MESSAGE_ID, false)?
            .visit_union::<HttpCommand, _>(
                "command_type",
                Self::VT_COMMAND_TYPE,
                "command",
                Self::VT_COMMAND,
                false,
                |key, v, pos| match key {
                    HttpCommand::HttpQuery => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<HttpQuery>>(
                            "HttpCommand::HttpQuery",
                            pos,
                        ),
                    HttpCommand::HttpResultSet => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<HttpResultSet>>(
                            "HttpCommand::HttpResultSet",
                            pos,
                        ),
                    HttpCommand::HttpError => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<HttpError>>(
                            "HttpCommand::HttpError",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "connection_id",
                Self::VT_CONNECTION_ID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct HttpMessageArgs<'a> {
    pub message_id: u32,
    pub command_type: HttpCommand,
    pub command: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub connection_id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HttpMessageArgs<'a> {
    #[inline]
    fn default() -> Self {
        HttpMessageArgs {
            message_id: 0,
            command_type: HttpCommand::NONE,
            command: None,
            connection_id: None,
        }
    }
}

pub struct HttpMessageBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpMessageBuilder<'a, 'b> {
    #[inline]
    pub fn add_message_id(&mut self, message_id: u32) {
        self.fbb_
            .push_slot::<u32>(HttpMessage::VT_MESSAGE_ID, message_id, 0);
    }
    #[inline]
    pub fn add_command_type(&mut self, command_type: HttpCommand) {
        self.fbb_.push_slot::<HttpCommand>(
            HttpMessage::VT_COMMAND_TYPE,
            command_type,
            HttpCommand::NONE,
        );
    }
    #[inline]
    pub fn add_command(&mut self, command: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpMessage::VT_COMMAND, command);
    }
    #[inline]
    pub fn add_connection_id(&mut self, connection_id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            HttpMessage::VT_CONNECTION_ID,
            connection_id,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HttpMessageBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HttpMessageBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HttpMessage<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HttpMessage<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HttpMessage");
        ds.field("message_id", &self.message_id());
        ds.field("command_type", &self.command_type());
        match self.command_type() {
            HttpCommand::HttpQuery => {
                if let Some(x) = self.command_as_http_query() {
                    ds.field("command", &x)
                } else {
                    ds.field(
                        "command",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            HttpCommand::HttpResultSet => {
                if let Some(x) = self.command_as_http_result_set() {
                    ds.field("command", &x)
                } else {
                    ds.field(
                        "command",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            HttpCommand::HttpError => {
                if let Some(x) = self.command_as_http_error() {
                    ds.field("command", &x)
                } else {
                    ds.field(
                        "command",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("command", &x)
            }
        };
        ds.field("connection_id", &self.connection_id());
        ds.finish()
    }
}
pub enum HttpQueryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HttpQuery<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpQuery<'a> {
    type Inner = HttpQuery<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HttpQuery<'a> {
    pub const VT_QUERY: flatbuffers::VOffsetT = 4;
    pub const VT_TRACE_OBJ: flatbuffers::VOffsetT = 6;
    pub const VT_INLINE_TABLES: flatbuffers::VOffsetT = 8;
    pub const VT_PARAMETERS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HttpQuery { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HttpQueryArgs<'args>,
    ) -> flatbuffers::WIPOffset<HttpQuery<'bldr>> {
        let mut builder = HttpQueryBuilder::new(_fbb);
        if let Some(x) = args.parameters {
            builder.add_parameters(x);
        }
        if let Some(x) = args.inline_tables {
            builder.add_inline_tables(x);
        }
        if let Some(x) = args.trace_obj {
            builder.add_trace_obj(x);
        }
        if let Some(x) = args.query {
            builder.add_query(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn query(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(HttpQuery::VT_QUERY, None)
        }
    }
    #[inline]
    pub fn trace_obj(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(HttpQuery::VT_TRACE_OBJ, None)
        }
    }
    #[inline]
    pub fn inline_tables(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpTable<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpTable>>,
            >>(HttpQuery::VT_INLINE_TABLES, None)
        }
    }
    #[inline]
    pub fn parameters(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpParameter<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpParameter>>,
            >>(HttpQuery::VT_PARAMETERS, None)
        }
    }
}

impl flatbuffers::Verifiable for HttpQuery<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("query", Self::VT_QUERY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "trace_obj",
                Self::VT_TRACE_OBJ,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<HttpTable>>,
            >>("inline_tables", Self::VT_INLINE_TABLES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<HttpParameter>>,
            >>("parameters", Self::VT_PARAMETERS, false)?
            .finish();
        Ok(())
    }
}
pub struct HttpQueryArgs<'a> {
    pub query: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trace_obj: Option<flatbuffers::WIPOffset<&'a str>>,
    pub inline_tables: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpTable<'a>>>,
        >,
    >,
    pub parameters: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpParameter<'a>>>,
        >,
    >,
}
impl<'a> Default for HttpQueryArgs<'a> {
    #[inline]
    fn default() -> Self {
        HttpQueryArgs {
            query: None,
            trace_obj: None,
            inline_tables: None,
            parameters: None,
        }
    }
}

pub struct HttpQueryBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpQueryBuilder<'a, 'b> {
    #[inline]
    pub fn add_query(&mut self, query: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpQuery::VT_QUERY, query);
    }
    #[inline]
    pub fn add_trace_obj(&mut self, trace_obj: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpQuery::VT_TRACE_OBJ, trace_obj);
    }
    #[inline]
    pub fn add_inline_tables(
        &mut self,
        inline_tables: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<HttpTable<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            HttpQuery::VT_INLINE_TABLES,
            inline_tables,
        );
    }
    #[inline]
    pub fn add_parameters(
        &mut self,
        parameters: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<HttpParameter<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpQuery::VT_PARAMETERS, parameters);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HttpQueryBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HttpQueryBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HttpQuery<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HttpQuery<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HttpQuery");
        ds.field("query", &self.query());
        ds.field("trace_obj", &self.trace_obj());
        ds.field("inline_tables", &self.inline_tables());
        ds.field("parameters", &self.parameters());
        ds.finish()
    }
}
pub enum HttpTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HttpTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpTable<'a> {
    type Inner = HttpTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HttpTable<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_COLUMNS: flatbuffers::VOffsetT = 6;
    pub const VT_TYPES: flatbuffers::VOffsetT = 8;
    pub const VT_CSV_ROWS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HttpTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HttpTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<HttpTable<'bldr>> {
        let mut builder = HttpTableBuilder::new(_fbb);
        if let Some(x) = args.csv_rows {
            builder.add_csv_rows(x);
        }
        if let Some(x) = args.types {
            builder.add_types(x);
        }
        if let Some(x) = args.columns {
            builder.add_columns(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(HttpTable::VT_NAME, None)
        }
    }
    #[inline]
    pub fn columns(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(HttpTable::VT_COLUMNS, None)
        }
    }
    #[inline]
    pub fn types(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(HttpTable::VT_TYPES, None)
        }
    }
    #[inline]
    pub fn csv_rows(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(HttpTable::VT_CSV_ROWS, None)
        }
    }
}

impl flatbuffers::Verifiable for HttpTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("columns", Self::VT_COLUMNS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("types", Self::VT_TYPES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "csv_rows",
                Self::VT_CSV_ROWS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct HttpTableArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub columns: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub types: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub csv_rows: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HttpTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        HttpTableArgs {
            name: None,
            columns: None,
            types: None,
            csv_rows: None,
        }
    }
}

pub struct HttpTableBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpTableBuilder<'a, 'b> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpTable::VT_NAME, name);
    }
    #[inline]
    pub fn add_columns(
        &mut self,
        columns: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpTable::VT_COLUMNS, columns);
    }
    #[inline]
    pub fn add_types(
        &mut self,
        types: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpTable::VT_TYPES, types);
    }
    #[inline]
    pub fn add_csv_rows(&mut self, csv_rows: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpTable::VT_CSV_ROWS, csv_rows);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HttpTableBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HttpTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HttpTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HttpTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HttpTable");
        ds.field("name", &self.name());
        ds.field("columns", &self.columns());
        ds.field("types", &self.types());
        ds.field("csv_rows", &self.csv_rows());
        ds.finish()
    }
}
pub enum HttpErrorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HttpError<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpError<'a> {
    type Inner = HttpError<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HttpError<'a> {
    pub const VT_ERROR: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HttpError { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HttpErrorArgs<'args>,
    ) -> flatbuffers::WIPOffset<HttpError<'bldr>> {
        let mut builder = HttpErrorBuilder::new(_fbb);
        if let Some(x) = args.error {
            builder.add_error(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn error(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(HttpError::VT_ERROR, None)
        }
    }
}

impl flatbuffers::Verifiable for HttpError<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("error", Self::VT_ERROR, false)?
            .finish();
        Ok(())
    }
}
pub struct HttpErrorArgs<'a> {
    pub error: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HttpErrorArgs<'a> {
    #[inline]
    fn default() -> Self {
        HttpErrorArgs { error: None }
    }
}

pub struct HttpErrorBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpErrorBuilder<'a, 'b> {
    #[inline]
    pub fn add_error(&mut self, error: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpError::VT_ERROR, error);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HttpErrorBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HttpErrorBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HttpError<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HttpError<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HttpError");
        ds.field("error", &self.error());
        ds.finish()
    }
}
pub enum HttpResultSetOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HttpResultSet<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpResultSet<'a> {
    type Inner = HttpResultSet<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HttpResultSet<'a> {
    pub const VT_COLUMNS: flatbuffers::VOffsetT = 4;
    pub const VT_ROWS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HttpResultSet { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HttpResultSetArgs<'args>,
    ) -> flatbuffers::WIPOffset<HttpResultSet<'bldr>> {
        let mut builder = HttpResultSetBuilder::new(_fbb);
        if let Some(x) = args.rows {
            builder.add_rows(x);
        }
        if let Some(x) = args.columns {
            builder.add_columns(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn columns(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(HttpResultSet::VT_COLUMNS, None)
        }
    }
    #[inline]
    pub fn rows(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpRow<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpRow>>,
            >>(HttpResultSet::VT_ROWS, None)
        }
    }
}

impl flatbuffers::Verifiable for HttpResultSet<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("columns", Self::VT_COLUMNS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<HttpRow>>,
            >>("rows", Self::VT_ROWS, false)?
            .finish();
        Ok(())
    }
}
pub struct HttpResultSetArgs<'a> {
    pub columns: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub rows: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpRow<'a>>>>,
    >,
}
impl<'a> Default for HttpResultSetArgs<'a> {
    #[inline]
    fn default() -> Self {
        HttpResultSetArgs {
            columns: None,
            rows: None,
        }
    }
}

pub struct HttpResultSetBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpResultSetBuilder<'a, 'b> {
    #[inline]
    pub fn add_columns(
        &mut self,
        columns: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpResultSet::VT_COLUMNS, columns);
    }
    #[inline]
    pub fn add_rows(
        &mut self,
        rows: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<HttpRow<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpResultSet::VT_ROWS, rows);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HttpResultSetBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HttpResultSetBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HttpResultSet<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HttpResultSet<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HttpResultSet");
        ds.field("columns", &self.columns());
        ds.field("rows", &self.rows());
        ds.finish()
    }
}
pub enum HttpRowOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HttpRow<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpRow<'a> {
    type Inner = HttpRow<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HttpRow<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HttpRow { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HttpRowArgs<'args>,
    ) -> flatbuffers::WIPOffset<HttpRow<'bldr>> {
        let mut builder = HttpRowBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn values(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpColumnValue<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpColumnValue>>,
            >>(HttpRow::VT_VALUES, None)
        }
    }
}

impl flatbuffers::Verifiable for HttpRow<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<HttpColumnValue>>,
            >>("values", Self::VT_VALUES, false)?
            .finish();
        Ok(())
    }
}
pub struct HttpRowArgs<'a> {
    pub values: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HttpColumnValue<'a>>>,
        >,
    >,
}
impl<'a> Default for HttpRowArgs<'a> {
    #[inline]
    fn default() -> Self {
        HttpRowArgs { values: None }
    }
}

pub struct HttpRowBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpRowBuilder<'a, 'b> {
    #[inline]
    pub fn add_values(
        &mut self,
        values: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<HttpColumnValue<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpRow::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HttpRowBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HttpRowBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HttpRow<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HttpRow<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HttpRow");
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum Int64ValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Int64Value<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Int64Value<'a> {
    type Inner = Int64Value<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Int64Value<'a> {
    pub const VT_V: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Int64Value { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Int64ValueArgs,
    ) -> flatbuffers::WIPOffset<Int64Value<'bldr>> {
        let mut builder = Int64ValueBuilder::new(_fbb);
        builder.add_v(args.v);
        builder.finish()
    }

    #[inline]
    pub fn v(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i64>(Int64Value::VT_V, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for Int64Value<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<i64>("v", Self::VT_V, false)?
            .finish();
        Ok(())
    }
}
pub struct Int64ValueArgs {
    pub v: i64,
}
impl<'a> Default for Int64ValueArgs {
    #[inline]
    fn default() -> Self {
        Int64ValueArgs { v: 0 }
    }
}

pub struct Int64ValueBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Int64ValueBuilder<'a, 'b> {
    #[inline]
    pub fn add_v(&mut self, v: i64) {
        self.fbb_.push_slot::<i64>(Int64Value::VT_V, v, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Int64ValueBuilder<'a, 'b> {
        let start = _fbb.start_table();
        Int64ValueBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Int64Value<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Int64Value<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Int64Value");
        ds.field("v", &self.v());
        ds.finish()
    }
}
pub enum BoolValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoolValue<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoolValue<'a> {
    type Inner = BoolValue<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> BoolValue<'a> {
    pub const VT_V: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BoolValue { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BoolValueArgs,
    ) -> flatbuffers::WIPOffset<BoolValue<'bldr>> {
        let mut builder = BoolValueBuilder::new(_fbb);
        builder.add_v(args.v);
        builder.finish()
    }

    #[inline]
    pub fn v(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<bool>(BoolValue::VT_V, Some(false)).unwrap() }
    }
}

impl flatbuffers::Verifiable for BoolValue<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<bool>("v", Self::VT_V, false)?
            .finish();
        Ok(())
    }
}
pub struct BoolValueArgs {
    pub v: bool,
}
impl<'a> Default for BoolValueArgs {
    #[inline]
    fn default() -> Self {
        BoolValueArgs { v: false }
    }
}

pub struct BoolValueBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BoolValueBuilder<'a, 'b> {
    #[inline]
    pub fn add_v(&mut self, v: bool) {
        self.fbb_.push_slot::<bool>(BoolValue::VT_V, v, false);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BoolValueBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BoolValueBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<BoolValue<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for BoolValue<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("BoolValue");
        ds.field("v", &self.v());
        ds.finish()
    }
}
pub enum StringValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StringValue<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StringValue<'a> {
    type Inner = StringValue<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> StringValue<'a> {
    pub const VT_V: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StringValue { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StringValueArgs<'args>,
    ) -> flatbuffers::WIPOffset<StringValue<'bldr>> {
        let mut builder = StringValueBuilder::new(_fbb);
        if let Some(x) = args.v {
            builder.add_v(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn v(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(StringValue::VT_V, None)
        }
    }
}

impl flatbuffers::Verifiable for StringValue<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("v", Self::VT_V, false)?
            .finish();
        Ok(())
    }
}
pub struct StringValueArgs<'a> {
    pub v: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StringValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        StringValueArgs { v: None }
    }
}

pub struct StringValueBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StringValueBuilder<'a, 'b> {
    #[inline]
    pub fn add_v(&mut self, v: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(StringValue::VT_V, v);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StringValueBuilder<'a, 'b> {
        let start = _fbb.start_table();
        StringValueBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StringValue<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for StringValue<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("StringValue");
        ds.field("v", &self.v());
        ds.finish()
    }
}
pub enum BinaryValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinaryValue<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryValue<'a> {
    type Inner = BinaryValue<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> BinaryValue<'a> {
    pub const VT_V: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BinaryValue { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BinaryValueArgs<'args>,
    ) -> flatbuffers::WIPOffset<BinaryValue<'bldr>> {
        let mut builder = BinaryValueBuilder::new(_fbb);
        if let Some(x) = args.v {
            builder.add_v(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn v(&self) -> Option<flatbuffers::Vector<'a, i8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(
                    BinaryValue::VT_V,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for BinaryValue<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(
                "v",
                Self::VT_V,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct BinaryValueArgs<'a> {
    pub v: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for BinaryValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        BinaryValueArgs { v: None }
    }
}

pub struct BinaryValueBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BinaryValueBuilder<'a, 'b> {
    #[inline]
    pub fn add_v(&mut self, v: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryValue::VT_V, v);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BinaryValueBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BinaryValueBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<BinaryValue<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for BinaryValue<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("BinaryValue");
        ds.field("v", &self.v());
        ds.finish()
    }
}
pub enum Float64ValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Float64Value<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Float64Value<'a> {
    type Inner = Float64Value<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Float64Value<'a> {
    pub const VT_V: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Float64Value { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Float64ValueArgs,
    ) -> flatbuffers::WIPOffset<Float64Value<'bldr>> {
        let mut builder = Float64ValueBuilder::new(_fbb);
        builder.add_v(args.v);
        builder.finish()
    }

    #[inline]
    pub fn v(&self) -> f64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<f64>(Float64Value::VT_V, Some(0.0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for Float64Value<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<f64>("v", Self::VT_V, false)?
            .finish();
        Ok(())
    }
}
pub struct Float64ValueArgs {
    pub v: f64,
}
impl<'a> Default for Float64ValueArgs {
    #[inline]
    fn default() -> Self {
        Float64ValueArgs { v: 0.0 }
    }
}

pub struct Float64ValueBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Float64ValueBuilder<'a, 'b> {
    #[inline]
    pub fn add_v(&mut self, v: f64) {
        self.fbb_.push_slot::<f64>(Float64Value::VT_V, v, 0.0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Float64ValueBuilder<'a, 'b> {
        let start = _fbb.start_table();
        Float64ValueBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Float64Value<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Float64Value<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Float64Value");
        ds.field("v", &self.v());
        ds.finish()
    }
}
pub enum NullValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NullValue<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NullValue<'a> {
    type Inner = NullValue<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> NullValue<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        NullValue { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args NullValueArgs,
    ) -> flatbuffers::WIPOffset<NullValue<'bldr>> {
        let mut builder = NullValueBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for NullValue<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct NullValueArgs {}
impl<'a> Default for NullValueArgs {
    #[inline]
    fn default() -> Self {
        NullValueArgs {}
    }
}

pub struct NullValueBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NullValueBuilder<'a, 'b> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NullValueBuilder<'a, 'b> {
        let start = _fbb.start_table();
        NullValueBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<NullValue<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for NullValue<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("NullValue");
        ds.finish()
    }
}
pub enum HttpParameterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HttpParameter<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpParameter<'a> {
    type Inner = HttpParameter<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HttpParameter<'a> {
    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HttpParameter { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HttpParameterArgs,
    ) -> flatbuffers::WIPOffset<HttpParameter<'bldr>> {
        let mut builder = HttpParameterBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_value_type(args.value_type);
        builder.finish()
    }

    #[inline]
    pub fn value_type(&self) -> HttpParameterValue {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<HttpParameterValue>(
                    HttpParameter::VT_VALUE_TYPE,
                    Some(HttpParameterValue::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    HttpParameter::VT_VALUE,
                    None,
                )
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_int_64_value(&self) -> Option<Int64Value<'a>> {
        if self.value_type() == HttpParameterValue::Int64Value {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { Int64Value::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_bool_value(&self) -> Option<BoolValue<'a>> {
        if self.value_type() == HttpParameterValue::BoolValue {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { BoolValue::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_string_value(&self) -> Option<StringValue<'a>> {
        if self.value_type() == HttpParameterValue::StringValue {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { StringValue::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_binary_value(&self) -> Option<BinaryValue<'a>> {
        if self.value_type() == HttpParameterValue::BinaryValue {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { BinaryValue::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_float_64_value(&self) -> Option<Float64Value<'a>> {
        if self.value_type() == HttpParameterValue::Float64Value {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { Float64Value::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_null_value(&self) -> Option<NullValue<'a>> {
        if self.value_type() == HttpParameterValue::NullValue {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { NullValue::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for HttpParameter<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_union::<HttpParameterValue, _>(
                "value_type",
                Self::VT_VALUE_TYPE,
                "value",
                Self::VT_VALUE,
                false,
                |key, v, pos| match key {
                    HttpParameterValue::Int64Value => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Int64Value>>(
                            "HttpParameterValue::Int64Value",
                            pos,
                        ),
                    HttpParameterValue::BoolValue => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<BoolValue>>(
                            "HttpParameterValue::BoolValue",
                            pos,
                        ),
                    HttpParameterValue::StringValue => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<StringValue>>(
                            "HttpParameterValue::StringValue",
                            pos,
                        ),
                    HttpParameterValue::BinaryValue => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<BinaryValue>>(
                            "HttpParameterValue::BinaryValue",
                            pos,
                        ),
                    HttpParameterValue::Float64Value => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Float64Value>>(
                            "HttpParameterValue::Float64Value",
                            pos,
                        ),
                    HttpParameterValue::NullValue => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<NullValue>>(
                            "HttpParameterValue::NullValue",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct HttpParameterArgs {
    pub value_type: HttpParameterValue,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for HttpParameterArgs {
    #[inline]
    fn default() -> Self {
        HttpParameterArgs {
            value_type: HttpParameterValue::NONE,
            value: None,
        }
    }
}

pub struct HttpParameterBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpParameterBuilder<'a, 'b> {
    #[inline]
    pub fn add_value_type(&mut self, value_type: HttpParameterValue) {
        self.fbb_.push_slot::<HttpParameterValue>(
            HttpParameter::VT_VALUE_TYPE,
            value_type,
            HttpParameterValue::NONE,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpParameter::VT_VALUE, value);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HttpParameterBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HttpParameterBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HttpParameter<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HttpParameter<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HttpParameter");
        ds.field("value_type", &self.value_type());
        match self.value_type() {
            HttpParameterValue::Int64Value => {
                if let Some(x) = self.value_as_int_64_value() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            HttpParameterValue::BoolValue => {
                if let Some(x) = self.value_as_bool_value() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            HttpParameterValue::StringValue => {
                if let Some(x) = self.value_as_string_value() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            HttpParameterValue::BinaryValue => {
                if let Some(x) = self.value_as_binary_value() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            HttpParameterValue::Float64Value => {
                if let Some(x) = self.value_as_float_64_value() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            HttpParameterValue::NullValue => {
                if let Some(x) = self.value_as_null_value() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("value", &x)
            }
        };
        ds.finish()
    }
}
pub enum HttpColumnValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HttpColumnValue<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpColumnValue<'a> {
    type Inner = HttpColumnValue<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HttpColumnValue<'a> {
    pub const VT_STRING_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HttpColumnValue { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HttpColumnValueArgs<'args>,
    ) -> flatbuffers::WIPOffset<HttpColumnValue<'bldr>> {
        let mut builder = HttpColumnValueBuilder::new(_fbb);
        if let Some(x) = args.string_value {
            builder.add_string_value(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn string_value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(HttpColumnValue::VT_STRING_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for HttpColumnValue<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "string_value",
                Self::VT_STRING_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct HttpColumnValueArgs<'a> {
    pub string_value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HttpColumnValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        HttpColumnValueArgs { string_value: None }
    }
}

pub struct HttpColumnValueBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpColumnValueBuilder<'a, 'b> {
    #[inline]
    pub fn add_string_value(&mut self, string_value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            HttpColumnValue::VT_STRING_VALUE,
            string_value,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HttpColumnValueBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HttpColumnValueBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HttpColumnValue<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HttpColumnValue<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HttpColumnValue");
        ds.field("string_value", &self.string_value());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `HttpMessage`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_http_message_unchecked`.
pub fn root_as_http_message(buf: &[u8]) -> Result<HttpMessage, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<HttpMessage>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `HttpMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_http_message_unchecked`.
pub fn size_prefixed_root_as_http_message(
    buf: &[u8],
) -> Result<HttpMessage, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<HttpMessage>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `HttpMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_http_message_unchecked`.
pub fn root_as_http_message_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<HttpMessage<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<HttpMessage<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `HttpMessage` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_http_message_unchecked`.
pub fn size_prefixed_root_as_http_message_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<HttpMessage<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<HttpMessage<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a HttpMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `HttpMessage`.
pub unsafe fn root_as_http_message_unchecked(buf: &[u8]) -> HttpMessage {
    flatbuffers::root_unchecked::<HttpMessage>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed HttpMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `HttpMessage`.
pub unsafe fn size_prefixed_root_as_http_message_unchecked(buf: &[u8]) -> HttpMessage {
    flatbuffers::size_prefixed_root_unchecked::<HttpMessage>(buf)
}
#[inline]
pub fn finish_http_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<HttpMessage<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_http_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<HttpMessage<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
