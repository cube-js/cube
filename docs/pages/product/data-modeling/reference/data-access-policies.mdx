# Access policies

You can use the `access_policy` parameter within [cubes][ref-ref-cubes] and [views][ref-ref-views]
to configure [access policies][ref-dap] for them.

## Parameters

The `access_policy` parameter should define a list of access policies. Each policy
can be configured using the following parameters:

- [`group`](#group) or [`groups`](#groups) define which groups a policy applies to.
- [`conditions`](#conditions) can be optionally used to specify when a policy
takes effect.
- [`member_level`](#member-level) and [`row_level`](#row-level) parameters are used
to configure [member-level][ref-dap-mls] and [row-level][ref-dap-rls] access.

<InfoBox>

When you define access policies for specific groups, access is automatically denied to all other groups. You don't need to create a default policy that denies access.

</InfoBox>

### `group`

The `group` parameter defines which group a policy applies to. To define a policy that applies to all users regardless of their groups, use the _any group_ shorthand: `group: "*"`.

In the following example, two access policies are defined for users with `marketing` or `finance` groups, respectively.

<CodeTabs>

```yaml
cubes:
  - name: orders
    # ...

    access_policy:
      - group: marketing
        # ...

      - group: finance
        # ...
```

```javascript
cube(`orders`, {
  // ...

  access_policy: [
    {
      group: `marketing`,
      // ...
    },
    {
      group: `finance`,
      // ...
    }
  ]
})
```

</CodeTabs>

### `groups`

The `groups` parameter (plural) allows you to apply the same policy to multiple groups at once by providing an array of group names.

In the following example, a single policy applies to both `analysts` and `managers` groups:

<CodeTabs>

```yaml
cubes:
  - name: orders
    # ...

    access_policy:
      - groups: [analysts, managers]
        member_level:
          includes: "*"
```

```javascript
cube(`orders`, {
  // ...

  access_policy: [
    {
      groups: [`analysts`, `managers`],
      member_level: {
        includes: `*`
      }
    }
  ]
})
```

</CodeTabs>

### `conditions`

The optional `conditions` parameter, when present, defines a list of conditions
that should all be `true` in order for a policy to take effect. Each condition is
configured with an `if` parameter that is expected to reference the [security
context][ref-sec-ctx] or user attributes.

In the following example, a permissive policy for all groups will only apply to
EMEA-based users, as determined by the `is_EMEA_based` user attribute:

<CodeTabs>

```yaml
cubes:
  - name: orders
    # ...

    access_policy:
      - group: "*"
        conditions:
          - if: "{ userAttributes.is_EMEA_based }"
        member_level:
          includes: "*"
```

```javascript
cube(`orders`, {
  // ...

  access_policy: [
    {
      group: `*`,
      conditions: [
        { if: userAttributes.is_EMEA_based }
      ],
      member_level: {
        includes: `*`
      }
    }
  ]
})
```

</CodeTabs>

You can use the `conditions` parameter to define multiple policies for the same
group.

In the following example, the first policy provides access to a _subset of members_
to users in the manager group who are full-time employees while the other one provides access to
_all members_ to users in the manager group who are full-time employees and have also completed a
data privacy training:

<CodeTabs>

```yaml
cubes:
  - name: orders
    # ...

    access_policy:
      - group: manager
        conditions:
          - if: "{ userAttributes.is_full_time_employee }"
        member_level:
          includes:
            - status
            - count

      - group: manager
        conditions:
          - if: "{ userAttributes.is_full_time_employee }"
          - if: "{ userAttributes.has_completed_privacy_training }"
        member_level:
          includes: "*"
```

```javascript
cube(`orders`, {
  // ...

  access_policy: [
    {
      group: `manager`,
      conditions: [
        { if: userAttributes.is_full_time_employee }
      ],
      member_level: {
        includes: [
          `status`,
          `count`
        ]
      }
    },
    {
      group: `manager`,
      conditions: [
        { if: userAttributes.is_full_time_employee },
        { if: userAttributes.has_completed_privacy_training }
      ],
      member_level: {
        includes: `*`
      }
    }
  ]
})
```

</CodeTabs>

### `member_level`

The optional `member_level` parameter, when present, configures [member-level
access][ref-dap-mls] for a policy by specifying allowed or disallowed members.

You can either provide a list of allowed members with the `includes` parameter,
or a list of disallowed members with the `excludes` parameter. There's also the
_all members_ shorthand for both of these paramaters: `includes: "*"`, `excludes: "*"`.

In the following example, member-level access is configured this way:

| Group | Access |
| --- | --- |
| `manager` | All members except for `count` |
| `observer` | All members except for `count` and `count_7d` |
| `guest` | Only the `count_30d` measure |
| All other groups | No access to this cube at all |

<CodeTabs>

```yaml
cubes:
  - name: orders
    # ...
    
    access_policy:
      - group: manager
        member_level:
          # Includes all members except for `count`
          excludes:
            - count
      
      - group: observer
        member_level:
          # Includes all members except for `count` and `count_7d`
          excludes:
            - count
            - count_7d
      
      - group: guest
        # Includes only `count_30d`, excludes all other members
        member_level:
          includes:
            - count_30d
```

```javascript
cube(`orders`, {
  // ...

  access_policy: [
    {
      group: `manager`,
      // Includes all members except for `count`
      member_level: {
        excludes: [
          `count`
        ]
      }
    },
    {
      group: `observer`,
      // Includes all members except for `count` and `count_7d`
      member_level: {
        excludes: [
          `count`,
          `count_7d`
        ]
      }
    },
    {
      group: `guest`,
      // Includes only `count_30d`, excludes all other members
      member_level: {
        includes: [
          `count_30d`
        ]
      }
    }
  ]
})
```

</CodeTabs>

Note that access policies also respect [member-level security][ref-mls] restrictions
configured via `public` parameters. See [member-level access][ref-dap-mls] to
learn more about policy evaluation.

### `row_level`

The optional `row_level` parameter, when present, configures [row-level
access][ref-dap-rls] for a policy by specifying `filters` that should apply to result set rows.

In the following example, users in the `manager` group are allowed to access only
rows that have the `state` dimension matching the state from the [security context][ref-sec-ctx].
All other users are disallowed from accessing any rows at all.

<CodeTabs>

```yaml
cubes:
  - name: orders
    # ...
    
    access_policy:
      - group: manager
        row_level:
          filters:
            - member: state
              operator: equals
              values: [ "{ userAttributes.state }" ]
```

```javascript
cube(`orders`, {
  // ...

  access_policy: [
    {
      group: `manager`,
      row_level: {
        filters: [
          {
            member: `state`,
            operator: `equals`,
            values: [ userAttributes.state ]
          }
        ]
      }
    }
  ]
})
```

</CodeTabs>

For convenience, row filters are configured using the same format as [filters in
REST API][ref-rest-query-filters] queries, allowing to use the same set of
[filter operators][ref-rest-query-ops], e.g., `equals`, `contains`, `gte`, etc.
You can also use `and` and `or` parameters to combine multiple filters into
[boolean logical operators][ref-rest-boolean-ops].

Note that access policies also respect [row-level security][ref-rls] restrictions
configured via the `query_rewrite` configuration option. See [row-level access][ref-dap-rls] to
learn more about policy evaluation.

## Using securityContext

The [`userAttributes`][ref-sec-ctx] object is only available in Cube Cloud platform. If you are using Cube Core or authenticating against [Core Data APIs][ref-core-data-apis] directly, you won't have access to `userAttributes`. Instead, you need to use `securityContext` directly when referencing user attributes in access policies (e.g., in `row_level` filters or `conditions`). For example, use `securityContext.userId` instead of `userAttributes.userId`.

<CodeTabs>

```yaml
cubes:
  - name: orders
    # ...

    access_policy:
      - group: manager
        row_level:
          filters:
            - member: country
              operator: equals
              values: [ "{ securityContext.country }" ]
```

```javascript
cube(`orders`, {
  // ...

  access_policy: [
    {
      group: `manager`,
      row_level: {
        filters: [
          {
            member: `country`,
            operator: `equals`,
            values: [ securityContext.country ]
          }
        ]
      }
    }
  ]
})
```

</CodeTabs>


[ref-ref-cubes]: /product/data-modeling/reference/cube
[ref-ref-views]: /product/data-modeling/reference/view
[ref-dap]: /product/auth/data-access-policies
[ref-dap-mls]: /product/auth/data-access-policies#member-level-access
[ref-dap-rls]: /product/auth/data-access-policies#row-level-access
[ref-mls]: /product/auth/member-level-security
[ref-rls]: /product/auth/row-level-security
[ref-sec-ctx]: /product/auth/context
[ref-core-data-apis]: /product/apis-integrations/core-data-apis
[ref-rest-query-filters]: /product/apis-integrations/rest-api/query-format#filters-format
[ref-rest-query-ops]: /product/apis-integrations/rest-api/query-format#filters-operators
[ref-rest-boolean-ops]: /product/apis-integrations/rest-api/query-format#boolean-logical-operators
