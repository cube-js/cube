---
title: Deployment
permalink: /deployment
category: Cube.js Backend
menuOrder: 7
---

Below you can find guides for popular deployment environments:

- [Docker](#docker)
- [Serverless](#serverless)
- [As a part of Express application](#express)
- [Heroku](#heroku)

## Production Mode

When running Cube.js Backend in production make sure `NODE_ENV` is set to `production`.
Such platforms, such as Heroku, do it by default.
In this mode Cube.js unsecured development server and Playground will be disabled by default because there's a security risk serving those in production environments.
Production Cube.js servers can be accessed only with [REST API](rest-api) and Cube.js frontend libraries.

### Redis

Also, Cube.js requires [Redis](https://redis.io/), in-memory data structure store, to run in production.
It uses Redis for query caching and queue.
Set `REDIS_URL` environment variable to provide Cube.js with Redis connection. In case your Redis instance has password, please set password via `REDIS_PASSWORD` environment variable.
Make sure, your Redis allows at least 15 concurrent connections.
Set `REDIS_TLS` env variable to `true` if you want to enable secure connection.

[[warning | Note]]
| Cube.js server instances used by same tenant environments should have same Redis instances. Otherwise they will have different query queues which can lead to incorrect pre-aggregation states and intermittent data access errors.

### Redis Pool

If `REDIS_URL` is provided Cube.js will create Redis pool with 2 min and 1000 max of concurrent connections by default.
`CUBEJS_REDIS_POOL_MIN` and `CUBEJS_REDIS_POOL_MAX` environment variables can be used to tweak pool size.
No pool behavior with each connection created on demand can be achieved with `CUBEJS_REDIS_POOL_MAX=0` setting.

If your `CUBEJS_REDIS_POOL_MAX` too low you may see `TimeoutError: ResourceRequest timed out` errors.
As a rule of a thumb you need to have `Queue Size * Number of tenants` concurrent connections to ensure best performance possible.
If you use clustered deployments please make sure you have enough connections for all Cube.js server instances.
Lower number of connections still can work however Redis becomes performance bottleneck in this case.

### Running without Redis

If you want to run Cube.js in production without redis you can use `CUBEJS_CACHE_AND_QUEUE_DRIVER=memory` env setting.

[[warning | Note]]
| Serverless and clustered deployments can't be run without Redis as it's used to manage querying queue.

## Docker

Starting from the `v0.23` version, Cube.js provides the [official Docker image](https://hub.docker.com/r/cubejs/cube).

Inside the Docker image, there are two base paths:

- `/cube` - System directory, preinstalled Cube.js with [all drivers](https://github.com/cube-js/cube.js/blob/master/packages/cubejs-docker/package.json).
- `/cube/conf` - Directory for configuration file (`cube.js`) and schema files.

### Create a new app using Cube.js-CLI

```bash
$ cubejs create cubejs-docker-demo -t docker -d postgres
$ cd cubejs-docker-demo
```

The directory will contain files:

- `docker-compose.yml` - Example of docker-compose usage.
- `cube.js` - Configuration file.
- `.env` - Env variables file for local development.

### Run Docker image

To test just built Docker image, you need to set environment variables required by Cube.js Backend.
Generate a secret for JWT Tokens as described in [Security](/security) section and fill in database credentials.

```bash
$ docker run --rm \
  --name cubejs-docker-demo \
  -e CUBEJS_API_SECRET=<YOUR-API-SECRET> \
  -e CUBEJS_DB_HOST=<YOUR-DB-HOST-HERE> \
  -e CUBEJS_DB_NAME=<YOUR-DB-NAME-HERE> \
  -e CUBEJS_DB_USER=<YOUR-DB-USER-HERE> \
  -e CUBEJS_DB_PASS=<YOUR-DB-PASS-HERE> \
  -e CUBEJS_DB_TYPE=postgres \
  -v "$(pwd):/cube/conf" \
  cubejs/cube:latest
```

### Stop Docker image

```bash
$ docker stop cubejs-docker-demo
```

### Docker Compose

Take a look at `docker-compose.yml` file that was generated by `cubejs create`. It's an example, but a good starting point.

#### Start/Stop the containers

```bash
$ docker-compose up
```

```bash
$ docker-compose stop
```

#### Extending Docker image

If you need to use npm packages with native extensions inside `cube.js` configuration file, you need to build your own docker image.

```bash
$ touch Dockerfile
$ touch .dockerignore
```

Example `Dockerfile`:

```dockerfile
FROM cubejs/cube:latest

COPY . .
RUN npm install
```

Example `.dockerignore`:

```bash
node_modules
npm-debug.log
schema
cube.js
.env
```

```bash
$ docker build -t <YOUR-USERNAME>/cubejs-docker-demo .
```

```bash
$ docker run --rm \
  --name cubejs-docker-demo \
  -e CUBEJS_API_SECRET=<YOUR-API-SECRET> \
  -e CUBEJS_DB_HOST=<YOUR-DB-HOST-HERE> \
  -e CUBEJS_DB_NAME=<YOUR-DB-NAME-HERE> \
  -e CUBEJS_DB_USER=<YOUR-DB-USER-HERE> \
  -e CUBEJS_DB_PASS=<YOUR-DB-PASS-HERE> \
  -e CUBEJS_DB_TYPE=postgres \
  --volume "$(pwd):/cube/conf" \
  <YOUR-USERNAME>/cubejs-docker-demo
```


## Serverless

Cube.js could be deployed in serverless mode with [Serverless
Framework](https://serverless.com/). The following guide shows how to setup
deployment to AWS Lambda.

### Create New Cube.js Service with Serverless template

Create Cube.js Serverless app:

```bash
$ npm install -g serverless
$ cubejs create cubejs-serverless -d athena -t serverless
```

### Setup Redis

Create AWS ElasticCache Redis instance within the same region where lambda hosts.

Add Redis security group and subnet to `serverless.yml` vpc settings:

```yaml
provider:
  vpc:
    securityGroupIds:
     - sg-12345678901234567 # Your DB and Redis security groups here
    subnetIds:
     - subnet-12345678901234567 # Your DB and Redis subnets here
```

### Add internet access for Lambda

When you assign vpc to a Lambda functions internet access will be disabled by default.
Lambda functions require internet access to send SNS messages for query processing.
Please follow [this guide](https://medium.com/@philippholly/aws-lambda-enable-outgoing-internet-access-within-vpc-8dd250e11e12) to set up internet access for your Lambda functions.

### Athena permissions

Please add following permissions to `serverless.yml` if you need Athena within your Lambda functions:

```yaml
provider:
  iamRoleStatements:
    - Effect: "Allow"
      Action:
        - "sns:*"
# Athena permissions
        - "athena:*"
        - "s3:*"
        - "glue:*"
      Resource:
        - "*"
```

### Deploy

```bash
$ serverless deploy -v
```

### Logs

```bash
$ serverless logs -t -f cubejs
$ serverless logs -t -f cubejsProcess
```

### Passing server core options for serverless

[Server core options](@cubejs-backend-server-core#options-reference) can be passed by instantiating appropriate `Handlers` class directly.
For example:

**index.js:**

```javascript
const AWSHandlers = require('@cubejs-backend/serverless-aws');
const MySQLDriver = require('@cubejs-backend/mysql-driver');

module.exports = new AWSHandlers({
  externalDbType: 'mysql',
  externalDriverFactory: () => new MySQLDriver({
    host: process.env.CUBEJS_EXT_DB_HOST,
    database: process.env.CUBEJS_EXT_DB_NAME,
    port: process.env.CUBEJS_EXT_DB_PORT,
    user: process.env.CUBEJS_EXT_DB_USER,
    password: process.env.CUBEJS_EXT_DB_PASS,
  })
});
```

## Serverless Google Cloud Platform

Also, You can deploy Cube.js in serverless mode to Google Cloud Platform

```
$ npm install -g serverless
$ cubejs create -d bigquery -t serverless-google
```

Update all placeholders in just created `serverless.yml`.

### Setup Redis

1. [Create Redis](https://cloud.google.com/memorystore/docs/redis/quickstart-console).
2. [Setup Serverless VPC Access Connector](https://cloud.google.com/functions/docs/connecting-vpc).

### Deploy

```
$ serverless deploy -v
```

As serverless-google-cloudfunctions plugin doesn't support vpc-connector, you need to [set it manually](https://cloud.google.com/functions/docs/connecting-vpc#configuring) each time after deploy.

### Logs

```
$ serverless logs -t -f cubejs
$ serverless logs -t -f cubejsProcess
```

## Express

[[warning | Warning]]
| It is suitable to host single node applications this way without any significant load anticipated. Please consider deploying Cube.js as a microservice inside Docker if you need to host multiple Cube.js instances.

Minimal setup for such serving looks as following:

**index.js**
```javascript
require('dotenv').config();
const express = require('express');
const bodyParser = require('body-parser');
const CubejsServerCore = require('@cubejs-backend/server-core');

const app = express();
app.use(require('cors')());
app.use(bodyParser.json({ limit: '50mb' }));

const serverCore = CubejsServerCore.create();
serverCore.initApp(app);

const port = process.env.PORT || 4000;
app.listen(port, (err) => {
  if (err) {
    console.error('Fatal error during server start: ');
    console.error(e.stack || e);
  }
  console.log(`ðŸš€ Cube.js server (${CubejsServerCore.version()}) is listening on ${port}`);
});
```

### Express with Basic Passport Authentication

To serve simple dashboard application with minimal basic authentication security following setup can be used:

**index.js**
```javascript
require('dotenv').config();
const http = require('http');
const express = require('express');
const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');
const session = require('express-session');
const passport = require('passport');
const serveStatic = require('serve-static');
const path = require('path');
const { BasicStrategy } = require('passport-http');
const CubejsServerCore = require('@cubejs-backend/server-core');

const app = express();
app.use(require('cors')());
app.use(cookieParser());
app.use(bodyParser.json({ limit: '50mb' }));
app.use(session({ secret: process.env.CUBEJS_API_SECRET }));
app.use(passport.initialize());
app.use(passport.session());

passport.use(new BasicStrategy(
  (user, password, done) => {
    if (user === 'admin' && password === 'admin') {
      done(null, { user });
    } else {
      done(null, false);
    }
  }
));

passport.serializeUser((user, done) => done(null, user));
passport.deserializeUser((user, done) => done(null, user));

app.get('/login', passport.authenticate('basic'), (req, res) => {
  res.redirect('/')
});

app.use((req, res, next) => {
  if (!req.user) {
    res.redirect('/login');
    return;
  }
  next();
});

if (process.env.NODE_ENV === 'production') {
  app.use(serveStatic(path.join(__dirname, 'dashboard-app/build')));
}

const serverCore = CubejsServerCore.create({
  checkAuth: (req, auth) => {
    if (!req.user) {
      throw new Error(`Unauthorized`);
    }
    req.authInfo = { u: req.user };
  }
});

serverCore.initApp(app);

const port = process.env.PORT || 4000;
const server = http.createServer(app);

server.listen(port, (err) => {
  if (err) {
    console.error('Fatal error during server start: ');
    console.error(e.stack || e);
  }
  console.log(`ðŸš€ Cube.js server (${CubejsServerCore.version()}) is listening on ${port}`);
});
```

Use **admin / admin** as **user / password** to access the dashboard.

## Heroku

### Create new app using Cube.js-CLI

```bash
$ cubejs create cubejs-heroku-demo -t express -d postgres
$ cd cubejs-heroku-demo
```

### Init a git repository

```bash
$ git init
```

### Create new Heroku app

```bash
$ heroku create cubejs-heroku-demo
```

### Provision Redis

You can use any Redis server. If you don't have one, you can use a free Redis provided by Heroku:

```bash
$ heroku addons:create heroku-redis:hobby-dev -a cubejs-heroku-demo
```

If you use another Redis server, you should pass your Redis URL as an environment variable:

```bash
$ heroku config:set REDIS_URL:<YOUR-REDIS-URL>
```

Note that Cube.js requires at least 15 concurrent connections allowed by Redis server.
Please [setup connection pool](deployment#production-mode-redis-pool) according to your redis max connections.

### Create Heroku Procfile

```bash
$ echo "web: node index.js" > Procfile
```

### Set up connection to your database

```bash
$ heroku config:set \
  CUBEJS_DB_HOST=<YOUR-DB-HOST> \
  CUBEJS_DB_NAME=<YOUR-DB-NAME> \
  CUBEJS_DB_USER=<YOUR-DB-USER> \
  CUBEJS_DB_PASS=<YOUR-DB-PASSWORD>
```

### Deploy app to Heroku

```bash
$ git add -A
$ git commit -am "Initial"
$ git push heroku master
```
