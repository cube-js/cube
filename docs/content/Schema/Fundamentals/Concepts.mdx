---
title: Data Schema Concepts
permalink: /schema/fundamentals/concepts
category: Data Schema
subCategory: Fundamentals
menuOrder: 2
---

Cube borrows a lot of terminology from data science and [OLAP
theory][wiki-olap], and this document is intended for both newcomers and regular
users to refresh their understanding.

We'll use a sample e-commerce database with two tables, `orders` and
`line_items` to illustrate the concepts throughout this page:

**`orders`**

| **id** | **status** | **completed_at**           | **created_at**             |
| ------ | ---------- | -------------------------- | -------------------------- |
| 1      | completed  | 2019-01-05 00:00:00.000000 | 2019-01-02 00:00:00.000000 |
| 2      | shipped    | 2019-01-17 00:00:00.000000 | 2019-01-02 00:00:00.000000 |
| 3      | completed  | 2019-01-27 00:00:00.000000 | 2019-01-02 00:00:00.000000 |
| 4      | shipped    | 2019-01-09 00:00:00.000000 | 2019-01-02 00:00:00.000000 |
| 5      | processing | 2019-01-29 00:00:00.000000 | 2019-01-02 00:00:00.000000 |

**`line_items`**

| **id** | **product_id** | **order_id** | **quantity** | **price** | **created_at**             |
| ------ | -------------- | ------------ | ------------ | --------- | -------------------------- |
| 1      | 31             | 1            | 1            | 275       | 2019-01-31 00:00:00.000000 |
| 2      | 49             | 2            | 6            | 248       | 2021-01-20 00:00:00.000000 |
| 3      | 89             | 3            | 6            | 197       | 2021-11-25 00:00:00.000000 |
| 4      | 71             | 4            | 8            | 223       | 2019-12-23 00:00:00.000000 |
| 5      | 64             | 5            | 5            | 75        | 2019-04-20 00:00:00.000000 |

## Cubes

A cube represents a dataset in Cube, and is conceptually similar to a [view in
SQL][wiki-view-sql]. Cubes are typically declared in separate files with one
cube per file. Within each cube are definitions of [dimensions][self-dimensions]
and [measures][self-measures]. Typically, a cube points to a single table in
your database using the [`sql` property][ref-schema-ref-sql]:

<CodeTabs>

```javascript
cube('Orders', {
  sql: `SELECT * FROM orders`,
});
```

```yaml
cubes:
  - name: Orders
    sql: SELECT * FROM orders
```

</CodeTabs>

The `sql` property of a cube is flexible enough to accommodate more complex SQL
queries too:

<CodeTabs>

```javascript
cube('Orders', {
  sql: `
SELECT
  *
FROM
  orders,
  line_items
WHERE
  orders.id = line_items.order_id
  `,
});
```

```yaml
cubes:
  - name: Orders
    sql: >
      SELECT * FROM
        orders,
        line_items
      WHERE
        orders.id = line_items.order_id
```

</CodeTabs>

## Dimensions

Dimensions represent the properties of a **single** data point in the cube.
[The `orders` table](#top) contains only dimensions, so representing them in the
`Orders` cube is straightforward:

<CodeTabs>

```javascript
cube('Orders', {
  dimensions: {
    id: {
      sql: `id`,
      type: `number`,
      // Here we explicitly let Cube know this field is the primary key
      // This is required for de-duplicating results when using joins
      primary_key: true,
    },
    status: {
      sql: `status`,
      type: `string`,
    },
  },
});
```

```yaml
cubes:
  - name: Orders

    dimensions:
      - name: id
        sql: id
        type: number
        # Here we explicitly let Cube know this field is the primary key
        # This is required for de-duplicating results when using joins
        primary_key: true
      - name: status
        sql: status
        type: string
```

</CodeTabs>

[The `line_items` table](#top) also has a couple of dimensions which can be
represented as follows:

<CodeTabs>

```javascript
cube('LineItems', {
  dimensions: {
    id: {
      sql: `id`,
      type: `number`,
      // Again, we explicitly let Cube know this field is the primary key
      // This is required for de-duplicating results when using joins
      primary_key: true,
    },

    order_id: {
      sql: `order_id`,
      type: `number`,
    },
  },
});
```

```yaml
cubes:
  - name: LineItems

    dimensions:
      - name: id
        sql: id
        type: number
        # Again, we explicitly let Cube know this field is the primary key
        # This is required for de-duplicating results when using joins
        primary_key: true
      - name: order_id
        sql: order_id
        type: number
```

</CodeTabs>

Dimensions can be of different types, and you can find them all
[here][ref-schema-dimension-types].

### <--{"id" : "Dimensions"}--> Time Dimensions

Time-based properties should be represented as dimensions with type `time`. Time
dimensions allow grouping the result set by a unit of time (e.g. hours, days,
weeks). In analytics, this is also known as "granularity".

We can add the necessary time dimensions to both schemas as follows:

<CodeTabs>

```javascript
cube('Orders', {
  dimensions: {
    created_at: {
      sql: `created_at`,
      type: `time`,
    },

    completed_at: {
      sql: `completed_at`,
      type: `time`,
    },
  },
});
```

```yaml
cubes:
  - name: Orders
    dimensions:
      - name: created_at
        sql: 'created_at'
        type: time
      - name: completed_at
        sql: 'completed_at'
        type: time
```

</CodeTabs>

<CodeTabs>

```javascript
cube('LineItems', {
  dimensions: {
    created_at: {
      sql: `created_at`,
      type: `time`,
    },
  },
});
```

```yaml
cubes:
  - name: LineItems
    dimensions:
      - name: created_at
        sql: created_at
        type: time
```

</CodeTabs>

Time dimensions are essential to enabling performance boosts such as
[partitioned pre-aggregations][ref-caching-use-preaggs-partition-time] and
[incremental refreshes][ref-tutorial-incremental-preagg].

## Measures

Measures represent the properties of a **set of data points** in the cube. To
add a measure called `count` to our `Orders` cube, for example, we can do the
following:

<CodeTabs>

```javascript
cube('Orders', {
  measures: {
    count: {
      type: `count`,
    },
  },
});
```

```yaml
cubes:
  - name: Orders
    measures:
      - name: count
        type: count
```

</CodeTabs>

In our `LineItems` cube, we can also create a measure to sum up the total value
of line items sold:

<CodeTabs>

```javascript
cube('LineItems', {
  measures: {
    total: {
      sql: `price`,
      type: `sum`,
    },
  },
});
```

```yaml
cubes:
  - name: LineItems
    measures:
      - name: total
        sql: price
        type: sum
```

</CodeTabs>

Measures can be of different types, and you can find them all
[here][ref-schema-measure-types].

## Joins

Joins define the relationships between cubes, which then allows accessing and
comparing properties from two or more cubes at the same time. In Cube, all joins
are `LEFT JOIN`s.

<InfoBox>

An `INNER JOIN` can be replicated with Cube; when making a Cube query, add a
filter for `IS NOT NULL` on the required column.

</InfoBox>

In the following example, we are left-joining the `LineItems` cube onto our
`Orders` cube:

<CodeTabs>

```javascript
cube('Orders', {
  joins: {
    LineItems: {
      relationship: `belongs_to`,
      // Here we use the `CUBE` global to refer to the current cube,
      // so the following is equivalent to `Orders.id = LineItems.order_id`
      sql: `${CUBE}.id = ${LineItems.order_id}`,
    },
  },
});
```

```yaml
cubes:
  - name: Orders
    joins:
      - name: LineItems
        # Here we use the `CUBE` global to refer to the current cube,
        # so the following is equivalent to `Orders.id = LineItems.order_id`
        sql: '{CUBE}.id = {LineItems.order_id}'
        relationship: belongs_to
```

</CodeTabs>

There are three kinds of join relationships:

- `belongs_to`
- `has_one`
- `has_many`

More information can be found in the [Joins reference
documentation][ref-schema-ref-joins-types].

## Segments

Segments are filters that are predefined in the schema instead of [a Cube
query][ref-backend-query-filters]. They allow simplifying Cube queries and make
it easy to re-use common filters across a variety of queries.

To add a segment which limits results to completed orders, we can do the
following:

<CodeTabs>

```javascript
cube('Orders', {
  segments: {
    only_completed: {
      sql: `${CUBE}.status = 'completed'`,
    },
  },
});
```

```yaml
cubes:
  - name: Orders
    segments:
      - name: only_completed
        sql: "{CUBE}.status = 'completed'"
```

</CodeTabs>

## Pre-Aggregations

Pre-aggregations are a powerful way of caching frequently-used, expensive
queries and keeping the cache up-to-date on a periodic basis. Within a data
schema, they are defined under the `pre_aggregations` property:

<CodeTabs>

```javascript
cube('Orders', {
  pre_aggregations: {
    main: {
      measures: [CUBE.count],
      dimensions: [CUBE.status],
      time_dimension: CUBE.created_at,
      granularity: 'day',
    },
  },
});
```

```yaml
cubes:
  - name: Orders
    pre_aggregations:
      - name: main
        measures: [CUBE.count]
        dimensions: [CUBE.status]
        time_dimension: created_at
        granularity: day
```

</CodeTabs>

A more thorough introduction can be found in [Getting Started with
Pre-Aggregations][ref-caching-preaggs-intro].

[ref-backend-query-filters]: /query-format#filters-format
[ref-caching-preaggs-intro]: /caching/pre-aggregations/getting-started
[ref-caching-use-preaggs-partition-time]:
  /caching/using-pre-aggregations#time-partitioning
[ref-schema-dimension-types]: /schema/reference/types-and-formats#types
[ref-schema-measure-types]: /schema/reference/types-and-formats#measures-types
[ref-schema-ref-joins-types]: /schema/reference/joins#relationship
[ref-schema-ref-sql]: /schema/reference/cube#sql
[ref-tutorial-incremental-preagg]: /incremental-pre-aggregations
[self-dimensions]: #dimensions
[self-measures]: #measures
[wiki-olap]: https://en.wikipedia.org/wiki/Online_analytical_processing
[wiki-view-sql]: https://en.wikipedia.org/wiki/View_(SQL)
