---
title: SQL Commands
category: SQL API
permalink: /backend/sql/reference/commands
subCategory: Reference
menuOrder: 4
---

## SELECT

### Synopsis

```sql
SELECT select_expr [, ...]
  FROM from_item
    CROSS JOIN join_item
    ON join_criteria]*
  [ WHERE where_condition ]
  [ GROUP BY grouping_expression ]
  [ HAVING having_expression ]
  [ LIMIT count ];
```

### Description

`SELECT` retrieves rows from a cube.

The `FROM` clause specifies one or more source **cube tables** for the `SELECT`.
Qualification conditions can be added (via `WHERE`) to restrict the returned
rows to a small subset of the original dataset.

The `WHERE` clause specifies a `where_condition` as any expression that
evaluates to a result of type boolean. Any row that does not satisfy this
condition is eliminated from the result dataset. A row satisfies the condition
if it returns `true`.

The `GROUP BY` clause will condense all selected rows that share the same values
for the grouped expressions into a single row. An expression used inside a
`grouping_expression` can be an input column name, or the name or ordinal number
of an output column (SELECT list item), or an arbitrary expression formed from
input-column values. In case of ambiguity, a `GROUP BY` name will be interpreted
as an input-column name rather than an output column name.

The `HAVING` clause eliminates group rows that do not satisfy the condition.
`HAVING` is different from `WHERE` in that `WHERE` filters individual rows
before the application of `GROUP BY`, while `HAVING` filters group rows created
by `GROUP BY`. Each column referenced in condition must unambiguously reference
a grouping column.

The `LIMIT` clause allows specifying the maximum number of rows to return, while
start specifies the number of rows to skip before starting to return rows. When
both are specified, start rows are skipped before starting to count the count
rows to be returned.

### Example

```sql
SELECT *
FROM Orders;
```

## EXPLAIN

### Synopsis

```sql
EXPLAIN [ ANALYZE ] statement
```

### Description

The `EXPLAIN` command displays the query execution plan that the Cube planner
will generate for the supplied `statement`.

The `ANALYZE` option will ...

### Example

```sql
cube=> EXPLAIN
cube-> SELECT o.count as count, p.name as product_name, p.description as product_description
cube-> FROM Orders o
cube-> CROSS JOIN Products p;
   plan_type   |            plan
---------------+----------------------------
 logical_plan  | CubeScan: request={       +
               |   "measures": [           +
               |     "Orders.count"        +
               |   ],                      +
               |   "dimensions": [         +
               |     "Products.name",      +
               |     "Products.description"+
               |   ],                      +
               |   "segments": []          +
               | }
 physical_plan | CubeScanExecutionPlan     +
               |
(2 rows)
```

with `ANALYZE`:

```sql
cube=> EXPLAIN ANALYZE
cube-> SELECT o.count as count, p.name as product_name, p.description as product_description
cube-> FROM Orders o
cube-> CROSS JOIN Products p;
     plan_type     |               plan
-------------------+-----------------------------------
 Plan with Metrics | CubeScanExecutionPlan, metrics=[]+
                   |
(1 row)
```

## SHOW

### Synopsis

```sql
SHOW
```

### Description

Returns the value of a runtime parameter.

### Example

```sql
SHOW name;
SHOW ALL;
```
