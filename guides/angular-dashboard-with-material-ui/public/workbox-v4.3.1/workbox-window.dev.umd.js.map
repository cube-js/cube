{"version":3,"file":"workbox-window.dev.umd.js","sources":["../_version.mjs","../messageSW.mjs","../../workbox-core/_version.mjs","../../workbox-core/_private/Deferred.mjs","../../workbox-core/_private/logger.mjs","../utils/EventTargetShim.mjs","../utils/urlsMatch.mjs","../utils/WorkboxEvent.mjs","../Workbox.mjs","../index.mjs"],"sourcesContent":["try{self['workbox:window:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\n\n/**\n * Sends a data object to a service worker via `postMessage` and resolves with\n * a response (if any).\n *\n * A response can be set in a message handler in the service worker by\n * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n * returned by `messageSW()`. If no response is set, the promise will not\n * resolve.\n *\n * @param {ServiceWorker} sw The service worker to send the message to.\n * @param {Object} data An object to send to the service worker.\n * @return {Promise<Object|undefined>}\n *\n * @memberof module:workbox-window\n */\nconst messageSW = (sw, data) => {\n  return new Promise((resolve) => {\n    let messageChannel = new MessageChannel();\n    messageChannel.port1.onmessage = (evt) => resolve(evt.data);\n    sw.postMessage(data, [messageChannel.port2]);\n  });\n};\n\nexport {messageSW};\n","try{self['workbox:core:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nexport class Deferred {\n  /**\n   * Creates a promise and exposes its resolve and reject functions as methods.\n   */\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst logger = process.env.NODE_ENV === 'production' ? null : (() => {\n  let inGroup = false;\n\n  const methodToColorMap = {\n    debug: `#7f8c8d`, // Gray\n    log: `#2ecc71`, // Green\n    warn: `#f39c12`, // Yellow\n    error: `#c0392b`, // Red\n    groupCollapsed: `#3498db`, // Blue\n    groupEnd: null, // No colored prefix on groupEnd\n  };\n\n  const print = function(method, args) {\n    if (method === 'groupCollapsed') {\n      // Safari doesn't print all console.groupCollapsed() arguments:\n      // https://bugs.webkit.org/show_bug.cgi?id=182754\n      if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        console[method](...args);\n        return;\n      }\n    }\n\n    const styles = [\n      `background: ${methodToColorMap[method]}`,\n      `border-radius: 0.5em`,\n      `color: white`,\n      `font-weight: bold`,\n      `padding: 2px 0.5em`,\n    ];\n\n    // When in a group, the workbox prefix is not displayed.\n    const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n\n    console[method](...logPrefix, ...args);\n\n    if (method === 'groupCollapsed') {\n      inGroup = true;\n    }\n    if (method === 'groupEnd') {\n      inGroup = false;\n    }\n  };\n\n  const api = {};\n  for (const method of Object.keys(methodToColorMap)) {\n    api[method] = (...args) => {\n      print(method, args);\n    };\n  }\n\n  return api;\n})();\n\nexport {logger};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * A minimal `EventTarget` shim.\n * This is necessary because not all browsers support constructable\n * `EventTarget`, so using a real `EventTarget` will error.\n * @private\n */\nclass EventTargetShim {\n  /**\n   * Creates an event listener registry\n   *\n   * @private\n   */\n  constructor() {\n    // A registry of event types to listeners.\n    this._eventListenerRegistry = {};\n  }\n  /**\n   * @param {string} type\n   * @param {Function} listener\n   * @private\n   */\n  addEventListener(type, listener) {\n    this._getEventListenersByType(type).add(listener);\n  }\n\n  /**\n   * @param {string} type\n   * @param {Function} listener\n   * @private\n   */\n  removeEventListener(type, listener) {\n    this._getEventListenersByType(type).delete(listener);\n  }\n\n  /**\n   * @param {Event} event\n   * @private\n   */\n  dispatchEvent(event) {\n    event.target = this;\n    this._getEventListenersByType(event.type).forEach(\n        (listener) => listener(event));\n  }\n\n  /**\n   * Returns a Set of listeners associated with the passed event type.\n   * If no handlers have been registered, an empty Set is returned.\n   *\n   * @param {string} type The event type.\n   * @return {Set} An array of handler functions.\n   * @private\n   */\n  _getEventListenersByType(type) {\n    return this._eventListenerRegistry[type] =\n        (this._eventListenerRegistry[type] || new Set());\n  }\n}\n\nexport {EventTargetShim};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * Returns true if two URLs have the same `.href` property. The URLS can be\n * relative, and if they are the current location href is used to resolve URLs.\n *\n * @private\n * @param {string} url1\n * @param {string} url2\n * @return {boolean}\n */\nconst urlsMatch = (url1, url2) => {\n  return new URL(url1, location).href === new URL(url2, location).href;\n};\n\nexport {urlsMatch};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * A minimal `Event` subclass shim.\n * This doesn't *actually* subclass `Event` because not all browsers support\n * constructable `EventTarget`, and using a real `Event` will error.\n * @private\n */\nclass WorkboxEvent {\n  /**\n   * @param {string} type\n   * @param {Object} props\n   */\n  constructor(type, props) {\n    Object.assign(this, props, {type});\n  }\n}\n\nexport {WorkboxEvent};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {Deferred} from 'workbox-core/_private/Deferred.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {messageSW} from './messageSW.mjs';\nimport {EventTargetShim} from './utils/EventTargetShim.mjs';\nimport {urlsMatch} from './utils/urlsMatch.mjs';\nimport {WorkboxEvent} from './utils/WorkboxEvent.mjs';\nimport './_version.mjs';\n\n\n// The time a SW must be in the waiting phase before we can conclude\n// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\nconst WAITING_TIMEOUT_DURATION = 200;\n\n// The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\n\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @fires [message]{@link module:workbox-window.Workbox#message}\n * @fires [installed]{@link module:workbox-window.Workbox#installed}\n * @fires [waiting]{@link module:workbox-window.Workbox#waiting}\n * @fires [controlling]{@link module:workbox-window.Workbox#controlling}\n * @fires [activated]{@link module:workbox-window.Workbox#activated}\n * @fires [redundant]{@link module:workbox-window.Workbox#redundant}\n * @fires [externalinstalled]{@link module:workbox-window.Workbox#externalinstalled}\n * @fires [externalwaiting]{@link module:workbox-window.Workbox#externalwaiting}\n * @fires [externalactivated]{@link module:workbox-window.Workbox#externalactivated}\n *\n * @memberof module:workbox-window\n */\nclass Workbox extends EventTargetShim {\n  /**\n   * Creates a new Workbox instance with a script URL and service worker\n   * options. The script URL and options are the same as those used when\n   * calling `navigator.serviceWorker.register(scriptURL, options)`. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register\n   *\n   * @param {string} scriptURL The service worker script associated with this\n   *     instance.\n   * @param {Object} [registerOptions] The service worker options associated\n   *     with this instance.\n   */\n  constructor(scriptURL, registerOptions = {}) {\n    super();\n\n    this._scriptURL = scriptURL;\n    this._registerOptions = registerOptions;\n    this._updateFoundCount = 0;\n\n    // Deferreds we can resolve later.\n    this._swDeferred = new Deferred();\n    this._activeDeferred = new Deferred();\n    this._controllingDeferred = new Deferred();\n\n    // Bind event handler callbacks.\n    this._onMessage = this._onMessage.bind(this);\n    this._onStateChange = this._onStateChange.bind(this);\n    this._onUpdateFound = this._onUpdateFound.bind(this);\n    this._onControllerChange = this._onControllerChange.bind(this);\n  }\n\n  /**\n   * Registers a service worker for this instances script URL and service\n   * worker options. By default this method delays registration until after\n   * the window has loaded.\n   *\n   * @param {Object} [options]\n   * @param {Function} [options.immediate=false] Setting this to true will\n   *     register the service worker immediately, even if the window has\n   *     not loaded (not recommended).\n   */\n  async register({immediate = false} = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (this._registrationTime) {\n        logger.error('Cannot re-register a Workbox instance after it has ' +\n            'been registered. Create a new instance instead.');\n        return;\n      }\n    }\n\n    if (!immediate && document.readyState !== 'complete') {\n      await new Promise((res) => addEventListener('load', res));\n    }\n\n    // Set this flag to true if any service worker was controlling the page\n    // at registration time.\n    this._isUpdate = Boolean(navigator.serviceWorker.controller);\n\n    // Before registering, attempt to determine if a SW is already controlling\n    // the page, and if that SW script (and version, if specified) matches this\n    // instance's script.\n    this._compatibleControllingSW = this._getControllingSWIfCompatible();\n\n    this._registration = await this._registerScript();\n\n    // If we have a compatible controller, store the controller as the \"own\"\n    // SW, resolve active/controlling deferreds and add necessary listeners.\n    if (this._compatibleControllingSW) {\n      this._sw = this._compatibleControllingSW;\n      this._activeDeferred.resolve(this._compatibleControllingSW);\n      this._controllingDeferred.resolve(this._compatibleControllingSW);\n\n      this._reportWindowReady(this._compatibleControllingSW);\n      this._compatibleControllingSW.addEventListener(\n          'statechange', this._onStateChange, {once: true});\n    }\n\n    // If there's a waiting service worker with a matching URL before the\n    // `updatefound` event fires, it likely means that this site is open\n    // in another tab, or the user refreshed the page (and thus the prevoius\n    // page wasn't fully unloaded before this page started loading).\n    // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n    const waitingSW = this._registration.waiting;\n    if (waitingSW && urlsMatch(waitingSW.scriptURL, this._scriptURL)) {\n      // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n      // a compatible controller.\n      this._sw = waitingSW;\n\n      // Run this in the next microtask, so any code that adds an event\n      // listener after awaiting `register()` will get this event.\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new WorkboxEvent('waiting', {\n          sw: waitingSW,\n          wasWaitingBeforeRegister: true,\n        }));\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn('A service worker was already waiting to activate ' +\n              'before this script was registered...');\n        }\n      });\n    }\n\n    // If an \"own\" SW is already set, resolve the deferred.\n    if (this._sw) {\n      this._swDeferred.resolve(this._sw);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log('Successfully registered service worker.', this._scriptURL);\n\n      if (navigator.serviceWorker.controller) {\n        if (this._compatibleControllingSW) {\n          logger.debug('A service worker with the same script URL ' +\n              'is already controlling this page.');\n        } else {\n          logger.debug('A service worker with a different script URL is ' +\n              'currently controlling the page. The browser is now fetching ' +\n              'the new script now...');\n        }\n      }\n\n      const currentPageIsOutOfScope = () => {\n        const scopeURL = new URL(\n            this._registerOptions.scope || this._scriptURL, document.baseURI);\n        const scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n        return !location.pathname.startsWith(scopeURLBasePath);\n      };\n      if (currentPageIsOutOfScope()) {\n        logger.warn('The current page is not in scope for the registered ' +\n            'service worker. Was this a mistake?');\n      }\n    }\n\n    this._registration.addEventListener('updatefound', this._onUpdateFound);\n    navigator.serviceWorker.addEventListener(\n        'controllerchange', this._onControllerChange, {once: true});\n\n    // Add message listeners.\n    if ('BroadcastChannel' in self) {\n      this._broadcastChannel = new BroadcastChannel('workbox');\n      this._broadcastChannel.addEventListener('message', this._onMessage);\n    }\n    navigator.serviceWorker.addEventListener('message', this._onMessage);\n\n    return this._registration;\n  }\n\n  /**\n   * Resolves to the service worker registered by this instance as soon as it\n   * is active. If a service worker was already controlling at registration\n   * time then it will resolve to that if the script URLs (and optionally\n   * script versions) match, otherwise it will wait until an update is found\n   * and activates.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  get active() {\n    return this._activeDeferred.promise;\n  }\n\n  /**\n   * Resolves to the service worker registered by this instance as soon as it\n   * is controlling the page. If a service worker was already controlling at\n   * registration time then it will resolve to that if the script URLs (and\n   * optionally script versions) match, otherwise it will wait until an update\n   * is found and starts controlling the page.\n   * Note: the first time a service worker is installed it will active but\n   * not start controlling the page unless `clients.claim()` is called in the\n   * service worker.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  get controlling() {\n    return this._controllingDeferred.promise;\n  }\n\n  /**\n   * Resolves with a reference to a service worker that matches the script URL\n   * of this instance, as soon as it's available.\n   *\n   * If, at registration time, there's already an active or waiting service\n   * worker with a matching script URL, it will be used (with the waiting\n   * service worker taking precedence over the active service worker if both\n   * match, since the waiting service worker would have been registered more\n   * recently).\n   * If there's no matching active or waiting service worker at registration\n   * time then the promise will not resolve until an update is found and starts\n   * installing, at which point the installing service worker is used.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  async getSW() {\n    // If `this._sw` is set, resolve with that as we want `getSW()` to\n    // return the correct (new) service worker if an update is found.\n    return this._sw || this._swDeferred.promise;\n  }\n\n  /**\n   * Sends the passed data object to the service worker registered by this\n   * instance (via [`getSW()`]{@link module:workbox-window.Workbox#getSW}) and resolves\n   * with a response (if any).\n   *\n   * A response can be set in a message handler in the service worker by\n   * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n   * returned by `messageSW()`. If no response is set, the promise will never\n   * resolve.\n   *\n   * @param {Object} data An object to send to the service worker\n   * @return {Promise<Object>}\n   */\n  async messageSW(data) {\n    const sw = await this.getSW();\n    return messageSW(sw, data);\n  }\n\n  /**\n   * Checks for a service worker already controlling the page and returns\n   * it if its script URL matchs.\n   *\n   * @private\n   * @return {ServiceWorker|undefined}\n   */\n  _getControllingSWIfCompatible() {\n    const controller = navigator.serviceWorker.controller;\n    if (controller && urlsMatch(controller.scriptURL, this._scriptURL)) {\n      return controller;\n    }\n  }\n\n  /**\n   * Registers a service worker for this instances script URL and register\n   * options and tracks the time registration was complete.\n   *\n   * @private\n   */\n  async _registerScript() {\n    try {\n      const reg = await navigator.serviceWorker.register(\n          this._scriptURL, this._registerOptions);\n\n      // Keep track of when registration happened, so it can be used in the\n      // `this._onUpdateFound` heuristic. Also use the presence of this\n      // property as a way to see if `.register()` has been called.\n      this._registrationTime = performance.now();\n\n      return reg;\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error(error);\n      }\n      // Re-throw the error.\n      throw error;\n    }\n  }\n\n\n  /**\n   * Sends a message to the passed service worker that the window is ready.\n   *\n   * @param {ServiceWorker} sw\n   * @private\n   */\n  _reportWindowReady(sw) {\n    messageSW(sw, {\n      type: 'WINDOW_READY',\n      meta: 'workbox-window',\n    });\n  }\n\n  /**\n   * @private\n   */\n  _onUpdateFound() {\n    const installingSW = this._registration.installing;\n\n    // If the script URL passed to `navigator.serviceWorker.register()` is\n    // different from the current controlling SW's script URL, we know any\n    // successful registration calls will trigger an `updatefound` event.\n    // But if the registered script URL is the same as the current controlling\n    // SW's script URL, we'll only get an `updatefound` event if the file\n    // changed since it was last registered. This can be a problem if the user\n    // opens up the same page in a different tab, and that page registers\n    // a SW that triggers an update. It's a problem because this page has no\n    // good way of knowing whether the `updatefound` event came from the SW\n    // script it registered or from a registration attempt made by a newer\n    // version of the page running in another tab.\n    // To minimize the possibility of a false positive, we use the logic here:\n    let updateLikelyTriggeredExternally =\n        // Since we enforce only calling `register()` once, and since we don't\n        // add the `updatefound` event listener until the `register()` call, if\n        // `_updateFoundCount` is > 0 then it means this method has already\n        // been called, thus this SW must be external\n        this._updateFoundCount > 0 ||\n        // If the script URL of the installing SW is different from this\n        // instance's script URL, we know it's definitely not from our\n        // registration.\n        !urlsMatch(installingSW.scriptURL, this._scriptURL) ||\n        // If all of the above are false, then we use a time-based heuristic:\n        // Any `updatefound` event that occurs long after our registration is\n        // assumed to be external.\n        (performance.now() >\n            this._registrationTime + REGISTRATION_TIMEOUT_DURATION) ?\n                // If any of the above are not true, we assume the update was\n                // triggered by this instance.\n                true : false;\n\n    if (updateLikelyTriggeredExternally) {\n      this._externalSW = installingSW;\n      this._registration.removeEventListener(\n          'updatefound', this._onUpdateFound);\n    } else {\n      // If the update was not triggered externally we know the installing\n      // SW is the one we registered, so we set it.\n      this._sw = installingSW;\n      this._swDeferred.resolve(installingSW);\n\n      // The `installing` state isn't something we have a dedicated\n      // callback for, but we do log messages for it in development.\n      if (process.env.NODE_ENV !== 'production') {\n        if (navigator.serviceWorker.controller) {\n          logger.log('Updated service worker found. Installing now...');\n        } else {\n          logger.log('Service worker is installing...');\n        }\n      }\n    }\n\n    // Increment the `updatefound` count, so future invocations of this\n    // method can be sure they were triggered externally.\n    ++this._updateFoundCount;\n\n    // Add a `statechange` listener regardless of whether this update was\n    // triggered externally, since we have callbacks for both.\n    installingSW.addEventListener('statechange', this._onStateChange);\n  }\n\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n  _onStateChange(originalEvent) {\n    const sw = originalEvent.target;\n    const {state} = sw;\n    const isExternal = sw === this._externalSW;\n    const eventPrefix = isExternal ? 'external' : '';\n\n    const eventProps = {sw, originalEvent};\n    if (!isExternal && this._isUpdate) {\n      eventProps.isUpdate = true;\n    }\n\n    this.dispatchEvent(new WorkboxEvent(\n        eventPrefix + state, eventProps));\n\n    if (state === 'installed') {\n      // This timeout is used to ignore cases where the service worker calls\n      // `skipWaiting()` in the install event, thus moving it directly in the\n      // activating state. (Since all service workers *must* go through the\n      // waiting phase, the only way to detect `skipWaiting()` called in the\n      // install event is to observe that the time spent in the waiting phase\n      // is very short.)\n      // NOTE: we don't need separate timeouts for the own and external SWs\n      // since they can't go through these phases at the same time.\n      this._waitingTimeout = setTimeout(() => {\n        // Ensure the SW is still waiting (it may now be redundant).\n        if (state === 'installed' && this._registration.waiting === sw) {\n          this.dispatchEvent(new WorkboxEvent(\n              eventPrefix + 'waiting', eventProps));\n\n          if (process.env.NODE_ENV !== 'production') {\n            if (isExternal) {\n              logger.warn('An external service worker has installed but is ' +\n                  'waiting for this client to close before activating...');\n            } else {\n              logger.warn('The service worker has installed but is waiting ' +\n                  'for existing clients to close before activating...');\n            }\n          }\n        }\n      }, WAITING_TIMEOUT_DURATION);\n    } else if (state === 'activating') {\n      clearTimeout(this._waitingTimeout);\n      if (!isExternal) {\n        this._activeDeferred.resolve(sw);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      switch (state) {\n        case 'installed':\n          if (isExternal) {\n            logger.warn('An external service worker has installed. ' +\n                'You may want to suggest users reload this page.');\n          } else {\n            logger.log('Registered service worker installed.');\n          }\n          break;\n        case 'activated':\n          if (isExternal) {\n            logger.warn('An external service worker has activated.');\n          } else {\n            logger.log('Registered service worker activated.');\n            if (sw !== navigator.serviceWorker.controller) {\n              logger.warn('The registered service worker is active but ' +\n                  'not yet controlling the page. Reload or run ' +\n                  '`clients.claim()` in the service worker.');\n            }\n          }\n          break;\n        case 'redundant':\n          if (sw === this._compatibleControllingSW) {\n            logger.log('Previously controlling service worker now redundant!');\n          } else if (!isExternal) {\n            logger.log('Registered service worker now redundant!');\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n  _onControllerChange(originalEvent) {\n    const sw = this._sw;\n    if (sw === navigator.serviceWorker.controller) {\n      this.dispatchEvent(new WorkboxEvent('controlling', {sw, originalEvent}));\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log('Registered service worker now controlling this page.');\n      }\n      this._controllingDeferred.resolve(sw);\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n  _onMessage(originalEvent) {\n    const {data} = originalEvent;\n    this.dispatchEvent(new WorkboxEvent('message', {data, originalEvent}));\n  }\n}\n\n// The jsdoc comments below outline the events this instance may dispatch:\n// -----------------------------------------------------------------------\n\n/**\n * The `message` event is dispatched any time a `postMessage` (or a\n * `BroadcastChannel` message with the `workbox` channel name) is received.\n *\n * @event module:workbox-window.Workbox#message\n * @type {WorkboxEvent}\n * @property {*} data The `data` property from the original `message` event.\n * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n *     event.\n * @property {string} type `message`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `installed` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed`.\n *\n * Then can happen either the very first time a service worker is installed,\n * or after an update to the current service worker is found. In the case\n * of an update being found, the event's `isUpdate` property will be `true`.\n *\n * @event module:workbox-window.Workbox#installed\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `installed`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `waiting` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed` and then doesn't immediately change to `activating`.\n * It may also be dispatched if a service worker with the same\n * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * was already waiting when the [`register()`]{@link module:workbox-window.Workbox#register}\n * method was called.\n *\n * @event module:workbox-window.Workbox#waiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The native `controllerchange` event\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with\n *     a matching `scriptURL` was already waiting when this `Workbox`\n *     instance called `register()`.\n * @property {string} type `waiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `controlling` event is dispatched if a\n * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}\n * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}\n * matches the `scriptURL` of the `Workbox` instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.\n *\n * @event module:workbox-window.Workbox#controlling\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this service worker was registered.\n * @property {string} type `controlling`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `activated` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#activated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `activated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `redundant` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `redundant`.\n *\n * @event module:workbox-window.Workbox#redundant\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `redundant`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalinstalled` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-external-sw}\n * changes to `installed`.\n *\n * @event module:workbox-window.Workbox#externalinstalled\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalinstalled`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalwaiting` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-external-sw}\n * changes to `waiting`.\n *\n * @event module:workbox-window.Workbox#externalwaiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event|undefined} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalwaiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalactivated` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-external-sw}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#externalactivated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalactivated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\nexport {Workbox};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {messageSW} from './messageSW.mjs';\nimport {Workbox} from './Workbox.mjs';\nimport './_version.mjs';\n\n\n/**\n * @module workbox-window\n */\nexport {\n  Workbox,\n  messageSW,\n};\n"],"names":["self","_","e","messageSW","sw","data","Promise","resolve","messageChannel","MessageChannel","port1","onmessage","evt","postMessage","port2","Deferred","promise","reject","logger","process","inGroup","methodToColorMap","debug","log","warn","error","groupCollapsed","groupEnd","print","method","args","test","navigator","userAgent","console","styles","logPrefix","join","api","Object","keys","EventTargetShim","_eventListenerRegistry","addEventListener","type","listener","_getEventListenersByType","add","removeEventListener","delete","dispatchEvent","event","target","forEach","Set","urlsMatch","url1","url2","URL","location","href","WorkboxEvent","props","assign","body","recover","result","then","f","i","arguments","length","apply","value","direct","WAITING_TIMEOUT_DURATION","REGISTRATION_TIMEOUT_DURATION","Workbox","scriptURL","registerOptions","_scriptURL","_registerOptions","_updateFoundCount","_swDeferred","_activeDeferred","_controllingDeferred","_onMessage","bind","_onStateChange","_onUpdateFound","_onControllerChange","register","immediate","_registrationTime","document","readyState","res","_isUpdate","Boolean","serviceWorker","controller","_compatibleControllingSW","_getControllingSWIfCompatible","_registerScript","_registration","_sw","_reportWindowReady","once","waitingSW","waiting","wasWaitingBeforeRegister","currentPageIsOutOfScope","scopeURL","scope","baseURI","scopeURLBasePath","pathname","startsWith","_broadcastChannel","BroadcastChannel","getSW","reg","performance","now","meta","installingSW","installing","updateLikelyTriggeredExternally","_externalSW","originalEvent","state","isExternal","eventPrefix","eventProps","isUpdate","_waitingTimeout","setTimeout","clearTimeout"],"mappings":"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"}