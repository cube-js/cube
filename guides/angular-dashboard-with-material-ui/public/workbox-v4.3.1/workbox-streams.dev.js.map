{"version":3,"file":"workbox-streams.dev.js","sources":["../_version.mjs","../concatenate.mjs","../utils/createHeaders.mjs","../concatenateToResponse.mjs","../isSupported.mjs","../strategy.mjs","../index.mjs"],"sourcesContent":["try{self['workbox:streams:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\n\nimport './_version.mjs';\n\n/**\n * Takes either a Response, a ReadableStream, or a\n * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n * ReadableStreamReader object associated with it.\n *\n * @param {workbox.streams.StreamSource} source\n * @return {ReadableStreamReader}\n * @private\n */\nfunction _getReaderFromSource(source) {\n  if (source.body && source.body.getReader) {\n    return source.body.getReader();\n  }\n\n  if (source.getReader) {\n    return source.getReader();\n  }\n\n  // TODO: This should be possible to do by constructing a ReadableStream, but\n  // I can't get it to work. As a hack, construct a new Response, and use the\n  // reader associated with its body.\n  return new Response(source).body.getReader();\n}\n\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n *\n * Returns an object exposing a ReadableStream with each individual stream's\n * data returned in sequence, along with a Promise which signals when the\n * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<workbox.streams.StreamSource>>} sourcePromises\n * @return {Object<{done: Promise, stream: ReadableStream}>}\n *\n * @memberof workbox.streams\n */\nfunction concatenate(sourcePromises) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isArray(sourcePromises, {\n      moduleName: 'workbox-streams',\n      funcName: 'concatenate',\n      paramName: 'sourcePromises',\n    });\n  }\n\n  const readerPromises = sourcePromises.map((sourcePromise) => {\n    return Promise.resolve(sourcePromise).then((source) => {\n      return _getReaderFromSource(source);\n    });\n  });\n\n  let fullyStreamedResolve;\n  let fullyStreamedReject;\n  const done = new Promise((resolve, reject) => {\n    fullyStreamedResolve = resolve;\n    fullyStreamedReject = reject;\n  });\n\n  let i = 0;\n  const logMessages = [];\n  const stream = new ReadableStream({\n    pull(controller) {\n      return readerPromises[i]\n          .then((reader) => reader.read())\n          .then((result) => {\n            if (result.done) {\n              if (process.env.NODE_ENV !== 'production') {\n                logMessages.push(['Reached the end of source:',\n                  sourcePromises[i]]);\n              }\n\n              i++;\n              if (i >= readerPromises.length) {\n              // Log all the messages in the group at once in a single group.\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.groupCollapsed(\n                      `Concatenating ${readerPromises.length} sources.`);\n                  for (const message of logMessages) {\n                    if (Array.isArray(message)) {\n                      logger.log(...message);\n                    } else {\n                      logger.log(message);\n                    }\n                  }\n                  logger.log('Finished reading all sources.');\n                  logger.groupEnd();\n                }\n\n                controller.close();\n                fullyStreamedResolve();\n                return;\n              }\n\n              return this.pull(controller);\n            } else {\n              controller.enqueue(result.value);\n            }\n          }).catch((error) => {\n            if (process.env.NODE_ENV !== 'production') {\n              logger.error('An error occurred:', error);\n            }\n            fullyStreamedReject(error);\n            throw error;\n          });\n    },\n\n    cancel() {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn('The ReadableStream was cancelled.');\n      }\n\n      fullyStreamedResolve();\n    },\n  });\n\n  return {done, stream};\n}\n\nexport {concatenate};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * This is a utility method that determines whether the current browser supports\n * the features required to create streamed responses. Currently, it checks if\n * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * is available.\n *\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {boolean} `true`, if the current browser meets the requirements for\n * streaming responses, and `false` otherwise.\n *\n * @memberof workbox.streams\n */\nfunction createHeaders(headersInit = {}) {\n  // See https://github.com/GoogleChrome/workbox/issues/1461\n  const headers = new Headers(headersInit);\n  if (!headers.has('content-type')) {\n    headers.set('content-type', 'text/html');\n  }\n  return headers;\n}\n\nexport {createHeaders};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {createHeaders} from './utils/createHeaders.mjs';\nimport {concatenate} from './concatenate.mjs';\n\nimport './_version.mjs';\n\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit),\n * along with a\n * [HeadersInit](https://fetch.spec.whatwg.org/#typedefdef-headersinit).\n *\n * Returns an object exposing a Response whose body consists of each individual\n * stream's data returned in sequence, along with a Promise which signals when\n * the stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<workbox.streams.StreamSource>>} sourcePromises\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {Object<{done: Promise, response: Response}>}\n *\n * @memberof workbox.streams\n */\nfunction concatenateToResponse(sourcePromises, headersInit) {\n  const {done, stream} = concatenate(sourcePromises);\n\n  const headers = createHeaders(headersInit);\n  const response = new Response(stream, {headers});\n\n  return {done, response};\n}\n\nexport {concatenateToResponse};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\nlet cachedIsSupported = undefined;\n\n/**\n * This is a utility method that determines whether the current browser supports\n * the features required to create streamed responses. Currently, it checks if\n * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * can be created.\n *\n * @return {boolean} `true`, if the current browser meets the requirements for\n * streaming responses, and `false` otherwise.\n *\n * @memberof workbox.streams\n */\nfunction isSupported() {\n  if (cachedIsSupported === undefined) {\n    // See https://github.com/GoogleChrome/workbox/issues/1473\n    try {\n      new ReadableStream({start() {}});\n      cachedIsSupported = true;\n    } catch (error) {\n      cachedIsSupported = false;\n    }\n  }\n\n  return cachedIsSupported;\n}\n\nexport {isSupported};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\n\nimport {createHeaders} from './utils/createHeaders.mjs';\nimport {concatenateToResponse} from './concatenateToResponse.mjs';\nimport {isSupported} from './isSupported.mjs';\n\nimport './_version.mjs';\n\n/**\n * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n *\n * On browsers that do not support constructing new `ReadableStream`s, this\n * strategy will automatically wait for all the `sourceFunctions` to complete,\n * and create a final response that concatenates their values together.\n *\n * @param {\n *   Array<function(workbox.routing.Route~handlerCallback)>} sourceFunctions\n * Each function should return a {@link workbox.streams.StreamSource} (or a\n * Promise which resolves to one).\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {workbox.routing.Route~handlerCallback}\n *\n * @memberof workbox.streams\n */\nexport function strategy(sourceFunctions, headersInit) {\n  return async ({event, url, params}) => {\n    if (isSupported()) {\n      const {done, response} = concatenateToResponse(sourceFunctions.map(\n          (fn) => fn({event, url, params})), headersInit);\n      event.waitUntil(done);\n      return response;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`The current browser doesn't support creating response ` +\n        `streams. Falling back to non-streaming response instead.`);\n    }\n\n    // Fallback to waiting for everything to finish, and concatenating the\n    // responses.\n    const parts = await Promise.all(\n        sourceFunctions.map(\n            (sourceFunction) => sourceFunction({event, url, params})\n        ).map(async (responsePromise) => {\n          const response = await responsePromise;\n          if (response instanceof Response) {\n            return response.blob();\n          }\n\n          // Otherwise, assume it's something like a string which can be used\n          // as-is when constructing the final composite blob.\n          return response;\n        })\n    );\n\n    const headers = createHeaders(headersInit);\n    // Constructing a new Response from a Blob source is well-supported.\n    // So is constructing a new Blob from multiple source Blobs or strings.\n    return new Response(new Blob(parts), {headers});\n  };\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {concatenate} from './concatenate.mjs';\nimport {concatenateToResponse} from './concatenateToResponse.mjs';\nimport {isSupported} from './isSupported.mjs';\nimport {strategy} from './strategy.mjs';\nimport './_version.mjs';\n\n\n/**\n * @namespace workbox.streams\n */\n\nexport {\n  concatenate,\n  concatenateToResponse,\n  isSupported,\n  strategy,\n};\n"],"names":["self","_","e","_getReaderFromSource","source","body","getReader","Response","concatenate","sourcePromises","assert","isArray","moduleName","funcName","paramName","readerPromises","map","sourcePromise","Promise","resolve","then","fullyStreamedResolve","fullyStreamedReject","done","reject","i","logMessages","stream","ReadableStream","pull","controller","reader","read","result","push","length","logger","groupCollapsed","message","Array","log","groupEnd","close","enqueue","value","catch","error","cancel","warn","createHeaders","headersInit","headers","Headers","has","set","concatenateToResponse","response","cachedIsSupported","undefined","isSupported","start","strategy","sourceFunctions","event","url","params","fn","waitUntil","parts","all","sourceFunction","responsePromise","blob","Blob"],"mappings":"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"}