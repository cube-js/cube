{"version":3,"file":"workbox-core.prod.js","sources":["../_version.mjs","../_private/logger.mjs","../models/messages/messageGenerator.mjs","../_private/WorkboxError.mjs","../_private/assert.mjs","../models/quotaErrorCallbacks.mjs","../_private/cacheNames.mjs","../_private/getFriendlyURL.mjs","../_private/executeQuotaErrorCallbacks.mjs","../models/pluginEvents.mjs","../utils/pluginUtils.mjs","../_private/cacheWrapper.mjs","../_private/DBWrapper.mjs","../_private/deleteDatabase.mjs","../_private/fetchWrapper.mjs","../_private/Deferred.mjs","../cacheNames.mjs","../index.mjs","../clientsClaim.mjs","../registerQuotaErrorCallback.mjs","../setCacheNameDetails.mjs","../skipWaiting.mjs"],"sourcesContent":["try{self['workbox:core:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst logger = process.env.NODE_ENV === 'production' ? null : (() => {\n  let inGroup = false;\n\n  const methodToColorMap = {\n    debug: `#7f8c8d`, // Gray\n    log: `#2ecc71`, // Green\n    warn: `#f39c12`, // Yellow\n    error: `#c0392b`, // Red\n    groupCollapsed: `#3498db`, // Blue\n    groupEnd: null, // No colored prefix on groupEnd\n  };\n\n  const print = function(method, args) {\n    if (method === 'groupCollapsed') {\n      // Safari doesn't print all console.groupCollapsed() arguments:\n      // https://bugs.webkit.org/show_bug.cgi?id=182754\n      if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        console[method](...args);\n        return;\n      }\n    }\n\n    const styles = [\n      `background: ${methodToColorMap[method]}`,\n      `border-radius: 0.5em`,\n      `color: white`,\n      `font-weight: bold`,\n      `padding: 2px 0.5em`,\n    ];\n\n    // When in a group, the workbox prefix is not displayed.\n    const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n\n    console[method](...logPrefix, ...args);\n\n    if (method === 'groupCollapsed') {\n      inGroup = true;\n    }\n    if (method === 'groupEnd') {\n      inGroup = false;\n    }\n  };\n\n  const api = {};\n  for (const method of Object.keys(methodToColorMap)) {\n    api[method] = (...args) => {\n      print(method, args);\n    };\n  }\n\n  return api;\n})();\n\nexport {logger};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {messages} from './messages.mjs';\nimport '../../_version.mjs';\n\nconst fallback = (code, ...args) => {\n  let msg = code;\n  if (args.length > 0) {\n    msg += ` :: ${JSON.stringify(args)}`;\n  }\n  return msg;\n};\n\nconst generatorFunction = (code, ...args) => {\n  const message = messages[code];\n  if (!message) {\n    throw new Error(`Unable to find message for code '${code}'.`);\n  }\n\n  return message(...args);\n};\n\nexport const messageGenerator = (process.env.NODE_ENV === 'production') ?\n    fallback : generatorFunction;\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {messageGenerator} from '../models/messages/messageGenerator.mjs';\nimport '../_version.mjs';\n\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\nclass WorkboxError extends Error {\n  /**\n   *\n   * @param {string} errorCode The error code that\n   * identifies this particular error.\n   * @param {Object=} details Any relevant arguments\n   * that will help developers identify issues should\n   * be added as a key on the context object.\n   */\n  constructor(errorCode, details) {\n    let message = messageGenerator(errorCode, details);\n\n    super(message);\n\n    this.name = errorCode;\n    this.details = details;\n  }\n}\n\nexport {WorkboxError};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from '../_private/WorkboxError.mjs';\nimport '../_version.mjs';\n\n/*\n * This method returns true if the current context is a service worker.\n */\nconst isSWEnv = (moduleName) => {\n  if (!('ServiceWorkerGlobalScope' in self)) {\n    throw new WorkboxError('not-in-sw', {moduleName});\n  }\n};\n\n/*\n * This method throws if the supplied value is not an array.\n * The destructed values are required to produce a meaningful error for users.\n * The destructed and restructured object is so it's clear what is\n * needed.\n */\nconst isArray = (value, {moduleName, className, funcName, paramName}) => {\n  if (!Array.isArray(value)) {\n    throw new WorkboxError('not-an-array', {\n      moduleName,\n      className,\n      funcName,\n      paramName,\n    });\n  }\n};\n\nconst hasMethod = (object, expectedMethod,\n    {moduleName, className, funcName, paramName}) => {\n  const type = typeof object[expectedMethod];\n  if (type !== 'function') {\n    throw new WorkboxError('missing-a-method', {paramName, expectedMethod,\n      moduleName, className, funcName});\n  }\n};\n\nconst isType = (object, expectedType,\n    {moduleName, className, funcName, paramName}) => {\n  if (typeof object !== expectedType) {\n    throw new WorkboxError('incorrect-type', {paramName, expectedType,\n      moduleName, className, funcName});\n  }\n};\n\nconst isInstance = (object, expectedClass,\n    {moduleName, className, funcName,\n      paramName, isReturnValueProblem}) => {\n  if (!(object instanceof expectedClass)) {\n    throw new WorkboxError('incorrect-class', {paramName, expectedClass,\n      moduleName, className, funcName, isReturnValueProblem});\n  }\n};\n\nconst isOneOf = (value, validValues, {paramName}) => {\n  if (!validValues.includes(value)) {\n    throw new WorkboxError('invalid-value', {\n      paramName,\n      value,\n      validValueDescription: `Valid values are ${JSON.stringify(validValues)}.`,\n    });\n  }\n};\n\nconst isArrayOfClass = (value, expectedClass,\n    {moduleName, className, funcName, paramName}) => {\n  const error = new WorkboxError('not-array-of-class', {\n    value, expectedClass,\n    moduleName, className, funcName, paramName,\n  });\n  if (!Array.isArray(value)) {\n    throw error;\n  }\n\n  for (let item of value) {\n    if (!(item instanceof expectedClass)) {\n      throw error;\n    }\n  }\n};\n\nconst finalAssertExports = process.env.NODE_ENV === 'production' ? null : {\n  hasMethod,\n  isArray,\n  isInstance,\n  isOneOf,\n  isSWEnv,\n  isType,\n  isArrayOfClass,\n};\n\nexport {finalAssertExports as assert};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n// Callbacks to be executed whenever there's a quota error.\nconst quotaErrorCallbacks = new Set();\n\nexport {quotaErrorCallbacks};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst _cacheNameDetails = {\n  googleAnalytics: 'googleAnalytics',\n  precache: 'precache-v2',\n  prefix: 'workbox',\n  runtime: 'runtime',\n  suffix: self.registration.scope,\n};\n\nconst _createCacheName = (cacheName) => {\n  return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]\n      .filter((value) => value.length > 0)\n      .join('-');\n};\n\nexport const cacheNames = {\n  updateDetails: (details) => {\n    Object.keys(_cacheNameDetails).forEach((key) => {\n      if (typeof details[key] !== 'undefined') {\n        _cacheNameDetails[key] = details[key];\n      }\n    });\n  },\n  getGoogleAnalyticsName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n  },\n  getPrecacheName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.precache);\n  },\n  getPrefix: () => {\n    return _cacheNameDetails.prefix;\n  },\n  getRuntimeName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n  },\n  getSuffix: () => {\n    return _cacheNameDetails.suffix;\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nconst getFriendlyURL = (url) => {\n  const urlObj = new URL(url, location);\n  if (urlObj.origin === location.origin) {\n    return urlObj.pathname;\n  }\n  return urlObj.href;\n};\n\nexport {getFriendlyURL};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from '../_private/logger.mjs';\nimport {quotaErrorCallbacks} from '../models/quotaErrorCallbacks.mjs';\nimport '../_version.mjs';\n\n\n/**\n * Runs all of the callback functions, one at a time sequentially, in the order\n * in which they were registered.\n *\n * @memberof workbox.core\n * @private\n */\nasync function executeQuotaErrorCallbacks() {\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log(`About to run ${quotaErrorCallbacks.size} ` +\n        `callbacks to clean up caches.`);\n  }\n\n  for (const callback of quotaErrorCallbacks) {\n    await callback();\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(callback, 'is complete.');\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Finished running callbacks.');\n  }\n}\n\nexport {executeQuotaErrorCallbacks};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nexport const pluginEvents = {\n  CACHE_DID_UPDATE: 'cacheDidUpdate',\n  CACHE_KEY_WILL_BE_USED: 'cacheKeyWillBeUsed',\n  CACHE_WILL_UPDATE: 'cacheWillUpdate',\n  CACHED_RESPONSE_WILL_BE_USED: 'cachedResponseWillBeUsed',\n  FETCH_DID_FAIL: 'fetchDidFail',\n  FETCH_DID_SUCCEED: 'fetchDidSucceed',\n  REQUEST_WILL_FETCH: 'requestWillFetch',\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nexport const pluginUtils = {\n  filter: (plugins, callbackName) => {\n    return plugins.filter((plugin) => callbackName in plugin);\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from './WorkboxError.mjs';\nimport {assert} from './assert.mjs';\nimport {getFriendlyURL} from './getFriendlyURL.mjs';\nimport {logger} from './logger.mjs';\nimport {executeQuotaErrorCallbacks} from './executeQuotaErrorCallbacks.mjs';\nimport {pluginEvents} from '../models/pluginEvents.mjs';\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n\n\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({\n  cacheName,\n  request,\n  response,\n  event,\n  plugins = [],\n  matchOptions,\n} = {}) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (request.method && request.method !== 'GET') {\n      throw new WorkboxError('attempt-to-cache-non-get-request', {\n        url: getFriendlyURL(request.url),\n        method: request.method,\n      });\n    }\n  }\n\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins, request, mode: 'write'});\n\n  if (!response) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Cannot cache non-existent response for ` +\n        `'${getFriendlyURL(effectiveRequest.url)}'.`);\n    }\n\n    throw new WorkboxError('cache-put-with-no-response', {\n      url: getFriendlyURL(effectiveRequest.url),\n    });\n  }\n\n  let responseToCache = await _isResponseSafeToCache({\n    event,\n    plugins,\n    response,\n    request: effectiveRequest,\n  });\n\n  if (!responseToCache) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\n      `not be cached.`, responseToCache);\n    }\n    return;\n  }\n\n  const cache = await caches.open(cacheName);\n\n  const updatePlugins = pluginUtils.filter(\n      plugins, pluginEvents.CACHE_DID_UPDATE);\n\n  let oldResponse = updatePlugins.length > 0 ?\n      await matchWrapper({cacheName, matchOptions, request: effectiveRequest}) :\n      null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n      `${getFriendlyURL(effectiveRequest.url)}.`);\n  }\n\n  try {\n    await cache.put(effectiveRequest, responseToCache);\n  } catch (error) {\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n    if (error.name === 'QuotaExceededError') {\n      await executeQuotaErrorCallbacks();\n    }\n    throw error;\n  }\n\n  for (let plugin of updatePlugins) {\n    await plugin[pluginEvents.CACHE_DID_UPDATE].call(plugin, {\n      cacheName,\n      event,\n      oldResponse,\n      newResponse: responseToCache,\n      request: effectiveRequest,\n    });\n  }\n};\n\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that propted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({\n  cacheName,\n  request,\n  event,\n  matchOptions,\n  plugins = [],\n}) => {\n  const cache = await caches.open(cacheName);\n\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins, request, mode: 'read'});\n\n  let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n  if (process.env.NODE_ENV !== 'production') {\n    if (cachedResponse) {\n      logger.debug(`Found a cached response in '${cacheName}'.`);\n    } else {\n      logger.debug(`No cached response found in '${cacheName}'.`);\n    }\n  }\n\n  for (const plugin of plugins) {\n    if (pluginEvents.CACHED_RESPONSE_WILL_BE_USED in plugin) {\n      cachedResponse = await plugin[pluginEvents.CACHED_RESPONSE_WILL_BE_USED]\n          .call(plugin, {\n            cacheName,\n            event,\n            matchOptions,\n            cachedResponse,\n            request: effectiveRequest,\n          });\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n          assert.isInstance(cachedResponse, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n    }\n  }\n\n  return cachedResponse;\n};\n\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({request, response, event, plugins}) => {\n  let responseToCache = response;\n  let pluginsUsed = false;\n  for (let plugin of plugins) {\n    if (pluginEvents.CACHE_WILL_UPDATE in plugin) {\n      pluginsUsed = true;\n      responseToCache = await plugin[pluginEvents.CACHE_WILL_UPDATE]\n          .call(plugin, {\n            request,\n            response: responseToCache,\n            event,\n          });\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (responseToCache) {\n          assert.isInstance(responseToCache, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHE_WILL_UPDATE,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n\n      if (!responseToCache) {\n        break;\n      }\n    }\n  }\n\n  if (!pluginsUsed) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!responseToCache.status === 200) {\n        if (responseToCache.status === 0) {\n          logger.warn(`The response for '${request.url}' is an opaque ` +\n            `response. The caching strategy that you're using will not ` +\n            `cache opaque responses by default.`);\n        } else {\n          logger.debug(`The response for '${request.url}' returned ` +\n          `a status code of '${response.status}' and won't be cached as a ` +\n          `result.`);\n        }\n      }\n    }\n    responseToCache = responseToCache.status === 200 ? responseToCache : null;\n  }\n\n  return responseToCache ? responseToCache : null;\n};\n\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async ({request, mode, plugins}) => {\n  const cacheKeyWillBeUsedPlugins = pluginUtils.filter(\n      plugins, pluginEvents.CACHE_KEY_WILL_BE_USED);\n\n  let effectiveRequest = request;\n  for (const plugin of cacheKeyWillBeUsedPlugins) {\n    effectiveRequest = await plugin[pluginEvents.CACHE_KEY_WILL_BE_USED].call(\n        plugin, {mode, request: effectiveRequest});\n\n    if (typeof effectiveRequest === 'string') {\n      effectiveRequest = new Request(effectiveRequest);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(effectiveRequest, Request, {\n        moduleName: 'Plugin',\n        funcName: pluginEvents.CACHE_KEY_WILL_BE_USED,\n        isReturnValueProblem: true,\n      });\n    }\n  }\n\n  return effectiveRequest;\n};\n\nexport const cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper,\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nexport class DBWrapper {\n  /**\n   * @param {string} name\n   * @param {number} version\n   * @param {Object=} [callback]\n   * @param {!Function} [callbacks.onupgradeneeded]\n   * @param {!Function} [callbacks.onversionchange] Defaults to\n   *     DBWrapper.prototype._onversionchange when not specified.\n   * @private\n   */\n  constructor(name, version, {\n    onupgradeneeded,\n    onversionchange = this._onversionchange,\n  } = {}) {\n    this._name = name;\n    this._version = version;\n    this._onupgradeneeded = onupgradeneeded;\n    this._onversionchange = onversionchange;\n\n    // If this is null, it means the database isn't open.\n    this._db = null;\n  }\n\n  /**\n   * Returns the IDBDatabase instance (not normally needed).\n   *\n   * @private\n   */\n  get db() {\n    return this._db;\n  }\n\n  /**\n   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n   * callback, and added an onversionchange callback to the database.\n   *\n   * @return {IDBDatabase}\n   * @private\n   */\n  async open() {\n    if (this._db) return;\n\n    this._db = await new Promise((resolve, reject) => {\n      // This flag is flipped to true if the timeout callback runs prior\n      // to the request failing or succeeding. Note: we use a timeout instead\n      // of an onblocked handler since there are cases where onblocked will\n      // never never run. A timeout better handles all possible scenarios:\n      // https://github.com/w3c/IndexedDB/issues/223\n      let openRequestTimedOut = false;\n      setTimeout(() => {\n        openRequestTimedOut = true;\n        reject(new Error('The open request was blocked and timed out'));\n      }, this.OPEN_TIMEOUT);\n\n      const openRequest = indexedDB.open(this._name, this._version);\n      openRequest.onerror = () => reject(openRequest.error);\n      openRequest.onupgradeneeded = (evt) => {\n        if (openRequestTimedOut) {\n          openRequest.transaction.abort();\n          evt.target.result.close();\n        } else if (this._onupgradeneeded) {\n          this._onupgradeneeded(evt);\n        }\n      };\n      openRequest.onsuccess = ({target}) => {\n        const db = target.result;\n        if (openRequestTimedOut) {\n          db.close();\n        } else {\n          db.onversionchange = this._onversionchange.bind(this);\n          resolve(db);\n        }\n      };\n    });\n\n    return this;\n  }\n\n  /**\n   * Polyfills the native `getKey()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @return {Array}\n   * @private\n   */\n  async getKey(storeName, query) {\n    return (await this.getAllKeys(storeName, query, 1))[0];\n  }\n\n  /**\n   * Polyfills the native `getAll()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n  async getAll(storeName, query, count) {\n    return await this.getAllMatching(storeName, {query, count});\n  }\n\n\n  /**\n   * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n  async getAllKeys(storeName, query, count) {\n    return (await this.getAllMatching(\n        storeName, {query, count, includeKeys: true})).map(({key}) => key);\n  }\n\n  /**\n   * Supports flexible lookup in an object store by specifying an index,\n   * query, direction, and count. This method returns an array of objects\n   * with the signature .\n   *\n   * @param {string} storeName\n   * @param {Object} [opts]\n   * @param {string} [opts.index] The index to use (if specified).\n   * @param {*} [opts.query]\n   * @param {IDBCursorDirection} [opts.direction]\n   * @param {number} [opts.count] The max number of results to return.\n   * @param {boolean} [opts.includeKeys] When true, the structure of the\n   *     returned objects is changed from an array of values to an array of\n   *     objects in the form {key, primaryKey, value}.\n   * @return {Array}\n   * @private\n   */\n  async getAllMatching(storeName, {\n    index,\n    query = null, // IE errors if query === `undefined`.\n    direction = 'next',\n    count,\n    includeKeys,\n  } = {}) {\n    return await this.transaction([storeName], 'readonly', (txn, done) => {\n      const store = txn.objectStore(storeName);\n      const target = index ? store.index(index) : store;\n      const results = [];\n\n      target.openCursor(query, direction).onsuccess = ({target}) => {\n        const cursor = target.result;\n        if (cursor) {\n          const {primaryKey, key, value} = cursor;\n          results.push(includeKeys ? {primaryKey, key, value} : value);\n          if (count && results.length >= count) {\n            done(results);\n          } else {\n            cursor.continue();\n          }\n        } else {\n          done(results);\n        }\n      };\n    });\n  }\n\n  /**\n   * Accepts a list of stores, a transaction type, and a callback and\n   * performs a transaction. A promise is returned that resolves to whatever\n   * value the callback chooses. The callback holds all the transaction logic\n   * and is invoked with two arguments:\n   *   1. The IDBTransaction object\n   *   2. A `done` function, that's used to resolve the promise when\n   *      when the transaction is done, if passed a value, the promise is\n   *      resolved to that value.\n   *\n   * @param {Array<string>} storeNames An array of object store names\n   *     involved in the transaction.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {!Function} callback\n   * @return {*} The result of the transaction ran by the callback.\n   * @private\n   */\n  async transaction(storeNames, type, callback) {\n    await this.open();\n    return await new Promise((resolve, reject) => {\n      const txn = this._db.transaction(storeNames, type);\n      txn.onabort = ({target}) => reject(target.error);\n      txn.oncomplete = () => resolve();\n\n      callback(txn, (value) => resolve(value));\n    });\n  }\n\n  /**\n   * Delegates async to a native IDBObjectStore method.\n   *\n   * @param {string} method The method name.\n   * @param {string} storeName The object store name.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {...*} args The list of args to pass to the native method.\n   * @return {*} The result of the transaction.\n   * @private\n   */\n  async _call(method, storeName, type, ...args) {\n    const callback = (txn, done) => {\n      txn.objectStore(storeName)[method](...args).onsuccess = ({target}) => {\n        done(target.result);\n      };\n    };\n\n    return await this.transaction([storeName], type, callback);\n  }\n\n  /**\n   * The default onversionchange handler, which closes the database so other\n   * connections can open without being blocked.\n   *\n   * @private\n   */\n  _onversionchange() {\n    this.close();\n  }\n\n  /**\n   * Closes the connection opened by `DBWrapper.open()`. Generally this method\n   * doesn't need to be called since:\n   *   1. It's usually better to keep a connection open since opening\n   *      a new connection is somewhat slow.\n   *   2. Connections are automatically closed when the reference is\n   *      garbage collected.\n   * The primary use case for needing to close a connection is when another\n   * reference (typically in another tab) needs to upgrade it and would be\n   * blocked by the current, open connection.\n   *\n   * @private\n   */\n  close() {\n    if (this._db) {\n      this._db.close();\n      this._db = null;\n    }\n  }\n}\n\n// Exposed to let users modify the default timeout on a per-instance\n// or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n\n// Wrap native IDBObjectStore methods according to their mode.\nconst methodsToWrap = {\n  'readonly': ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n  'readwrite': ['add', 'put', 'clear', 'delete'],\n};\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n  for (const method of methods) {\n    if (method in IDBObjectStore.prototype) {\n      // Don't use arrow functions here since we're outside of the class.\n      DBWrapper.prototype[method] = async function(storeName, ...args) {\n        return await this._call(method, storeName, mode, ...args);\n      };\n    }\n  }\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * Deletes the database.\n * Note: this is exported separately from the DBWrapper module because most\n * usages of IndexedDB in workbox dont need deleting, and this way it can be\n * reused in tests to delete databases without creating DBWrapper instances.\n *\n * @param {string} name The database name.\n * @private\n */\nexport const deleteDatabase = async (name) => {\n  await new Promise((resolve, reject) => {\n    const request = indexedDB.deleteDatabase(name);\n    request.onerror = ({target}) => {\n      reject(target.error);\n    };\n    request.onblocked = () => {\n      reject(new Error('Delete blocked'));\n    };\n    request.onsuccess = () => {\n      resolve();\n    };\n  });\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from './WorkboxError.mjs';\nimport {logger} from './logger.mjs';\nimport {assert} from './assert.mjs';\nimport {getFriendlyURL} from '../_private/getFriendlyURL.mjs';\nimport {pluginEvents} from '../models/pluginEvents.mjs';\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst wrappedFetch = async ({\n  request,\n  fetchOptions,\n  event,\n  plugins = []}) => {\n  // We *should* be able to call `await event.preloadResponse` even if it's\n  // undefined, but for some reason, doing so leads to errors in our Node unit\n  // tests. To work around that, explicitly check preloadResponse's value first.\n  if (event && event.preloadResponse) {\n    const possiblePreloadResponse = await event.preloadResponse;\n    if (possiblePreloadResponse) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Using a preloaded navigation response for ` +\n          `'${getFriendlyURL(request.url)}'`);\n      }\n      return possiblePreloadResponse;\n    }\n  }\n\n  if (typeof request === 'string') {\n    request = new Request(request);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isInstance(request, Request, {\n      paramName: request,\n      expectedClass: 'Request',\n      moduleName: 'workbox-core',\n      className: 'fetchWrapper',\n      funcName: 'wrappedFetch',\n    });\n  }\n\n  const failedFetchPlugins = pluginUtils.filter(\n      plugins, pluginEvents.FETCH_DID_FAIL);\n\n  // If there is a fetchDidFail plugin, we need to save a clone of the\n  // original request before it's either modified by a requestWillFetch\n  // plugin or before the original request's body is consumed via fetch().\n  const originalRequest = failedFetchPlugins.length > 0 ?\n    request.clone() : null;\n\n  try {\n    for (let plugin of plugins) {\n      if (pluginEvents.REQUEST_WILL_FETCH in plugin) {\n        request = await plugin[pluginEvents.REQUEST_WILL_FETCH].call(plugin, {\n          request: request.clone(),\n          event,\n        });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (request) {\n            assert.isInstance(request, Request, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n  } catch (err) {\n    throw new WorkboxError('plugin-error-request-will-fetch', {\n      thrownError: err,\n    });\n  }\n\n  // The request can be altered by plugins with `requestWillFetch` making\n  // the original request (Most likely from a `fetch` event) to be different\n  // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n  let pluginFilteredRequest = request.clone();\n\n  try {\n    let fetchResponse;\n\n    // See https://github.com/GoogleChrome/workbox/issues/1796\n    if (request.mode === 'navigate') {\n      fetchResponse = await fetch(request);\n    } else {\n      fetchResponse = await fetch(request, fetchOptions);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Network request for `+\n      `'${getFriendlyURL(request.url)}' returned a response with ` +\n      `status '${fetchResponse.status}'.`);\n    }\n\n    for (const plugin of plugins) {\n      if (pluginEvents.FETCH_DID_SUCCEED in plugin) {\n        fetchResponse = await plugin[pluginEvents.FETCH_DID_SUCCEED]\n            .call(plugin, {\n              event,\n              request: pluginFilteredRequest,\n              response: fetchResponse,\n            });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (fetchResponse) {\n            assert.isInstance(fetchResponse, Response, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.FETCH_DID_SUCCEED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n\n    return fetchResponse;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Network request for `+\n      `'${getFriendlyURL(request.url)}' threw an error.`, error);\n    }\n\n    for (const plugin of failedFetchPlugins) {\n      await plugin[pluginEvents.FETCH_DID_FAIL].call(plugin, {\n        error,\n        event,\n        originalRequest: originalRequest.clone(),\n        request: pluginFilteredRequest.clone(),\n      });\n    }\n\n    throw error;\n  }\n};\n\nconst fetchWrapper = {\n  fetch: wrappedFetch,\n};\n\nexport {fetchWrapper};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nexport class Deferred {\n  /**\n   * Creates a promise and exposes its resolve and reject functions as methods.\n   */\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {cacheNames as _cacheNames} from './_private/cacheNames.mjs';\nimport './_version.mjs';\n\n\n/**\n * Get the current cache names and prefix/suffix used by Workbox.\n *\n * `cacheNames.precache` is used for precached assets,\n * `cacheNames.googleAnalytics` is used by `workbox-google-analytics` to\n * store `analytics.js`, and `cacheNames.runtime` is used for everything else.\n *\n * `cacheNames.prefix` can be used to retrieve just the current prefix value.\n * `cacheNames.suffix` can be used to retrieve just the current suffix value.\n *\n * @return {Object} An object with `precache`, `runtime`, `prefix`, and\n *     `googleAnalytics` properties.\n *\n * @alias workbox.core.cacheNames\n */\nexport const cacheNames = {\n  get googleAnalytics() {\n    return _cacheNames.getGoogleAnalyticsName();\n  },\n  get precache() {\n    return _cacheNames.getPrecacheName();\n  },\n  get prefix() {\n    return _cacheNames.getPrefix();\n  },\n  get runtime() {\n    return _cacheNames.getRuntimeName();\n  },\n  get suffix() {\n    return _cacheNames.getSuffix();\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {registerQuotaErrorCallback} from './registerQuotaErrorCallback.mjs';\nimport * as _private from './_private.mjs';\nimport {clientsClaim} from './clientsClaim.mjs';\nimport {cacheNames} from './cacheNames.mjs';\nimport {setCacheNameDetails} from './setCacheNameDetails.mjs';\nimport {skipWaiting} from './skipWaiting.mjs';\nimport './_version.mjs';\n\n\n// Give our version strings something to hang off of.\ntry {\n  self.workbox.v = self.workbox.v || {};\n} catch (errer) {\n  // NOOP\n}\n\n/**\n * All of the Workbox service worker libraries use workbox-core for shared\n * code as well as setting default values that need to be shared (like cache\n * names).\n *\n * @namespace workbox.core\n */\n\nexport {\n  _private,\n  clientsClaim,\n  cacheNames,\n  registerQuotaErrorCallback,\n  setCacheNameDetails,\n  skipWaiting,\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\n\n/**\n * Claim any currently available clients once the service worker\n * becomes active. This is normally used in conjunction with `skipWaiting()`.\n *\n * @alias workbox.core.clientsClaim\n */\nexport const clientsClaim = () => {\n  addEventListener('activate', () => clients.claim());\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from './_private/logger.mjs';\nimport {assert} from './_private/assert.mjs';\nimport {quotaErrorCallbacks} from './models/quotaErrorCallbacks.mjs';\nimport './_version.mjs';\n\n\n/**\n * Adds a function to the set of quotaErrorCallbacks that will be executed if\n * there's a quota error.\n *\n * @param {Function} callback\n * @memberof workbox.core\n */\nfunction registerQuotaErrorCallback(callback) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isType(callback, 'function', {\n      moduleName: 'workbox-core',\n      funcName: 'register',\n      paramName: 'callback',\n    });\n  }\n\n  quotaErrorCallbacks.add(callback);\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Registered a callback to respond to quota errors.', callback);\n  }\n}\n\nexport {registerQuotaErrorCallback};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from './_private/assert.mjs';\nimport {cacheNames} from './_private/cacheNames.mjs';\nimport {WorkboxError} from './_private/WorkboxError.mjs';\nimport './_version.mjs';\n\n\n/**\n * Modifies the default cache names used by the Workbox packages.\n * Cache names are generated as `<prefix>-<Cache Name>-<suffix>`.\n *\n * @param {Object} details\n * @param {Object} [details.prefix] The string to add to the beginning of\n *     the precache and runtime cache names.\n * @param {Object} [details.suffix] The string to add to the end of\n *     the precache and runtime cache names.\n * @param {Object} [details.precache] The cache name to use for precache\n *     caching.\n * @param {Object} [details.runtime] The cache name to use for runtime caching.\n * @param {Object} [details.googleAnalytics] The cache name to use for\n *     `workbox-google-analytics` caching.\n *\n * @alias workbox.core.setCacheNameDetails\n */\nexport const setCacheNameDetails = (details) => {\n  if (process.env.NODE_ENV !== 'production') {\n    Object.keys(details).forEach((key) => {\n      assert.isType(details[key], 'string', {\n        moduleName: 'workbox-core',\n        funcName: 'setCacheNameDetails',\n        paramName: `details.${key}`,\n      });\n    });\n\n    if ('precache' in details && details.precache.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'precache',\n        value: details.precache,\n      });\n    }\n\n    if ('runtime' in details && details.runtime.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'runtime',\n        value: details.runtime,\n      });\n    }\n\n    if ('googleAnalytics' in details && details.googleAnalytics.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'googleAnalytics',\n        value: details.googleAnalytics,\n      });\n    }\n  }\n\n  cacheNames.updateDetails(details);\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\n\n/**\n * Force a service worker to become active, instead of waiting. This is\n * normally used in conjunction with `clientsClaim()`.\n *\n * @alias workbox.core.skipWaiting\n */\nexport const skipWaiting = () => {\n  // We need to explicitly call `self.skipWaiting()` here because we're\n  // shadowing `skipWaiting` with this local function.\n  addEventListener('install', () => self.skipWaiting());\n};\n"],"names":["self","_","e","messageGenerator","code","args","msg","length","JSON","stringify","WorkboxError","Error","constructor","errorCode","details","name","quotaErrorCallbacks","Set","_cacheNameDetails","googleAnalytics","precache","prefix","runtime","suffix","registration","scope","_createCacheName","cacheName","filter","value","join","cacheNames","updateDetails","Object","keys","forEach","key","getGoogleAnalyticsName","userCacheName","getPrecacheName","getPrefix","getRuntimeName","getSuffix","getFriendlyURL","url","urlObj","URL","location","origin","pathname","href","async","executeQuotaErrorCallbacks","callback","pluginEvents","pluginUtils","plugins","callbackName","plugin","matchWrapper","request","event","matchOptions","cache","caches","open","effectiveRequest","_getEffectiveRequest","mode","cachedResponse","match","call","_isResponseSafeToCache","response","responseToCache","pluginsUsed","status","cacheKeyWillBeUsedPlugins","Request","cacheWrapper","put","updatePlugins","oldResponse","error","newResponse","DBWrapper","version","onupgradeneeded","onversionchange","this","_onversionchange","_name","_version","_onupgradeneeded","_db","Promise","resolve","reject","openRequestTimedOut","setTimeout","OPEN_TIMEOUT","openRequest","indexedDB","onerror","evt","transaction","abort","target","result","close","onsuccess","db","bind","storeName","query","getAllKeys","count","getAllMatching","includeKeys","map","index","direction","txn","done","store","objectStore","results","openCursor","cursor","primaryKey","push","continue","storeNames","type","onabort","oncomplete","method","prototype","methodsToWrap","methods","entries","IDBObjectStore","_call","fetchWrapper","fetch","fetchOptions","preloadResponse","possiblePreloadResponse","failedFetchPlugins","originalRequest","clone","err","thrownError","pluginFilteredRequest","fetchResponse","process","promise","deleteDatabase","onblocked","_cacheNames","workbox","v","errer","addEventListener","clients","claim","add","skipWaiting"],"mappings":"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"}